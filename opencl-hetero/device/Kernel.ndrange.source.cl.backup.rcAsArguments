// Waqar Nabi, Dec 5 2016
//

// include the custom header file generated for this run
#include "kernelCompilerInclude.h"
// -------------------------------
// Dealing with TYPES
// -------------------------------
//needed if we want to work with double
#if WORD==DOUBLE
#pragma OPENCL EXTENSION cl_khr_fp64 : enable
#endif

//If we are using floats or doubles, we use floating version of abs (fabs)
#if WORD==INT
 #define ABS abs
#else
 #define ABS fabs
#endif

// -------------------------------
// AOCL specific
// -------------------------------
#if TARGET==AOCL
#if NUM_COMPUTE_UNITS>1 
  __attribute__((num_compute_units(NUM_COMPUTE_UNITS)))
#endif
  
#if NUM_SIMD_ITEMS>1
  __attribute__((num_simd_work_items(NUM_SIMD_ITEMS)))
#endif
  
  //#ifdef REQ_WORKGROUP_SIZE
  //  __attribute__((reqd_work_group_size(REQ_WORKGROUP_SIZE)))
  //#endif
#endif

// -------------------------------
// SDACCEL specific
// -------------------------------
#if TARGET==SDACCEL
#endif    

// -------------------------------
// GENERIC attributes/opimizations
// -------------------------------
#ifdef REQ_WORKGROUPIZE
    __attribute__((reqd_work_group_size(REQ_WORKGROUP_SIZE)))
#endif

/*
// -------------------------------
// SUB-KERNEL SIGNATURES
// -------------------------------

void kernel_dyn1( const stypeDevice dt
               , const stypeDevice dx
               , const stypeDevice dy
               , const stypeDevice g
               , __global stypeDevice * restrict eta
               , __global stypeDevice * restrict un
               , __global stypeDevice * restrict u
               , __global stypeDevice * restrict wet
               , __global stypeDevice * restrict v
               , __global stypeDevice * restrict vn
               );
               

void kernel_dyn2( const stypeDevice dt
               , const stypeDevice dx
               , const stypeDevice dy
               , __global stypeDevice * restrict eta
               , __global stypeDevice * restrict un
               , __global stypeDevice * restrict u
               , __global stypeDevice * restrict v
               , __global stypeDevice * restrict vn
               , __global stypeDevice * restrict h
               , __global stypeDevice * restrict etan
               );


void kernel_shapiro  ( const stypeDevice eps 
                     , __global stypeDevice * restrict etan
                     , __global stypeDevice * restrict wet 
                     , __global stypeDevice * restrict eta
                     );

void kernel_updates ( __global stypeHost * restrict h 
                    , __global stypeHost * restrict hzero
                    , __global stypeHost * restrict eta
                    , __global stypeHost * restrict u
                    , __global stypeHost * restrict un
                    , __global stypeHost * restrict v
                    , __global stypeHost * restrict vn
                    , __global stypeHost * restrict wet
                    , stypeHost hmin
                    );
*/

// -------------------------------
// SUPER KERNEL
// -------------------------------
//NOTE: currently this is DYN only    
/*
__kernel void Kernel( const stypeDevice dt
                    , const stypeDevice dx
                    , const stypeDevice dy
                    , const stypeDevice g
                    , const stypeDevice eps
                    , const stypeDevice hmin
                    , __global stypeDevice * restrict eta
                    , __global stypeDevice * restrict un
                    , __global stypeDevice * restrict u
                    , __global stypeDevice * restrict wet
                    , __global stypeDevice * restrict v
                    , __global stypeDevice * restrict vn
                    , __global stypeDevice * restrict h
                    , __global stypeDevice * restrict etan
                    , __global stypeDevice * restrict hzero
                    ) {
//for (int i=0;i<NTOT;i++) {
kernel_dyn1( dt
          , dx
          , dy
          , g
          , eta
          , un
          , u
          , wet
          , v
          , vn
          );


kernel_dyn2( dt
          , dx
          , dy
          , eta
          , un
          , u
          , v
          , vn
          , h
          , etan
          );

kernel_shapiro  ( eps 
                , etan
                , wet 
                , eta
                );

kernel_updates ( h 
               , hzero
               , eta
               , u
               , un
               , v
               , vn
               , wet
               , hmin
               );
//}//for
}//()
*/
// -------------------------------
// DYN KERNELS
// -------------------------------

// DYN1
// -------------------------------

__kernel void kernel_dyn1( const stypeDevice dt
               , const stypeDevice dx
               , const stypeDevice dy
               , const stypeDevice g
               , __global stypeDevice * restrict eta
               , __global stypeDevice * restrict un
               , __global stypeDevice * restrict u
               , __global stypeDevice * restrict wet
               , __global stypeDevice * restrict v
               , __global stypeDevice * restrict vn
               , const int rows
               , const int cols
               ) {

 //locals
//-------------------
//__local stypeDevice du[rows][cols];
//__local stypeDevice dv[rows][cols];
//posix_memalign ((void**)&du, ALIGNMENT, SIZE*BytesPerWord);
//posix_memalign ((void**)&dv, ALIGNMENT, SIZE*BytesPerWord);
stypeDevice du;
stypeDevice dv;
stypeDevice uu;
stypeDevice vv;
stypeDevice duu;
stypeDevice dvv;
int j, k, index;

      index = get_global_id(0);
      j = index / rows;      
      k = index % rows;

//  for (j=1; j<= rows-2; j++) {
//    for (k=1; k<= cols-2; k++) {
      //*(du + j*cols + k)  = -dt 
      //du[j][k]  = -dt 

//exclude boundaries
if  ((j>=1) && (k>=1) && (j<= rows-2) && (k<=cols-2)) {      
//calculate du, dv on all non-boundary points
//-------------------------------------------
      index = get_global_id(0);
      j = index / rows;      
      k = index % rows;
      
      duu  = -dt 
           * g
           * ( eta[j*cols + k+1]
             - eta[j*cols + k  ]
             ) 
           / dx;
      //*(dv + j*cols + k)  = -dt 
      //dv[j][k]  = -dt 
      dvv  = -dt 
           * g
           * ( eta[(j+1)*cols + k]
             - eta[    j*cols + k]
             ) 
           / dy;

//prediction for u and v (merged loop)
//---------------------------------
      un[j*cols + k]  = 0.0;
      uu = u[j*cols + k];
      if (  ( (wet[j*cols + k] == 1)
              && ( (wet[j*cols + k+1] == 1) || (duu > 0.0)))
         || ( (wet[j*cols + k+1] == 1) && (duu < 0.0))     
         ){
          un[j*cols + k] = uu+duu;
      }//if
      
      vn[j*cols + k]  = 0.0;
      vv = v[j*cols + k];
      if (  (  (wet[j*cols + k] == 1)
             && ( (wet[(j+1)*cols + k] == 1) || (dvv > 0.0)))
         || ((wet[(j+1)*cols + k] == 1) && (dvv < 0.0))     
         ){
          vn[j*cols + k] = vv+dvv;
      }//if
}//if
//    }//for
//  }//for
}//()


// DYN2
// -------------------------------
__kernel void kernel_dyn2( const stypeDevice dt
               , const stypeDevice dx
               , const stypeDevice dy
               , __global stypeDevice * restrict eta
               , __global stypeDevice * restrict un
               , __global stypeDevice * restrict u
               , __global stypeDevice * restrict v
               , __global stypeDevice * restrict vn
               , __global stypeDevice * restrict h
               , __global stypeDevice * restrict etan
               , const int rows
               , const int cols
               ) {



 //locals
//-------------------
//__local stypeDevice du[rows][cols];
//__local stypeDevice dv[rows][cols];
//posix_memalign ((void**)&du, ALIGNMENT, SIZE*BytesPerWord);
//posix_memalign ((void**)&dv, ALIGNMENT, SIZE*BytesPerWord);
stypeDevice hue;
stypeDevice huw;
stypeDevice hwp;
stypeDevice hwn;
stypeDevice hen;
stypeDevice hep;
stypeDevice hvn;
stypeDevice hvs;
stypeDevice hsp;
stypeDevice hsn;
stypeDevice hnn;
stypeDevice hnp;
int j, k, index;

      index = get_global_id(0);
      j = index / rows;      
      k = index % rows;


//sea level predictor
//--------------------
//TODO: Can I merge this loop? Note the use of stencil.. if I merge, then I will get stale values?
//  for (j=1; j<= rows-2; j++) {
//    for (k=1; k<= cols-2; k++) {   

//exclude boundaries
if  ((j>=1) && (k>=1) && (j<= rows-2) && (k<=cols-2)) {      
      hep = 0.5*( un[j*cols + k] + ABS(un[j*cols + k]) ) * h[j*cols + k  ];
      hen = 0.5*( un[j*cols + k] - ABS(un[j*cols + k]) ) * h[j*cols + k+1];
      hue = hep+hen;

      hwp = 0.5*( un[j*cols + k-1] + ABS(un[j*cols + k-1]) ) * h[j*cols + k-1];
      hwn = 0.5*( un[j*cols + k-1] - ABS(un[j*cols + k-1]) ) * h[j*cols + k  ];
      huw = hwp+hwn;

      hnp = 0.5*( vn[j*cols + k] + ABS(vn[j*cols + k]) ) * h[    j*cols + k];
      hnn = 0.5*( vn[j*cols + k] - ABS(vn[j*cols + k]) ) * h[(j+1)*cols + k];
      hvn = hnp+hnn;

      hsp = 0.5*( vn[(j-1)*cols + k] + ABS(vn[(j-1)*cols + k]) ) * h[(j-1)*cols + k];
      hsn = 0.5*( vn[(j-1)*cols + k] - ABS(vn[(j-1)*cols + k]) ) * h[    j*cols + k];
      hvs = hsp+hsn;

      etan[j*cols + k]  = eta[j*cols + k]
                        - dt*(hue-huw)/dx
                        - dt*(hvn-hvs)/dy;
}//if

//    }//for
//  }//for  


}//()


//------------------------------------------
// SHAPIRO KERNEL
//------------------------------------------
__kernel void kernel_shapiro     ( const stypeDevice eps 
                        , __global stypeDevice * restrict etan
                        , __global stypeDevice * restrict wet 
                        , __global stypeDevice * restrict eta
                         , const int rows
                         , const int cols
                        ) {

  //locals
  int j,k, index;
  stypeDevice term1,term2,term3;

      index = get_global_id(0);
      j = index / rows;      
      k = index % rows;

  //1-order Shapiro filter
//  for (j=1; j<= rows-2; j++) {
//    for (k=1; k<= cols-2; k++) {   

//exclude boundaries
if  ((j>=1) && (k>=1) && (j<= rows-2) && (k<=cols-2)) {      
        if (wet[j*cols + k]==1) {
        term1 = ( 1.0-0.25*eps
                  * ( wet[    j*cols + k+1] 
                    + wet[    j*cols + k-1] 
                    + wet[(j+1)*cols + k  ] 
                    + wet[(j-1)*cols + k  ] 
                    ) 
                )
                * etan[j*cols + k]; 
        term2 = 0.25*eps
                * ( wet [j*cols + k+1]
                  * etan[j*cols + k+1]
                  + wet [j*cols + k-1]
                  * etan[j*cols + k-1]
                  );
        term3 = 0.25*eps
                * ( wet [(j+1)*cols + k]
                  * etan[(j+1)*cols + k]
                  + wet [(j-1)*cols + k]
                  * etan[(j-1)*cols + k]
                  );
        eta[j*cols + k] = term1 + term2 + term3;
      }//if
      else {
        eta[j*cols + k] = etan[j*cols + k];
      }//else
}//if

//    }//for
//  }//for
}//()


//------------------------------------------
// UPDATES KERNEL
//------------------------------------------
__kernel void kernel_updates ( __global stypeHost * restrict h 
                    , __global stypeHost * restrict hzero
                    , __global stypeHost * restrict eta
                    , __global stypeHost * restrict u
                    , __global stypeHost * restrict un
                    , __global stypeHost * restrict v
                    , __global stypeHost * restrict vn
                    , __global stypeHost * restrict wet
                    , stypeHost hmin
                    , const int rows
                    , const int cols
                    ) {

  int j, k, index;

  index = get_global_id(0);
  j = index / rows;      
  k = index % rows;

//  for (int j=0; j<= rows-1; j++) {
//    for (int k=0; k<=cols-1; k++) {
      //h update
      h[j*cols + k] = hzero[j*cols + k] 
                    + eta  [j*cols + k];
      //wet update
      wet[j*cols + k] = 1;
      if ( h[j*cols + k] < hmin )
            wet[j*cols + k] = 0;
      //u, v updates
      u[j*cols + k] = un[j*cols + k];
      v[j*cols + k] = vn[j*cols + k];
//    }//for
//  }//for
}//()
