// Waqar Nabi, Dec 5 2016
//

#define DEBUG_KERNEL


// include the custom header file generated for this run
#include "kernelCompilerInclude.h"
// -------------------------------
// Dealing with TYPES
// -------------------------------
//needed if we want to work with double
#if WORD==DOUBLE
#pragma OPENCL EXTENSION cl_khr_fp64 : enable
#endif

//If we are using floats or doubles, we use floating version of abs (fabs)
#if WORD==INT
 #define ABS abs
#else
 #define ABS fabs
#endif

// -------------------------------
// AOCL specific
// -------------------------------
#pragma OPENCL EXTENSION cl_altera_channels : enable


#if TARGET==AOCL
#if NUM_COMPUTE_UNITS>1 
  __attribute__((num_compute_units(NUM_COMPUTE_UNITS)))
#endif
  
#if NUM_SIMD_ITEMS>1
  __attribute__((num_simd_work_items(NUM_SIMD_ITEMS)))
#endif
  
  //#ifdef REQ_WORKGROUP_SIZE
  //  __attribute__((reqd_work_group_size(REQ_WORKGROUP_SIZE)))
  //#endif
#endif

// -------------------------------
// SDACCEL specific
// -------------------------------
#if TARGET==SDACCEL
#endif    

// -------------------------------
// GENERIC attributes/opimizations
// -------------------------------
#ifdef REQ_WORKGROUPIZE
    __attribute__((reqd_work_group_size(REQ_WORKGROUP_SIZE)))
#endif

// -------------------------------
// Channel declarations
// -------------------------------
channel stypeDevice  u_in_dyn       ;//__attribute__((depth(2)));      
channel stypeDevice  v_in_dyn       ;//__attribute__((depth(2)));
channel stypeDevice  h_in_dyn       ;//__attribute__((depth(2)));
channel stypeDevice  eta_in_dyn     ;//__attribute__((depth(2)));
channel stypeDevice  etan_in_dyn    ;//__attribute__((depth(2)));
channel stypeDevice  wet_in_dyn     ;//__attribute__((depth(2)));
channel stypeDevice  hzero_in_dyn   ;//__attribute__((depth(2)));

channel stypeDevice  un_dyn1_2_dyn2     ;//__attribute__((depth(2)));
channel stypeDevice  vn_dyn1_2_dyn2     ;//__attribute__((depth(2)));
channel stypeDevice  h_dyn1_2_dyn2      ;//__attribute__((depth(2)));
channel stypeDevice  eta_dyn1_2_dyn2    ;//__attribute__((depth(2)));
channel stypeDevice  etan_dyn1_2_dyn2   ;//__attribute__((depth(2)));
channel stypeDevice  wet_dyn1_2_dyn2    ;//__attribute__((depth(2)));
channel stypeDevice  hzero_dyn1_2_dyn2  ;//__attribute__((depth(2)));

channel stypeDevice  un_dyn2_2_shapiro      ;//__attribute__((depth(2)));
channel stypeDevice  vn_dyn2_2_shapiro      ;//__attribute__((depth(2)));
channel stypeDevice  h_dyn2_2_shapiro       ;//__attribute__((depth(2)));
channel stypeDevice  eta_dyn2_2_shapiro     ;//__attribute__((depth(2)));
channel stypeDevice  etan_dyn2_2_shapiro    ;//__attribute__((depth(2)));
channel stypeDevice  wet_dyn2_2_shapiro     ;//__attribute__((depth(2)));
channel stypeDevice  hzero_dyn2_2_shapiro   ;//__attribute__((depth(2)));

channel stypeDevice eta_shapiro_2_udpate    ;//__attribute__((depth(2)));
channel stypeDevice un_shapiro_2_udpate     ;//__attribute__((depth(2)));
channel stypeDevice vn_shapiro_2_udpate     ;//__attribute__((depth(2)));
channel stypeDevice h_shapiro_2_udpate      ;//__attribute__((depth(2)));
channel stypeDevice hzero_shapiro_2_udpate  ;//__attribute__((depth(2)));

channel stypeDevice  u_out_update     ;//__attribute__((depth(2)));
channel stypeDevice  v_out_update     ;//__attribute__((depth(2)));
channel stypeDevice  h_out_update     ;//__attribute__((depth(2)));
channel stypeDevice  eta_out_update   ;//__attribute__((depth(2)));
channel stypeDevice  wet_out_update   ;//__attribute__((depth(2)));

// ===============================
// KERNELS
// ===============================

//------------------------------------------
// Read memory kernel
//------------------------------------------

__kernel void kernel_mem_rd( __global stypeDevice * restrict u
                       , __global stypeDevice * restrict v
                       , __global stypeDevice * restrict h
                       , __global stypeDevice * restrict eta
                       , __global stypeDevice * restrict etan
                       , __global stypeDevice * restrict wet
                       , __global stypeDevice * restrict hzero
                      ) {
  uint j, k, index;

//  for (index=0; index < (SIZE + COLS); index++) {     
  for (index=0; index < SIZE; index++) {     
      stypeDevice u_data = u[index];
      stypeDevice v_data = v[index];
      stypeDevice h_data = h[index];
      stypeDevice eta_data  = eta[index];
      stypeDevice etan_data = etan[index];
      stypeDevice wet_data  = wet[index];
      stypeDevice hzero_data= hzero[index];

      #ifdef DEBUG_KERNEL
      printf("K_MEM-RD-ATTEMPT-WRITE: index = %d\n", index);
      #endif

      //the write and reads from the channel must be in the same sequence, synched with memory fences
      //otherwise a deadlock can occur as the channels can be read/written out of order...
      write_channel_altera(u_in_dyn   ,u_data   );    mem_fence(CLK_CHANNEL_MEM_FENCE);
      write_channel_altera(v_in_dyn   ,v_data   );    mem_fence(CLK_CHANNEL_MEM_FENCE);
      write_channel_altera(h_in_dyn   ,h_data   );    mem_fence(CLK_CHANNEL_MEM_FENCE);
      write_channel_altera(eta_in_dyn ,eta_data );    mem_fence(CLK_CHANNEL_MEM_FENCE);
      write_channel_altera(etan_in_dyn,etan_data );   mem_fence(CLK_CHANNEL_MEM_FENCE);
      write_channel_altera(wet_in_dyn ,wet_data );    mem_fence(CLK_CHANNEL_MEM_FENCE);
      write_channel_altera(hzero_in_dyn ,hzero_data );mem_fence(CLK_CHANNEL_MEM_FENCE);

      #ifdef DEBUG_KERNEL
      printf("K_MEM-RD-ATTEMPT-SUCCESS: index = %d\n", index);
      #endif

      
//    }
//  }
  }
}


// -------------------------------
// DYN1
// -------------------------------
__kernel void kernel_dyn1( const stypeDevice dt
                         , const stypeDevice dx
                         , const stypeDevice dy
                         , const stypeDevice g
                         ) {

  //locals
  //-------------------
  stypeDevice du;
  stypeDevice dv;
  stypeDevice uu;
  stypeDevice vv;
  stypeDevice duu;
  stypeDevice dvv;

  const int arrsize   = SIZE;                 //Size of  input array(s)
  const int maxoffpos = COLS;                 //max positive offset is (j+1,k) --> COLS
  const int maxoffneg = 0;                    //no negative offset
  const int buffsize  = maxoffpos+maxoffneg+1;//size of offset buffer
  const int nloop     = arrsize + maxoffpos;  //how many times loop?

  //location of stencil in the buffer
  const int me        = (buffsize-1) - maxoffpos; 
  const int south     = me + COLS;  
  const int east      = me + 1;     
  //const int north     = me - COLS;  
  //const int west      = me - 1;     


  int buffindex; //index keeping track of what's going in the buffer
  int compindex; //index keeping track of what we are currently computing
                 //always equal to buffindex-maxoffpos. MUST NOT BE UNSIGNED
  int j, k;      //2D indices, always refer to the computation index


  //buffers for  1 row +1 as we only want (j, k+1) and (j+1,k)
  stypeDevice buffer_eta[buffsize];
  stypeDevice buffer_wet[buffsize];

  stypeDevice u_j_k      ;
  stypeDevice v_j_k      ;
  stypeDevice h_j_k      ;
  stypeDevice hzero_j_k  ;
  stypeDevice etan_j_k   ;

  stypeDevice eta_j_k  ;
  stypeDevice eta_j_kp1;
  stypeDevice eta_jp1_k;
  stypeDevice wet_j_k  ;
  stypeDevice wet_j_kp1;
  stypeDevice wet_jp1_k;

  //loop for the entire array + offset buffer
  for (int count=0; count < nloop ; count++) {  

    
    //buffindex follows loop counter, compindex trails behind due to any positive offset
    buffindex = count;
    compindex = buffindex-maxoffpos;
    j = compindex/COLS;
    k = compindex%COLS;

    #ifdef DEBUG_KERNEL
    printf("\n--------------------------------------------------------------------------------------\n");
    printf("K_DYN1-STARTING_ITERATION: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d;\n", count, buffindex, compindex, j, k);
    #endif

    //this unrolled loop implements a SHIFT-RIGHT register for the buffer, which is (should be)
    //more effecient than a naive buffer that is written in a RAM fashion
    #pragma unroll 
     for (int i = 0; i < buffsize-1 ; ++i) {
          buffer_eta[i] = buffer_eta[i + 1];
          buffer_wet[i] = buffer_wet[i + 1];
          //#ifdef DEBUG_KERNEL
          //printf("K_DYN1: buffindex = %d; buffer_wet[%d] = %f, \n",buffindex, i, buffer_wet[i]);
          //#endif

      }

    //we read into buffers until buffindex reaches limit of input array
    if(buffindex < arrsize) {
      //read in from the channel into MS location 
      //buffer_eta[buffsize-1] = read_channel_altera(eta_in_dyn);
      //buffer_wet[buffsize-1] = read_channel_altera(wet_in_dyn);
      #ifdef DEBUG_KERNEL
      printf("K_DYN1-READ-ATTEMPT-BUFFER\t: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d; Attempting to READ to channels\n", count, buffindex, compindex, j, k);
      #endif
        //count = OK

        stypeDevice a = read_channel_altera(eta_in_dyn);
        stypeDevice b = read_channel_altera(wet_in_dyn);
        
      #ifdef DEBUG_KERNEL
      printf("K_DYN1-READ,-NOT-UPDATED\t: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d; !!READ channels succeeded!!\n", count, buffindex, compindex, j, k);
      #endif      
        //count = OK
  

        buffer_eta[buffindex-1]  = a;  
        buffer_wet[buffindex-1] = b; 
        
      #ifdef DEBUG_KERNEL
      printf("K_DYN1-READ-SUCCESS-BUFFER\t: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d; !!READ channels succeeded!!\n", count, buffindex, compindex, j, k);
      #endif      
        //count = ***CORRUPTED*** (or some times count ok, j/k corrupted)
  
      count = buffindex;
      compindex = buffindex-maxoffpos;
      j = compindex/COLS;
      k = compindex%COLS;
      #ifdef DEBUG_KERNEL
      printf("K_DYN1-READ-COUNTER-RESET\t: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d; !!READ channels succeeded!!\n", count, buffindex, compindex, j, k);
      #endif      
        //count (and others) = Should be ok now

//      #ifdef DEBUG_KERNEL
//      printf("K_DYN1: buffindex = %d, compindex = %d; buffer_wet[buffindex-1] = %f:: %d, %d , %d, %f, %f, %f\n"
//       ,buffindex, compindex, buffer_wet[buffindex-1], me, south, east, buffer_wet[me], buffer_wet[south], buffer_wet[east]);
//      #endif
    }//if

    //reset corrupted counter ; TODO: This is a hack; no good reason I should have to do this...
    //also, I need to reset all derived counters as well, as they were getting corrupted too!!! (e.g. i and j)


  //start computing when compute-index gets to zero
  if(compindex>=0) {
    //get the stencil values from buffer
    eta_j_k   = buffer_eta[me];
    eta_j_kp1 = buffer_eta[east];
    eta_jp1_k = buffer_eta[south];

    wet_j_k   = buffer_wet[me];
    wet_j_kp1 = buffer_wet[east];
    wet_jp1_k = buffer_wet[south];

//    #ifdef DEBUG_KERNEL
//    printf("K_DYN1: l = %d; read wet from buffer, buffer_wet[0] = %f\n",l, wet_j_k);
//    #endif

    //get the other arrays directly from channel, which would start from index 0
    u_j_k = read_channel_altera(u_in_dyn);
    v_j_k = read_channel_altera(v_in_dyn);
    h_j_k = read_channel_altera(h_in_dyn);
    etan_j_k  = read_channel_altera(etan_in_dyn);
    hzero_j_k = read_channel_altera(hzero_in_dyn);

 //  #ifdef DEBUG_KERNEL
 //  printf("K_DYN1: buffindex = %d, compindex = %d; j = %d, k = %d, wet_j_k = %f, wet_jp1_k = %f, wet_j_kp1 = %f\n"
 //    ,buffindex, compindex ,j, k, wet_j_k, wet_jp1_k, wet_j_kp1);
 //  #endif

    stypeDevice un = 0.0;
    stypeDevice vn = 0.0;
    //exclude boundaries when computing un and vn
    if  ((j>=1) && (k>=1) && (j<= ROWS-2) && (k<=COLS-2)) {      
      //#ifdef DEBUG_KERNEL
      //printf("K_DYN1: l = %d, index = %d, (j,k) = (%d, %d); wet_j_k = %f, wet_jp1_k = %f, wet_j_kp1 = %f \n",l, index, j ,k
      //  , wet_j_k, wet_jp1_k, wet_j_kp1);
      //#endif

      duu  = -dt 
           * g
           * ( eta_j_kp1
             - eta_j_k
             ) 
           / dx;
      dvv  = -dt 
           * g
           * ( eta_jp1_k
             - eta_j_k
             ) 
           / dy;

      //prediction for u and v (merged loop)
      //---------------------------------
      uu = u_j_k;
      if (  ( (wet_j_k == 1)
              && ( (wet_j_kp1 == 1) || (duu > 0.0)))
         || ( (wet_j_kp1 == 1) && (duu < 0.0))     
         ){
          un = uu+duu;
      }//if
      
      vv = v_j_k;
      if (  (  (wet_j_k == 1)
             && ( (wet_jp1_k == 1) || (dvv > 0.0)))
         || ((wet_jp1_k == 1) && (dvv < 0.0))     
         ){
          vn = vv+dvv;
      }//if

//      #ifdef DEBUG_KERNEL
//      printf("K_DYN1:compindex = %d; computed: j = %d, k = %d, un = %f, vn = %f, wet = %f, wet_jp1_k = %f, wet_j_kp1 = %f,  eta_j_k = %f, eta_jp1_k = %f, eta_j_kp1 = %f,uu = %f, duu = %f, vv = %f, dvv = %f \n"
//                   ,compindex,j, k, un, vn, wet_j_k, wet_jp1_k, wet_j_kp1, eta_j_k,  eta_jp1_k, eta_j_kp1, uu, duu, vv, dvv);
//      #endif
    }//if not boundary
      
      #ifdef DEBUG_KERNEL
      printf("K_DYN1-WRITE-ATTEMPT: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d; Attempting to READ to channels\n", count, buffindex, compindex, j, k);
      #endif      
      
    write_channel_altera(un_dyn1_2_dyn2  ,un);
    write_channel_altera(vn_dyn1_2_dyn2  ,vn);
    write_channel_altera(h_dyn1_2_dyn2   ,h_j_k);
    write_channel_altera(eta_dyn1_2_dyn2 ,eta_j_k);
    write_channel_altera(etan_dyn1_2_dyn2 ,etan_j_k);
    write_channel_altera(wet_dyn1_2_dyn2 ,wet_j_k); 
    write_channel_altera(hzero_dyn1_2_dyn2 ,hzero_j_k); 
    
          #ifdef DEBUG_KERNEL
      printf("K_DYN1-WRITE_SUCCESS: count = %d, buffindex = %d, compindex = %d; j = %d, k = %d; Attempting to READ to channels\n", count, buffindex, compindex, j, k);
      #endif
    
  }//if(l>=BUFFSIZE)
 }//for l
}//()


// DYN2
// -------------------------------
__kernel void kernel_dyn2( const stypeDevice dt
                         , const stypeDevice dx
                         , const stypeDevice dy
                         ) {

  const int arrsize   = SIZE;                 //Size of  input array(s)
  const int maxoffpos = COLS;                 //max positive offset is (j+1,k) --> COLS
  const int maxoffneg = COLS;                 //max negative offset is (j-1,k) --> COLS
  const int buffsize  = maxoffpos+maxoffneg+1;//size of offset buffer
  const int nloop     = arrsize + maxoffpos;  //how many times loop?

  //location of stencil in the buffer
  const int me        = (buffsize-1) - maxoffpos; 
  const int south     = me + COLS;  
  const int east      = me + 1;     
  const int north     = me - COLS;  
  const int west      = me - 1;     


  int buffindex; //index keeping track of what's going in the buffer
  int compindex; //index keeping track of what we are currently computing
                 //always equal to buffindex-maxoffpos. MUST NOT BE UNSIGNED
  int j, k;      //2D indices, always refer to the computation index

  //local scalars
  stypeDevice hue;
  stypeDevice huw;
  stypeDevice hwp;
  stypeDevice hwn;
  stypeDevice hen;
  stypeDevice hep;
  stypeDevice hvn;
  stypeDevice hvs;
  stypeDevice hsp;
  stypeDevice hsn;
  stypeDevice hnn;
  stypeDevice hnp;

  //buffers for  2 row +1 for h as we need 4-point stencil
  stypeDevice buffer_h[buffsize];
  //TODO: Can I make these smaller as I  only need j+1 and k+1
  stypeDevice buffer_un[buffsize];
  stypeDevice buffer_vn[buffsize];

  //int count_dyn2 = 0;
  // The main loop //
  //while(buffindex < nloop) {
  for (int count_dyn2=0; count_dyn2 < nloop; count_dyn2++) {  
    
    buffindex = count_dyn2;
    compindex = buffindex - maxoffpos;
    j = compindex/COLS;
    k = compindex%COLS;

    #ifdef DEBUG_KERNEL
    printf("K_DYN2-LOOPTOP: count_dyn2 = %d, arrsize = %d, nloop = %d, buffindex = %d, compindex = %d; j = %d, k = %d; \n", count_dyn2, arrsize, nloop, buffindex, compindex, j, k);
    #endif
    
    // keep reading buffer until you get to end of array //
    //this unrolled loop implements a shift register
    #pragma unroll 
    for (int i = 0; i < buffsize-1 ; ++i) {
         buffer_h[i]   = buffer_h[i + 1];
         buffer_un[i]  = buffer_un[i + 1];
         buffer_vn[i]  = buffer_vn[i + 1];
    }

    // Buffering branch
    if(buffindex < arrsize) {
      #ifdef DEBUG_KERNEL
      printf("K_DYN2-READ-ATTEMPT-BUFFER: count_dyn2 = %d, buffindex = %d, compindex = %d; j = %d, k = %d; Attempting to READ to channels\n", count_dyn2, buffindex, compindex, j, k);
      #endif
      
      //read in from the channel into 0th location of shift register (for stencil)
//      buffer_h[buffindex-1]  = read_channel_altera(h_dyn1_2_dyn2);
//      buffer_un[buffindex-1] = read_channel_altera(un_dyn1_2_dyn2);
//      buffer_vn[buffindex-1] = read_channel_altera(vn_dyn1_2_dyn2);

      stypeDevice a = read_channel_altera(h_dyn1_2_dyn2);
      stypeDevice b = read_channel_altera(un_dyn1_2_dyn2);
      stypeDevice c = read_channel_altera(vn_dyn1_2_dyn2);
          
      #ifdef DEBUG_KERNEL
      printf("K_DYN2-READ-SUCCESS-BUFFER: count_dyn2 = %d, buffindex = %d, compindex = %d; j = %d, k = %d; !!READ channels succeeded!!\n", count_dyn2, buffindex, compindex, j, k);
      #endif      
    
      buffer_h[buffindex-1]  = a;  
      buffer_un[buffindex-1] = b; 
      buffer_vn[buffindex-1] = c; 
        
    
    
    
    }//if

    // Computing branch
    if (compindex>=0)  {
      //get the stencil values
      stypeDevice h_jm1_k = buffer_h[north];
      stypeDevice h_j_km1 = buffer_h[west];
      stypeDevice h_j_k   = buffer_h[me];
      stypeDevice h_j_kp1 = buffer_h[east];
      stypeDevice h_jp1_k = buffer_h[south];

      stypeDevice un_jm1_k = buffer_un[north];
      stypeDevice un_j_km1 = buffer_un[west];
      stypeDevice un_j_k   = buffer_un[me];

      stypeDevice vn_jm1_k = buffer_vn[north];
      stypeDevice vn_j_km1 = buffer_vn[west];
      stypeDevice vn_j_k   = buffer_vn[me];

      #ifdef DEBUG_KERNEL
      printf("K_DYN2-READ-ATTEMPT-OTHERS:count_dyn2 = %d, buffindex = %d, compindex = %d; j = %d, k = %d; Attempting to READ to channels\n", count_dyn2, buffindex, compindex, j, k);
      #endif
      
      //read from channel (variables not requiring stencil)
      stypeDevice eta_j_k   = read_channel_altera(eta_dyn1_2_dyn2);
      stypeDevice etan_j_k  = read_channel_altera(etan_dyn1_2_dyn2);
      stypeDevice wet_j_k   = read_channel_altera(wet_dyn1_2_dyn2);
      stypeDevice hzero_j_k = read_channel_altera(hzero_dyn1_2_dyn2);
 
      #ifdef DEBUG_KERNEL
      printf("K_DYN2-READ-SUCCESS-OTHERS:count_dyn2 = %d, buffindex = %d, compindex = %d; j = %d, k = %d; !!READ channels succeeded!!\n", count_dyn2, buffindex, compindex, j, k);
      #endif   
 
//      #ifdef DEBUG_KERNEL
//      printf("K_DYN2:compindex = %d; computed: j = %d, k = %d, etan_j_k = %f , eta_j_k = %f \n", compindex, j, k,  etan_j_k, eta_j_k);
//      #endif

      //exclude boundaries
      if  ((j>=1) && (k>=1) && (j<= ROWS-2) && (k<=COLS-2)) {      
        hep = 0.5*( un_j_k + ABS(un_j_k) ) * h_j_k;
        hen = 0.5*( un_j_k - ABS(un_j_k) ) * h_j_kp1;
        hue = hep+hen;
  
          hwp = 0.5*( un_j_km1 + ABS(un_j_km1) ) * h_j_km1;
          hwn = 0.5*( un_j_km1 - ABS(un_j_km1) ) * h_j_k;
          huw = hwp+hwn;
  
          hnp = 0.5*( vn_j_k + ABS(vn_j_k) ) * h_j_k;
          hnn = 0.5*( vn_j_k - ABS(vn_j_k) ) * h_jp1_k;
          hvn = hnp+hnn;
  
          hsp = 0.5*( vn_jm1_k + ABS(vn_jm1_k) ) * h_jm1_k;
          hsn = 0.5*( vn_jm1_k - ABS(vn_jm1_k) ) * h_j_k;
          hvs = hsp+hsn;
  
          etan_j_k  = eta_j_k
                    - dt*(hue-huw)/dx
                    - dt*(hvn-hvs)/dy;
      #ifdef DEBUG_KERNEL
      printf("K_DYN2-COMPUTE:count_dyn2 = %d, compindex = %d; computed: j = %d, k = %d, etan_j_k = %f , eta_j_k = %f \n", count_dyn2, compindex, j, k,  etan_j_k, eta_j_k);
      #endif
      }//if not boundary

      #ifdef DEBUG_KERNEL
      printf("K_DYN2-WRITE-ATTEMPT:count_dyn2 = %d, compindex = %d; j = %d, k = %d; Attempting to write to channels\n", count_dyn2, compindex, j, k);
      #endif

      write_channel_altera(un_dyn2_2_shapiro  , un_j_k);
      write_channel_altera(vn_dyn2_2_shapiro  , vn_j_k);
      write_channel_altera(wet_dyn2_2_shapiro , wet_j_k);
      write_channel_altera(eta_dyn2_2_shapiro, eta_j_k);          
      write_channel_altera(etan_dyn2_2_shapiro, etan_j_k);          
      write_channel_altera(hzero_dyn2_2_shapiro, hzero_j_k);
      
      #ifdef DEBUG_KERNEL
      printf("K_DYN2-WRITESUCCESS:count_dyn2 = %d, compindex = %d; j = %d, k = %d; !!Write channels succeeded!!\n", count_dyn2, compindex, j, k);
      #endif
      }//if l>=BUFFERSIZE
      
      #ifdef DEBUG_KERNEL
      printf("K_DYN2-ENDOFLOOP: nloop = %d, count_dyn2 = %d, compindex = %d; j = %d, k = %d; \n", nloop, count_dyn2, compindex, j, k);
      printf("----------------------------------------------------------------------------\n");
      #endif
      
      //count_dyn2 = count_dyn2 + 1;
  }//for l
}//()


//------------------------------------------
// SHAPIRO KERNEL
//------------------------------------------
__kernel void kernel_shapiro  ( const stypeDevice eps 
                              ) {

  const int arrsize   = SIZE;                 //Size of  input array(s)
  const int maxoffpos = COLS;                 //max positive offset is (j+1,k) --> COLS
  const int maxoffneg = COLS;                 //max negative offset is (j-1,k) --> COLS
  const int buffsize  = maxoffpos+maxoffneg+1;//size of offset buffer
  const int nloop     = arrsize + maxoffpos;  //how many times loop?

  //location of stencil in the buffer
  const int me        = (buffsize-1) - maxoffpos; 
  const int south     = me + COLS;  
  const int east      = me + 1;     
  const int north     = me - COLS;  
  const int west      = me - 1;     


  // Buffers //
  stypeDevice buffer_wet[buffsize];
  stypeDevice buffer_etan[buffsize];

  int buffindex; //index keeping track of what's going in the buffer
  int compindex; //index keeping track of what we are currently computing
                 //always equal to buffindex-maxoffpos. MUST NOT BE UNSIGNED
  int j, k;      //2D indices, always refer to the computation index

  // The main loop //
  for (int count=0; count < nloop; count++) {  

    buffindex = count;
    compindex = buffindex - maxoffpos;
    j = compindex/COLS;
    k = compindex%COLS;
      
    //this unrolled loop implements a shift register
    #pragma unroll 
    for (int i = 0; i < buffsize-1 ; ++i) {
      buffer_wet[i]   = buffer_wet[i + 1];
      buffer_etan[i]  = buffer_etan[i + 1];
    }

    if(buffindex < arrsize) {
      //read in from the channel into MS location of shift register (for stencil)
      buffer_wet[buffsize-1]  = read_channel_altera(wet_dyn2_2_shapiro);
//      printf("K_SHAPIRO\t:l = %d; read wet from channel at buffer[%d]= %f, %f, %f, %f, %f, %f \n"
//                      ,l
//                      ,BUFFSIZE-1
//                      ,buffer_wet[BUFFSIZE-1]
//                      ,buffer_wet[0]
//                      ,buffer_wet[COLS-1]
//                      ,buffer_wet[COLS] 
//                      ,buffer_wet[COLS+1]
//                      ,buffer_wet[2*COLS]
//            );

      buffer_etan[buffsize-1] = read_channel_altera(etan_dyn2_2_shapiro);
    }//if
    
    
    if(compindex>=0) {
      //get the stencil values
      stypeDevice etan_jm1_k = buffer_etan[north];
      stypeDevice etan_j_km1 = buffer_etan[west];
      stypeDevice etan_j_k   = buffer_etan[me];
      stypeDevice etan_j_kp1 = buffer_etan[east];
      stypeDevice etan_jp1_k = buffer_etan[south];

      stypeDevice wet_jm1_k = buffer_wet[north];
      stypeDevice wet_j_km1 = buffer_wet[west];
      stypeDevice wet_j_k   = buffer_wet[me];
      stypeDevice wet_j_kp1 = buffer_wet[east];
      stypeDevice wet_jp1_k = buffer_wet[south];

 //     printf("K_SHAPIRO\t:compindex = %d, j = %d, k = %d, ; got wet from buffer=  %f, %f, %f, %f, %f \n"
 //                     ,compindex, j, k 
 //                     ,buffer_wet[0]
 //                     ,buffer_wet[COLS-1]
 //                     ,buffer_wet[COLS] 
 //                     ,buffer_wet[COLS+1]
 //                     ,buffer_wet[2*COLS]
 //           );
      
      //read from channel (variables not requiring stencil)
      stypeDevice un_j_k    = read_channel_altera(un_dyn2_2_shapiro);
      stypeDevice vn_j_k    = read_channel_altera(vn_dyn2_2_shapiro);
      stypeDevice hzero_j_k = read_channel_altera(hzero_dyn2_2_shapiro);
      stypeDevice eta_j_k   = read_channel_altera(eta_dyn2_2_shapiro);

      //locals
      stypeDevice term1,term2,term3;
      
      //exclude boundaries
      if  ((j>=1) && (k>=1) && (j<= ROWS-2) && (k<=COLS-2)) {      
          if (wet_j_k==1) {
          term1 = ( 1.0-0.25*eps
                    * ( wet_j_kp1
                      + wet_j_km1
                      + wet_jp1_k
                      + wet_jm1_k
                      ) 
                  )
                  * etan_j_k;
          term2 = 0.25*eps
                  * ( wet_j_kp1
                    * etan_j_kp1
                    + wet_j_km1
                    * etan_j_km1
                    );
          term3 = 0.25*eps
                  * ( wet_jp1_k
                    * etan_jp1_k
                    + wet_jm1_k
                    * etan_jm1_k
                    );
          eta_j_k = term1 + term2 + term3;
        }//if
        else {
          eta_j_k = etan_j_k;
        }//else

//      #ifdef DEBUG_KERNEL
//      printf("K_SHAPIRO\t:compindex = %d; computed: j = %d, k = %d, eta = %f, wet_j_k = %f, wet_jp1_k = %f, wet_j_kp1 = %f, wet_jm1_k = %f, wet_j_km1 = %f \n"
//                      ,compindex, j, k, eta_j_k
//                      ,wet_j_k                      
//                      ,wet_jp1_k 
//                      ,wet_j_kp1 
//                      ,wet_jm1_k 
//                      ,wet_j_km1 
//      );
//      #endif

      }//if not boundary
    
      write_channel_altera(eta_shapiro_2_udpate , eta_j_k);
      write_channel_altera(un_shapiro_2_udpate  , un_j_k);
      write_channel_altera(vn_shapiro_2_udpate  , vn_j_k);
      write_channel_altera(hzero_shapiro_2_udpate  , hzero_j_k);      
    }//if l>BUFFERSIZE
  }//for l
}//()


//------------------------------------------
// UPDATES KERNEL
//------------------------------------------
__kernel void kernel_updates  ( stypeHost hmin
                              ) {
  int j, k, index;
  stypeDevice h_j_k;
  stypeDevice u_j_k;
  stypeDevice v_j_k;
  stypeDevice hzero_j_k ;
  stypeDevice eta_j_k   ;
  stypeDevice un_j_k    ;
  stypeDevice vn_j_k    ;
  stypeDevice wet_j_k   ;

  //we need to iterate over the entire space inc boundaries as we are reading from channel and not RAM
  for (int index=0; index < SIZE; index++) {     
      hzero_j_k = read_channel_altera(hzero_shapiro_2_udpate);
      eta_j_k   = read_channel_altera(eta_shapiro_2_udpate);
      un_j_k    = read_channel_altera(un_shapiro_2_udpate);
      vn_j_k    = read_channel_altera(vn_shapiro_2_udpate);

      int j = index/COLS;
      int k = index%COLS;

      //h update
      h_j_k = hzero_j_k
            + eta_j_k;
      //wet update
      wet_j_k = 1;
      if ( h_j_k < hmin )
            wet_j_k = 0;
      //u, v updates
      u_j_k = un_j_k;
      v_j_k = vn_j_k;

 //     #ifdef DEBUG_KERNEL
 //     printf("K_UPDATE\t:index = %d; computed: j = %d, k = %d, h = %f, h_zero = %f, eta_j_k = %f \n"
 //                     ,index, j, k
 //                     ,h_j_k
 //                     ,hzero_j_k
 //                     ,eta_j_k
 //     );
 //     #endif

      write_channel_altera(u_out_update   , u_j_k);
      write_channel_altera(v_out_update   , v_j_k);
      write_channel_altera(h_out_update   , h_j_k);
      write_channel_altera(eta_out_update , eta_j_k);
      write_channel_altera(wet_out_update , wet_j_k);
  }//for
}//()


//------------------------------------------
// Write memory kernel
//------------------------------------------
kernel void kernel_mem_wr  (__global stypeDevice* restrict u
                           ,__global stypeDevice* restrict v
                           ,__global stypeDevice* restrict h
                           ,__global stypeDevice* restrict eta
                           ,__global stypeDevice* restrict wet
) {
  for (int index=0; index < SIZE; index++) {       
      stypeDevice u_new   = read_channel_altera(u_out_update);  
      stypeDevice v_new   = read_channel_altera(v_out_update);  
      stypeDevice h_new   = read_channel_altera(h_out_update);  
      stypeDevice eta_new = read_channel_altera(eta_out_update);  
      stypeDevice wet_new = read_channel_altera(wet_out_update);  
      
      u[index] = u_new;
      v[index] = v_new;
      h[index] = h_new;
      eta[index] = eta_new;
      wet[index] = wet_new;
  }
}//()

