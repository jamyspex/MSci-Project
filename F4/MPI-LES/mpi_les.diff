---: OLD
+++: NEW

diff -ru MPI-LES/src/SConstruct Nested-LES/MPI-LES_20170624/src/SConstruct
--- MPI-LES/src/SConstruct	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/SConstruct	2017-06-24 11:19:34.000000000 +0100
@@ -1,12 +1,12 @@
 import os
 import os.path # for getting environmental variables on the system
 
-### Importing OclBuilder, this is not required for ocl=0
-### If you want to build just the Fortran code without OpenCL support, use SConstruct.F95_only
+# Importing OclBuilder, this is not required for ocl=0
+# If you want to build just the Fortran code without OpenCL support, use SConstruct.F95_only
 import OclBuilder
 from OclBuilder import initOcl
 
-### Adding path to includes for kernels
+# Adding path to includes for kernels
 CWD= os.environ['PWD']
 OclBuilder.kopts='-cl-mad-enable -cl-fast-relaxed-math -I'+CWD+'/../OpenCL/Kernels/'
 
@@ -14,7 +14,7 @@
 OclBuilder.opts=Variables()
 envF=Environment(useF=1)
 envF=Environment(ENV={'PATH' : os.environ['PATH']})
-### Then build the rest of the code
+# Then build the rest of the code
 other=''
 WITH_OCL=''
 with_ocl= getOpt('ocl','Use OpenCL','1')
@@ -51,8 +51,8 @@
     envF['LINK']=envF['F95']
 
 #if other =='':
-#    USE_NETCDF_OUTPUT='-DUSE_NETCDF_OUTPUT'
-    #envF.Append(LIBS=['netcdf']) # for version less than 4.2.0
+    USE_NETCDF_OUTPUT='-DUSE_NETCDF_OUTPUT'
+    envF.Append(LIBS=['netcdf']) # for version less than 4.2.0
 #    envF.Append(LIBS=['netcdff']) # for version more than and equal to 4.2.0 
 
 GR_DEBUG=''
@@ -75,7 +75,7 @@
 if with_ocl == '0':
 #    FFLAGS += ['-cpp', '-O', '-Wall','-ffree-form', '-fconvert=big-endian', '-mcmodel=medium', VERBOSE,TIMINGS]
      FFLAGS += ['-cpp', '-O', '-Wall','-ffree-form', '-fconvert=big-endian', '-mcmodel=medium', '-fno-range-check','-fbounds-check','-Wuninitialized','-ffpe-trap=invalid,zero,overflow', VERBOSE,TIMINGS]
-#     FFLAGS += ['-cpp', '-O', '-Wall','-ffree-form', '-fconvert=big-endian', '-mcmodel=medium','-fbounds-check', VERBOSE,TIMINGS]
+     FFLAGS += ['-cpp', '-O', '-Wall','-ffree-form', '-fconvert=big-endian', '-mcmodel=medium','-fbounds-check', VERBOSE,TIMINGS]
 #    FFLAGS += ['-cpp','-Ofast', '-m64', '-Wall','-ffree-form', '-fconvert=big-endian', VERBOSE,TIMINGS]
 
 csources=[]
@@ -92,7 +92,7 @@
 if USE_NETCDF_OUTPUT != '':
     fsources += ['./module_LES_write_netcdf.f95']
 
-fsources+= ['./fortran_helper.f95', './anime.f95','./aveflow.f95','./bondFG.f95','./bondv1.f95','./bondv1_data24.f95','./boundp.f95','./boundsm.f95','./vel2.f95','./velFG.f95','./feedbf.f95','./feedbfm.f95','./les.f95','./grid.f95','./ifdata.f95','./init.f95','./main.f95','./set.f95','./timdata.f95','./common_sn.f95','./params_common_sn.f95']
+fsources+= ['./fortran_helper.f95', './anime.f95','./aveflow.f95','./bondFG.f95','./bondv1.f95','./boundp.f95','./boundsm.f95','./vel2.f95','./velFG.f95','./feedbf.f95','./feedbfm.f95','./les.f95','./grid.f95','./ifdata.f95','./init.f95','./main.f95','./set.f95','./timdata.f95','./common_sn.f95','./params_common_sn.f95']
 
 ffsources=[]
 
@@ -127,12 +127,12 @@
         LIBPATH = '/opt/rh/devtoolset-2/root/usr/lib'
     else:
 # reasonable default ...
-  	NETCDF = os.environ.get('NETCDF')
-#	INCLPATH = [NETCDF + '/include']
-#	LIBPATH  = [NETCDF + '/lib']
-        MPICH = os.environ.get('MPICH')
-        INCLPATH = [NETCDF + '/include', MPICH + '/include']
-        LIBPATH  = [NETCDF + '/lib', MPICH + '/lib']
+  	NETCDF = os.environ.get('NETCDF_DIR')
+	INCLPATH = [NETCDF + '/include']
+	LIBPATH  = [NETCDF + '/lib']
+#MPICH = os.environ.get('MPICH')
+#INCLPATH = [NETCDF + '/include', MPICH + '/include']
+#LIBPATH = [NETCDF + '/lib', MPICH + '/lib']
 #        INCLPATH = [NETCDF + '/include', '/usr/include']
 #        LIBPATH  = [NETCDF + '/lib', '/usr/local/lib']
 #        INCLPATH = ['/usr/local/include', '/usr/include' ]

================================================================================================================================================================
diff -ru MPI-LES/src/anime.f95 Nested-LES/MPI-LES_20170624/src/anime.f95
--- MPI-LES/src/anime.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/anime.f95	2017-06-24 11:19:34.000000000 +0100
@@ -3,8 +3,7 @@
 use communication_helper_mpi
 contains
 
-!subroutine anime(n,n0,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,amask1,zbm1)
-subroutine anime(n,n0,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,amask1,zbm)
+subroutine anime(n,n0,n1,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,p,amask1,zbm)
 
     use common_sn ! create_new_include_statements() line 102
     real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(InOut) :: amask1
@@ -19,82 +18,88 @@
     integer, intent(In) :: km
     integer, intent(In) :: n
     integer, intent(In) :: n0
+    integer, intent(In) :: n1
     integer, intent(In) :: nmax
     real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
     real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
     real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
+    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(In) :: p
     real(kind=4), dimension(kp+2) , intent(In) :: z2
     real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(In)  :: zbm
 !average_out
     real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1)  :: uani
     real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1)  :: vani
     real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: wani
+    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) :: pani
 !mpi_out
+!    real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,0:kp+1)  :: ua
+!    real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,0:kp+1)  :: va
+!    real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,-1:kp+1)  :: wa
+!    real(kind=4), dimension(0:ipmax+1,0:jpmax+1,0:kp+1)   :: amask1a
+!    real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1,1) , intent(in) :: zbm1
+!    character(len=70) :: filename
 
     real(kind=4),allocatable :: ua(:,:,:)
     real(kind=4),allocatable :: va(:,:,:)
     real(kind=4),allocatable :: wa(:,:,:)
+    real(kind=4),allocatable :: pa(:,:,:)
     real(kind=4),allocatable :: amask1a(:,:,:)
 
 
-
-
-    if(n == n0.or.n == nmax.or.mod(n,1000) == 0.) then
-        do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    a1(i,j,k) = real(dxl(i-1)+dx1(i))
-                    a2(i,j,k) = real(dyl(j-1)+dy1(j))
-                    a3(i,j,k) = real(z2(k))
-                end do
-            end do
-        end do
-        open(unit=22,file=data22,form='unformatted',status='unknown')
-        write(22) im,jm,km
-        write(22) (((real(a1(i,j,k)),i=1,im),j=1,jm),k=1,km), &
-                  (((real(a3(i,j,k)),i=1,im),j=1,jm),k=1,km), &
-                  (((real(a2(i,j,k)),i=1,im),j=1,jm),k=1,km)
-        close(unit=22)
-   end if
+!    if(n == n0.or.n == nmax.or.mod(n,1000) == 0.) then
+!        do k = 1,km
+!            do j = 1,jm
+!                do i = 1,im
+!                    a1(i,j,k) = real(dxl(i-1)+dx1(i))
+!                    a2(i,j,k) = real(dyl(j-1)+dy1(j))
+!                    a3(i,j,k) = real(z2(k))
+!                end do
+!            end do
+!        end do
+!        open(unit=22,file=data22,form='unformatted',status='unknown')
+!        write(22) im,jm,km
+!        write(22) (((real(a1(i,j,k)),i=1,im),j=1,jm),k=1,km), &
+!                  (((real(a3(i,j,k)),i=1,im),j=1,jm),k=1,km), &
+!                  (((real(a2(i,j,k)),i=1,im),j=1,jm),k=1,km)
+!        close(unit=22)
+!   end if
 #ifdef MPI
 
-
-
-
-
-
-!for_average_out
-      do k=0,km
-      do j=0,jm
-      do i=0,im
-      uani(i,j,k)=uani(i,j,k)+u(i,j,k)
-      vani(i,j,k)=vani(i,j,k)+v(i,j,k)
-      wani(i,j,k)=wani(i,j,k)+w(i,j,k)
-      end do
-      end do
-      end do
-
 !reset
-!      if(n.eq.40000) then
+!      if(n.eq.n1) then  
 !      do k=0,km
 !      do j=0,jm
 !      do i=0,im
 !      uani(i,j,k)=0.
 !      vani(i,j,k)=0.
 !      wani(i,j,k)=0.
+!      pani(i,j,k)=0.
 !      end do
 !      end do
 !      end do
 !      end if
 
+!average_out
+      do k=0,km
+      do j=0,jm
+      do i=0,im
+      uani(i,j,k)=uani(i,j,k)+u(i,j,k)
+      vani(i,j,k)=vani(i,j,k)+v(i,j,k)
+      wani(i,j,k)=wani(i,j,k)+w(i,j,k)
+      pani(i,j,k)=pani(i,j,k)+p(i,j,k)
+      end do
+      end do
+      end do
+
+
+       if(n.ge.n1.and.mod(n,avetime).eq.0) then !default
+!       if(mod(n,avetime).eq.0) then !default
 
-!       if(n.gt.40001.and.mod(n,50).eq.0) then
-       if(mod(n,50).eq.0) then ! for outputing every 50 timesteps
 
 
        if (isMaster()) then
        write(filename, '("../out/data23",i6.6, ".dat")') n
-       open(unit=23,file=filename,form='unformatted',access='direct',recl=4*ipmax*jpmax) !for gfortran, recl=4*ipmax*jpmax
+       open(unit=23,file=filename,form='unformatted',access='direct',recl=4*ipmax*jpmax)
        end if
 
        allocate(ua(0:ipmax+1,-1:jpmax+1,0:kp+1))
@@ -111,7 +116,7 @@
        do k=1,km
         do j=1,jpmax
          do i=1,ipmax
-            ua(i,j,k)=ua(i,j,k)/50.
+            ua(i,j,k)=ua(i,j,k)/real(avetime)
          end do
         end do
        end do
@@ -124,7 +129,7 @@
        end do
 
        irec = 1
-       do  k=1,km
+       do  k=1,km_sl
        write(23,rec=irec) ((real(0.5*(ua(i-1,j,k)+ua(i,j,k))),i=1,ipmax),j=1,jpmax)
        irec = irec + 1
        end do
@@ -148,7 +153,7 @@
        do k=1,km
         do j=1,jpmax
          do i=1,ipmax
-            wa(i,j,k)=wa(i,j,k)/50.
+            wa(i,j,k)=wa(i,j,k)/real(avetime)
          end do
         end do
        end do
@@ -160,7 +165,8 @@
                 end do
             end do
 
-       do  k=1,km
+!       do  k=1,km
+       do  k=1,km_sl
        write(23,rec=irec) ((real(0.5*(wa(i,j,k-1)+wa(i,j,k))),i=1,ipmax),j=1,jpmax)
        irec = irec + 1
        end do
@@ -182,7 +188,7 @@
        do k=1,km
         do j=1,jpmax
          do i=1,ipmax
-            va(i,j,k)=va(i,j,k)/50.
+            va(i,j,k)=va(i,j,k)/real(avetime)
          end do
         end do
        end do
@@ -190,55 +196,60 @@
 !boundary
             do k = 1,km
                 do i = 1,ipmax
-                    va(i,0,k) = va(i,jpmax,k)
+                  va(i,0,k) = va(i,jpmax,k)
                 end do
             end do
 
 
-       do  k=1,km
+       do  k=1,km_sl
        write(23,rec=irec) ((real(0.5*(va(i,j-1,k)+va(i,j,k))),i=1,ipmax),j=1,jpmax)
        irec = irec + 1
        end do
+!------ if you output p, have to comment out this colose 
+!       close(23)
+!----------------------
        end if
        deallocate(va)
 
-
-       allocate(amask1a(0:ipmax+1,0:jpmax+1,0:kp+1))
-        call distributeamask(amask1a, amask1, ip, jp, kp, ipmax, jpmax, procPerRow)
+!--------pressure-----------
+       allocate(pa(0:ipmax+2,0:jpmax+2,0:kp+1))
+       call distributep(pa, pani, ip, jp, kp, ipmax, jpmax, procPerRow)
        if (isMaster()) then
-          do k = 1,km
+         do k = 1,km
             do j = 1,jm
                 do i = 1,im
-                 amask1a(i,j,k) = amask1(i,j,k)
+                 pa(i,j,k) = pani(i,j,k)
                 end do
             end do
           end do
 
+       do k=1,km
+        do j=1,jpmax
+         do i=1,ipmax
+            pa(i,j,k)=pa(i,j,k)/real(avetime)
+         end do
+        end do
+       end do
 
 
-
-       do  k=1,km
-       write(23,rec=irec) ((real(amask1a(i,j,k)),i=1,ipmax),j=1,jpmax)
+!       do  k=1,km
+       do  k=1,km_sl
+       write(23,rec=irec) ((pa(i,j,k),i=1,ipmax),j=1,jpmax)
        irec = irec + 1
        end do
+       close(23)
        end if
-       deallocate(amask1a)
 
-
-       if (isMaster()) then
-       write(23,rec=irec) ((real(zbm(i,j)),i=1,ipmax),j=1,jpmax)
-       irec= irec + 1
+       deallocate(pa)
 
 
-       close(unit=23)
-       end if
-
       do k=0,km
       do j=0,jm
       do i=0,im
       uani(i,j,k)=0.
       vani(i,j,k)=0.
       wani(i,j,k)=0.
+      pani(i,j,k)=0.
       end do
       end do
       end do
@@ -251,77 +262,6 @@
 
 
 
-subroutine anime_bond(n,n0,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,amask1,zbm)
-
-    use common_sn ! create_new_include_statements() line 102
-    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(InOut) :: amask1
-    character(len=70), intent(In) :: data22
-    character(len=70), intent(In) :: data23
-    real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
-    real(kind=4), dimension(0:ip) , intent(In) :: dxl
-    real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
-    real(kind=4), dimension(0:jp) , intent(In) :: dyl
-    integer, intent(In) :: im
-    integer, intent(In) :: jm
-    integer, intent(In) :: km
-    integer, intent(In) :: n
-    integer, intent(In) :: n0
-    integer, intent(In) :: nmax
-    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
-    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
-    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
-    real(kind=4), dimension(kp+2) , intent(In) :: z2
-    real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(In)  :: zbm
-
-!bond_out
-    real(kind=4), dimension(1,jpmax,kp)  :: ubonda
-    real(kind=4), dimension(1,jpmax,kp)  :: vbonda
-    real(kind=4), dimension(1,jpmax,kp)  :: wbonda
-
-
-#ifdef MPI
-
-
-
-       call distributebondoutu(ubonda, u, ip, jp, kp, ipmax, jpmax, procPerRow)
-       call distributebondoutu(vbonda, v, ip, jp, kp, ipmax, jpmax, procPerRow)
-       call distributebondoutw(wbonda, w, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-
-
-       if (isMaster()) then
-
-
-       write(filename, '("data24",i6.6, ".dat")') n
-
-       open(unit=24,file=filename,form='unformatted',status='replace',access='direct',recl=4*jpmax)
-       irec = 1
-        do k=1,km
-        write(24,rec=irec) (ubonda(1,j,k),j=1,jpmax)
-      irec=irec+1
-        end do
-
-        do k=1,km
-        write(24,rec=irec) (wbonda(1,j,k),j=1,jpmax)
-      irec=irec+1
-        end do
-
-        do k=1,km
-        write(24,rec=irec) (vbonda(1,j,k),j=1,jpmax)
-      irec=irec+1
-        end do
-
-       close(unit=24)
-
-
-       end if
-#endif
-
-end subroutine anime_bond
-
-
-
-
 !data30,31
 subroutine ifdata_out(n,n0,n1,nmax,time,km,jm,im,u,w,v,p,usum,vsum,wsum,f,g,h,fold,gold,hold)
 
@@ -342,17 +282,31 @@
     real(kind=4), dimension(0:ip,0:jp,0:kp), intent(In)  :: usum
     real(kind=4), dimension(0:ip,0:jp,0:kp), intent(In)  :: vsum
     real(kind=4), dimension(0:ip,0:jp,0:kp), intent(In)  :: wsum
+
     real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1),intent(In)  :: p
 
     real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In)  :: f
     real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In)  :: g
     real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In)  :: h
+!    real(kind=4), dimension(0:ipmax,0:jpmax,0:kp) :: fa
+!    real(kind=4), dimension(0:ipmax,0:jpmax,0:kp) :: ga
+!    real(kind=4), dimension(0:ipmax,0:jpmax,0:kp) :: ha
 
     real(kind=4), dimension(ip,jp,kp) , intent(In)  :: fold
     real(kind=4), dimension(ip,jp,kp) , intent(In)  :: gold
     real(kind=4), dimension(ip,jp,kp) , intent(In)  :: hold
+!    real(kind=4), dimension(ipmax,jpmax,kp) :: folda
+!    real(kind=4), dimension(ipmax,jpmax,kp) :: golda
+!    real(kind=4), dimension(ipmax,jpmax,kp) :: holda
 
 !mpi_out
+!    real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,0:kp+1)  :: ua
+!    real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,0:kp+1)  :: va
+!    real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,-1:kp+1)  :: wa
+!    real(kind=4), dimension(0:ipmax+1,0:jpmax+1,0:kp+1)   :: amask1a
+!    real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1,1) , intent(in) :: zbm1
+!    character(len=70) :: filename
+
     real(kind=4),allocatable :: ua(:,:,:)
     real(kind=4),allocatable :: va(:,:,:)
     real(kind=4),allocatable :: wa(:,:,:)
@@ -370,9 +324,10 @@
 
 
        if((n.eq.n1-1).or.(n.eq.nmax))  then      
+!       if((mod(n,12000).eq.0).or.(n.eq.nmax))  then      
 
         if (isMaster()) then
-        write(filename, '("data30",i6.6, ".dat")') n
+        write(filename, '("../data/data30",i6.6, ".dat")') n
 
         open(unit=30,file=filename,form='unformatted',status='replace')
 
@@ -489,7 +444,7 @@
 
 
         if (isMaster()) then
-        write(filename, '("data31",i6.6, ".dat")') n
+        write(filename, '("../data/data31",i6.6, ".dat")') n
         open(unit=31,file=filename,form='unformatted',status='replace')
 
         end if
@@ -586,240 +541,11 @@
         end if
         deallocate(holda)
 
- 
-
         end if
 
-
-
 end subroutine ifdata_out
 
 
 
-subroutine timestep_out_all_k(n,n0,n1,nmax,km,jm,im,z2,data22,data23,u,w,v,amask1,ut_x1,vt_x1,wt_x1,ut_x2,vt_x2,wt_x2,nspec&
-,u_spany2,v_spany2,w_spany2,u_spany3,v_spany3,w_spany3&
-,u_x1_19_spany2,v_x1_19_spany2,w_x1_19_spany2,u_x1_19_spany3,v_x1_19_spany3,w_x1_19_spany3)
-
-    use common_sn ! create_new_include_statements() line 102
-    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(InOut) :: amask1
-    character(len=70), intent(In) :: data22
-    character(len=70), intent(In) :: data23
-    integer, intent(In) :: im
-    integer, intent(In) :: jm
-    integer, intent(In) :: km
-    integer, intent(In) :: n
-    integer, intent(In) :: n0
-    integer, intent(In) :: nmax
-
-    integer, intent(In) ::  nspec
-
-    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
-    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
-    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
-    real(kind=4), dimension(kp+2) , intent(In) :: z2
-
-    real(kind=4), dimension(1,1,nspec+1,kp),intent(out)  :: ut_x1
-    real(kind=4), dimension(1,1,nspec+1,kp),intent(out)  :: ut_x2
-    real(kind=4), dimension(1,1,nspec+1,kp),intent(out)  :: vt_x1
-    real(kind=4), dimension(1,1,nspec+1,kp),intent(out)  :: vt_x2
-    real(kind=4), dimension(1,1,nspec+1,kp),intent(out)  :: wt_x1
-    real(kind=4), dimension(1,1,nspec+1,kp),intent(out)  :: wt_x2
-
-
-    real(kind=4), dimension(1,kp,nspec+1),intent(out)  :: u_spany2
-    real(kind=4), dimension(1,kp,nspec+1),intent(out)  :: v_spany2
-    real(kind=4), dimension(1,kp,nspec+1),intent(out)  :: w_spany2
-    real(kind=4), dimension(1,kp,nspec+1),intent(out)  :: u_spany3
-    real(kind=4), dimension(1,kp,nspec+1),intent(out)  :: v_spany3
-    real(kind=4), dimension(1,kp,nspec+1),intent(out)  :: w_spany3
-
-    real(kind=4), dimension(19,kp,nspec+1),intent(out)  :: u_x1_19_spany2
-    real(kind=4), dimension(19,kp,nspec+1),intent(out)  :: v_x1_19_spany2
-    real(kind=4), dimension(19,kp,nspec+1),intent(out)  :: w_x1_19_spany2
-    real(kind=4), dimension(19,kp,nspec+1),intent(out)  :: u_x1_19_spany3
-    real(kind=4), dimension(19,kp,nspec+1),intent(out)  :: v_x1_19_spany3
-    real(kind=4), dimension(19,kp,nspec+1),intent(out)  :: w_x1_19_spany3
-
-    integer :: x1,x2,x3,y1,y2,y3,t,nsta
-
-
-      x1=20
-      x2=60
-      x3=80
-!      y1=1  
-      y2=25
-      y3=50
-!spanwise timestep output,   
-     if(n.ge.n1) then
-     if(rank.ge.54.and.rank.le.59) then !for using outflow boundary value and this case is procPerRow=6 procPerCol=10
-
-     do k=1,kp
-     u_spany2(1,k,n-n1+1) = real(0.5*(u(x3-1,y2,k)+u(x3,y2,k)))
-     v_spany2(1,k,n-n1+1) = real(0.5*(v(x3,y2-1,k)+v(x3,y2,k)))
-     w_spany2(1,k,n-n1+1) = real(0.5*(w(x3,y2,k-1)+w(x3,y2,k)))
-     u_spany3(1,k,n-n1+1) = real(0.5*(u(x3-1,y3,k)+u(x3,y3,k)))
-     v_spany3(1,k,n-n1+1) = real(0.5*(v(x3,y3-1,k)+v(x3,y3,k)))
-     w_spany3(1,k,n-n1+1) = real(0.5*(w(x3,y3,k-1)+w(x3,y3,k)))
-     end do
-
-      if(n.eq.nmax) then
-
-       write(filename, '("uvw_y2_spanwise",i3.3,"_outflow.dat")') rank
-
-!       do t=1,nspec
-!        write(*,*) 'u_spany2=',u_spany2(1,10,t)
-!        write(*,*) 'v_spany2=',v_spany2(1,10,t)
-!        write(*,*) 'w_spany2=',w_spany2(1,10,t)
-!       end do
-
-       open(unit=15,file=filename,form='unformatted',status='unknown')
-       write(15) ((real(u_spany2(1,k,t)),k=1,kp),t=1,nspec)
-       write(15) ((real(v_spany2(1,k,t)),k=1,kp),t=1,nspec)
-       write(15) ((real(w_spany2(1,k,t)),k=1,kp),t=1,nspec)
-
-      close(15)
-
-
-       write(filename, '("uvw_y3_spanwise",i3.3,"_outflow.dat")') rank
-
-!       do t=1,nspec
-!        write(*,*) 'u_spany3=',u_spany3(1,10,t)
-!        write(*,*) 'v_spany3=',v_spany3(1,10,t)
-!        write(*,*) 'w_spany3=',w_spany3(1,10,t)
-!       end do
-
-       open(unit=15,file=filename,form='unformatted',status='unknown')
-       write(15) ((real(u_spany3(1,k,t)),k=1,kp),t=1,nspec)
-       write(15) ((real(v_spany3(1,k,t)),k=1,kp),t=1,nspec)
-       write(15) ((real(w_spany3(1,k,t)),k=1,kp),t=1,nspec)
-
-       close(15)
-
-
-
-     end if
-     end if
-     end if
-
-
-
-! near-input timestep output
-     if(n.ge.n1) then
-     if(rank.ge.0.and.rank.le.5) then !for using value near to inflow boundary and this case is procPerRow=6 procPerCol=10
-
-     do k=1,kp
-     do i=1,19
-     u_x1_19_spany2(i,k,n-n1+1) = real(0.5*(u(i-1,y2,k)+u(i,y2,k)))
-     v_x1_19_spany2(i,k,n-n1+1) = real(0.5*(v(i,y2-1,k)+v(i,y2,k)))
-     w_x1_19_spany2(i,k,n-n1+1) = real(0.5*(w(i,y2,k-1)+w(i,y2,k)))
-     u_x1_19_spany3(i,k,n-n1+1) = real(0.5*(u(i-1,y3,k)+u(i,y3,k)))
-     v_x1_19_spany3(i,k,n-n1+1) = real(0.5*(v(i,y3-1,k)+v(i,y3,k)))
-     w_x1_19_spany3(i,k,n-n1+1) = real(0.5*(w(i,y3,k-1)+w(i,y3,k)))
-     end do
-     end do
-
-      if(n.eq.nmax) then
-
-       write(filename, '("uvw_x1_19_y2_spanwise",i3.3,".dat")') rank
-
-!       do t=1,nspec
-!        write(*,*) 'u_x1_19_spany2=',u_x1_19_spany2(1,10,t)
-!        write(*,*) 'v_x1_19_spany2=',v_x1_19_spany2(1,10,t)
-!        write(*,*) 'w_x1_19_spany2=',w_x1_19_spany2(1,10,t)
-!       end do
-
-       open(unit=15,file=filename,form='unformatted',status='unknown')
-       write(15) (((real(u_x1_19_spany2(i,k,t)),i=1,19),k=1,kp),t=1,nspec)
-       write(15) (((real(v_x1_19_spany2(i,k,t)),i=1,19),k=1,kp),t=1,nspec)
-       write(15) (((real(w_x1_19_spany2(i,k,t)),i=1,19),k=1,kp),t=1,nspec)
-
-       close(15)
-
-
-       write(filename, '("uvw_x1_19_y3_spanwise",i3.3,".dat")') rank
-
-!       do t=1,nspec
-!        write(*,*) 'u_x1_19_spany3=',u_x1_19_spany3(1,10,t)
-!        write(*,*) 'v_x1_19_spany3=',v_x1_19_spany3(1,10,t)
-!        write(*,*) 'w_x1_19_spany3=',w_x1_19_spany3(1,10,t)
-!       end do
-
-       open(unit=15,file=filename,form='unformatted',status='unknown')
-       write(15) (((real(u_x1_19_spany3(i,k,t)),i=1,19),k=1,kp),t=1,nspec)
-       write(15) (((real(v_x1_19_spany3(i,k,t)),i=1,19),k=1,kp),t=1,nspec)
-       write(15) (((real(w_x1_19_spany3(i,k,t)),i=1,19),k=1,kp),t=1,nspec)
-
-       close(15)
-
-     end if
-     end if
-     end if
-
-
-
-!streamwise timestep output
-
-      if(n.ge.n1) then
-
-      if(mod(rank,6).eq.3) then !for using middle value in domain and this case is procPerRow=6 procPerCol=10
-      call MPI_COMM_Rank(communicator, rank, ierror)
-      call checkMPIError()
-      write(*,*) 'rank=',rank
-
-
-      nsta = n - n1 + 1
-
-      
-      do k=1,kp
-
-! u&v&w are outputed at scalar point
-
-      ut_x1(1,1,nsta,k)=real(0.5*(u(x1-1,y3,k)+u(x1,y3,k)))
-
-      ut_x2(1,1,nsta,k)=real(0.5*(u(x2-1,y3,k)+u(x2,y3,k)))
-
-      vt_x1(1,1,nsta,k)=real(0.5*(v(x1,y3-1,k)+v(x1,y3,k)))
-
-      vt_x2(1,1,nsta,k)=real(0.5*(v(x2,y3-1,k)+v(x2,y3,k)))
-
-      wt_x1(1,1,nsta,k)=real(0.5*(w(x1,y3,k-1)+w(x1,y3,k)))
-
-      wt_x2(1,1,nsta,k)=real(0.5*(w(x2,y3,k-1)+w(x1,y3,k)))
-
-
-      end do
-
-
-      if(n.eq.nmax) then
-
-       write(filename, '("uvwt_x1","_",i3.3,"_",i6.6,".dat")') rank,nmax
-
-       open(unit=25,file=filename,form='unformatted',status='unknown')
-       write(25) ((real(ut_x1(1,1,t,k)),t=1,nspec),k=1,kp)
-       write(25) ((real(vt_x1(1,1,t,k)),t=1,nspec),k=1,kp)
-       write(25) ((real(wt_x1(1,1,t,k)),t=1,nspec),k=1,kp)
-       
- 
-       close(25)
-
-
-       write(filename, '("uvwt_x2","_",i3.3,"_",i6.6,".dat")') rank,nmax
-
-       open(unit=26,file=filename,form='unformatted',status='unknown')
-       write(26) ((real(ut_x2(1,1,t,k)),t=1,nspec),k=1,kp)
-       write(26) ((real(vt_x2(1,1,t,k)),t=1,nspec),k=1,kp)
-       write(26) ((real(wt_x2(1,1,t,k)),t=1,nspec),k=1,kp)
-
-
-       close(26)
-
-       
-    
-      end if
-      end if
-      end if
-end subroutine timestep_out_all_k
-
-
 
 end module module_anime
================================================================================================================================================================
diff -ru MPI-LES/src/aveflow.f95 Nested-LES/MPI-LES_20170624/src/aveflow.f95
--- MPI-LES/src/aveflow.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/aveflow.f95	2017-06-24 11:19:34.000000000 +0100
@@ -75,7 +75,7 @@
     real(kind=4),allocatable :: avevva(:,:,:)
     real(kind=4),allocatable :: avewwa(:,:,:)
     real(kind=4),allocatable :: uwfxa(:,:,:)
-
+    real(kind=4),allocatable :: avepa(:,:,:)
 
     if(n == n1) then
         do k = 1,km
@@ -108,11 +108,8 @@
                 end do
             end do
         end do
-
-
     end if
 
-
     if(n >= n1) then
         do k = 1,km
             do j = 1,jm
@@ -130,7 +127,6 @@
             end do
         end do
 
-
         do k = 0,km
             do j = 1,jm
                 do i = 1,im
@@ -145,47 +141,45 @@
                 end do
             end do
         end do
+    endif
 
-
-  endif
   if(n == nmax) then
       do k = 1,km
           do j = 1,jm
               do i = 1,im
-!                  aveu(i,j,k) = aveu(i,j,k)/float(nmax-n1+1)
-                  avev(i,j,k) = avev(i,j,k)/float(nmax-n1+1)
-!                  avew(i,j,k) = avew(i,j,k)/float(nmax-n1+1)
-                  avep(i,j,k) = avep(i,j,k)/float(nmax-n1+1)
-                  avel(i,j,k) = avel(i,j,k)/float(nmax-n1+1)
-                  aveuu(i,j,k) = aveuu(i,j,k)/float(nmax-n1+1)
-                  avevv(i,j,k) = avevv(i,j,k)/float(nmax-n1+1)
-                  aveww(i,j,k) = aveww(i,j,k)/float(nmax-n1+1)
-                  avesm(i,j,k) = avesm(i,j,k)/float(nmax-n1+1)
-                  avesmsm(i,j,k) = avesmsm(i,j,k)/float(nmax-n1+1)
+!                  aveu(i,j,k) = aveu(i,j,k)/real(nmax-n1+1)
+                  avev(i,j,k) = avev(i,j,k)/real(nmax-n1+1)
+!                  avew(i,j,k) = avew(i,j,k)/real(nmax-n1+1)
+                  avep(i,j,k) = avep(i,j,k)/real(nmax-n1+1)
+                  avel(i,j,k) = avel(i,j,k)/real(nmax-n1+1)
+                  aveuu(i,j,k) = aveuu(i,j,k)/real(nmax-n1+1)
+                  avevv(i,j,k) = avevv(i,j,k)/real(nmax-n1+1)
+                  aveww(i,j,k) = aveww(i,j,k)/real(nmax-n1+1)
+                  avesm(i,j,k) = avesm(i,j,k)/real(nmax-n1+1)
+                  avesmsm(i,j,k) = avesmsm(i,j,k)/real(nmax-n1+1)
               end do
       end do
     end do
 
-        do k = 0,km
-            do j = 1,jm
-                do i = 1,im
-                    aveu(i,j,k) = aveu(i,j,k)/float(nmax-n1+1)
-                end do
+    do k = 0,km
+        do j = 1,jm
+            do i = 1,im
+                aveu(i,j,k) = aveu(i,j,k)/real(nmax-n1+1)
             end do
         end do
-        do k = 0,km
-            do j = 1,jm
-                do i = 1,im+1
-                    avew(i,j,k) = avew(i,j,k)/float(nmax-n1+1)
-                end do
+    end do
+    do k = 0,km
+        do j = 1,jm
+            do i = 1,im+1
+                avew(i,j,k) = avew(i,j,k)/real(nmax-n1+1)
             end do
         end do
-
+    end do
 
     do k = 1,km
         do j = 1,jm
             do i = 1,im
-                uwfx(i,j,k) = uwfx(i,j,k)/float(nmax-n1+1) - &
+                uwfx(i,j,k) = uwfx(i,j,k)/real(nmax-n1+1) - &
                               0.5*(aveu(i,j,k-1)+aveu(i,j,k)) * &
                               0.5*(avew(i,j, k-1)+avew(i+1,j,k-1))
             end do
@@ -193,7 +187,7 @@
     end do
 
 
-      do k = 1,km
+    do k = 1,km
         do j = 1,jm
             do i = 1,im
                 aveuu(i,j,k) = sqrt(abs(aveuu(i,j,k)-aveu(i,j,k)**2))
@@ -201,151 +195,153 @@
                 aveww(i,j,k) = sqrt(abs(aveww(i,j,k)-avew(i,j,k)**2))
             end do
         end do
-        end do
-
-
-
-       if (isMaster()) then
-    open(unit=10,file=data10,form='unformatted',status='unknown')
-
-       end if
-      allocate(aveua(0:ipmax,0:jpmax,0:kp))
-      call distributeaveu(aveua, aveu, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-       if (isMaster()) then
-          do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    aveua(i,j,k) = aveu(i,j,k)
-                end do
-            end do
-        end do
-
-        write(10) (((aveua(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
-
-       end if
-       deallocate(aveua)
-
-
-      allocate(avewa(ipmax+1,jpmax,0:kp+2))
-      call distributeavew(avewa, avew, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-       if (isMaster()) then
-          do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    avewa(i,j,k) = avew(i,j,k)
-                end do
-            end do
-        end do
-
-        write(10) (((avewa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
-
-       end if
-       deallocate(avewa)
-
-
-      allocate(aveva(0:ipmax,0:jpmax,0:kp))
-      call distributeaveu(aveva, avev, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-       if (isMaster()) then
-          do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    aveva(i,j,k) = avev(i,j,k)
-                end do
-            end do
-        end do
-
-
-        write(10) (((aveva(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
+    end do
 
-       close(10)
 
-       end if
-       deallocate(aveva)
 
+    if (isMaster()) then
+       write(filename, '("../ave_data/data10",i6.6, ".dat")') n
+       open(unit=10,file=filename,form='unformatted',status='unknown')
+    end if
+         allocate(aveua(0:ipmax,0:jpmax,0:kp))
+         call distributeaveu(aveua, aveu, ip, jp, kp, ipmax, jpmax, procPerRow)
+            if (isMaster()) then
+               do k = 1,km
+                  do j = 1,jm
+                     do i = 1,im
+                         aveua(i,j,k) = aveu(i,j,k)
+                     end do
+                  end do
+               end do
+               write(10) (((aveua(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+            end if
+         deallocate(aveua)
    
+         allocate(avewa(ipmax+1,jpmax,0:kp+2))
+         call distributeavew(avewa, avew, ip, jp, kp, ipmax, jpmax, procPerRow)
+            if (isMaster()) then
+               do k = 1,km
+                  do j = 1,jm
+                     do i = 1,im
+                         avewa(i,j,k) = avew(i,j,k)
+                     end do
+                  end do
+               end do
+               write(10) (((avewa(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+            end if
+         deallocate(avewa)
+   
+         allocate(aveva(0:ipmax,0:jpmax,0:kp))
+         call distributeaveu(aveva, avev, ip, jp, kp, ipmax, jpmax, procPerRow)
+            if (isMaster()) then
+               do k = 1,km
+                  do j = 1,jm
+                     do i = 1,im
+                         aveva(i,j,k) = avev(i,j,k)
+                     end do
+                  end do
+               end do
+               write(10) (((aveva(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+            end if
+         deallocate(aveva)
+   
+         allocate(avepa(0:ipmax,0:jpmax,0:kp))
+         call distributeaveuu(avepa, avep, ip, jp, kp, ipmax, jpmax, procPerRow)
+            if (isMaster()) then
+               do k = 1,km
+                  do j = 1,jm
+                     do i = 1,im
+                         avepa(i,j,k) = avep(i,j,k)
+                     end do
+                  end do
+               end do
+               write(10) (((avepa(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
 
+       close(10)
+            end if
+         deallocate(avepa)
 
 
-       if (isMaster()) then
-       open(unit=11,file=data11,form='unformatted',status='unknown')
-       end if
-      allocate(aveuua(0:ipmax,0:jpmax,0:kp))
-      call distributeaveuu(aveuua, aveuu, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-       if (isMaster()) then
-          do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    aveuua(i,j,k) = aveuu(i,j,k)
-                end do
-            end do
-        end do
-
-        write(11) (((aveuua(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
-
-       end if
-       deallocate(aveuua)
-
-
-
-      allocate(avewwa(0:ipmax,0:jpmax,0:kp))
-      call distributeaveuu(avewwa, aveww, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-       if (isMaster()) then
-          do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    avewwa(i,j,k) = aveww(i,j,k)
-                end do
-            end do
-        end do
-
-        write(11) (((avewwa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
-
-       end if
-       deallocate(avewwa)
-
-
-      allocate(avevva(0:ipmax,0:jpmax,0:kp))
-      call distributeaveuu(avevva, avevv, ip, jp, kp, ipmax, jpmax, procPerRow)
-
-       if (isMaster()) then
-          do k = 1,km
-            do j = 1,jm
-                do i = 1,im
-                    avevva(i,j,k) = avevv(i,j,k)
-                end do
+    if (isMaster()) then
+       write(filename, '("../ave_data/data11",i6.6, ".dat")') n
+       open(unit=11,file=filename,form='unformatted',status='unknown')
+    end if
+         allocate(aveuua(0:ipmax,0:jpmax,0:kp))
+         call distributeaveuu(aveuua, aveuu, ip, jp, kp, ipmax, jpmax, procPerRow)
+         if (isMaster()) then
+            do k = 1,km
+               do j = 1,jm
+                  do i = 1,im
+                      aveuua(i,j,k) = aveuu(i,j,k)
+                  end do
+               end do
+            end do
+            write(11) (((aveuua(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+         end if
+         deallocate(aveuua)
+       
+       
+         allocate(avewwa(0:ipmax,0:jpmax,0:kp))
+         call distributeaveuu(avewwa, aveww, ip, jp, kp, ipmax, jpmax, procPerRow)
+         if (isMaster()) then
+            do k = 1,km
+               do j = 1,jm
+                  do i = 1,im
+                      avewwa(i,j,k) = aveww(i,j,k)
+                  end do
+               end do
+            end do
+            write(11) (((avewwa(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+         end if
+         deallocate(avewwa)
+       
+         allocate(avevva(0:ipmax,0:jpmax,0:kp))
+         call distributeaveuu(avevva, avevv, ip, jp, kp, ipmax, jpmax, procPerRow)
+         if (isMaster()) then
+            do k = 1,km
+               do j = 1,jm
+                  do i = 1,im
+                      avevva(i,j,k) = avevv(i,j,k)
+                  end do
+               end do
+            end do
+            write(11) (((avevva(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+         end if
+         deallocate(avevva)
+       
+        allocate(uwfxa(0:ipmax,0:jpmax,0:kp))
+        call distributeaveuu(uwfxa, uwfx, ip, jp, kp, ipmax, jpmax, procPerRow)
+        if (isMaster()) then
+            do k = 1,km
+               do j = 1,jm
+                  do i = 1,im
+                      uwfxa(i,j,k) = uwfx(i,j,k)
+                  end do
+               end do
             end do
-        end do
-
-        write(11) (((avevva(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
-
-       end if
-       deallocate(avevva)
-
-
-      allocate(uwfxa(0:ipmax,0:jpmax,0:kp))
-      call distributeaveuu(uwfxa, uwfx, ip, jp, kp, ipmax, jpmax, procPerRow)
+            write(11) (((uwfxa(i,j,k),i=ibuffer+1,ipmax-ibuffer),j=jbuffer+1,jpmax-jbuffer),k=1,km)
+      close(11) 
+ 
+        end if
+        deallocate(uwfxa)
 
-       if (isMaster()) then
-          do k = 1,km
+        do k = 1,km
             do j = 1,jm
                 do i = 1,im
-                    uwfxa(i,j,k) = uwfx(i,j,k)
+                    aveu(i,j,k) = 0.0
+                    avev(i,j,k) = 0.0
+                    avew(i,j,k) = 0.0
+                    avep(i,j,k) = 0.0
+                    avel(i,j,k) = 0.0
+                    aveuu(i,j,k) = 0.0
+                    avevv(i,j,k) = 0.0
+                    aveww(i,j,k) = 0.0
+                    avesm(i,j,k) = 0.0
+                    avesmsm(i,j,k) = 0.0
+                    uwfx(i,j,k) = 0.0
                 end do
             end do
         end do
-
-        write(11) (((uwfxa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
-     
-       close(11) 
- 
-       end if
-       deallocate(uwfxa)
-
     
 
 !#endif
@@ -354,3 +350,4 @@
 end subroutine aveflow
 
 end module module_aveflow
+
================================================================================================================================================================
diff -ru MPI-LES/src/bondv1.f95 Nested-LES/MPI-LES_20170624/src/bondv1.f95
--- MPI-LES/src/bondv1.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/bondv1.f95	2017-06-24 11:19:34.000000000 +0100
@@ -15,7 +15,7 @@
     real(kind=4), dimension(0:kp+2) , intent(In) :: z2
     real(kind=4) :: u_val
     integer :: i, j, k
-    real(kind=4) :: aaa, bbb, uout
+    real(kind=4) :: aaa, bbb, uout, gaaa, gbbb
 !    integer, intent(In) :: ical
 
 #ifdef MPI
@@ -33,10 +33,10 @@
         do i = 0,1
             do k = 1,78 ! kp = 90 so OK
                 do j = 1,jm
-!                    u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
+                    u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
+                    u(i,j,k) = u_val
                     !print *, u_val
-!                    u(i,j,k) = u_val
-                    u(i,j,k) = 5.0
+!                    u(i,j,k) = 5.0
                     v(i,j,k) = 0.0
                     w(i,j,k) = 0.0
                 end do
@@ -95,43 +95,72 @@
 ! ------------- outflow condition ------------
 !      advective condition
 !
+
+!    aaa = 0.0
+!    bbb = 0.0
+!    gaaa = 0.0
+!    gbbb = 0.0
+!    do k = 1,km
+!        do j = 1,jm
+!            aaa = amax1(aaa,u(im,j,k))
+!            bbb = amin1(bbb,u(im,j,k))
+!        end do
+!    end do
+!#ifdef MPI
+!    call gatheraaa(gaaa, aaa, procPerRow)
+!    call gatherbbb(gbbb, bbb, procPerRow)
+!#endif
+
     aaa = 0.0
-    bbb = 0.0
+    gaaa = 0.0
     do k = 1,km
         do j = 1,jm
             aaa = amax1(aaa,u(im,j,k))
+        end do
+    end do
+#ifdef MPI
+    call gatheraaa(gaaa, aaa, procPerRow)
+#endif
+    bbb = aaa
+    gbbb = gaaa
+    do k = 1,km
+        do j = 1,jm
             bbb = amin1(bbb,u(im,j,k))
         end do
     end do
 #ifdef MPI
-    call getGlobalMaxOf(aaa)
-    call getGlobalMinOf(bbb)
+    call gatherbbb(gbbb, bbb, procPerRow)
 #endif
+
 #if GR_DEBUG
-    print*, 'GR: aaa ', aaa, ' bbb ', bbb
+    print*, 'GR: gaaa ', gaaa, ' gbbb ', gbbb
 #endif
 
-    uout = (aaa+bbb)/2.
+    uout = (gaaa+gbbb)/2.
 #ifdef WV_DEBUG
     print *, 'F95: UOUT: ',uout
 #endif
-    do k = 1,km
-        do j = 1,jm
-            u(im,j,k) = u(im,j,k)-dt*uout *(u(im,j,k)-u(im-1,j,k))/dxs(im)
-        end do
-    end do
-
-    do k = 1,km
-        do j = 1,jm
-            v(im+1,j,k) = v(im+1,j,k)-dt*uout *(v(im+1,j,k)-v(im,j,k))/dxs(im)
-        end do
-    end do
+    if (isBottomRow(procPerRow)) then
 
-    do k = 1,km
-        do j = 1,jm
-            w(im+1,j,k) = w(im+1,j,k)-dt*uout *(w(im+1,j,k)-w(im,j,k))/dxs(im)
-        end do
-    end do
+      do k = 1,km
+          do j = 1,jm
+              u(im,j,k) = u(im,j,k)-dt*uout *(u(im,j,k)-u(im-1,j,k))/dxs(im)
+          end do
+      end do
+   
+      do k = 1,km
+          do j = 1,jm
+              v(im+1,j,k) = v(im+1,j,k)-dt*uout *(v(im+1,j,k)-v(im,j,k))/dxs(im)
+          end do
+      end do
+   
+      do k = 1,km
+          do j = 1,jm
+              w(im+1,j,k) = w(im+1,j,k)-dt*uout *(w(im+1,j,k)-w(im,j,k))/dxs(im)
+          end do
+      end do
+ 
+    end if
 #if !defined(MPI) || (PROC_PER_ROW==1)
 ! --side flow condition; periodic
     do k = 0,km+1
Only in MPI-LES/src/: bondv1_data24.f95
================================================================================================================================================================
diff -ru MPI-LES/src/communication_helper_real.f95 Nested-LES/MPI-LES_20170624/src/communication_helper_real.f95
--- MPI-LES/src/communication_helper_real.f95	2016-08-09 14:34:13.000000000 +0100
+++ Nested-LES/MPI-LES_20170624/src/communication_helper_real.f95	2017-06-24 11:19:34.000000000 +0100
@@ -69,56 +69,55 @@
     rowCount = size(array, 1) - topThickness - bottomThickness
     colCount = size(array, 2) - leftThickness - rightThickness
     depthSize = size(array, 3)
-    allocate(leftRecv(rowCount, rightThickness, depthSize)) 
-    allocate(rightSend(rowCount, leftThickness, depthSize)) 
-    allocate(rightRecv(rowCount, leftThickness, depthSize)) 
-    allocate(leftSend(rowCount, rightThickness, depthSize)) 
-    allocate(topRecv(bottomThickness, colCount, depthSize)) 
-    allocate(bottomSend(topThickness, colCount, depthSize)) 
-    allocate(bottomRecv(topThickness, colCount, depthSize)) 
-    allocate(topSend(bottomThickness, colCount, depthSize)) 
+    allocate(leftRecv(rowCount, rightThickness, depthSize))
+    allocate(rightSend(rowCount, leftThickness, depthSize))
+    allocate(rightRecv(rowCount, leftThickness, depthSize))
+    allocate(leftSend(rowCount, rightThickness, depthSize))
+    allocate(topRecv(bottomThickness, colCount, depthSize))
+    allocate(bottomSend(topThickness, colCount, depthSize))
+    allocate(bottomRecv(topThickness, colCount, depthSize))
+    allocate(topSend(bottomThickness, colCount, depthSize))
 #ifdef MPI
     do i=1,8
         requests(i)= MPI_REQUEST_NULL
     end do
 #endif
-    ! Top edge to send, bottom edge to receive. 
+    ! Top edge to send, bottom edge to receive
     commWith = neighbours(topNeighbour)
     if (commWith .ne. -1) then
         !print*, 'rank ', rank, ' communicating with top neighbour ', commWith
         do r=1, bottomThickness
             do c=1, colCount
                 do d=1, depthSize
-                    topSend(r, c, d) = array(r + topThickness, c+leftThickness, d) 
+                    topSend(r, c, d) = array(r + topThickness, c+leftThickness, d)
                 end do
             end do
         end do
         call MPI_ISend(topSend, bottomThickness*colCount*depthSize, MPI_REAL, commWith, topTag, &
-                      cartTopComm, requests(1), ierror) 
+                      cartTopComm, requests(1), ierror)
         call checkMPIError()
         call MPI_IRecv(bottomRecv, topThickness*colCount*depthSize, MPI_REAL, commWith, bottomTag, &
-                      communicator, requests(2), ierror)  
+                      communicator, requests(2), ierror)
         call checkMPIError()
     end if
     ! Bottom edge to send, top edge to receive
     commWith = neighbours(bottomNeighbour)
     if (commWith .ne. -1) then
         !print*, 'rank ', rank, ' communicating with bottom neighbour ', commWith
-        do r=1, topThickness 
+        do r=1, topThickness
             do c=1, colCount
                 do d=1, depthSize
                     bottomSend(r, c, d) = array(size(array, 1) - bottomThickness - topThickness + r, &
                                           c+leftThickness, &
-                                          d) 
-
+                                          d)
                 end do
             end do
         end do
         call MPI_IRecv(topRecv, bottomThickness*colCount*depthSize, MPI_REAL, commWith, topTag, &
-                      cartTopComm, requests(3), ierror) 
+                      cartTopComm, requests(3), ierror)
         call checkMPIError()
         call MPI_ISend(bottomSend, topThickness*colCount*depthSize, MPI_REAL, commWith, bottomTag, &
-                      communicator, requests(4), ierror) 
+                      communicator, requests(4), ierror)
         call checkMPIError()
     end if
     ! Left edge to send, right edge to receive
@@ -128,7 +127,7 @@
         do r=1, rowCount
             do c=1, rightThickness
                 do d=1, depthSize
-                leftSend(r, c, d) = array(r+topThickness, c + leftThickness, d) 
+                    leftSend(r, c, d) = array(r+topThickness, c + leftThickness, d)
                 end do
             end do
         end do
@@ -148,7 +147,7 @@
                 do d=1, depthSize
                     rightSend(r, c, d) = array(r+topThickness, &
                                                size(array, 2) - rightThickness - leftThickness + c,&
-                                               d) 
+                                               d)
                 end do
             end do
         end do
@@ -169,7 +168,7 @@
         do r=1, topThickness
             do c=1, colCount
                 do d=1, depthSize
-                    array(r, c+leftThickness, d) = bottomRecv(r, c, d) 
+                    array(r, c+leftThickness, d) = bottomRecv(r, c, d)
                 end do
             end do
         end do
@@ -178,7 +177,7 @@
         do r=1, bottomThickness
             do c=1, colCount
                 do d=1, depthSize
-                    array(size(array, 1) - bottomThickness + r, c+leftThickness, d) = topRecv(r, c, d) 
+                    array(size(array, 1) - bottomThickness + r, c+leftThickness, d) = topRecv(r, c, d)
                 end do
             end do
         end do
@@ -187,7 +186,7 @@
         do r=1, rowCount
             do c=1, leftThickness
                 do d=1, depthSize
-                    array(r+topThickness, c, d) = rightRecv(r, c, d) ! OK
+                    array(r+topThickness, c, d) = rightRecv(r, c, d)
                 end do
             end do
         end do
@@ -196,7 +195,7 @@
         do r=1, rowCount
             do c=1, rightThickness
                 do d=1, depthSize
-                    array(r+topThickness, size(array, 2) - rightThickness + c, d) = leftRecv(r, c, d) 
+                    array(r+topThickness, size(array, 2) - rightThickness + c, d) = leftRecv(r, c, d)
                 end do
             end do
         end do
@@ -606,72 +605,6 @@
 end subroutine collect3DReal4Array
 
 
-
-
-subroutine distributeamask(ua, u,ip, jp, kp, ipmax, jpmax, procPerRow)
-    integer, intent(in) :: ip, jp, ipmax, jpmax, procPerRow
-    real(kind=4), dimension(0:ipmax+1,0:jpmax+1,0:kp+1) , intent(InOut) :: ua
-    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(In) :: u
-    integer :: startRow, startCol, i, r, c, k, rank,j
-    character(70) :: cha
-    real(kind=4), dimension(ip, jp, kp) :: sendBuffer, recvBuffer
-
-    if (.not.isMaster()) then
-
-            do k=1, kp
-                do c=1, jp
-                   do r=1, ip
-                    sendBuffer(r, c, k) = u(r, c, k)
-                   end do
-                end do
-            end do
-            print*, 'GR: sendBuffer  sum: ', sum(sendBuffer)
-         
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-!        write(*,*) 'send_rank=',rank
-
-
-            call MPI_Send(sendBuffer, (ip*jp*kp), MPI_REAL, 0, zbmTag, &
-                          communicator, ierror)
-            call checkMPIError()
-
-
-    else
-  
-        do i = 1, mpi_size - 1
-
-        call MPI_Recv(recvBuffer, (ip*jp*kp), MPI_REAL, i, zbmTag,communicator,&
-                      status, ierror)
-        call checkMPIError()
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-
-        print*, 'GR: recvBuffer  sum: ', sum(recvBuffer)
-
-            startRow = topLeftRowValue(i, procPerRow, ip)
-            startCol = topLeftColValue(i, procPerRow, jp)
-        write(*,*) 'startRow=',startRow,'startCol=',startCol
-
-        do k=1, kp
-             do c=1, jp
-               do r=1, ip
-                ua(startRow +r, startCol + c, k) = recvBuffer(r, c, k)
-               end do
-            end do
-        end do
-   
-       
-        end do
-       end if
-    
-            
-
-end subroutine distributeamask
-
-
 subroutine distributeu(ua, u,ip, jp, kp, ipmax, jpmax, procPerRow)
     integer, intent(in) :: ip, jp, ipmax, jpmax, procPerRow
     real(kind=4), dimension(0:ipmax+1,-1:jpmax+1,0:kp+1) , intent(InOut) :: ua
@@ -797,8 +730,6 @@
         end do
        end if
     
-            
-
 end subroutine distributev
 
 
@@ -866,141 +797,6 @@
 end subroutine distributew
 
 
-subroutine distributebondu(u, ip, jp, kp, ipmax, jpmax, procPerRow)
-    integer, intent(in) :: ip, jp, ipmax, jpmax, procPerRow, kp
-    real(kind=4), dimension(1,-1:jpmax+1,0:kp+1) , intent(InOut) :: u
-    integer :: startRow, startCol, i, r, c, k
-    real(kind=4), dimension(1, jp, kp) :: sendBuffer, recvBuffer
-
-    if (isMaster()) then
-        ! Send appropriate 2D section to the other ranks
-        do i = 1, procPerRow - 1
-            startRow = topLeftRowValue(i, procPerRow, ip)
-            startCol = topLeftColValue(i, procPerRow, jp)
-
-            do k=1, kp
-                do c=1, jp
-                    sendBuffer(1, c, k) = u(1, startCol + c, k)
-                end do
-            end do
-            print*, 'GR: sendBuffer  sum: ', sum(sendBuffer)
-
-
-            call MPI_Send(sendBuffer, (jp*kp), MPI_REAL, i, zbmTag, &
-                          communicator, ierror)
-            call checkMPIError()
-        end do
-    else
-        ! Receive appropriate 2D section from master
-        call MPI_Recv(recvBuffer, (jp*kp), MPI_REAL, 0, zbmTag, communicator, &
-                      status, ierror)
-        call checkMPIError()
-
-
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-!        write(*,*) 'recv_rank=',rank
-
-
-        print*, 'GR: recvBuffer sum: ', sum(recvBuffer)
-        do k=1, kp
-            do c=1, jp
-                u(1, c, k) = recvBuffer(1, c, k)
-            end do
-        end do
-    end if
-end subroutine distributebondu
-
-
-subroutine distributebondv(u, ip, jp, kp, ipmax, jpmax, procPerRow)
-    integer, intent(in) :: ip, jp, ipmax, jpmax, procPerRow, kp
-    real(kind=4), dimension(1,-1:jpmax+1,0:kp+1) , intent(InOut) :: u
-    integer :: startRow, startCol, i, r, c, k
-    real(kind=4), dimension(1, jp, kp) :: sendBuffer, recvBuffer
-    if (isMaster()) then
-        ! Send appropriate 2D section to the other ranks
-        do i = 1, procPerRow - 1
-            startRow = topLeftRowValue(i, procPerRow, ip)
-            startCol = topLeftColValue(i, procPerRow, jp)
-
-            do k=1, kp
-                do c=1, jp
-                    sendBuffer(1, c, k) = u(1, startCol + c, k)
-                end do
-            end do
-            print*, 'GR: sendBuffer sum: ', sum(sendBuffer)
-            call MPI_Send(sendBuffer, (jp*kp), MPI_REAL, i, zbmTag, &
-                          communicator, ierror)
-            call checkMPIError()
-        end do
-
-
-    else
-        ! Receive appropriate 2D section from master
-        call MPI_Recv(recvBuffer, (jp*kp), MPI_REAL, 0, zbmTag ,communicator, &
-                      status, ierror)
-        call checkMPIError()
-        print*, 'GR: recvBuffer sum: ', sum(recvBuffer)
-        do k=1, kp
-            do c=1, jp
-                u(1, c, k) = recvBuffer(1, c, k)
-            end do
-        end do
-    end if
-end subroutine distributebondv
-
-
-
-
-
-
-subroutine distributebondw(u, ip, jp, kp, ipmax, jpmax, procPerRow)
-    integer, intent(in) :: ip, jp, ipmax, jpmax, procPerRow, kp
-    real(kind=4), dimension(1,-1:jpmax+1,-1:kp+1) , intent(InOut) :: u
-    integer :: startRow, startCol, i, r, c, k
-    real(kind=4), dimension(1, jp, kp) :: sendBuffer, recvBuffer
-
-    if (isMaster()) then
-        ! Send appropriate 2D section to the other ranks
-        do i = 1, procPerRow - 1
-            startRow = topLeftRowValue(i, procPerRow, ip)
-            startCol = topLeftColValue(i, procPerRow, jp)
-
-            do k=1, kp
-                do c=1, jp
-                    sendBuffer(1, c, k) = u(1, startCol + c, k)
-                end do
-            end do
-            print*, 'GR: sendBuffer sum: ', sum(sendBuffer)
-
-
-            call MPI_Send(sendBuffer, (jp*kp), MPI_REAL, i, zbmTag, &
-                          communicator, ierror)
-            call checkMPIError()
-        end do
-    else
-        ! Receive appropriate 2D section from master
-        call MPI_Recv(recvBuffer, (jp*kp), MPI_REAL, 0, zbmTag, communicator, &
-                      status, ierror)
-        call checkMPIError()
-
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-!        write(*,*) 'recv_rank=',rank
-
-
-        print*, 'GR: recvBuffer sum: ', sum(recvBuffer)
-        do k=1, kp
-            do c=1, jp
-                u(1, c, k) = recvBuffer(1, c, k)
-            end do
-        end do
-    end if
-end subroutine distributebondw
-
-
 subroutine distributeusum(usuma, usum,ip, jp, kp, ipmax, jpmax, procPerRow)
     integer, intent(in) :: ip, jp, ipmax, jpmax, procPerRow
     real(kind=4), dimension(0:ipmax,0:jpmax,0:kp) , intent(InOut) :: usuma
@@ -1742,130 +1538,95 @@
         end do
        end if
     
-            
-
 end subroutine distributeaveuu
 
-
-
-subroutine distributebondoutu(ubonda, u,ip, jp, kp, ipmax, jpmax, procPerRow)
-    integer, intent(in) :: ip, jp, kp, ipmax, jpmax, procPerRow
-    real(kind=4), dimension(1,jpmax,kp) , intent(InOut) :: ubonda
-    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
-    integer :: startRow, startCol, i, r, c, k, rank,j
-    character(70) :: cha
-    real(kind=4), dimension( 1, jp, kp) :: sendBuffer, recvBuffer
-
-    if (isBottomRow(procPerRow)) then
-
-            do k=1, kp
-                do c=1, jp
-                    sendBuffer(1, c, k) = u(ip, c, k)
-                end do
-            end do
-            print*, 'GR: sendBuffer sum: ', sum(sendBuffer)
-         
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-!        write(*,*) 'send_rank=',rank
-
-
-
-            call MPI_Send(sendBuffer, (jp*kp), MPI_REAL, 0, zbmTag, &
-                          communicator, ierror)
-            call checkMPIError()
-
-    end if
-
-        if (isMaster()) then
-
-        do i = mpi_size - procPerRow, mpi_size - 1
-
-        call MPI_Recv(recvBuffer, (jp*kp), MPI_REAL, i,zbmTag,communicator,&
-                      status, ierror)
-        call checkMPIError()
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-        print*, 'GR: recvBuffer sum: ', sum(recvBuffer)
-
-
-            startRow = topLeftRowValue(i, procPerRow, ip)
-            startCol = topLeftColValue(i, procPerRow, jp)
-        write(*,*) 'startRow=',startRow,'startCol=',startCol
-
-        do k=1, kp
-             do c=1, jp
-                ubonda(1, startCol + c, k) = recvBuffer(1, c, k)
-            end do
-        end do
-
-       
-        end do
-       end if
- end subroutine distributebondoutu
-
-
-
-subroutine distributebondoutw(wbonda, w,ip, jp, kp, ipmax, jpmax, procPerRow)
-    integer, intent(in) :: ip, jp, kp,ipmax, jpmax, procPerRow
-    real(kind=4), dimension(1,jpmax,kp) , intent(InOut) :: wbonda
-    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
-    integer :: startRow, startCol, i, r, c, k, rank,j
-    character(70) :: cha
-    real(kind=4), dimension( 1, jp, kp) :: sendBuffer, recvBuffer
-    if (isBottomRow(procPerRow)) then
-
-            do k=1, kp
-                do c=1, jp
-                    sendBuffer(1, c, k) = w(ip, c, k)
-                end do
-            end do
-            print*, 'GR: sendBuffer sum: ', sum(sendBuffer)
-         
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-!        write(*,*) 'send_rank=',rank
-
-
-
-            call MPI_Send(sendBuffer, (jp*kp), MPI_REAL, 0, zbmTag, &
-                          communicator, ierror)
-            call checkMPIError()
-
+subroutine gatheraaa(gaaa, aaa, procPerRow)
+    integer, intent(in) ::  procPerRow
+    real(kind=4), intent(InOut) :: gaaa
+    real(kind=4), intent(In) :: aaa
+    integer :: startRow, startCol, i, j, r, c, k, rank
+    real(kind=4) :: sendBuffer, recvBuffer
+
+
+    call MPI_COMM_Rank(communicator, rank, ierror)
+    call checkMPIError()
+
+    if (rank.gt.mpi_size - procPerRow) then
+         sendBuffer = aaa
+!         print*, 'Rank: ', rank, ' before aaa: ', aaa
+         call MPI_Send(sendBuffer, 1, MPI_REAL, mpi_size - procPerRow,zbmTag, &
+                       communicator, ierror)
+         call checkMPIError()
+    else if(rank.eq.mpi_size - procPerRow) then
+!         print*, 'Rank: ', rank, ' before aaa: ', aaa
+         do i = mpi_size - procPerRow + 1, mpi_size - 1
+             call MPI_Recv(recvBuffer, 1, MPI_REAL, i,zbmTag,communicator,&
+                           status, ierror)
+             call checkMPIError()
+             gaaa = amax1(gaaa,recvBuffer)      
+         end do
+!         print*, 'Rank: ', rank, ' after aaa: ', gaaa
+         sendBuffer = gaaa
+         do i = mpi_size - procPerRow + 1, mpi_size - 1
+             call MPI_Send(sendBuffer, 1, MPI_REAL, i,zbmTag, &
+                           communicator, ierror) 
+         end do
+    end if
+
+    if (rank.gt.mpi_size - procPerRow) then
+         call MPI_Recv(recvBuffer, 1, MPI_REAL, mpi_size - procPerRow,zbmTag,communicator,&
+                       status, ierror)
+         call checkMPIError()
+         gaaa=recvBuffer
+!    print*, 'Rank: ', rank, ' after aaa: ', gaaa
+
+    end if
+
+  end subroutine gatheraaa
+
+
+subroutine gatherbbb(gbbb, bbb, procPerRow)
+    integer, intent(in) ::  procPerRow
+    real(kind=4), intent(InOut) :: gbbb
+    real(kind=4), intent(In) :: bbb
+    integer :: startRow, startCol, i, j, r, c, k, rank
+    real(kind=4) :: sendBuffer, recvBuffer
+
+
+    call MPI_COMM_Rank(communicator, rank, ierror)
+    call checkMPIError()
+
+    if (rank.gt.mpi_size - procPerRow) then
+         sendBuffer = bbb
+!         print*, 'Rank: ', rank, ' before bbb: ', bbb
+         call MPI_Send(sendBuffer, 1, MPI_REAL, mpi_size - procPerRow,zbmTag, &
+                       communicator, ierror)
+         call checkMPIError()
+    else if(rank.eq.mpi_size - procPerRow) then
+!         print*, 'Rank: ', rank, ' before bbb: ', bbb
+         do i = mpi_size - procPerRow + 1, mpi_size - 1
+             call MPI_Recv(recvBuffer, 1, MPI_REAL, i,zbmTag,communicator,&
+                           status, ierror)
+             call checkMPIError()
+             gbbb = amin1(gbbb,recvBuffer)      
+         end do
+!         print*, 'Rank: ', rank, ' after bbb: ', gbbb
+         sendBuffer = gbbb
+         do i = mpi_size - procPerRow + 1, mpi_size - 1
+             call MPI_Send(sendBuffer, 1, MPI_REAL, i,zbmTag, &
+                           communicator, ierror) 
+         end do
+    end if
+
+    if (rank.gt.mpi_size - procPerRow) then
+         call MPI_Recv(recvBuffer, 1, MPI_REAL, mpi_size - procPerRow,zbmTag,communicator,&
+                       status, ierror)
+         call checkMPIError()
+         gbbb=recvBuffer
+!    print*, 'Rank: ', rank, ' after bbb: ', gbbb
 
     end if
 
-        if (isMaster()) then
-  
-        do i = mpi_size - procPerRow, mpi_size - 1
-
-        call MPI_Recv(recvBuffer, (jp*kp), MPI_REAL, i,zbmTag,communicator,&
-                      status, ierror)
-        call checkMPIError()
-
-!        call MPI_COMM_Rank(communicator, rank, ierror)
-!        call checkMPIError()
-        print*, 'GR: recvBuffer sum: ', sum(recvBuffer)
-
-
-            startRow = topLeftRowValue(i, procPerRow, ip)
-            startCol = topLeftColValue(i, procPerRow, jp)
-        write(*,*) 'startRow=',startRow,'startCol=',startCol
-
-        do k=1, kp
-             do c=1, jp
-               do r=1, ip
-                wbonda(1, startCol + c, k) = recvBuffer(1, c, k)
-               end do
-            end do
-        end do
-
-       
-        end do
-       end if
+  end subroutine gatherbbb
 
-  end subroutine distributebondoutw
 end module
Only in MPI-LES/src/: data
================================================================================================================================================================
diff -ru MPI-LES/src/feedbf.f95 Nested-LES/MPI-LES_20170624/src/feedbf.f95
--- MPI-LES/src/feedbf.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/feedbf.f95	2017-06-24 11:19:34.000000000 +0100
@@ -3,7 +3,7 @@
 contains
 
 subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,&
-                  dt,beta,fx,fy,fz,f,g,h)
+                  dt,beta,fx,fy,fz,f,g,h,n)
     use common_sn ! create_new_include_statements() line 102
     real(kind=4), intent(In) :: alpha
     real(kind=4), intent(In) :: beta
@@ -20,6 +20,7 @@
     integer, intent(In) :: im
     integer, intent(In) :: jm
     integer, intent(In) :: km
+    integer, intent(In) :: n
     real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
     real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: usum
     real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
@@ -32,6 +33,11 @@
     print *, 'F95 VSUMSUM after bondv1:',sum(vsum)
     print *, 'F95 WSUMSUM after bondv1:',sum(wsum)
 #endif
+!    if (isMaster()) then
+!      do i=20,30
+!      write(*,*) "u",u(i,5,2),i,rank,n
+!      end do
+!    end if 
     do k = 1,km
         do j = 1,jm
             do i = 1,im
@@ -59,6 +65,7 @@
             end do
         end do
     end do
+
 #ifdef WV_DEBUG
     print *, 'F95 FGHSUM after feedbf:',sum(f)+sum(g)+sum(h)
     print *, 'F95 FSUM after feedbf:',sum(f)
================================================================================================================================================================
diff -ru MPI-LES/src/feedbfm.f95 Nested-LES/MPI-LES_20170624/src/feedbfm.f95
--- MPI-LES/src/feedbfm.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/feedbfm.f95	2017-06-24 11:19:34.000000000 +0100
@@ -16,7 +16,7 @@
     real(kind=4), dimension(0:kp+2) , intent(In) :: z2
     real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(InOut) :: zbm
     integer :: i, j, k
-    real(kind=4), dimension(-1:3001,-1:751) :: dsm,dem
+    real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) :: dsm,dem
 
 
 !
@@ -32,76 +32,53 @@
             end do
         end do
     end do
-#ifdef MPI
-    if (isMaster()) then
-#endif
-        print*, 'zbm sum - file getting read'
-        !      print *, 'open GIS/Tokyo_20mgrid.txt'
-        ! WV: the problem with this is that this input file expects the grid to be 150 x 150, because otherwise zbm segfaults!
-!        open(70,file='GIS/LES_GIS_dsm.txt', form='formatted',status='unknown')
-!        do j = 1,250
-!            do i = 1,250
-!                read(70,*) zbm(i+25,j+25)
-!            end do
-!        end do
-!        close(70)
-
 
 
+    do j=1,jpmax
+      do i=1,ipmax
+            zbm(i,j)=0.
+      end do
+    end do
 
-      open(70,file='./GIS/DEM_LES_GIS.txt',form='formatted',status='unknown')
 
-      do j=1,750
-        do i=1,3000
-          read(70,*) dem(i,j)
-        end do
-      end do
-      close(70)
 
-      open(71,file='./GIS/DSM_LES_GIS.txt',form='formatted',status='unknown')
+#ifdef MPI
+!    if (isMaster()) then
+#endif
+        print*, 'zbm sum - file getting read'
+        !      print *, 'open GIS/Tokyo_20mgrid.txt'
+        ! WV: the problem with this is that this input file expects the grid to be 150 x 150, because otherwise zbm segfaults!
 
-      do j=1,750
-        do i=1,3000
-          read(71,*) dsm(i,j)
-        end do
-      end do
-      close(71)
+!--
 
+      if (isMaster()) then
+        open(70,file=datafile,form='formatted',status='unknown')
+           do j=1,jpmax
+              do i=1,ipmax
+                 read(70,*) zbm(i,j)
+              end do
+           end do
+        close(70)
+      end if !for imaster
+      call distributeZBM(zbm, ip, jp, ipmax, jpmax, procPerRow)
 
-!this domain is using 11km(the north to south direction) × 1km(the west to east direction) in Kyoto city
-      do j=1,250
-        do i=1,2750
-!if we use this setting for zbm, it can include our observation point, our observation point is (i,j)=(2788,152) in our observation point  
-          zbm(i+125,j+25)=dsm(i+250,j+138)-dem(i+250,j+138)
-        end do
+! print *, 'assign amask'
+      do j = 1,jm
+          do i = 1,im
+              do k = 1,km
+                  if(zbm(i,j) > z2(k)+0.5*dzn(k)) then
+                      amask1(i,j,k) = 0.0
+                  end if
+              end do
+          end do
       end do
 
-
 #ifdef MPI
-    end if
-    call distributeZBM(zbm, ip, jp, ipmax, jpmax, procPerRow)
+!    end if
+!    call distributeZBM(zbm, ip, jp, ipmax, jpmax, procPerRow)
 #endif
 
 ! -----------------------------------------------------------------------
-! print *, 'assign amask'
-    do j = 1,jm
-        do i = 1,im
-            do k = 1,km
-                if(zbm(i,j) > z2(k)+0.5*dzn(k)) then
-                    amask1(i,j,k) = 0.0
-                end if
-            end do
-        end do
-    end do
-
-    if (isMaster()) then
-      do k=1,km
-!       write(*,*) 'a=',amask1(100,100,k)
-!       write(*,*) 'zbm(i,j)=', zbm(100,100)
-        write(*,*) 'z2=',z2(k)
-      end do
-    end if
-! -----------------------------------------------------------------------
 !print *, 'assign bcd masks'
     do k = 1,km
         do j = 1,jm
================================================================================================================================================================
diff -ru MPI-LES/src/grid.f95 Nested-LES/MPI-LES_20170624/src/grid.f95
--- MPI-LES/src/grid.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/grid.f95	2017-06-24 11:19:34.000000000 +0100
@@ -28,13 +28,13 @@
 #ifdef MPI
     if (isMaster()) then
         do i=-1,(ip*procPerCol)+1
-            dx1Tot(i) = 4.
+            dx1Tot(i) = dxgrid
         end do
     end if
     call distribute1DRealRowWiseArray(dx1Tot,dx1, 2, 1, procPerRow)
 #else
       do i = -1,ip+1
-       dx1(i) = 4.
+       dx1(i) = dxgrid
       end do
 #endif
 
@@ -59,13 +59,13 @@
 #ifdef MPI
     if (isMaster()) then
         do j=0,(jp*procPerRow)+1
-            dy1Tot(j) = 4.
+            dy1Tot(j) = dygrid
         end do
     end if
     call distribute1DRealColumnWiseArray(dy1Tot, dy1, 1, 1, procPerRow)
 #else
       do j = 0,jp+1
-       dy1(j) = 4.
+       dy1(j) = dygrid
       end do
 #endif
 
@@ -111,7 +111,7 @@
 !      end do
 
 
-        z2(0)= 1.
+        z2(0)= 0.
         dzn(0)= 1.
 
         z2(1)= 1.
@@ -119,7 +119,7 @@
 
       do k=2,15
         dzn(k)=dzn(k-1)*1.1
-        write(*,*) 'dzn=',dzn(k)
+        ! write(*,*) 'dzn=',dzn(k)
       end do
       do k=16,44
         dzn(k)=4.
@@ -136,9 +136,7 @@
 
     if (isMaster()) then
       do k=1,kp
-!       write(*,*) 'a=',amask1(100,100,k)
-!       write(*,*) 'zbm(i,j)=', zbm(100,100)
-        write(*,*) 'z2grid=',z2(k)
+       ! write(*,*) 'z2grid=',z2(k)
       end do
     end if
 
@@ -174,7 +172,7 @@
 #ifdef VERBOSE
       write(6,*) 'Computational Domain X,Y,Z=',dxl(ip),dyl(jp),z2(kp)
       do k = 1,kp
-      write(6,*) 'Vertical grid size=',k,dzn(k)
+      write(6,*) 'Vertical grid size=',k,dzn(k),dzs(k)
       end do
 #endif
 !
Only in MPI-LES/src/: hist.txt
================================================================================================================================================================
diff -ru MPI-LES/src/ifdata.f95 Nested-LES/MPI-LES_20170624/src/ifdata.f95
--- MPI-LES/src/ifdata.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/ifdata.f95	2017-06-24 11:19:34.000000000 +0100
@@ -53,6 +53,7 @@
         real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
         real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
 
+
           do k = 0,kp+1
           do j = 0,jp+2
           do i = -1,ip+2
@@ -133,7 +134,7 @@
       n,u,im,jm,km,v,w,p,usum,vsum,wsum, &
       delx1,dx1,dy1,dzn,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,z2,dt, &
       dxs,cov1,cov2,cov3,dfu1,vn,cov4,cov5,cov6,dfv1,cov7,cov8,cov9,dfw1,dzs,nou1,nou5,nou9,nou2, &
-      nou3,nou4,nou6,nou7,nou8,bmask1,cmask1,dmask1,alpha,beta,fx,fy,fz,amask1,zbm,ical)
+      nou3,nou4,nou6,nou7,nou8,bmask1,cmask1,dmask1,alpha,beta,fx,fy,fz,amask1,zbm,ical,nif)
       use common_sn ! create_new_include_statements() line 102
 !#if ICAL == 1
         character(len=70), intent(In) :: data30
@@ -190,6 +191,7 @@
         integer, intent(InOut) :: jm
         integer, intent(InOut) :: km
         integer, intent(InOut) :: n
+        integer, intent(in) :: nif   
         real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
         real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
         real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
@@ -210,21 +212,20 @@
         real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: wsum
         real(kind=4), dimension(0:kp+2) , intent(In) :: z2
         real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(InOut) :: zbm
-!
-!input
-    real(kind=4),allocatable :: ua(:,:,:)
-    real(kind=4),allocatable :: va(:,:,:)
-    real(kind=4),allocatable :: wa(:,:,:)
-    real(kind=4),allocatable :: usuma(:,:,:)
-    real(kind=4),allocatable :: vsuma(:,:,:)
-    real(kind=4),allocatable :: wsuma(:,:,:)
-    real(kind=4),allocatable :: pa(:,:,:)
-    real(kind=4),allocatable :: fa(:,:,:)
-    real(kind=4),allocatable :: ga(:,:,:)
-    real(kind=4),allocatable :: ha(:,:,:)
-    real(kind=4),allocatable :: folda(:,:,:)
-    real(kind=4),allocatable :: golda(:,:,:)
-    real(kind=4),allocatable :: holda(:,:,:)
+
+        real(kind=4),allocatable :: ua(:,:,:)
+        real(kind=4),allocatable :: va(:,:,:)
+        real(kind=4),allocatable :: wa(:,:,:)
+        real(kind=4),allocatable :: usuma(:,:,:)
+        real(kind=4),allocatable :: vsuma(:,:,:)
+        real(kind=4),allocatable :: wsuma(:,:,:)
+        real(kind=4),allocatable :: pa(:,:,:)
+        real(kind=4),allocatable :: fa(:,:,:)
+        real(kind=4),allocatable :: ga(:,:,:)
+        real(kind=4),allocatable :: ha(:,:,:)
+        real(kind=4),allocatable :: folda(:,:,:)
+        real(kind=4),allocatable :: golda(:,:,:)
+        real(kind=4),allocatable :: holda(:,:,:)
 
         
 
@@ -253,8 +254,9 @@
 
  
         if (isMaster()) then
+        write(filename, '("../data/data30",i6.6, ".dat")') nif 
 
-        open(unit=30,file='data30048000.dat',form='unformatted',status='unknown')
+        open(unit=30,file=filename,form='unformatted',status='unknown')
         read(30) n,time
         end if
  
@@ -377,8 +379,8 @@
 
 !31
         if (isMaster()) then
-
-        open(unit=31,file='data31048000.dat',form='unformatted',status='unknown')
+        write(filename, '("../data/data31",i6.6, ".dat")') nif
+        open(unit=31,file=filename,form='unformatted',status='unknown')
         end if
 
         allocate(fa(0:ipmax,0:jpmax,0:kp))
@@ -488,7 +490,9 @@
 
 !#endif
 
+        call boundp1(km,jm,p,im)
 
+        call boundp2(jm,im,p,km)
 
 
 
@@ -509,9 +513,9 @@
 
 !        call bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
 
-!        call boundp1(km,jm,p,im)
+        call boundp1(km,jm,p,im)
 
-!        call boundp2(jm,im,p,km)
+        call boundp2(jm,im,p,km)
 !        call velfg(km,jm,im,dx1,cov1,cov2,cov3,dfu1,diu1,diu2,dy1,diu3,dzn,vn,f,cov4,cov5,cov6,dfv1, &
 !      diu4,diu5,diu6,g,cov7,cov8,cov9,dfw1,diu7,diu8,diu9,dzs,h,nou1,u,nou5,v,nou9,w,nou2,nou3, &
 !      nou4,nou6,nou7,nou8)
================================================================================================================================================================
diff -ru MPI-LES/src/les.f95 Nested-LES/MPI-LES_20170624/src/les.f95
--- MPI-LES/src/les.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/les.f95	2017-06-24 11:19:34.000000000 +0100
@@ -4,7 +4,7 @@
 contains
 
       subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g, &
-      h,uspd,vspd,dxs,dys)
+      h,u,v,uspd,vspd,dxs,dys,n)
       use common_sn ! create_new_include_statements() line 102
         real(kind=4), dimension(kp) , intent(Out) :: delx1
         real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu1
@@ -25,15 +25,17 @@
         integer, intent(In) :: im
         integer, intent(In) :: jm
         integer, intent(In) :: km
+        integer, intent(In) :: n
         real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: sm
 !wall function
+        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
+        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
         real(kind=4), dimension(0:ip+1,0:jp+1) , intent(in) :: uspd
         real(kind=4), dimension(0:ip+1,0:jp+1) , intent(in) :: vspd
         real(kind=4), dimension(0:ip) , intent(in) :: dxs
         real(kind=4), dimension(0:jp) , intent(in) :: dys
 !
 !
-      cs0 = .1
 ! --length scale
         do k = 1,km
 !  WV: was          delx1(k)=(dx1(i)*dy1(j)*dzn(k))**(1./3.)
@@ -55,7 +57,7 @@
       dwdxx1 =  (diu7(i  ,j,k)+diu7(i  ,j,k-1) +diu7(i+1,j,k)+diu7(i+1,j,k-1) ) *.25
       dwdyx1 =  (diu8(i,j  ,k)+diu8(i,j  ,k-1) +diu8(i,j+1,k)+diu8(i,j+1,k-1) ) *.25
       dwdzx1 =  diu9(i,j,k)
-!
+
       csx1 = cs0
 ! --abl or channel
       sm(i,j,k) = ( csx1*delx1(k) )**2  * sqrt( 2.*( dudxx1**2+dvdyx1**2+dwdzx1**2 ) +( dudyx1+dvdxx1 )**2  &
@@ -63,6 +65,11 @@
       end do
       end do
       end do
+!      if (isMaster()) then
+!      do i=20,30
+!          write(*,*) "sm",sm(i,10,1),i,n
+!      end do
+!      end if
 #ifdef WV_DEBUG
     print *, 'F95 FGHSUM after calc_sm:',sum(f)+sum(g)+sum(h)
     print *, 'F95 FSUM after calc_sm:',sum(f)
@@ -130,11 +137,11 @@
       visuy2=(evsy2)* ( diu2(i  ,j+1,1  )+diu4(i+1,j  ,1 ) )
       visuy1=(evsy1)* ( diu2(i  ,j  ,1  )+diu4(i+1,j-1,1 ) )
       visuz2=(evsz2)* ( diu3(i  ,j  ,2  )+diu7(i+1,j  ,1 ) )
-      visuz1=(0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
+      visuz1=(0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
 !
-      vfu= (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
+      vfu= (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
 !
-      F(i,j,1)=(F(i,j,1)+vfu)
+      f(i,j,1)=(f(i,j,1)+vfu)
       end do
       end do
 
@@ -192,11 +199,11 @@
       visvy2=(evsy2)*2.*diu5(i  ,j+1,1  )
       visvy1=(evsy1)*2.*diu5(i  ,j  ,1  )
       visvz2=(evsz2)* ( diu6(i  ,j  ,2  )+diu8(i  ,j+1,1  ) )
-      visvz1=(0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
+      visvz1=(0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
 !
       vfv=(visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
 !
-      G(i,j,1)=(G(i,j,1)+vfv)
+      g(i,j,1)=(g(i,j,1)+vfv)
       end do
       end do
 
Only in Nested-LES/MPI-LES_20170624/src/: les_main_mpi
================================================================================================================================================================
diff -ru MPI-LES/src/main.f95 Nested-LES/MPI-LES_20170624/src/main.f95
--- MPI-LES/src/main.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/main.f95	2017-06-24 11:19:34.000000000 +0100
@@ -16,7 +16,6 @@
 #else
     use module_velnw
     use module_bondv1
-    use module_bondv1_data24
     use module_velFG
 #if IFBF == 1
     use module_feedbf
@@ -36,6 +35,7 @@
     integer :: n
     integer :: n0
     integer :: n1
+    integer :: nif
     integer :: nmax
     real(kind=4) :: beta
     character(len=70) :: data10
@@ -43,6 +43,7 @@
     character(len=70) :: data12
     character(len=70) :: data13
     character(len=70) :: data14
+    character(len=70) :: data15
     character(len=70) :: data20
     character(len=70) :: data21
     character(len=70) :: data22
@@ -154,41 +155,10 @@
     real(kind=4), dimension(0:ip,0:jp,0:kp)  :: wsum
     real(kind=4), dimension(0:kp+2)  :: z2
     real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1)  :: zbm
-!wall function
+
     real(kind=4), dimension(0:ip+1,0:jp+1)  :: uspd
     real(kind=4), dimension(0:ip+1,0:jp+1)  :: vspd
-!idata24
-    integer :: idata24
-!jdata24
-    integer :: jdata24
-
-!nspec
-    integer :: nspec
-
-
-    real(kind=4), dimension(1,1,36001,kp) :: ut_x1_2
-    real(kind=4), dimension(1,1,36001,kp) :: ut_x2_2
-    real(kind=4), dimension(1,1,36001,kp) :: vt_x1_2
-    real(kind=4), dimension(1,1,36001,kp) :: vt_x2_2
-    real(kind=4), dimension(1,1,36001,kp) :: wt_x1_2
-    real(kind=4), dimension(1,1,36001,kp) :: wt_x2_2
-
-
-    real(kind=4), dimension(1,kp,36001)  :: u_spany2
-    real(kind=4), dimension(1,kp,36001)  :: v_spany2
-    real(kind=4), dimension(1,kp,36001)  :: w_spany2
-    real(kind=4), dimension(1,kp,36001)  :: u_spany3
-    real(kind=4), dimension(1,kp,36001)  :: v_spany3
-    real(kind=4), dimension(1,kp,36001)  :: w_spany3
-
-    real(kind=4), dimension(19,kp,36001)  :: u_x1_19_spany2
-    real(kind=4), dimension(19,kp,36001)  :: v_x1_19_spany2
-    real(kind=4), dimension(19,kp,36001)  :: w_x1_19_spany2
-    real(kind=4), dimension(19,kp,36001)  :: u_x1_19_spany3
-    real(kind=4), dimension(19,kp,36001)  :: v_x1_19_spany3
-    real(kind=4), dimension(19,kp,36001)  :: w_x1_19_spany3
-
-
+  
 
 #ifdef TIMINGS
     integer (kind=4), dimension(0:9) :: timestamp
@@ -207,8 +177,8 @@
     call init_netcdf_file()
 #endif
     call set(data10,data11,data20,data21,data22,data23,data24,data25,data26,&
-             data27,data30,data31,im,jm,km,ifbf,ianime,ical,n0,n1,nmax,dt,ro,&
-             vn,alpha,beta,data12,data13,data14,idata24,nspec,jdata24)
+             data27,data30,data31,im,jm,km,ifbf,ianime,ical,nif,n0,n1,nmax,dt,ro,&
+             vn,alpha,beta,data12,data13,data14,data15)
     call grid(dx1,dxl,dy1,dyl,z2,dzn,dzs,dxs,dys)
     call timdata()
     call init(km,jm,im,u,v,w,p,cn2s,dxs,cn2l,cn3s,dys,cn3l,dzs,cn4s,cn4l,cn1,&
@@ -222,7 +192,7 @@
                 diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,z2,dt,dxs,cov1, &
                 cov2,cov3,dfu1,vn,cov4,cov5,cov6,dfv1,cov7,cov8,cov9,dfw1,dzs,&
                 nou1,nou5,nou9,nou2,nou3,nou4,nou6,nou7,nou8,bmask1,cmask1,&
-                dmask1,alpha,beta,fx,fy,fz,amask1,zbm,ical)
+                dmask1,alpha,beta,fx,fy,fz,amask1,zbm,ical,nif)
 !     n=n0
 
 #ifdef _OPENCL_LES_WV
@@ -246,6 +216,11 @@
 #endif
     do n = n0,nmax
         time = float(n-1)*dt
+!        if (isMaster()) then
+!        do i=20,30
+!          write(*,*) "main_p",p(i,5,2),i,n,l
+!        end do
+!        end if
 ! -------calculate turbulent flow--------c
 #ifdef _OPENCL_LES_WV
         call run_LES_kernel(n, nmax)
@@ -261,11 +236,7 @@
 #ifdef TIMINGS
         call system_clock(timestamp(1), clock_rate)
 #endif
-     if(jdata24.eq.0) then
         call bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
-     else
-        call bondv1_data24(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
-     end if
 #ifdef TIMINGS
         call system_clock(timestamp(2), clock_rate)
 #endif
@@ -278,13 +249,13 @@
 #endif
 #if IFBF == 1
         call feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha, &
-                    dt,beta,fx,fy,fz,f,g,h)
+                    dt,beta,fx,fy,fz,f,g,h,n)
 #endif
 #ifdef TIMINGS
         call system_clock(timestamp(4), clock_rate)
 #endif
         call les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6, &
-                 diu7,diu8,diu9,sm,f,g,h,uspd,vspd,dxs,dys)
+                 diu7,diu8,diu9,sm,f,g,h,u,v,uspd,vspd,dxs,dys,n)
 #ifdef TIMINGS
         call system_clock(timestamp(5), clock_rate)
 #endif
@@ -308,26 +279,21 @@
         call timseris(n,dt,u,v,w)
 #endif
 #if IANIME == 1
-        call anime(n,n0,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,&
+      if (i_anime.eq.1) then
+        call anime(n,n0,n1,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,p,&
                    amask1,zbm)
-
-        if (idata24.eq.1) then
-        call anime_bond(n,n0,nmax,km,jm,im,dxl,dx1,dyl,dy1,z2,data22,data23,u,w,v,amask1,zbm)
-        end if
-#endif
+      end if
+      if (i_ifdata_out.eq.1) then  
         call ifdata_out(n,n0,n1,nmax,time,km,jm,im,u,w,v,p,usum,vsum,wsum,f,g,h,fold,gold,hold)
-
+      end if
+      if (i_aveflow.eq.1) then  
         call aveflow(n,n1,km,jm,im,aveu,avev,avew,avep,avel,aveuu,avevv,aveww, &
                      avesm,avesmsm,uwfx,avesu,avesv,avesw,avesuu,avesvv, &
                      avesww,u,v,w,p,sm,nmax,uwfxs,data10,time,data11,data13,data14,amask1)
-
-        call timestep_out_all_k(n,n0,n1,nmax,km,jm,im,z2,data22,data23,u,w,v,amask1&
-,ut_x1_2,vt_x1_2,wt_x1_2,ut_x2_2,vt_x2_2,wt_x2_2,nspec&
-,u_spany2,v_spany2,w_spany2,u_spany3,v_spany3,w_spany3&
-,u_x1_19_spany2,v_x1_19_spany2,w_x1_19_spany2,u_x1_19_spany3,v_x1_19_spany3,w_x1_19_spany3)
-
-
-        end do
+      end if
+#endif
+     
+     end do
 #ifdef USE_NETCDF_OUTPUT
     call close_netcdf_file()
 #endif
Only in Nested-LES/MPI-LES_20170624/src/: out.log
================================================================================================================================================================
diff -ru MPI-LES/src/params_common_sn.f95 Nested-LES/MPI-LES_20170624/src/params_common_sn.f95
--- MPI-LES/src/params_common_sn.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/params_common_sn.f95	2017-06-24 11:19:34.000000000 +0100
@@ -1,3 +1,4 @@
+
 module params_common_sn
 #ifdef MPI
     use communication_helper
@@ -9,16 +10,39 @@
     data dimensionSizes /procPerCol,procPerRow/, periodicDimensions /.false.,.false./, &
     reorder /.false./
 #endif
-    integer, parameter :: ipmax = 3000, jpmax = 300
+    integer, parameter :: ipmax = 300, jpmax = 300
 #ifndef TEST_SMALL_DOMAIN
 #ifdef MPI
-    integer, parameter :: ip = 3000/PROC_PER_COL ! rows per process
-    integer, parameter :: jp = 300/PROC_PER_ROW ! columns per process
-    integer, parameter :: kp=105
+    integer, parameter :: ip = ipmax/PROC_PER_COL ! rows per process
+    integer, parameter :: jp = jpmax/PROC_PER_ROW ! columns per process
+    integer, parameter :: kp=80
 #else
-    integer, parameter :: ip = 300, jp = 300, kp = 105
+    integer, parameter :: ip = 300, jp = 300, kp = 80
 #endif
 #else
-    integer, parameter :: ip = 25, jp = 25, kp = 105
+    integer, parameter :: ip = 25, jp = 25, kp = 80
 #endif
+
+    integer, parameter :: bipmax = 300, bjpmax = 300, bx = 0, by = 0
+    character(300) :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt'
+
+!-- grid
+    real, parameter :: dxgrid = 4.
+    real, parameter :: dygrid = 4.
+
+!-- les
+    real, parameter :: cs0 = 0.14 !smagorinsky constant
+ 
+!-- parameter for anime
+    integer, parameter :: i_anime=0
+    integer, parameter :: avetime=20, km_sl=80
+
+!-- parameter for aveflow
+    integer, parameter :: i_aveflow=0
+
+!-- for output-if
+    integer, parameter :: i_ifdata_out=0
+
+
 end module params_common_sn
+
================================================================================================================================================================
diff -ru MPI-LES/src/press.f95 Nested-LES/MPI-LES_20170624/src/press.f95
--- MPI-LES/src/press.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/press.f95	2017-06-24 11:19:34.000000000 +0100
@@ -109,6 +109,7 @@
 #ifdef VERBOSE
 ! --check
         if ((mod(n-1,10) == 0).and.(mod(l,20) == 0)) then
+!        if ((mod(n-1,10) == 0)) then
             print *, 'time step, iteration step, conv =',n,l,sor
         end if
 #endif
@@ -194,13 +195,14 @@
     end if
 #endif
 #endif
+
     if(mod(n,1000) == 0.or.n == nmax) then
         nn = n/1000
         print *, 'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2), &
                 'vel at centre: ', &
                 u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
 #ifdef USE_NETCDF_OUTPUT
-!        call write_to_netcdf_file(p,u,v,w,usum,vsum,wsum,nn)
+        call write_to_netcdf_file(p,u,v,w,usum,vsum,wsum,nn)
 #endif
 #ifndef NO_IO
 #ifndef MPI
Only in Nested-LES/MPI-LES_20170624/src/: press_mod.f95
Only in Nested-LES/MPI-LES_20170624/src/: press_mod2.f95
Only in Nested-LES/MPI-LES_20170624/src/: sdiff.sh
================================================================================================================================================================
diff -ru MPI-LES/src/set.f95 Nested-LES/MPI-LES_20170624/src/set.f95
--- MPI-LES/src/set.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/set.f95	2017-06-24 11:19:34.000000000 +0100
@@ -1,9 +1,10 @@
+
 module module_set
 
 contains
 
       subroutine set(data10,data11,data20,data21,data22,data23,data24,data25,data26,data27,data30, &
-      data31,im,jm,km,ifbf,ianime,ical,n0,n1,nmax,dt,ro,vn,alpha,beta,data12,data13,data14,idata24,nspec,jdata24)
+      data31,im,jm,km,ifbf,ianime,ical,nif,n0,n1,nmax,dt,ro,vn,alpha,beta,data12,data13,data14,data15)
       use common_sn ! create_new_include_statements() line 102
         real(kind=4), intent(Out) :: alpha
         real(kind=4), intent(Out) :: beta
@@ -12,6 +13,7 @@
         character(len=70), intent(InOut) :: data12
         character(len=70), intent(InOut) :: data13
         character(len=70), intent(InOut) :: data14
+        character(len=70), intent(InOut) :: data15
         character(len=70), intent(InOut) :: data20
         character(len=70), intent(InOut) :: data21
         character(len=70), intent(InOut) :: data22
@@ -30,32 +32,30 @@
         integer, intent(Out) :: jm
         integer, intent(Out) :: km
         integer, intent(Out) :: n0
+        integer, intent(Out) :: nif
         integer, intent(Out) :: n1
         integer, intent(Out) :: nmax
         real(kind=4), intent(Out) :: ro
         real(kind=4), intent(Out) :: vn
-!idata24
-        integer, intent(Out) :: idata24
-!jdata24
-        integer, intent(Out) :: jdata24
 
 !
 !
-      data10 = './data/data10'
-      data11 = './data/data11'
-      data12 = './data/data12'
-      data13 = './data/data13'
-      data14 = './data/data14'      
-      data20 = './data/data20'
-      data21 = './data/data21'
-      data22 = './data/data22'
-      data23 = './data/data23'
-      data24 = './data/data24'
-      data25 = './data/data25'
-      data26 = './data/data26'
-      data27 = './data/data27'
-      data30 = './data/data30'
-      data31 = './data/data31'
+      data10 = '../ave_data/data10'
+      data11 = '../ave_data/data11'
+      data12 = '../data/data12'
+      data13 = '../data/data13'
+      data14 = '../data/data14'      
+      data15 = '../data/data15'      
+      data20 = '../data/data20'
+      data21 = '../data/data21'
+      data22 = '../data/data22'
+      data23 = '../data/data23'
+      data24 = '../data/data24'
+      data25 = '../data/data25'
+      data26 = '../data/data26'
+      data27 = '../data/data27'
+      data30 = '../data/data30'
+      data31 = '../data/data31'
 !      data50:tim series of wind data
 !      data51:tim series od concentration data
 ! --flow region
@@ -79,12 +79,11 @@
 !      ical = 0; initial start
 !           = 1; continuous computation
       ical = 0
+      nif = 8000
       n0 = 1
       n1 = 1
 ! --setnmax
-      nmax = 10
-! --for sepctrum, nspec = nmax-n1+1
-      nspec = 10
+      nmax = 8000
 ! --time step
       dt = 0.05
 ! --physical property set
@@ -99,12 +98,9 @@
       write(6,*) 'IBM parameter, dt=' ,((-beta-(beta*beta-2.*alpha)**(0.5))/alpha),dt
       stop
       endif
-!--make_data24
-      idata24 = 0
-!--use_data24
-      jdata24 = 0
 ! =======================================
       return
       end subroutine set
 
 end module module_set
+
Only in Nested-LES/MPI-LES_20170624/src/: start.sh
Only in MPI-LES/src/: test_halo_exchange.f95
Only in MPI-LES/src/: test_halo_exchange.o
Only in MPI-LES/src/: test_halo_exchanges
Only in MPI-LES/src/: test_halos.f95
Only in MPI-LES/src/: test_halos.mod
Only in MPI-LES/src/: test_halos.o
================================================================================================================================================================
diff -ru MPI-LES/src/vel2.f95 Nested-LES/MPI-LES_20170624/src/vel2.f95
--- MPI-LES/src/vel2.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/vel2.f95	2017-06-24 11:19:34.000000000 +0100
@@ -49,8 +49,6 @@
       integer, parameter  :: u0 = 0
 
         
-
-
       do j=1,jm
         do i=1,im
          uspd(i,j)=(u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)&
@@ -68,8 +66,6 @@
         write(6,*) 'CHK_uspd=',uspd(im/2,jm/2),vspd(im/2,jm/2)
        end if
 
-
-
 !
       do k = 1,km
       do j = 1,jm
@@ -125,12 +121,6 @@
       end do
       end do
       end do
-!
-!      do j=1,jm
-!      do i=1,im
-!       diu3(i,j,1)=0.45/0.4/(0.5*dzn(1))*uspd(i,j)
-!      end do
-!      end do
 
       do j=1,jm
       do i=1,im
@@ -161,12 +151,6 @@
       end do
       end do
 !
-!      do j=1,jm
-!      do i=1,im
-!       diu6(i,j,1)=0.45/0.4/(0.5*dzn(1))*vspd(i,j)
-!      end do
-!      end do
-
       do j=1,jm
       do i=1,im
        nou6(i,j,1) = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
@@ -304,6 +288,16 @@
       end do
 #ifdef MPI
     end if
+    if (isTopRow(procPerRow)) then
+#endif
+      do k = 1,km+1
+      do j = 1,jm+1
+        diu2(0,j,k) = diu2(1,j,k)
+        diu3(0,j,k) = diu3(1,j,k)
+      end do
+      end do
+#ifdef MPI
+    end if
 #endif
 #if !defined(MPI) || (PROC_PER_ROW==1)
       do k = 1,km+1
@@ -348,12 +342,12 @@
 #endif
 
 !uspd,vspd
-        do j=1,jm
-        do i=1,im
-         uspd(i,j)=u(i,j,1)/uspd(i,j)
-         vspd(i,j)=v(i,j,1)/vspd(i,j)
-        end do
-        end do
+!        do j=1,jm
+!        do i=1,im
+!         uspd(i,j)=u(i,j,1)/uspd(i,j)
+!         vspd(i,j)=v(i,j,1)/vspd(i,j)
+!        end do
+!        end do
 
 
 
================================================================================================================================================================
diff -ru MPI-LES/src/velFG.f95 Nested-LES/MPI-LES_20170624/src/velFG.f95
--- MPI-LES/src/velFG.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/velFG.f95	2017-06-24 11:19:34.000000000 +0100
@@ -68,10 +68,13 @@
         covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
         covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
         covc = covx1+covy1+covz1
-        dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))  +   (-diu2(i,j,k)+diu2(i, &
-      j+1,k))/dy1(j) +   (-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
-        df = vn*dfu1(i,j,k)
-        f(i,j,k) = (-covc+df)
+!-- molecular viscous term is neglected
+!        dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))  +   (-diu2(i,j,k)+diu2(i, &
+!      j+1,k))/dy1(j) +   (-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
+!        df = vn*dfu1(i,j,k)
+!        f(i,j,k) = (-covc+df)
+!--
+        f(i,j,k) = (-covc)
       end do
       end do
       end do
@@ -84,10 +87,13 @@
         covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k)) /(dy1(j)+dy1(j+1))
         covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
         covc = covx1+covy1+covz1
-        dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)  +2.*(-diu5(i,j,k)+diu5(i,j+1, &
-      k))/(dy1(j)+dy1(j+1)) +(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
-        df = vn*dfv1(i,j,k)
-        g(i,j,k) = (-covc+df)
+!-- molecular viscous term is neglected
+!        dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)  +2.*(-diu5(i,j,k)+diu5(i,j+1, &
+!      k))/(dy1(j)+dy1(j+1)) +(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
+!        df = vn*dfv1(i,j,k) 
+!        g(i,j,k) = (-covc+df)
+!--
+        g(i,j,k) = (-covc)
       end do
       end do
       end do
@@ -101,10 +107,13 @@
        covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
        covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1)) /(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
-        dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)  +(-diu8(i,j,k)+diu8(i,j+1, &
-      k))/dy1(j) +(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
-        df = vn*dfw1(i,j,k)
-        h(i,j,k) = (-covc+df)
+!-- molecular viscous term is neglected
+!        dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)  +(-diu8(i,j,k)+diu8(i,j+1, &
+!      k))/dy1(j) +(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
+!        df = vn*dfw1(i,j,k)  
+!        h(i,j,k) = (-covc+df)
+!--
+        h(i,j,k) = (-covc)
       end do
       end do
       end do
================================================================================================================================================================
diff -ru MPI-LES/src/velFG_init.f95 Nested-LES/MPI-LES_20170624/src/velFG_init.f95
--- MPI-LES/src/velFG_init.f95	2015-12-16 11:13:17.000000000 +0000
+++ Nested-LES/MPI-LES_20170624/src/velFG_init.f95	2017-06-24 11:19:34.000000000 +0100
@@ -64,10 +64,12 @@
         covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
         covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
         covc = covx1+covy1+covz1
-        dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))  +   (-diu2(i,j,k)+diu2(i, &
-      j+1,k))/dy1(j) +   (-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
-        df = vn*dfu1(i,j,k)
-        f(i,j,k) = (-covc+df)
+!-- molecular viscous term is neglected
+!        dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))  +   (-diu2(i,j,k)+diu2(i, &
+!      j+1,k))/dy1(j) +   (-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
+!        df = vn*dfu1(i,j,k)
+!        f(i,j,k) = (-covc+df)
+        f(i,j,k) = (-covc)
       end do
       end do
       end do
@@ -80,10 +82,12 @@
         covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k)) /(dy1(j)+dy1(j+1))
         covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
         covc = covx1+covy1+covz1
-        dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)  +2.*(-diu5(i,j,k)+diu5(i,j+1, &
-      k))/(dy1(j)+dy1(j+1)) +(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
-        df = vn*dfv1(i,j,k)
-        g(i,j,k) = (-covc+df)
+!-- molecular viscous term is neglected
+!        dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)  +2.*(-diu5(i,j,k)+diu5(i,j+1, &
+!      k))/(dy1(j)+dy1(j+1)) +(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
+!        df = vn*dfv1(i,j,k)
+!        g(i,j,k) = (-covc+df)
+        g(i,j,k) = (-covc)
       end do
       end do
       end do
@@ -97,10 +101,12 @@
        covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
        covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1)) /(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
-        dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)  +(-diu8(i,j,k)+diu8(i,j+1, &
-      k))/dy1(j) +(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
-        df = vn*dfw1(i,j,k)
-        h(i,j,k) = (-covc+df)
+!-- molecular viscous term is neglected
+!        dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)  +(-diu8(i,j,k)+diu8(i,j+1, &
+!      k))/dy1(j) +(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
+!        df = vn*dfw1(i,j,k)
+!        h(i,j,k) = (-covc+df)
+        h(i,j,k) = (-covc)
       end do
       end do
       end do
