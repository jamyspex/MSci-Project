
================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	adam
	bondv1
	feedbf
	les
	press
	velfg
	velnw
File containing main subroutine: 
	main.f95
Source directory:
	./src
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: WV_OPENCL, WV_NEW, WV_NEW_VELFG, NO_GLOBAL_SOR, INLINE_BOUND_CALCS, WV_TEST, TWINNED_BUFFER, NO_IO, IFBF=1, IADAM=0, 
CPP Excludes:

"Executing compiler main..."
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/main_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/init_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/grid_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/set_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/aveflow_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/ifdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/main.f95
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velfg_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DWV_NEW_VELFG -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/adam.f95
Parsing ./src/bondv1.f95
Parsing ./src/feedbf.f95
Parsing ./src/les.f95
Parsing ./src/press.f95
Parsing ./src/velfg.f95
Parsing ./src/velnw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4) :: alpha
      integer :: ical
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nif
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data15
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(,,) :: cn1
      real(4), dimension() :: cn2l
      real(4), dimension() :: cn2s
      real(4), dimension() :: cn3l
      real(4), dimension() :: cn3s
      real(4), dimension() :: cn4l
      real(4), dimension() :: cn4s
      real(4), dimension() :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(,,) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(,,) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(,,) :: hold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(,,) :: uwfx
      real(4), dimension(,) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      integer :: clock_rate
      integer(4), dimension(0:9) :: timestamp
      integer(4) :: i
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, ical, nif, n0, n1, nmax&
&, dt, ro, vn, alpha, beta, data12, data13, data14, data15)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call init(u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(fold, gold, hold, time, n, u, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, d&
&iu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, vn, dzs, nou1, nou2, nou3, nou4, nou5, nou6, nou7, nou8, nou9, amask1, bmask1, cmask1, dm&
&ask1, alpha, beta, fx, fy, fz, zbm, ical, nif)
    do n = n0, nmax, 1
        time = float(n-n0)*dt
        call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
        call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
        call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
        call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys&
&, n)
        call adam(n, nmax, data21, fold, gold, hold, f, g, h)
        call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
    end do

end program main

AST not shown.
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, gold, hold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "n0", argument = VarName (fromList []) "n0"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	les->
	    call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys, n)
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	press->
	    call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	velfg->
	    call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	velnw->
	    call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: adam
Filename: ./src/adam.f95
Source:
subroutine adam(n,nmax,data21,fold,gold,hold,f,g,h)
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      character*70, intent(In) :: data21
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(,,), intent(InOut) :: hold
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: i,j,k
      real(4) :: fd,gd,hd
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
end subroutine adam

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: bondv1
Filename: ./src/bondv1.f95
Source:
subroutine bondv1(u,z2,dzn,v,w,n,n0,dt,dxs)
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      integer, intent(In) :: n,n0
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:kp+2), intent(In) :: z2
      real(4) :: u_val
      integer :: i,j,k
      real(4) :: aaa,bbb,uout,gaaa,gbbb
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jp, 1
                                u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
                                u(i,j,k) = u_val
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, kp, 1
                do j = 1, jp, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==n0) then
        do k = 1, kp, 1
                do j = 1, jp, 1
                                do i = 2, ip, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    do k = 1, kp, 1
        do j = 1, jp, 1
                aaa = amax1(aaa,u(ip,j,k))
        end do
    end do
    gaaa = aaa
    bbb = 1e38
    do k = 1, kp, 1
        do j = 1, jp, 1
                bbb = amin1(bbb,u(ip,j,k))
        end do
    end do
    gbbb = bbb
    uout = (gaaa+gbbb)/2.
    do k = 1, kp, 1
        do j = 1, jp, 1
                u(ip,j,k) = u(ip,j,k)-dt*uout*(u(ip,j,k)-u(ip-1,j,k))/dxs(ip)
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                v(ip+1,j,k) = v(ip+1,j,k)-dt*uout*(v(ip+1,j,k)-v(ip,j,k))/dxs(ip)
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                w(ip+1,j,k) = w(ip+1,j,k)-dt*uout*(w(ip+1,j,k)-w(ip,j,k))/dxs(ip)
        end do
    end do
    do k = 0, kp+1, 1
        do i = 0, ip+1, 1
                u(i,0,k) = u(i,jp,k)
                u(i,jp+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, kp+1, 1
        do i = 0, ip+1, 1
                v(i,0,k) = v(i,jp,k)
                v(i,jp+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, kp, 1
        do i = 0, ip+1, 1
                w(i,0,k) = w(i,jp,k)
                w(i,jp+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jp+1, 1
        do i = 0, ip+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,kp+1) = u(i,j,kp)
        end do
    end do
    do j = 0, jp+1, 1
        do i = 0, ip+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,kp+1) = v(i,j,kp)
        end do
    end do
    do j = -1, jp+1, 1
        do i = 0, ip+1, 1
                w(i,j,0) = 0.0
                w(i,j,kp) = 0.0
        end do
    end do
end subroutine bondv1

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: feedbf
Filename: ./src/feedbf.f95
Source:
subroutine feedbf(usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,dt,beta,fx,fy,fz,f,g,h,n)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      integer, intent(In) :: n
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      integer :: i,j,k
      real(4) :: f1x,f1y,f1z,f2x,f2y,f2z
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
end subroutine feedbf

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: les
Filename: ./src/les.f95
Source:
subroutine les(delx1,dx1,dy1,dzn,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,u,v,uspd,vspd,dxs,dys,n)
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      integer, intent(In) :: n
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      integer :: i,j,k
      real(4) :: csx1
      real(4) :: dudxx1,dudyx1,dudzx1,dvdxx1,dvdyx1,dvdzx1,dwdxx1,dwdyx1,dwdzx1
      real(4) :: visux2,visux1,visuy2,visuy1,visuz2,visuz1
      real(4) :: visvx2,visvx1,visvy2,visvy1,visvz2,visvz1
      real(4) :: viswx2,viswx1,viswy2,viswy1,viswz2,viswz1
      real(4) :: evsx2,evsx1,evsy2,evsy1,evsz2,evsz1
      real(4) :: vfu,vfv,vfw
    do k = 1, kp, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dv&
&dzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    do k = 0, kp+1, 1
        do j = -1, jp+1, 1
                sm(0,j,k) = sm(1,j,k)
                sm(ip+1,j,k) = sm(ip,j,k)
        end do
    end do
    do k = 0, kp+1, 1
        do i = 0, ip+1, 1
                sm(i,jp+1,k) = sm(i,jp,k)
                sm(i,0,k) = sm(i,1,k)
        end do
    end do
    do j = -1, jp+1, 1
        do i = 0, ip+1, 1
                sm(i,j,0) = -sm(i,j,1)
                sm(i,j,kp+1) = sm(i,j,kp)
        end do
    end do
    do k = 2, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i&
&,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*&
&sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i&
&,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*&
&sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jp, 1
        do i = 1, ip, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*s&
&m(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)&
&*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+&
&1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                f(i,j,1) = (f(i,j,1)+vfu)
        end do
    end do
    do k = 2, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i&
&,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1&
&,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i&
&,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*&
&sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jp, 1
        do i = 1, ip, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*s&
&m(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)&
&*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+&
&1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                g(i,j,1) = (g(i,j,1)+vfv)
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i&
&,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1&
&,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i&
&,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j&
&-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
end subroutine les

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: press
Filename: ./src/press.f95
Source:
subroutine press(u,v,w,p,rhs,f,g,h,dx1,dy1,dzn,dxs,dys,dzs,dt,n,nmax)
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4) :: cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,dz1,dz2
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      integer :: nn
      integer :: i,j,k,l,nrd
      real(4) :: rhsav,pav,area,pco,sor,reltmp
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
    do k = 1, kp, 1
        do j = 1, jp, 1
                f(0,j,k) = f(1,j,k)
        end do
    end do
    do k = 1, kp, 1
        do i = 1, ip, 1
                g(i,0,k) = g(i,jp,k)
        end do
    end do
    do j = 1, jp, 1
        do i = 1, ip, 1
                h(i,j,0) = 0.0
                h(i,j,kp) = 0.0
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(&
&k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+&
&rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, kp, 1
                                do j = 1, jp, 1
                                                                do i = 1, ip, 1
                                                                                                                                dz1 &
&= dzs(k-1)
                                                                                                                                dz2 &
&= dzs(k)
                                                                                                                                cn4s&
& = 2./(dz1*(dz1+dz2))
                                                                                                                                cn4l&
& = 2./(dz2*(dz1+dz2))
                                                                                                                                cn3s&
& = 2./(dys(j-1)*(dys(j-1)+dys(j)))
                                                                                                                                cn3l&
& = 2./(dys(j)*(dys(j-1)+dys(j)))
                                                                                                                                cn2s&
& = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
                                                                                                                                cn2l&
& = 2./(dxs(i)*(dxs(i-1)+dxs(i)))
                                                                                                                                cn1 &
&= 1./(2./(dxs(i-1)*dxs(i))+2./(dys(j-1)*dys(j))+2./(dz1*dz2))
                                                                                                                                if (&
&nrd==0) then
                                                                                                                                    &
&                                                                                                                            reltmp =&
& omega*(cn1*(cn2l*p(0,i+1,j,k)+cn2s*p(0,i-1,j,k)+cn3l*p(0,i,j+1,k)+cn3s*p(0,i,j-1,k)+cn4l*p(0,i,j,k+1)+cn4s*p(0,i,j,k-1)-rhs(i,j,k))&
&-p(0,i,j,k))
                                                                                                                                    &
&                                                                                                                            p(1,i,j,&
&k) = p(0,i,j,k)+reltmp
                                                                                                                                else
                                                                                                                                    &
&                                                                                                                            reltmp =&
& omega*(cn1*(cn2l*p(1,i+1,j,k)+cn2s*p(1,i-1,j,k)+cn3l*p(1,i,j+1,k)+cn3s*p(1,i,j-1,k)+cn4l*p(1,i,j,k+1)+cn4s*p(1,i,j,k-1)-rhs(i,j,k))&
&-p(1,i,j,k))
                                                                                                                                    &
&                                                                                                                            p(0,i,j,&
&k) = p(1,i,j,k)+reltmp
                                                                                                                                end &
&if
                                                                end do
                                end do
                end do
                do k = 0, kp+1, 1
                                do j = 0, jp+1, 1
                                                                p(0,0,j,k) = p(0,1,j,k)
                                                                p(0,ip+1,j,k) = p(0,ip,j,k)
                                end do
                end do
                do k = 0, kp+1, 1
                                do i = 0, ip+1, 1
                                                                p(0,i,0,k) = p(0,i,jp,k)
                                                                p(0,i,jp+1,k) = p(0,i,1,k)
                                end do
                end do
        end do
        do j = 0, jp+1, 1
                do i = 0, ip+1, 1
                                p(0,i,j,0) = p(0,i,j,1)
                                p(0,i,j,kp+1) = p(0,i,j,kp)
                end do
        end do
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                p(0,i,j,k) = p(0,i,j,k)-pav
                end do
        end do
    end do
    do k = 0, kp+1, 1
        do j = 0, jp+1, 1
                p(0,0,j,k) = p(0,1,j,k)
                p(0,ip+1,j,k) = p(0,ip,j,k)
        end do
    end do
    do k = 0, kp+1, 1
        do i = 0, ip+1, 1
                p(0,i,0,k) = p(0,i,jp,k)
                p(0,i,jp+1,k) = p(0,i,1,k)
        end do
    end do
    do j = 0, jp+1, 1
        do i = 0, ip+1, 1
                p(0,i,j,0) = p(0,i,j,1)
                p(0,i,j,kp+1) = p(0,i,j,kp)
        end do
    end do
end subroutine press

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velfg
Filename: ./src/velfg.f95
Source:
subroutine velfg(dx1,dy1,dzn,f,g,dzs,h,u,v,w)
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: h
      real(4) :: nou1_,nou2_,nou3_,nou4_,nou5_,nou6_,nou7_,nou8_,nou9_
      real(4) :: diu1_,diu2_,diu3_,diu4_,diu5_,diu6_,diu7_,diu8_,diu9_
      real(4) :: cov1_i,cov2_j,cov3_k,cov4_i,cov5_j,cov6_k,cov7_i,cov8_j,cov9_k
      real(4) :: nou1_ip1,nou2_jp1,nou3_kp1,nou4_ip1,nou5_jp1,nou6_kp1,nou7_ip1,nou8_jp1,nou9_kp1
      real(4) :: diu1_ip1,diu2_jp1,diu3_kp1,diu4_ip1,diu5_jp1,diu6_kp1,diu7_ip1,diu8_jp1,diu9_kp1
      real(4) :: cov1_ip1,cov2_jp1,cov3_kp1,cov4_ip1,cov5_jp1,cov6_kp1,cov7_ip1,cov8_jp1,cov9_kp1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      integer :: i,j,k
      real(4) :: covc,covx1,covy1,covz1
      integer, parameter :: u0 = 0 
    do j = 1, jp, 1
        do i = 1, ip, 1
                if (j==jp/2 .and. i==ip/2) then
                                uspd = (u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)+0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(&
&i)+dx1(i+1)))**2)**0.5
                                vspd = (v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)+0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(&
&j)+dy1(j+1)))**2)**0.5
                                write(6, *)('CHK_uspd_vspd=', uspd, vspd)
                end if
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
                                diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
                                cov1_i = nou1_*diu1_
                                nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
                                diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
                                cov1_ip1 = nou1_ip1*diu1_ip1
                                if (i==ip) then
                                                                cov1_ip1 = cov1_i
                                end if
                                nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
                                diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
                                cov2_j = nou2_*diu2_
                                nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
                                diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
                                cov2_jp1 = nou2_jp1*diu2_jp1
                                if (j==jp) then
                                                                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                                                                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                                                                cov2_jp1 = nou2_*diu2_
                                end if
                                nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
                                diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
                                cov3_k = nou3_*diu3_
                                nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
                                diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
                                cov3_kp1 = nou3_kp1*diu3_kp1
                                if (k==1) then
                                                                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                                                                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                                                                cov3_k = nou3_*diu3_
                                end if
                                covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
                                covy1 = (cov2_j+cov2_jp1)/2.
                                covz1 = (cov3_k+cov3_kp1)/2.
                                covc = covx1+covy1+covz1
                                f(i,j,k) = (-covc)
                end do
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
                                diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
                                cov4_i = (nou4_-u0)*diu4_
                                nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
                                diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
                                cov4_ip1 = (nou4_ip1-u0)*diu4_ip1
                                if (i==ip) then
                                                                cov4_ip1 = cov4_i
                                end if
                                nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
                                diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
                                cov5_j = nou5_*diu5_
                                nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
                                diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
                                cov5_jp1 = nou5_jp1*diu5_jp1
                                if (j==jp) then
                                                                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                                                                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                                                                cov5_jp1 = nou5_*diu5_
                                end if
                                nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
                                diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
                                cov6_k = nou6_*diu6_
                                nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
                                diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
                                cov6_kp1 = nou6_kp1*diu6_kp1
                                if (k==1) then
                                                                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                                                                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                                                                cov6_k = nou6_*diu6_
                                end if
                                covx1 = (cov4_i+cov4_ip1)/2.
                                covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
                                covz1 = (cov6_k+cov6_kp1)/2.
                                covc = covx1+covy1+covz1
                                g(i,j,k) = (-covc)
                end do
        end do
    end do
    do k = 1, kp-1, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
                                diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
                                cov7_i = (nou7_-u0)*diu7_
                                nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
                                diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
                                cov7_ip1 = (nou7_-u0)*diu7_
                                if (i==ip) then
                                                                cov7_ip1 = cov7_i
                                end if
                                nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
                                diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
                                cov8_j = nou8_*diu8_
                                nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
                                diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
                                cov8_jp1 = nou8_jp1*diu8_jp1
                                if (j==jp) then
                                                                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                                                                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                                                                cov8_jp1 = nou8_*diu8_
                                end if
                                nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
                                diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                cov9_k = nou9_*diu9_
                                nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
                                diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
                                cov9_kp1 = nou9_kp1*diu9_kp1
                                covx1 = (cov7_i+cov7_ip1)/2.
                                covy1 = (cov8_j+cov8_jp1)/2.
                                covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
                                covc = covx1+covy1+covz1
                                h(i,j,k) = (-covc)
                end do
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                f(0,j,k) = f(1,j,k)
        end do
    end do
    do k = 1, kp, 1
        do i = 1, ip, 1
                g(i,0,k) = g(i,jp,k)
        end do
    end do
    do j = 1, jp, 1
        do i = 1, ip, 1
                h(i,j,0) = 0.0
                h(i,j,kp) = 0.0
        end do
    end do
    return 
end subroutine velfg

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw
Filename: ./src/velnw.f95
Source:
subroutine velnw(p,ro,dxs,u,dt,f,dys,v,g,dzs,w,h)
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: h
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1), intent(In) :: p
      real(4), intent(In) :: ro
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      integer :: i,j,k
      real(4) :: pz
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, kp, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, kp-1, 1
        do j = 1, jp, 1
                do i = 1, ip, 1
                                pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
end subroutine velnw

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4) :: alpha
      integer :: ical
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nif
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data15
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(,,) :: cn1
      real(4), dimension() :: cn2l
      real(4), dimension() :: cn2s
      real(4), dimension() :: cn3l
      real(4), dimension() :: cn3s
      real(4), dimension() :: cn4l
      real(4), dimension() :: cn4s
      real(4), dimension() :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(,,) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(,,) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(,,) :: hold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(,,) :: uwfx
      real(4), dimension(,) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      integer :: clock_rate
      integer(4), dimension(0:9) :: timestamp
      integer(4) :: i
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, ical, nif, n0, n1, nmax&
&, dt, ro, vn, alpha, beta, data12, data13, data14, data15)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call init(u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(fold, gold, hold, time, n, u, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, d&
&iu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, vn, dzs, nou1, nou2, nou3, nou4, nou5, nou6, nou7, nou8, nou9, amask1, bmask1, cmask1, dm&
&ask1, alpha, beta, fx, fy, fz, zbm, ical, nif)
    do n = n0, nmax, 1
        time = float(n-n0)*dt
        call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
        call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
        call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
        call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys&
&, n)
        call adam(n, nmax, data21, fold, gold, hold, f, g, h)
        call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
    end do

end program main

AST not shown.
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, gold, hold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "n0", argument = VarName (fromList []) "n0"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	les->
	    call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys, n)
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	press->
	    call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	velfg->
	    call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	velnw->
	    call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,&
&diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fold,fx,fy,fz,g,gold,h,hold,n,n0,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: avetime = 2 
      real, parameter :: cs0 = 0.14 
      real, parameter :: dt_orig = 0.05 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      integer, parameter :: i_anime = 1 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      integer, parameter :: ip = 300 
      integer, parameter :: ipmax = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: jpmax = 300 
      integer, parameter :: km_sl = 80 
      integer, parameter :: kp = 80 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: u0 = 0 
      real(4) :: aaa
      real(4) :: bbb
      real(4) :: uout
      real(4) :: gaaa
      real(4) :: gbbb
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4) :: cn1
      real(4) :: cn2l
      real(4) :: cn2s
      real(4) :: cn3l
      real(4) :: cn3s
      real(4) :: cn4l
      real(4) :: cn4s
      real(4) :: dz1
      real(4) :: dz2
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: csx1
      character*70, intent(In) :: data21
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
      integer, intent(In) :: n
      integer, intent(In) :: n0
      integer, intent(In) :: nmax
      integer :: nn
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: pav
      real(4) :: area
      real(4) :: pco
      real(4) :: sor
      real(4) :: reltmp
      real(4), intent(In) :: ro
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfu
      real(4) :: vfv
      real(4) :: vfw
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
      real(4), dimension(0:82), intent(In) :: z2
! Original Subroutine Name: velnw {
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, 79, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
!}
! Original Subroutine Name: bondv1 {
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, 300, 1
                                u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
                                u(i,j,k) = u_val
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, 80, 1
                do j = 1, 300, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==n0) then
        do k = 1, 80, 1
                do j = 1, 300, 1
                                do i = 2, 300, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    do k = 1, 80, 1
        do j = 1, 300, 1
                aaa = amax1(aaa,u(300,j,k))
        end do
    end do
    gaaa = aaa
    bbb = 1e38
    do k = 1, 80, 1
        do j = 1, 300, 1
                bbb = amin1(bbb,u(300,j,k))
        end do
    end do
    gbbb = bbb
    uout = (gaaa+gbbb)/2.
    do k = 1, 80, 1
        do j = 1, 300, 1
                u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
        end do
    end do
    do k = 0, 81, 1
        do i = 0, 301, 1
                u(i,0,k) = u(i,300,k)
                u(i,301,k) = u(i,1,k)
        end do
    end do
    do k = 0, 81, 1
        do i = 0, 301, 1
                v(i,0,k) = v(i,300,k)
                v(i,301,k) = v(i,1,k)
        end do
    end do
    do k = 0, 80, 1
        do i = 0, 301, 1
                w(i,0,k) = w(i,300,k)
                w(i,301,k) = w(i,1,k)
        end do
    end do
    do j = 0, 301, 1
        do i = 0, 301, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,81) = u(i,j,80)
        end do
    end do
    do j = 0, 301, 1
        do i = 0, 301, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,81) = v(i,j,80)
        end do
    end do
    do j = -1, 301, 1
        do i = 0, 301, 1
                w(i,j,0) = 0.0
                w(i,j,80) = 0.0
        end do
    end do
!}
! Original Subroutine Name: velfg {
    do j = 1, 300, 1
        do i = 1, 300, 1
                if (j==300/2 .and. i==300/2) then
                                uspd = (u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)+0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(&
&i)+dx1(i+1)))**2)**0.5
                                vspd = (v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)+0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(&
&j)+dy1(j+1)))**2)**0.5
                                write(6, *)('CHK_uspd_vspd=', uspd, vspd)
                end if
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
                                diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
                                cov1_i = nou1_*diu1_
                                nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
                                diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
                                cov1_ip1 = nou1_ip1*diu1_ip1
                                if (i==300) then
                                                                cov1_ip1 = cov1_i
                                end if
                                nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
                                diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
                                cov2_j = nou2_*diu2_
                                nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
                                diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
                                cov2_jp1 = nou2_jp1*diu2_jp1
                                if (j==300) then
                                                                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                                                                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                                                                cov2_jp1 = nou2_*diu2_
                                end if
                                nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
                                diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
                                cov3_k = nou3_*diu3_
                                nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
                                diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
                                cov3_kp1 = nou3_kp1*diu3_kp1
                                if (k==1) then
                                                                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                                                                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                                                                cov3_k = nou3_*diu3_
                                end if
                                covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
                                covy1 = (cov2_j+cov2_jp1)/2.
                                covz1 = (cov3_k+cov3_kp1)/2.
                                covc = covx1+covy1+covz1
                                f(i,j,k) = (-covc)
                end do
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
                                diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
                                cov4_i = (nou4_-0)*diu4_
                                nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
                                diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
                                cov4_ip1 = (nou4_ip1-0)*diu4_ip1
                                if (i==300) then
                                                                cov4_ip1 = cov4_i
                                end if
                                nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
                                diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
                                cov5_j = nou5_*diu5_
                                nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
                                diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
                                cov5_jp1 = nou5_jp1*diu5_jp1
                                if (j==300) then
                                                                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                                                                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                                                                cov5_jp1 = nou5_*diu5_
                                end if
                                nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
                                diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
                                cov6_k = nou6_*diu6_
                                nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
                                diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
                                cov6_kp1 = nou6_kp1*diu6_kp1
                                if (k==1) then
                                                                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                                                                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                                                                cov6_k = nou6_*diu6_
                                end if
                                covx1 = (cov4_i+cov4_ip1)/2.
                                covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
                                covz1 = (cov6_k+cov6_kp1)/2.
                                covc = covx1+covy1+covz1
                                g(i,j,k) = (-covc)
                end do
        end do
    end do
    do k = 1, 79, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
                                diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
                                cov7_i = (nou7_-0)*diu7_
                                nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
                                diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
                                cov7_ip1 = (nou7_-0)*diu7_
                                if (i==300) then
                                                                cov7_ip1 = cov7_i
                                end if
                                nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
                                diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
                                cov8_j = nou8_*diu8_
                                nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
                                diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
                                cov8_jp1 = nou8_jp1*diu8_jp1
                                if (j==300) then
                                                                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                                                                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                                                                cov8_jp1 = nou8_*diu8_
                                end if
                                nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
                                diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                cov9_k = nou9_*diu9_
                                nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
                                diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
                                cov9_kp1 = nou9_kp1*diu9_kp1
                                covx1 = (cov7_i+cov7_ip1)/2.
                                covy1 = (cov8_j+cov8_jp1)/2.
                                covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
                                covc = covx1+covy1+covz1
                                h(i,j,k) = (-covc)
                end do
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                f(0,j,k) = f(1,j,k)
        end do
    end do
    do k = 1, 80, 1
        do i = 1, 300, 1
                g(i,0,k) = g(i,300,k)
        end do
    end do
    do j = 1, 300, 1
        do i = 1, 300, 1
                h(i,j,0) = 0.0
                h(i,j,80) = 0.0
        end do
    end do
!}
! Original Subroutine Name: feedbf {
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
!}
! Original Subroutine Name: les {
    do k = 1, 80, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = 0.14
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dv&
&dzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    do k = 0, 81, 1
        do j = -1, 301, 1
                sm(0,j,k) = sm(1,j,k)
                sm(301,j,k) = sm(300,j,k)
        end do
    end do
    do k = 0, 81, 1
        do i = 0, 301, 1
                sm(i,301,k) = sm(i,300,k)
                sm(i,0,k) = sm(i,1,k)
        end do
    end do
    do j = -1, 301, 1
        do i = 0, 301, 1
                sm(i,j,0) = -sm(i,j,1)
                sm(i,j,81) = sm(i,j,80)
        end do
    end do
    do k = 2, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i&
&,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*&
&sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i&
&,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*&
&sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, 300, 1
        do i = 1, 300, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*s&
&m(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)&
&*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+&
&1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                f(i,j,1) = (f(i,j,1)+vfu)
        end do
    end do
    do k = 2, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i&
&,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1&
&,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i&
&,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*&
&sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, 300, 1
        do i = 1, 300, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*s&
&m(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)&
&*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+&
&1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                g(i,j,1) = (g(i,j,1)+vfv)
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i&
&,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1&
&,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i&
&,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j&
&-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
!}
! Original Subroutine Name: adam {
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
!}
! Original Subroutine Name: press {
    do k = 1, 80, 1
        do j = 1, 300, 1
                f(0,j,k) = f(1,j,k)
        end do
    end do
    do k = 1, 80, 1
        do i = 1, 300, 1
                g(i,0,k) = g(i,300,k)
        end do
    end do
    do j = 1, 300, 1
        do i = 1, 300, 1
                h(i,j,0) = 0.0
                h(i,j,80) = 0.0
        end do
    end do
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(&
&k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+&
&rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, 50, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, 80, 1
                                do j = 1, 300, 1
                                                                do i = 1, 300, 1
                                                                                                                                dz1 &
&= dzs(k-1)
                                                                                                                                dz2 &
&= dzs(k)
                                                                                                                                cn4s&
& = 2./(dz1*(dz1+dz2))
                                                                                                                                cn4l&
& = 2./(dz2*(dz1+dz2))
                                                                                                                                cn3s&
& = 2./(dys(j-1)*(dys(j-1)+dys(j)))
                                                                                                                                cn3l&
& = 2./(dys(j)*(dys(j-1)+dys(j)))
                                                                                                                                cn2s&
& = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
                                                                                                                                cn2l&
& = 2./(dxs(i)*(dxs(i-1)+dxs(i)))
                                                                                                                                cn1 &
&= 1./(2./(dxs(i-1)*dxs(i))+2./(dys(j-1)*dys(j))+2./(dz1*dz2))
                                                                                                                                if (&
&nrd==0) then
                                                                                                                                    &
&                                                                                                                            reltmp =&
& 1.0*(cn1*(cn2l*p(0,i+1,j,k)+cn2s*p(0,i-1,j,k)+cn3l*p(0,i,j+1,k)+cn3s*p(0,i,j-1,k)+cn4l*p(0,i,j,k+1)+cn4s*p(0,i,j,k-1)-rhs(i,j,k))-p&
&(0,i,j,k))
                                                                                                                                    &
&                                                                                                                            p(1,i,j,&
&k) = p(0,i,j,k)+reltmp
                                                                                                                                else
                                                                                                                                    &
&                                                                                                                            reltmp =&
& 1.0*(cn1*(cn2l*p(1,i+1,j,k)+cn2s*p(1,i-1,j,k)+cn3l*p(1,i,j+1,k)+cn3s*p(1,i,j-1,k)+cn4l*p(1,i,j,k+1)+cn4s*p(1,i,j,k-1)-rhs(i,j,k))-p&
&(1,i,j,k))
                                                                                                                                    &
&                                                                                                                            p(0,i,j,&
&k) = p(1,i,j,k)+reltmp
                                                                                                                                end &
&if
                                                                end do
                                end do
                end do
                do k = 0, 81, 1
                                do j = 0, 301, 1
                                                                p(0,0,j,k) = p(0,1,j,k)
                                                                p(0,301,j,k) = p(0,300,j,k)
                                end do
                end do
                do k = 0, 81, 1
                                do i = 0, 301, 1
                                                                p(0,i,0,k) = p(0,i,300,k)
                                                                p(0,i,301,k) = p(0,i,1,k)
                                end do
                end do
        end do
        do j = 0, 301, 1
                do i = 0, 301, 1
                                p(0,i,j,0) = p(0,i,j,1)
                                p(0,i,j,81) = p(0,i,j,80)
                end do
        end do
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, 80, 1
        do j = 1, 300, 1
                do i = 1, 300, 1
                                p(0,i,j,k) = p(0,i,j,k)-pav
                end do
        end do
    end do
    do k = 0, 81, 1
        do j = 0, 301, 1
                p(0,0,j,k) = p(0,1,j,k)
                p(0,301,j,k) = p(0,300,j,k)
        end do
    end do
    do k = 0, 81, 1
        do i = 0, 301, 1
                p(0,i,0,k) = p(0,i,300,k)
                p(0,i,301,k) = p(0,i,1,k)
        end do
    end do
    do j = 0, 301, 1
        do i = 0, 301, 1
                p(0,i,j,0) = p(0,i,j,1)
                p(0,i,j,81) = p(0,i,j,80)
        end do
    end do
!}
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map + Fold Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,&
&diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fold,fx,fy,fz,g,gold,h,hold,n,n0,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: avetime = 2 
      real, parameter :: cs0 = 0.14 
      real, parameter :: dt_orig = 0.05 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      integer, parameter :: i_anime = 1 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      integer, parameter :: ip = 300 
      integer, parameter :: ipmax = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: jpmax = 300 
      integer, parameter :: km_sl = 80 
      integer, parameter :: kp = 80 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: u0 = 0 
      real(4) :: aaa
      real(4) :: bbb
      real(4) :: uout
      real(4) :: gaaa
      real(4) :: gbbb
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4) :: cn1
      real(4) :: cn2l
      real(4) :: cn2s
      real(4) :: cn3l
      real(4) :: cn3s
      real(4) :: cn4l
      real(4) :: cn4s
      real(4) :: dz1
      real(4) :: dz2
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: csx1
      character*70, intent(In) :: data21
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
      integer, intent(In) :: n
      integer, intent(In) :: n0
      integer, intent(In) :: nmax
      integer :: nn
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: pav
      real(4) :: area
      real(4) :: pco
      real(4) :: sor
      real(4) :: reltmp
      real(4), intent(In) :: ro
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfu
      real(4) :: vfv
      real(4) :: vfw
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
      real(4), dimension(0:82), intent(In) :: z2
! Original Subroutine Name: velnw {
! OpenCLMap ( ["ro","dxs","dt"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","dxs","k","dt"],["u"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","dxs","j","k","u","dt"],["u"],["(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["ro","dys","dt"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","dys","k","dt"],["v"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","j","dys","k","dt"],["v"],["(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["ro","dzs","dt"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","k","dzs","dt"],["w"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","k","dzs","j","dt"],["w"],["(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}
!}
! Original Subroutine Name: bondv1 {
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( [],["u","w"],["(k,1,78,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( [],["u","v","w"],["(j,1,300,1)"],[]) {
    u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
    u(i,j,k) = u_val
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["i"],["u","v","w"],["(k,79,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["i"],["u","v","w"],["(j,1,300,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==n0) then
! OpenCLMap ( [],["u","v","w"],["(k,1,80,1)","(j,1,300,1)","(i,2,300,1)","(i,2,300,1)"],[]) {
! OpenCLMap ( ["k"],["u","v","w"],["(j,1,300,1)","(i,2,300,1)"],[]) {
! OpenCLMap ( ["j","k"],["u","v","w"],["(i,2,300,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
! OpenCLReduce ( ["u"],["aaa"],["(j,1,300,1)"],[],["(aaa,0.0)"]) {
    aaa = amax1(aaa,u(300,j,k))
!}
!}
    gaaa = aaa
    bbb = 1e38
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
! OpenCLReduce ( ["u"],["bbb"],["(j,1,300,1)"],[],["(bbb,1e38)"]) {
    bbb = amin1(bbb,u(300,j,k))
!}
!}
    gbbb = bbb
    uout = (gaaa+gbbb)/2.
! OpenCLMap ( ["dt","uout","dxs"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k","dt","uout","dxs"],["u"],["(j,1,300,1)"],[]) {
    u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
!}
!}
! OpenCLMap ( ["dt","uout","dxs"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k","dt","uout","dxs"],["v"],["(j,1,300,1)"],[]) {
    v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
!}
!}
! OpenCLMap ( ["dt","uout","dxs"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k","dt","uout","dxs"],["w"],["(j,1,300,1)"],[]) {
    w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
!}
!}
! OpenCLMap ( [],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["u"],["(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}
!}
! OpenCLMap ( [],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["v"],["(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}
!}
! OpenCLMap ( [],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],[],["(i,0,301,1)"],[]) {
    w(i,0,k) = w(i,300,k)
    w(i,301,k) = w(i,1,k)
!}
!}
! OpenCLMap ( [],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],[],["(i,0,301,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,81) = u(i,j,80)
!}
!}
! OpenCLMap ( [],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],["v"],["(i,0,301,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,81) = v(i,j,80)
!}
!}
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( [],[],["(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
!}
!}
! Original Subroutine Name: velfg {
    do j = 1, 300, 1
        do i = 1, 300, 1
                if (j==300/2 .and. i==300/2) then
                                uspd = (u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)+0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(&
&i)+dx1(i+1)))**2)**0.5
                                vspd = (v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)+0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(&
&j)+dy1(j+1)))**2)**0.5
                                write(6, *)('CHK_uspd_vspd=', uspd, vspd)
                end if
        end do
    end do
! OpenCLMap ( ["dx1","dzs"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","dzs","k"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","j","dzs","k"],[],["(i,1,300,1)"],[]) {
    nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
    diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
    cov1_i = nou1_*diu1_
    nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
    diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
    cov1_ip1 = nou1_ip1*diu1_ip1
    if (i==300) then
        cov1_ip1 = cov1_i
    end if
    nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
    diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
    cov2_j = nou2_*diu2_
    nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
    diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
    cov2_jp1 = nou2_jp1*diu2_jp1
    if (j==300) then
        nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
        cov2_jp1 = nou2_*diu2_
    end if
    nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
    diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
    cov3_k = nou3_*diu3_
    nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
    diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
    cov3_kp1 = nou3_kp1*diu3_kp1
    if (k==1) then
        nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
        diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
        cov3_k = nou3_*diu3_
    end if
    covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
    covy1 = (cov2_j+cov2_jp1)/2.
    covz1 = (cov3_k+cov3_kp1)/2.
    covc = covx1+covy1+covz1
    f(i,j,k) = (-covc)
!}
!}
!}
! OpenCLMap ( ["dy1","dzs"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dy1","dzs","k"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","dy1","dzs","k"],[],["(i,1,300,1)"],[]) {
    nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
    diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
    cov4_i = (nou4_-0)*diu4_
    nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
    diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
    cov4_ip1 = (nou4_ip1-0)*diu4_ip1
    if (i==300) then
        cov4_ip1 = cov4_i
    end if
    nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
    diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
    cov5_j = nou5_*diu5_
    nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
    diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
    cov5_jp1 = nou5_jp1*diu5_jp1
    if (j==300) then
        nou5_ = (v(i,1,k)+v(i,2,k))/2.
        diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
        cov5_jp1 = nou5_*diu5_
    end if
    nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
    diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
    cov6_k = nou6_*diu6_
    nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
    diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
    cov6_kp1 = nou6_kp1*diu6_kp1
    if (k==1) then
        nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
        diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
        cov6_k = nou6_*diu6_
    end if
    covx1 = (cov4_i+cov4_ip1)/2.
    covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
    covz1 = (cov6_k+cov6_kp1)/2.
    covc = covx1+covy1+covz1
    g(i,j,k) = (-covc)
!}
!}
!}
! OpenCLMap ( ["dzn"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","dzn"],[],["(i,1,300,1)"],[]) {
    nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
    diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
    cov7_i = (nou7_-0)*diu7_
    nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
    diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
    cov7_ip1 = (nou7_-0)*diu7_
    if (i==300) then
        cov7_ip1 = cov7_i
    end if
    nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
    diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
    cov8_j = nou8_*diu8_
    nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
    diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
    cov8_jp1 = nou8_jp1*diu8_jp1
    if (j==300) then
        nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
        cov8_jp1 = nou8_*diu8_
    end if
    nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
    diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
    cov9_k = nou9_*diu9_
    nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
    diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
    cov9_kp1 = nou9_kp1*diu9_kp1
    covx1 = (cov7_i+cov7_ip1)/2.
    covy1 = (cov8_j+cov8_jp1)/2.
    covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
    covc = covx1+covy1+covz1
    h(i,j,k) = (-covc)
!}
!}
!}
! OpenCLMap ( [],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(j,1,300,1)"],[]) {
    f(0,j,k) = f(1,j,k)
!}
!}
! OpenCLMap ( [],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(i,1,300,1)"],[]) {
    g(i,0,k) = g(i,300,k)
!}
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( [],[],["(i,1,300,1)"],[]) {
    h(i,j,0) = 0.0
    h(i,j,80) = 0.0
!}
!}
!}
! Original Subroutine Name: feedbf {
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,300,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["fx","fy","fz"],["g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","fx","fy","fz"],["g"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","fx","fy","fz"],["g"],["(i,1,300,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
!}
! Original Subroutine Name: les {
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLMap ( ["diu1","diu5","diu9"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","diu1","diu5","diu9"],["sm"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","diu1","diu5","diu9"],["sm"],["(i,1,300,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 0.14
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}
! OpenCLMap ( [],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
! OpenCLMap ( ["k"],["sm"],["(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}
!}
! OpenCLMap ( [],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["sm"],["(i,0,301,1)"],[]) {
    sm(i,301,k) = sm(i,300,k)
    sm(i,0,k) = sm(i,1,k)
!}
!}
! OpenCLMap ( [],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],["sm"],["(i,0,301,1)"],[]) {
    sm(i,j,0) = -sm(i,j,1)
    sm(i,j,81) = sm(i,j,80)
!}
!}
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","sm","diu1","dxs","dy1","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","sm","diu1","dxs","dy1","dzn"],[],["(i,1,300,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}
!}
!}
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","sm","diu1","dxs","dy1","dzn"],["f"],["(i,1,300,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1&
&(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    f(i,j,1) = (f(i,j,1)+vfu)
!}
!}
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","sm","diu5","dx1","dys","dzn"],["g"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","sm","j","diu5","dx1","dys","dzn"],["g"],["(i,1,300,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k)&
&)/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}
!}
!}
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["sm","j","diu5","dx1","dys","dzn"],[],["(i,1,300,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1)&
&)/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1&
&(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    g(i,j,1) = (g(i,j,1)+vfv)
!}
!}
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["sm","k","diu9","dx1","dy1","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","sm","k","diu9","dx1","dy1","dzn"],[],["(i,1,300,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1)&
&)/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1)&
&)/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1)&
&)/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}
!}
!}
!}
! Original Subroutine Name: adam {
! OpenCLMap ( ["f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,300,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
!}
! Original Subroutine Name: press {
! OpenCLMap ( [],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(j,1,300,1)"],[]) {
    f(0,j,k) = f(1,j,k)
!}
!}
! OpenCLMap ( [],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(i,1,300,1)"],[]) {
    g(i,0,k) = g(i,300,k)
!}
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( [],[],["(i,1,300,1)"],[]) {
    h(i,j,0) = 0.0
    h(i,j,80) = 0.0
!}
!}
! OpenCLMap ( ["dx1","dy1","dzn","dt"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","dy1","k","dzn","dt"],["rhs"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","j","dy1","k","dzn","dt"],["rhs"],["(i,1,300,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["rhsav"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","rhsav"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","rhsav"],[],["(i,1,300,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLMap ( ["dzs","nrd"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],["nrd","l"]) {
! OpenCLMap ( ["dzs","k","nrd"],["p"],["(j,1,300,1)","(i,1,300,1)"],["nrd","l"]) {
! OpenCLMap ( ["dzs","k","nrd","j"],["p"],["(i,1,300,1)"],["nrd","l"]) {
                dz1 = dzs(k-1)
                dz2 = dzs(k)
                cn4s = 2./(dz1*(dz1+dz2))
                cn4l = 2./(dz2*(dz1+dz2))
                cn3s = 2./(dys(j-1)*(dys(j-1)+dys(j)))
                cn3l = 2./(dys(j)*(dys(j-1)+dys(j)))
                cn2s = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
                cn2l = 2./(dxs(i)*(dxs(i-1)+dxs(i)))
                cn1 = 1./(2./(dxs(i-1)*dxs(i))+2./(dys(j-1)*dys(j))+2./(dz1*dz2))
                if (nrd==0) then
                                reltmp = 1.0*(cn1*(cn2l*p(0,i+1,j,k)+cn2s*p(0,i-1,j,k)+cn3l*p(0,i,j+1,k)+cn3s*p(0,i,j-1,k)+cn4l*p(0,&
&i,j,k+1)+cn4s*p(0,i,j,k-1)-rhs(i,j,k))-p(0,i,j,k))
                                p(1,i,j,k) = p(0,i,j,k)+reltmp
                else
                                reltmp = 1.0*(cn1*(cn2l*p(1,i+1,j,k)+cn2s*p(1,i-1,j,k)+cn3l*p(1,i,j+1,k)+cn3s*p(1,i,j-1,k)+cn4l*p(1,&
&i,j,k+1)+cn4s*p(1,i,j,k-1)-rhs(i,j,k))-p(1,i,j,k))
                                p(0,i,j,k) = p(1,i,j,k)+reltmp
                end if
!}
!}
!}
! OpenCLMap ( [],["p"],["(k,0,81,1)","(j,0,301,1)"],["nrd","l"]) {
! OpenCLMap ( ["k"],["p"],["(j,0,301,1)"],["nrd","l"]) {
                p(0,0,j,k) = p(0,1,j,k)
                p(0,301,j,k) = p(0,300,j,k)
!}
!}
! OpenCLMap ( [],["p"],["(k,0,81,1)","(i,0,301,1)"],["nrd","l"]) {
! OpenCLMap ( ["k"],["p"],["(i,0,301,1)"],["nrd","l"]) {
                p(0,i,0,k) = p(0,i,300,k)
                p(0,i,301,k) = p(0,i,1,k)
!}
!}
        end do
! OpenCLMap ( [],["p"],["(j,0,301,1)","(i,0,301,1)"],["l"]) {
! OpenCLMap ( ["j"],["p"],["(i,0,301,1)"],["l"]) {
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
!}
!}
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["pav"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","pav"],["p"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","pav"],["p"],["(i,1,300,1)"],[]) {
    p(0,i,j,k) = p(0,i,j,k)-pav
!}
!}
!}
! OpenCLMap ( [],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["p"],["(j,0,301,1)"],[]) {
    p(0,0,j,k) = p(0,1,j,k)
    p(0,301,j,k) = p(0,300,j,k)
!}
!}
! OpenCLMap ( [],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["p"],["(i,0,301,1)"],[]) {
    p(0,i,0,k) = p(0,i,300,k)
    p(0,i,301,k) = p(0,i,1,k)
!}
!}
! OpenCLMap ( [],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],[],["(i,0,301,1)"],[]) {
    p(0,i,j,0) = p(0,i,j,1)
    p(0,i,j,81) = p(0,i,j,80)
!}
!}
!}
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Stencil Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4) :: alpha
      integer :: ical
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nif
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data15
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(,,) :: cn1
      real(4), dimension() :: cn2l
      real(4), dimension() :: cn2s
      real(4), dimension() :: cn3l
      real(4), dimension() :: cn3s
      real(4), dimension() :: cn4l
      real(4), dimension() :: cn4s
      real(4), dimension() :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(,,) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(,,) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(,,) :: hold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(,,) :: uwfx
      real(4), dimension(,) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      integer :: clock_rate
      integer(4), dimension(0:9) :: timestamp
      integer(4) :: i
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, ical, nif, n0, n1, nmax&
&, dt, ro, vn, alpha, beta, data12, data13, data14, data15)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call init(u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(fold, gold, hold, time, n, u, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, d&
&iu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, vn, dzs, nou1, nou2, nou3, nou4, nou5, nou6, nou7, nou8, nou9, amask1, bmask1, cmask1, dm&
&ask1, alpha, beta, fx, fy, fz, zbm, ical, nif)
    do n = n0, nmax, 1
        time = float(n-n0)*dt
        call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
        call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
        call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
        call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys&
&, n)
        call adam(n, nmax, data21, fold, gold, hold, f, g, h)
        call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
    end do

end program main

AST not shown.
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, gold, hold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "n0", argument = VarName (fromList []) "n0"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	les->
	    call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys, n)
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	press->
	    call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	velfg->
	    call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	velnw->
	    call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,&
&diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fold,fx,fy,fz,g,gold,h,hold,n,n0,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: avetime = 2 
      real, parameter :: cs0 = 0.14 
      real, parameter :: dt_orig = 0.05 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      integer, parameter :: i_anime = 1 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      integer, parameter :: ip = 300 
      integer, parameter :: ipmax = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: jpmax = 300 
      integer, parameter :: km_sl = 80 
      integer, parameter :: kp = 80 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: u0 = 0 
      real(4) :: aaa
      real(4) :: bbb
      real(4) :: uout
      real(4) :: gaaa
      real(4) :: gbbb
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4) :: cn1
      real(4) :: cn2l
      real(4) :: cn2s
      real(4) :: cn3l
      real(4) :: cn3s
      real(4) :: cn4l
      real(4) :: cn4s
      real(4) :: dz1
      real(4) :: dz2
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: csx1
      character*70, intent(In) :: data21
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
      integer, intent(In) :: n
      integer, intent(In) :: n0
      integer, intent(In) :: nmax
      integer :: nn
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: pav
      real(4) :: area
      real(4) :: pco
      real(4) :: sor
      real(4) :: reltmp
      real(4), intent(In) :: ro
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfu
      real(4) :: vfv
      real(4) :: vfw
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
      real(4), dimension(0:82), intent(In) :: z2
! Original Subroutine Name: velnw {
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","dxs","k","dt"],["u"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","dxs","j","k","u","dt"],["u"],["(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","dys","k","dt"],["v"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","j","dys","k","dt"],["v"],["(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","k","dzs","dt"],["w"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["ro","k","dzs","j","dt"],["w"],["(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}    
!}
!}
! Original Subroutine Name: bondv1 {
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( [],["u","w"],["(k,1,78,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( [],["u","v","w"],["(j,1,300,1)"],[]) {
    u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
    u(i,j,k) = u_val
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["i"],["u","v","w"],["(k,79,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["i"],["u","v","w"],["(j,1,300,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==n0) then
! OpenCLMap ( [],["u","v","w"],["(k,1,80,1)","(j,1,300,1)","(i,2,300,1)","(i,2,300,1)"],[]) {
! OpenCLMap ( ["k"],["u","v","w"],["(j,1,300,1)","(i,2,300,1)"],[]) {
! OpenCLMap ( ["j","k"],["u","v","w"],["(i,2,300,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
! OpenCLReduce ( ["u"],["aaa"],["(j,1,300,1)"],[],["(aaa,0.0)"]) {
    aaa = amax1(aaa,u(300,j,k))
!}
!}
    gaaa = aaa
    bbb = 1e38
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
! OpenCLReduce ( ["u"],["bbb"],["(j,1,300,1)"],[],["(bbb,1e38)"]) {
    bbb = amin1(bbb,u(300,j,k))
!}
!}
    gbbb = bbb
    uout = (gaaa+gbbb)/2.
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k","dt","uout","dxs"],["u"],["(j,1,300,1)"],[]) {
    u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k","dt","uout","dxs"],["v"],["(j,1,300,1)"],[]) {
    v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k","dt","uout","dxs"],["w"],["(j,1,300,1)"],[]) {
    w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( [],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["u"],["(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( [],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["v"],["(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( [],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],[],["(i,0,301,1)"],[]) {
    w(i,0,k) = w(i,300,k)
    w(i,301,k) = w(i,1,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( [],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],[],["(i,0,301,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,81) = u(i,j,80)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( [],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],["v"],["(i,0,301,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,81) = v(i,j,80)
!}
!}    
!}
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( [],[],["(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
!}
!}
! Original Subroutine Name: velfg {
    do j = 1, 300, 1
        do i = 1, 300, 1
                if (j==300/2 .and. i==300/2) then
                                uspd = (u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)+0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(&
&i)+dx1(i+1)))**2)**0.5
                                vspd = (v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)+0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(&
&j)+dy1(j+1)))**2)**0.5
                                write(6, *)('CHK_uspd_vspd=', uspd, vspd)
                end if
        end do
    end do
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","dzs","k"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","j","dzs","k"],[],["(i,1,300,1)"],[]) {
    nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
    diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
    cov1_i = nou1_*diu1_
    nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
    diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
    cov1_ip1 = nou1_ip1*diu1_ip1
    if (i==300) then
        cov1_ip1 = cov1_i
    end if
    nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
    diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
    cov2_j = nou2_*diu2_
    nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
    diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
    cov2_jp1 = nou2_jp1*diu2_jp1
    if (j==300) then
        nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
        cov2_jp1 = nou2_*diu2_
    end if
    nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
    diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
    cov3_k = nou3_*diu3_
    nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
    diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
    cov3_kp1 = nou3_kp1*diu3_kp1
    if (k==1) then
        nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
        diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
        cov3_k = nou3_*diu3_
    end if
    covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
    covy1 = (cov2_j+cov2_jp1)/2.
    covz1 = (cov3_k+cov3_kp1)/2.
    covc = covx1+covy1+covz1
    f(i,j,k) = (-covc)
!}
!}
!}    
!}
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dy1","dzs","k"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","dy1","dzs","k"],[],["(i,1,300,1)"],[]) {
    nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
    diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
    cov4_i = (nou4_-0)*diu4_
    nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
    diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
    cov4_ip1 = (nou4_ip1-0)*diu4_ip1
    if (i==300) then
        cov4_ip1 = cov4_i
    end if
    nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
    diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
    cov5_j = nou5_*diu5_
    nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
    diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
    cov5_jp1 = nou5_jp1*diu5_jp1
    if (j==300) then
        nou5_ = (v(i,1,k)+v(i,2,k))/2.
        diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
        cov5_jp1 = nou5_*diu5_
    end if
    nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
    diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
    cov6_k = nou6_*diu6_
    nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
    diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
    cov6_kp1 = nou6_kp1*diu6_kp1
    if (k==1) then
        nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
        diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
        cov6_k = nou6_*diu6_
    end if
    covx1 = (cov4_i+cov4_ip1)/2.
    covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
    covz1 = (cov6_k+cov6_kp1)/2.
    covc = covx1+covy1+covz1
    g(i,j,k) = (-covc)
!}
!}
!}    
!}
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","dzn"],[],["(i,1,300,1)"],[]) {
    nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
    diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
    cov7_i = (nou7_-0)*diu7_
    nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
    diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
    cov7_ip1 = (nou7_-0)*diu7_
    if (i==300) then
        cov7_ip1 = cov7_i
    end if
    nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
    diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
    cov8_j = nou8_*diu8_
    nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
    diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
    cov8_jp1 = nou8_jp1*diu8_jp1
    if (j==300) then
        nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
        cov8_jp1 = nou8_*diu8_
    end if
    nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
    diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
    cov9_k = nou9_*diu9_
    nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
    diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
    cov9_kp1 = nou9_kp1*diu9_kp1
    covx1 = (cov7_i+cov7_ip1)/2.
    covy1 = (cov8_j+cov8_jp1)/2.
    covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
    covc = covx1+covy1+covz1
    h(i,j,k) = (-covc)
!}
!}
!}    
!}
! OpenCLMap ( [],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(j,1,300,1)"],[]) {
    f(0,j,k) = f(1,j,k)
!}
!}
! OpenCLMap ( [],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(i,1,300,1)"],[]) {
    g(i,0,k) = g(i,300,k)
!}
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( [],[],["(i,1,300,1)"],[]) {
    h(i,j,0) = 0.0
    h(i,j,80) = 0.0
!}
!}
!}
! Original Subroutine Name: feedbf {
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,300,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["fx","fy","fz"],["g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","fx","fy","fz"],["g"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","fx","fy","fz"],["g"],["(i,1,300,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
!}
! Original Subroutine Name: les {
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","diu1","diu5","diu9"],["sm"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","diu1","diu5","diu9"],["sm"],["(i,1,300,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 0.14
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( [],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
! OpenCLMap ( ["k"],["sm"],["(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( [],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["sm"],["(i,0,301,1)"],[]) {
    sm(i,301,k) = sm(i,300,k)
    sm(i,0,k) = sm(i,1,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( [],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],["sm"],["(i,0,301,1)"],[]) {
    sm(i,j,0) = -sm(i,j,1)
    sm(i,j,81) = sm(i,j,80)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","sm","diu1","dxs","dy1","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","sm","diu1","dxs","dy1","dzn"],[],["(i,1,300,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","sm","diu1","dxs","dy1","dzn"],["f"],["(i,1,300,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1&
&(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    f(i,j,1) = (f(i,j,1)+vfu)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","sm","diu5","dx1","dys","dzn"],["g"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","sm","j","diu5","dx1","dys","dzn"],["g"],["(i,1,300,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k)&
&)/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["sm","j","diu5","dx1","dys","dzn"],[],["(i,1,300,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1)&
&)/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1&
&(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    g(i,j,1) = (g(i,j,1)+vfv)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["sm","k","diu9","dx1","dy1","dzn"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","sm","k","diu9","dx1","dy1","dzn"],[],["(i,1,300,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1)&
&)/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1)&
&)/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1)&
&)/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}
!}
!}    
!}
!}
! Original Subroutine Name: adam {
! OpenCLMap ( ["f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,300,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
!}
! Original Subroutine Name: press {
! OpenCLMap ( [],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(j,1,300,1)"],[]) {
    f(0,j,k) = f(1,j,k)
!}
!}
! OpenCLMap ( [],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k"],[],["(i,1,300,1)"],[]) {
    g(i,0,k) = g(i,300,k)
!}
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( [],[],["(i,1,300,1)"],[]) {
    h(i,j,0) = 0.0
    h(i,j,80) = 0.0
!}
!}
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","dy1","k","dzn","dt"],["rhs"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["dx1","j","dy1","k","dzn","dt"],["rhs"],["(i,1,300,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}    
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["rhsav"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","rhsav"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","rhsav"],[],["(i,1,300,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLStencil (
!	2 point stencil on 1D array dxs: [[0],[-1]]
!	2 point stencil on 1D array dys: [[0],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	14 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,1,0],[C=0,0,0,0],[C=0,0,0,1],[C=0,0,0,-1],[C=0,0,-1,0],[C=0,-1,0,0],[C=1,1,0,0],[C=1,0,1,0],[C=1,0,0,0],[C=1,0,0,1],[C=1,0,0,-1],[C=1,0,-1,0],[C=1,-1,0,0]]
!                ){
! OpenCLMap ( ["dzs","nrd"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],["nrd","l"]) {
! OpenCLMap ( ["dzs","k","nrd"],["p"],["(j,1,300,1)","(i,1,300,1)"],["nrd","l"]) {
! OpenCLMap ( ["dzs","k","nrd","j"],["p"],["(i,1,300,1)"],["nrd","l"]) {
                dz1 = dzs(k-1)
                dz2 = dzs(k)
                cn4s = 2./(dz1*(dz1+dz2))
                cn4l = 2./(dz2*(dz1+dz2))
                cn3s = 2./(dys(j-1)*(dys(j-1)+dys(j)))
                cn3l = 2./(dys(j)*(dys(j-1)+dys(j)))
                cn2s = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
                cn2l = 2./(dxs(i)*(dxs(i-1)+dxs(i)))
                cn1 = 1./(2./(dxs(i-1)*dxs(i))+2./(dys(j-1)*dys(j))+2./(dz1*dz2))
                if (nrd==0) then
                                reltmp = 1.0*(cn1*(cn2l*p(0,i+1,j,k)+cn2s*p(0,i-1,j,k)+cn3l*p(0,i,j+1,k)+cn3s*p(0,i,j-1,k)+cn4l*p(0,&
&i,j,k+1)+cn4s*p(0,i,j,k-1)-rhs(i,j,k))-p(0,i,j,k))
                                p(1,i,j,k) = p(0,i,j,k)+reltmp
                else
                                reltmp = 1.0*(cn1*(cn2l*p(1,i+1,j,k)+cn2s*p(1,i-1,j,k)+cn3l*p(1,i,j+1,k)+cn3s*p(1,i,j-1,k)+cn4l*p(1,&
&i,j,k+1)+cn4s*p(1,i,j,k-1)-rhs(i,j,k))-p(1,i,j,k))
                                p(0,i,j,k) = p(1,i,j,k)+reltmp
                end if
!}
!}
!}                
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!                ){
! OpenCLMap ( [],["p"],["(k,0,81,1)","(j,0,301,1)"],["nrd","l"]) {
! OpenCLMap ( ["k"],["p"],["(j,0,301,1)"],["nrd","l"]) {
                p(0,0,j,k) = p(0,1,j,k)
                p(0,301,j,k) = p(0,300,j,k)
!}
!}                
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!                ){
! OpenCLMap ( [],["p"],["(k,0,81,1)","(i,0,301,1)"],["nrd","l"]) {
! OpenCLMap ( ["k"],["p"],["(i,0,301,1)"],["nrd","l"]) {
                p(0,i,0,k) = p(0,i,300,k)
                p(0,i,301,k) = p(0,i,1,k)
!}
!}                
!}
        end do
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!        ){
! OpenCLMap ( [],["p"],["(j,0,301,1)","(i,0,301,1)"],["l"]) {
! OpenCLMap ( ["j"],["p"],["(i,0,301,1)"],["l"]) {
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
!}
!}        
!}
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["pav"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["k","pav"],["p"],["(j,1,300,1)","(i,1,300,1)"],[]) {
! OpenCLMap ( ["j","k","pav"],["p"],["(i,1,300,1)"],[]) {
    p(0,i,j,k) = p(0,i,j,k)-pav
!}
!}
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( [],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["p"],["(j,0,301,1)"],[]) {
    p(0,0,j,k) = p(0,1,j,k)
    p(0,301,j,k) = p(0,300,j,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( [],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["k"],["p"],["(i,0,301,1)"],[]) {
    p(0,i,0,k) = p(0,i,300,k)
    p(0,i,301,k) = p(0,i,1,k)
!}
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( [],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
! OpenCLMap ( ["j"],[],["(i,0,301,1)"],[]) {
    p(0,i,j,0) = p(0,i,j,1)
    p(0,i,j,81) = p(0,i,j,80)
!}
!}    
!}
!}
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Combined 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4) :: alpha
      integer :: ical
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nif
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data15
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(,,) :: cn1
      real(4), dimension() :: cn2l
      real(4), dimension() :: cn2s
      real(4), dimension() :: cn3l
      real(4), dimension() :: cn3s
      real(4), dimension() :: cn4l
      real(4), dimension() :: cn4s
      real(4), dimension() :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(,,) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(,,) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(,,) :: hold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(,,) :: uwfx
      real(4), dimension(,) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      integer :: clock_rate
      integer(4), dimension(0:9) :: timestamp
      integer(4) :: i
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, ical, nif, n0, n1, nmax&
&, dt, ro, vn, alpha, beta, data12, data13, data14, data15)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call init(u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(fold, gold, hold, time, n, u, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, d&
&iu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, vn, dzs, nou1, nou2, nou3, nou4, nou5, nou6, nou7, nou8, nou9, amask1, bmask1, cmask1, dm&
&ask1, alpha, beta, fx, fy, fz, zbm, ical, nif)
    do n = n0, nmax, 1
        time = float(n-n0)*dt
        call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
        call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
        call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
        call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys&
&, n)
        call adam(n, nmax, data21, fold, gold, hold, f, g, h)
        call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
    end do

end program main

AST not shown.
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, gold, hold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "n0", argument = VarName (fromList []) "n0"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	les->
	    call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys, n)
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	press->
	    call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	velfg->
	    call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	velnw->
	    call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,&
&diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fold,fx,fy,fz,g,gold,h,hold,n,n0,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: avetime = 2 
      real, parameter :: cs0 = 0.14 
      real, parameter :: dt_orig = 0.05 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      integer, parameter :: i_anime = 1 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      integer, parameter :: ip = 300 
      integer, parameter :: ipmax = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: jpmax = 300 
      integer, parameter :: km_sl = 80 
      integer, parameter :: kp = 80 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: u0 = 0 
      real(4) :: aaa
      real(4) :: bbb
      real(4) :: uout
      real(4) :: gaaa
      real(4) :: gbbb
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4) :: cn1
      real(4) :: cn2l
      real(4) :: cn2s
      real(4) :: cn3l
      real(4) :: cn3s
      real(4) :: cn4l
      real(4) :: cn4s
      real(4) :: dz1
      real(4) :: dz2
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: csx1
      character*70, intent(In) :: data21
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
      integer, intent(In) :: n
      integer, intent(In) :: n0
      integer, intent(In) :: nmax
      integer :: nn
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: pav
      real(4) :: area
      real(4) :: pco
      real(4) :: sor
      real(4) :: reltmp
      real(4), intent(In) :: ro
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfu
      real(4) :: vfv
      real(4) :: vfw
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
      real(4), dimension(0:82), intent(In) :: z2
! Original Subroutine Name: velnw {
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}    
!}
!}
! Original Subroutine Name: bondv1 {
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
    u(i,j,k) = u_val
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
    if (n==n0) then
! OpenCLMap ( ["k","j"],["u","v","w"],["(k,1,80,1)","(j,1,300,1)","(i,2,300,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
    end if
    aaa = 0.0
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    aaa = amax1(aaa,u(300,j,k))
!}
    gaaa = aaa
    bbb = 1e38
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    bbb = amin1(bbb,u(300,j,k))
!}
    gbbb = bbb
    uout = (gaaa+gbbb)/2.
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    w(i,0,k) = w(i,300,k)
    w(i,301,k) = w(i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,81) = u(i,j,80)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,81) = v(i,j,80)
!}    
!}
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
!}
! Original Subroutine Name: velfg {
    do j = 1, 300, 1
        do i = 1, 300, 1
                if (j==300/2 .and. i==300/2) then
                                uspd = (u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)+0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(&
&i)+dx1(i+1)))**2)**0.5
                                vspd = (v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)+0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(&
&j)+dy1(j+1)))**2)**0.5
                                write(6, *)('CHK_uspd_vspd=', uspd, vspd)
                end if
        end do
    end do
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
    diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
    cov1_i = nou1_*diu1_
    nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
    diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
    cov1_ip1 = nou1_ip1*diu1_ip1
    if (i==300) then
        cov1_ip1 = cov1_i
    end if
    nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
    diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
    cov2_j = nou2_*diu2_
    nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
    diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
    cov2_jp1 = nou2_jp1*diu2_jp1
    if (j==300) then
        nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
        cov2_jp1 = nou2_*diu2_
    end if
    nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
    diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
    cov3_k = nou3_*diu3_
    nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
    diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
    cov3_kp1 = nou3_kp1*diu3_kp1
    if (k==1) then
        nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
        diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
        cov3_k = nou3_*diu3_
    end if
    covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
    covy1 = (cov2_j+cov2_jp1)/2.
    covz1 = (cov3_k+cov3_kp1)/2.
    covc = covx1+covy1+covz1
    f(i,j,k) = (-covc)
!}    
!}
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
    diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
    cov4_i = (nou4_-0)*diu4_
    nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
    diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
    cov4_ip1 = (nou4_ip1-0)*diu4_ip1
    if (i==300) then
        cov4_ip1 = cov4_i
    end if
    nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
    diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
    cov5_j = nou5_*diu5_
    nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
    diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
    cov5_jp1 = nou5_jp1*diu5_jp1
    if (j==300) then
        nou5_ = (v(i,1,k)+v(i,2,k))/2.
        diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
        cov5_jp1 = nou5_*diu5_
    end if
    nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
    diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
    cov6_k = nou6_*diu6_
    nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
    diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
    cov6_kp1 = nou6_kp1*diu6_kp1
    if (k==1) then
        nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
        diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
        cov6_k = nou6_*diu6_
    end if
    covx1 = (cov4_i+cov4_ip1)/2.
    covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
    covz1 = (cov6_k+cov6_kp1)/2.
    covc = covx1+covy1+covz1
    g(i,j,k) = (-covc)
!}    
!}
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn","k","j"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
    diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
    cov7_i = (nou7_-0)*diu7_
    nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
    diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
    cov7_ip1 = (nou7_-0)*diu7_
    if (i==300) then
        cov7_ip1 = cov7_i
    end if
    nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
    diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
    cov8_j = nou8_*diu8_
    nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
    diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
    cov8_jp1 = nou8_jp1*diu8_jp1
    if (j==300) then
        nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
        cov8_jp1 = nou8_*diu8_
    end if
    nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
    diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
    cov9_k = nou9_*diu9_
    nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
    diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
    cov9_kp1 = nou9_kp1*diu9_kp1
    covx1 = (cov7_i+cov7_ip1)/2.
    covy1 = (cov8_j+cov8_jp1)/2.
    covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
    covc = covx1+covy1+covz1
    h(i,j,k) = (-covc)
!}    
!}
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    f(0,j,k) = f(1,j,k)
!}
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    g(i,0,k) = g(i,300,k)
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    h(i,j,0) = 0.0
    h(i,j,80) = 0.0
!}
!}
! Original Subroutine Name: feedbf {
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta","k","j","fx","fy","fz"],["fx","fy","fz","g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
! Original Subroutine Name: les {
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9","k","j"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 0.14
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    sm(i,301,k) = sm(i,300,k)
    sm(i,0,k) = sm(i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    sm(i,j,0) = -sm(i,j,1)
    sm(i,j,81) = sm(i,j,80)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","k","j"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","j"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1&
&(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    f(i,j,1) = (f(i,j,1)+vfu)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","k","j"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k)&
&)/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","j"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1)&
&)/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1)&
&)/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1&
&(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    g(i,j,1) = (g(i,j,1)+vfv)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1)&
&)/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1)&
&)/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1)&
&)/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1)&
&)/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}    
!}
!}
! Original Subroutine Name: adam {
! OpenCLMap ( ["f","g","h","fold","gold","hold","k","j"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
! Original Subroutine Name: press {
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    f(0,j,k) = f(1,j,k)
!}
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    g(i,0,k) = g(i,300,k)
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    h(i,j,0) = 0.0
    h(i,j,80) = 0.0
!}
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt","k","j"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}    
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
    rhsav = rhsav/area
! OpenCLMap ( ["rhsav","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
    do l = 1, 50, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLStencil (
!	2 point stencil on 1D array dxs: [[0],[-1]]
!	2 point stencil on 1D array dys: [[0],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	14 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,1,0],[C=0,0,0,0],[C=0,0,0,1],[C=0,0,0,-1],[C=0,0,-1,0],[C=0,-1,0,0],[C=1,1,0,0],[C=1,0,1,0],[C=1,0,0,0],[C=1,0,0,1],[C=1,0,0,-1],[C=1,0,-1,0],[C=1,-1,0,0]]
!                ){
! OpenCLMap ( ["dzs","nrd","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],["nrd","l"]) {
                dz1 = dzs(k-1)
                dz2 = dzs(k)
                cn4s = 2./(dz1*(dz1+dz2))
                cn4l = 2./(dz2*(dz1+dz2))
                cn3s = 2./(dys(j-1)*(dys(j-1)+dys(j)))
                cn3l = 2./(dys(j)*(dys(j-1)+dys(j)))
                cn2s = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
                cn2l = 2./(dxs(i)*(dxs(i-1)+dxs(i)))
                cn1 = 1./(2./(dxs(i-1)*dxs(i))+2./(dys(j-1)*dys(j))+2./(dz1*dz2))
                if (nrd==0) then
                                reltmp = 1.0*(cn1*(cn2l*p(0,i+1,j,k)+cn2s*p(0,i-1,j,k)+cn3l*p(0,i,j+1,k)+cn3s*p(0,i,j-1,k)+cn4l*p(0,&
&i,j,k+1)+cn4s*p(0,i,j,k-1)-rhs(i,j,k))-p(0,i,j,k))
                                p(1,i,j,k) = p(0,i,j,k)+reltmp
                else
                                reltmp = 1.0*(cn1*(cn2l*p(1,i+1,j,k)+cn2s*p(1,i-1,j,k)+cn3l*p(1,i,j+1,k)+cn3s*p(1,i,j-1,k)+cn4l*p(1,&
&i,j,k+1)+cn4s*p(1,i,j,k-1)-rhs(i,j,k))-p(1,i,j,k))
                                p(0,i,j,k) = p(1,i,j,k)+reltmp
                end if
!}                
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!                ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],["nrd","l"]) {
                p(0,0,j,k) = p(0,1,j,k)
                p(0,301,j,k) = p(0,300,j,k)
!}                
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!                ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],["nrd","l"]) {
                p(0,i,0,k) = p(0,i,300,k)
                p(0,i,301,k) = p(0,i,1,k)
!}                
!}
        end do
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!        ){
! OpenCLMap ( ["j"],["p"],["(j,0,301,1)","(i,0,301,1)"],["l"]) {
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
!}        
!}
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
    pav = pav/pco
! OpenCLMap ( ["pav","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    p(0,i,j,k) = p(0,i,j,k)-pav
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
    p(0,0,j,k) = p(0,1,j,k)
    p(0,301,j,k) = p(0,300,j,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    p(0,i,0,k) = p(0,i,300,k)
    p(0,i,301,k) = p(0,i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    p(0,i,j,0) = p(0,i,j,1)
    p(0,i,j,81) = p(0,i,j,80)
!}    
!}
!}
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 With Loop Guards 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      integer, parameter :: kp = 80 
      integer, parameter :: ip = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: ipmax = ip 
      integer, parameter :: jpmax = jp 
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      real, parameter :: cs0 = 0.14 
      integer, parameter :: i_anime = 1 
      integer, parameter :: avetime = 2 
      integer, parameter :: km_sl = 80 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      real, parameter :: dt_orig = 0.05 
      real(4) :: alpha
      integer :: ical
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nif
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data15
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(,,) :: cn1
      real(4), dimension() :: cn2l
      real(4), dimension() :: cn2s
      real(4), dimension() :: cn3l
      real(4), dimension() :: cn3s
      real(4), dimension() :: cn4l
      real(4), dimension() :: cn4s
      real(4), dimension() :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(,,) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(,,) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(,,) :: hold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:1,0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(,,) :: uwfx
      real(4), dimension(,) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      integer :: clock_rate
      integer(4), dimension(0:9) :: timestamp
      integer(4) :: i
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, ical, nif, n0, n1, nmax&
&, dt, ro, vn, alpha, beta, data12, data13, data14, data15)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call init(u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(fold, gold, hold, time, n, u, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, d&
&iu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, vn, dzs, nou1, nou2, nou3, nou4, nou5, nou6, nou7, nou8, nou9, amask1, bmask1, cmask1, dm&
&ask1, alpha, beta, fx, fy, fz, zbm, ical, nif)
    do n = n0, nmax, 1
        time = float(n-n0)*dt
        call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
        call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
        call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
        call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys&
&, n)
        call adam(n, nmax, data21, fold, gold, hold, f, g, h)
        call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
    end do

end program main

AST not shown.
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, gold, hold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(u, z2, dzn, v, w, n, n0, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "n0", argument = VarName (fromList []) "n0"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h, n)
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	les->
	    call les(delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, u, v, uspd, vspd, dxs, dys, n)
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	press->
	    call press(u, v, w, p, rhs, f, g, h, dx1, dy1, dzn, dxs, dys, dzs, dt, n, nmax)
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	velfg->
	    call velfg(dx1, dy1, dzn, f, g, dzs, h, u, v, w)
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	velnw->
	    call velnw(p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,&
&diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fold,fx,fy,fz,g,gold,h,hold,n,n0,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: avetime = 2 
      real, parameter :: cs0 = 0.14 
      real, parameter :: dt_orig = 0.05 
      real, parameter :: dxgrid = 4. 
      real, parameter :: dygrid = 4. 
      integer, parameter :: i_anime = 1 
      integer, parameter :: i_aveflow = 0 
      integer, parameter :: i_ifdata_out = 0 
      integer, parameter :: ip = 300 
      integer, parameter :: ipmax = 300 
      integer, parameter :: jp = 300 
      integer, parameter :: jpmax = 300 
      integer, parameter :: km_sl = 80 
      integer, parameter :: kp = 80 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: u0 = 0 
      real(4) :: aaa
      real(4) :: bbb
      real(4) :: uout
      real(4) :: gaaa
      real(4) :: gbbb
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4) :: cn1
      real(4) :: cn2l
      real(4) :: cn2s
      real(4) :: cn3l
      real(4) :: cn3s
      real(4) :: cn4l
      real(4) :: cn4s
      real(4) :: dz1
      real(4) :: dz2
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: csx1
      character*70, intent(In) :: data21
      character*300 :: datafile = '../GIS/Kyoto_1km2_4m_with_buffer.txt' 
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
      integer, intent(In) :: n
      integer, intent(In) :: n0
      integer, intent(In) :: nmax
      integer :: nn
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: pav
      real(4) :: area
      real(4) :: pco
      real(4) :: sor
      real(4) :: reltmp
      real(4), intent(In) :: ro
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfu
      real(4) :: vfv
      real(4) :: vfw
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
      real(4), dimension(0:82), intent(In) :: z2
! Original Subroutine Name: velnw {
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
    end if
!}    
!}
!}
! Original Subroutine Name: bondv1 {
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=78)) then
        u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
        u(i,j,k) = u_val
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=79) .and. (k<=80)) then
        u(i,j,k) = u(i,j,77)
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
    if (n==n0) then
! OpenCLMap ( ["k","j"],["u","v","w"],["(k,1,80,1)","(j,1,300,1)","(i,2,300,1)"],[]) {
        if ((i>=2) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
                u(i,j,k) = u(1,j,k)
                v(i,j,k) = v(1,j,k)
                w(i,j,k) = w(1,j,k)
        end if
!}
    end if
    aaa = 0.0
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        aaa = amax1(aaa,u(300,j,k))
    end if
!}
    gaaa = aaa
    bbb = 1e38
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        bbb = amin1(bbb,u(300,j,k))
    end if
!}
    gbbb = bbb
    uout = (gaaa+gbbb)/2.
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    if ((k>=0) .and. (k<=80)) then
        w(i,0,k) = w(i,300,k)
        w(i,301,k) = w(i,1,k)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        u(i,j,0) = -u(i,j,1)
        u(i,j,81) = u(i,j,80)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        v(i,j,0) = -v(i,j,1)
        v(i,j,81) = v(i,j,80)
    end if
!}    
!}
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
!}
! Original Subroutine Name: velfg {
    do j = 1, 300, 1
        do i = 1, 300, 1
                if (j==300/2 .and. i==300/2) then
                                uspd = (u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)+0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(&
&i)+dx1(i+1)))**2)**0.5
                                vspd = (v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)+0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(&
&j)+dy1(j+1)))**2)**0.5
                                write(6, *)('CHK_uspd_vspd=', uspd, vspd)
                end if
        end do
    end do
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
        diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        cov1_i = nou1_*diu1_
        nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
        diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
        cov1_ip1 = nou1_ip1*diu1_ip1
        if (i==300) then
                cov1_ip1 = cov1_i
        end if
        nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2_j = nou2_*diu2_
        nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov2_jp1 = nou2_jp1*diu2_jp1
        if (j==300) then
                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                cov2_jp1 = nou2_*diu2_
        end if
        nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
        diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3_k = nou3_*diu3_
        nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
        cov3_kp1 = nou3_kp1*diu3_kp1
        if (k==1) then
                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov3_k = nou3_*diu3_
        end if
        covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
        covy1 = (cov2_j+cov2_jp1)/2.
        covz1 = (cov3_k+cov3_kp1)/2.
        covc = covx1+covy1+covz1
        f(i,j,k) = (-covc)
    end if
!}    
!}
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4_i = (nou4_-0)*diu4_
        nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov4_ip1 = (nou4_ip1-0)*diu4_ip1
        if (i==300) then
                cov4_ip1 = cov4_i
        end if
        nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
        diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        cov5_j = nou5_*diu5_
        nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
        diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
        cov5_jp1 = nou5_jp1*diu5_jp1
        if (j==300) then
                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                cov5_jp1 = nou5_*diu5_
        end if
        nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
        diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6_k = nou6_*diu6_
        nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
        cov6_kp1 = nou6_kp1*diu6_kp1
        if (k==1) then
                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov6_k = nou6_*diu6_
        end if
        covx1 = (cov4_i+cov4_ip1)/2.
        covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
        covz1 = (cov6_k+cov6_kp1)/2.
        covc = covx1+covy1+covz1
        g(i,j,k) = (-covc)
    end if
!}    
!}
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn","k","j"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7_i = (nou7_-0)*diu7_
        nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov7_ip1 = (nou7_-0)*diu7_
        if (i==300) then
                cov7_ip1 = cov7_i
        end if
        nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8_j = nou8_*diu8_
        nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov8_jp1 = nou8_jp1*diu8_jp1
        if (j==300) then
                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                cov8_jp1 = nou8_*diu8_
        end if
        nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
        diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov9_k = nou9_*diu9_
        nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
        diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
        cov9_kp1 = nou9_kp1*diu9_kp1
        covx1 = (cov7_i+cov7_ip1)/2.
        covy1 = (cov8_j+cov8_jp1)/2.
        covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
        h(i,j,k) = (-covc)
    end if
!}    
!}
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
!}
! Original Subroutine Name: feedbf {
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta","k","j","fx","fy","fz"],["fx","fy","fz","g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
        vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
        wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
        f1x = alpha*usum(i,j,k)*dt
        f1y = alpha*vsum(i,j,k)*dt
        f1z = alpha*wsum(i,j,k)*dt
        f2x = beta*u(i,j,k)*bmask1(i,j,k)
        f2y = beta*v(i,j,k)*cmask1(i,j,k)
        f2z = beta*w(i,j,k)*dmask1(i,j,k)
        fx(i,j,k) = f1x+f2x
        fy(i,j,k) = f1y+f2y
        fz(i,j,k) = f1z+f2z
        f(i,j,k) = f(i,j,k)+fx(i,j,k)
        g(i,j,k) = g(i,j,k)+fy(i,j,k)
        h(i,j,k) = h(i,j,k)+fz(i,j,k)
    end if
!}
!}
! Original Subroutine Name: les {
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    if ((k>=1) .and. (k<=80)) then
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end if
!}
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9","k","j"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        dudxx1 = diu1(i,j,k)
        dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
        dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
        dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
        dvdyx1 = diu5(i,j,k)
        dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
        dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
        dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
        dwdzx1 = diu9(i,j,k)
        csx1 = 0.14
        sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)&
&**2)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,301,k) = sm(i,300,k)
        sm(i,0,k) = sm(i,1,k)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,j,0) = -sm(i,j,1)
        sm(i,j,81) = sm(i,j,80)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","k","j"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsx2 = sm(i+1,j,k)
        evsx1 = sm(i,j,k)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visux2 = (evsx2)*2.*diu1(i+1,j,k)
        visux1 = (evsx1)*2.*diu1(i,j,k)
        visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
        visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
        f(i,j,k) = (f(i,j,k)+vfu)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","j"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsx2 = sm(i+1,j,1)
        evsx1 = sm(i,j,1)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,&
&j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visux2 = (evsx2)*2.*diu1(i+1,j,1)
        visux1 = (evsx1)*2.*diu1(i,j,1)
        visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
        visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
        visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
        f(i,j,1) = (f(i,j,1)+vfu)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","k","j"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsy2 = sm(i,j+1,k)
        evsy1 = sm(i,j,k)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+&
&1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
        visvy2 = (evsy2)*2.*diu5(i,j+1,k)
        visvy1 = (evsy1)*2.*diu5(i,j,k)
        visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
        g(i,j,k) = (g(i,j,k)+vfv)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","j"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsy2 = sm(i,j+1,1)
        evsy1 = sm(i,j,1)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+&
&1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
        visvy2 = (evsy2)*2.*diu5(i,j+1,1)
        visvy1 = (evsy1)*2.*diu5(i,j,1)
        visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
        visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
        g(i,j,1) = (g(i,j,1)+vfv)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        evsz2 = sm(i,j,k+1)
        evsz1 = sm(i,j,k)
        evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,&
&k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
        evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,&
&k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
        evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,&
&k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
        viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
        viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
        viswz2 = (evsz2)*2.*diu9(i,j,k+1)
        viswz1 = (evsz1)*2.*diu9(i,j,k)
        vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
        h(i,j,k) = (h(i,j,k)+vfw)
    end if
!}    
!}
!}
! Original Subroutine Name: adam {
! OpenCLMap ( ["f","g","h","fold","gold","hold","k","j"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1) .and. (k>=1)) then
        fd = f(i,j,k)
        gd = g(i,j,k)
        hd = h(i,j,k)
        f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
        g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
        h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
        fold(i,j,k) = fd
        gold(i,j,k) = gd
        hold(i,j,k) = hd
    end if
!}
!}
! Original Subroutine Name: press {
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt","k","j"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
        rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
    end if
!}    
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
        area = area+dx1(i)*dy1(j)*dzn(k)
    end if
!}
    rhsav = rhsav/area
! OpenCLMap ( ["rhsav","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = rhs(i,j,k)-rhsav
    end if
!}
    do l = 1, 50, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLStencil (
!	2 point stencil on 1D array dxs: [[0],[-1]]
!	2 point stencil on 1D array dys: [[0],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	14 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,1,0],[C=0,0,0,0],[C=0,0,0,1],[C=0,0,0,-1],[C=0,0,-1,0],[C=0,-1,0,0],[C=1,1,0,0],[C=1,0,1,0],[C=1,0,0,0],[C=1,0,0,1],[C=1,0,0,-1],[C=1,0,-1,0],[C=1,-1,0,0]]
!                ){
! OpenCLMap ( ["dzs","nrd","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],["nrd","l"]) {
                if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
                                dz1 = dzs(k-1)
                                dz2 = dzs(k)
                                cn4s = 2./(dz1*(dz1+dz2))
                                cn4l = 2./(dz2*(dz1+dz2))
                                cn3s = 2./(dys(j-1)*(dys(j-1)+dys(j)))
                                cn3l = 2./(dys(j)*(dys(j-1)+dys(j)))
                                cn2s = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
                                cn2l = 2./(dxs(i)*(dxs(i-1)+dxs(i)))
                                cn1 = 1./(2./(dxs(i-1)*dxs(i))+2./(dys(j-1)*dys(j))+2./(dz1*dz2))
                                if (nrd==0) then
                                                                reltmp = 1.0*(cn1*(cn2l*p(0,i+1,j,k)+cn2s*p(0,i-1,j,k)+cn3l*p(0,i,j+&
&1,k)+cn3s*p(0,i,j-1,k)+cn4l*p(0,i,j,k+1)+cn4s*p(0,i,j,k-1)-rhs(i,j,k))-p(0,i,j,k))
                                                                p(1,i,j,k) = p(0,i,j,k)+reltmp
                                else
                                                                reltmp = 1.0*(cn1*(cn2l*p(1,i+1,j,k)+cn2s*p(1,i-1,j,k)+cn3l*p(1,i,j+&
&1,k)+cn3s*p(1,i,j-1,k)+cn4l*p(1,i,j,k+1)+cn4s*p(1,i,j,k-1)-rhs(i,j,k))-p(1,i,j,k))
                                                                p(0,i,j,k) = p(1,i,j,k)+reltmp
                                end if
                end if
!}                
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!                ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],["nrd","l"]) {
                if ((j<=301)) then
                                p(0,0,j,k) = p(0,1,j,k)
                                p(0,301,j,k) = p(0,300,j,k)
                end if
!}                
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!                ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],["nrd","l"]) {
                if ((i<=301)) then
                                p(0,i,0,k) = p(0,i,300,k)
                                p(0,i,301,k) = p(0,i,1,k)
                end if
!}                
!}
        end do
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!        ){
! OpenCLMap ( ["j"],["p"],["(j,0,301,1)","(i,0,301,1)"],["l"]) {
        if ((i<=301) .and. (j<=301)) then
                p(0,i,j,0) = p(0,i,j,1)
                p(0,i,j,81) = p(0,i,j,80)
        end if
!}        
!}
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
        pco = pco+dx1(i)*dy1(j)*dzn(k)
    end if
!}
    pav = pav/pco
! OpenCLMap ( ["pav","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        p(0,i,j,k) = p(0,i,j,k)-pav
    end if
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
    if ((j<=301)) then
        p(0,0,j,k) = p(0,1,j,k)
        p(0,301,j,k) = p(0,300,j,k)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i<=301)) then
        p(0,i,0,k) = p(0,i,300,k)
        p(0,i,301,k) = p(0,i,1,k)
    end if
!}    
!}
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((i<=301) .and. (j<=301)) then
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
    end if
!}    
!}
!}
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Kernels 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


--------------------
velnw
--------------------
subroutine velnw_0(dt,dxs,f,p,ro,u)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_0

======================


--------------------
velnw
--------------------
subroutine velnw_1(dt,dys,g,p,ro,v)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_1

======================


--------------------
velnw
--------------------
subroutine velnw_2(dt,dzs,h,p,ro,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_2

======================


--------------------
bondv1
--------------------
subroutine bondv1_0(dzn,u,v,w,z2)
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:82), intent(In) :: z2
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=78)) then
        u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
        u(i,j,k) = u_val
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_0

======================


--------------------
bondv1
--------------------
subroutine bondv1_1(u,v,w)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=79) .and. (k<=80)) then
        u(i,j,k) = u(i,j,77)
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_1

======================


--------------------
bondv1
--------------------
subroutine bondv1_2(u)
      real(4) :: aaa
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        aaa = amax1(aaa,u(300,j,k))
    end if
!}
end subroutine bondv1_2

======================


--------------------
bondv1
--------------------
subroutine bondv1_3(u)
      real(4) :: bbb
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        bbb = amin1(bbb,u(300,j,k))
    end if
!}
end subroutine bondv1_3

======================


--------------------
bondv1
--------------------
subroutine bondv1_4(dt,dxs,u)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_4

======================


--------------------
bondv1
--------------------
subroutine bondv1_5(dt,dxs,v)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_5

======================


--------------------
bondv1
--------------------
subroutine bondv1_6(dt,dxs,w)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_6

======================


--------------------
bondv1
--------------------
subroutine bondv1_7(u)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
end subroutine bondv1_7

======================


--------------------
bondv1
--------------------
subroutine bondv1_8(v)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
end subroutine bondv1_8

======================


--------------------
bondv1
--------------------
subroutine bondv1_9(w)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    if ((k>=0) .and. (k<=80)) then
        w(i,0,k) = w(i,300,k)
        w(i,301,k) = w(i,1,k)
    end if
!}    
!}
end subroutine bondv1_9

======================


--------------------
bondv1
--------------------
subroutine bondv1_10(u)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        u(i,j,0) = -u(i,j,1)
        u(i,j,81) = u(i,j,80)
    end if
!}    
!}
end subroutine bondv1_10

======================


--------------------
bondv1
--------------------
subroutine bondv1_11(v)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        v(i,j,0) = -v(i,j,1)
        v(i,j,81) = v(i,j,80)
    end if
!}    
!}
end subroutine bondv1_11

======================


--------------------
bondv1
--------------------
subroutine bondv1_12(w)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
end subroutine bondv1_12

======================


--------------------
velfg
--------------------
subroutine velfg_0(dx1,dy1,dzn,dzs,f,u,v,w)
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
        diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        cov1_i = nou1_*diu1_
        nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
        diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
        cov1_ip1 = nou1_ip1*diu1_ip1
        if (i==300) then
                cov1_ip1 = cov1_i
        end if
        nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2_j = nou2_*diu2_
        nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov2_jp1 = nou2_jp1*diu2_jp1
        if (j==300) then
                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                cov2_jp1 = nou2_*diu2_
        end if
        nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
        diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3_k = nou3_*diu3_
        nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
        cov3_kp1 = nou3_kp1*diu3_kp1
        if (k==1) then
                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov3_k = nou3_*diu3_
        end if
        covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
        covy1 = (cov2_j+cov2_jp1)/2.
        covz1 = (cov3_k+cov3_kp1)/2.
        covc = covx1+covy1+covz1
        f(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_0

======================


--------------------
velfg
--------------------
subroutine velfg_1(dx1,dy1,dzn,dzs,g,u,v,w)
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4_i = (nou4_-0)*diu4_
        nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov4_ip1 = (nou4_ip1-0)*diu4_ip1
        if (i==300) then
                cov4_ip1 = cov4_i
        end if
        nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
        diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        cov5_j = nou5_*diu5_
        nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
        diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
        cov5_jp1 = nou5_jp1*diu5_jp1
        if (j==300) then
                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                cov5_jp1 = nou5_*diu5_
        end if
        nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
        diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6_k = nou6_*diu6_
        nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
        cov6_kp1 = nou6_kp1*diu6_kp1
        if (k==1) then
                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov6_k = nou6_*diu6_
        end if
        covx1 = (cov4_i+cov4_ip1)/2.
        covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
        covz1 = (cov6_k+cov6_kp1)/2.
        covc = covx1+covy1+covz1
        g(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_1

======================


--------------------
velfg
--------------------
subroutine velfg_2(dx1,dy1,dzn,h,u,v,w)
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn","k","j"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7_i = (nou7_-0)*diu7_
        nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov7_ip1 = (nou7_-0)*diu7_
        if (i==300) then
                cov7_ip1 = cov7_i
        end if
        nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8_j = nou8_*diu8_
        nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov8_jp1 = nou8_jp1*diu8_jp1
        if (j==300) then
                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                cov8_jp1 = nou8_*diu8_
        end if
        nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
        diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov9_k = nou9_*diu9_
        nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
        diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
        cov9_kp1 = nou9_kp1*diu9_kp1
        covx1 = (cov7_i+cov7_ip1)/2.
        covy1 = (cov8_j+cov8_jp1)/2.
        covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
        h(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_2

======================


--------------------
velfg
--------------------
subroutine velfg_3(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine velfg_3

======================


--------------------
velfg
--------------------
subroutine velfg_4(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine velfg_4

======================


--------------------
velfg
--------------------
subroutine velfg_5(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine velfg_5

======================


--------------------
feedbf
--------------------
subroutine feedbf(alpha,beta,bmask1,cmask1,dmask1,dt,f,fx,fy,fz,g,h,u,usum,v,vsum,w,wsum)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta","k","j","fx","fy","fz"],["fx","fy","fz","g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
        vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
        wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
        f1x = alpha*usum(i,j,k)*dt
        f1y = alpha*vsum(i,j,k)*dt
        f1z = alpha*wsum(i,j,k)*dt
        f2x = beta*u(i,j,k)*bmask1(i,j,k)
        f2y = beta*v(i,j,k)*cmask1(i,j,k)
        f2z = beta*w(i,j,k)*dmask1(i,j,k)
        fx(i,j,k) = f1x+f2x
        fy(i,j,k) = f1y+f2y
        fz(i,j,k) = f1z+f2z
        f(i,j,k) = f(i,j,k)+fx(i,j,k)
        g(i,j,k) = g(i,j,k)+fy(i,j,k)
        h(i,j,k) = h(i,j,k)+fz(i,j,k)
    end if
!}
end subroutine feedbf

======================


--------------------
les
--------------------
subroutine les_0(delx1,dx1,dy1,dzn)
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: k
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    if ((k>=1) .and. (k<=80)) then
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end if
!}
end subroutine les_0

======================


--------------------
les
--------------------
subroutine les_1(delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm)
      real(4) :: csx1
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9","k","j"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        dudxx1 = diu1(i,j,k)
        dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
        dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
        dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
        dvdyx1 = diu5(i,j,k)
        dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
        dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
        dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
        dwdzx1 = diu9(i,j,k)
        csx1 = 0.14
        sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)&
&**2)
    end if
!}    
!}
end subroutine les_1

======================


--------------------
les
--------------------
subroutine les_2(sm)
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}    
!}
end subroutine les_2

======================


--------------------
les
--------------------
subroutine les_3(sm)
      integer :: i
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,301,k) = sm(i,300,k)
        sm(i,0,k) = sm(i,1,k)
    end if
!}    
!}
end subroutine les_3

======================


--------------------
les
--------------------
subroutine les_4(sm)
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,j,0) = -sm(i,j,1)
        sm(i,j,81) = sm(i,j,80)
    end if
!}    
!}
end subroutine les_4

======================


--------------------
les
--------------------
subroutine les_5(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","k","j"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsx2 = sm(i+1,j,k)
        evsx1 = sm(i,j,k)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visux2 = (evsx2)*2.*diu1(i+1,j,k)
        visux1 = (evsx1)*2.*diu1(i,j,k)
        visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
        visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
        f(i,j,k) = (f(i,j,k)+vfu)
    end if
!}    
!}
end subroutine les_5

======================


--------------------
les
--------------------
subroutine les_6(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm,u,uspd)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","j"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsx2 = sm(i+1,j,1)
        evsx1 = sm(i,j,1)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,&
&j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visux2 = (evsx2)*2.*diu1(i+1,j,1)
        visux1 = (evsx1)*2.*diu1(i,j,1)
        visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
        visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
        visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
        f(i,j,1) = (f(i,j,1)+vfu)
    end if
!}    
!}
end subroutine les_6

======================


--------------------
les
--------------------
subroutine les_7(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","k","j"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsy2 = sm(i,j+1,k)
        evsy1 = sm(i,j,k)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+&
&1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
        visvy2 = (evsy2)*2.*diu5(i,j+1,k)
        visvy1 = (evsy1)*2.*diu5(i,j,k)
        visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
        g(i,j,k) = (g(i,j,k)+vfv)
    end if
!}    
!}
end subroutine les_7

======================


--------------------
les
--------------------
subroutine les_8(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm,v,vspd)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","j"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsy2 = sm(i,j+1,1)
        evsy1 = sm(i,j,1)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+&
&1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
        visvy2 = (evsy2)*2.*diu5(i,j+1,1)
        visvy1 = (evsy1)*2.*diu5(i,j,1)
        visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
        visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
        g(i,j,1) = (g(i,j,1)+vfv)
    end if
!}    
!}
end subroutine les_8

======================


--------------------
les
--------------------
subroutine les_9(diu3,diu6,diu7,diu8,diu9,dx1,dy1,dzn,h,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfw
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        evsz2 = sm(i,j,k+1)
        evsz1 = sm(i,j,k)
        evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,&
&k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
        evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,&
&k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
        evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,&
&k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
        viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
        viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
        viswz2 = (evsz2)*2.*diu9(i,j,k+1)
        viswz1 = (evsz1)*2.*diu9(i,j,k)
        vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
        h(i,j,k) = (h(i,j,k)+vfw)
    end if
!}    
!}
end subroutine les_9

======================


--------------------
adam
--------------------
subroutine adam(f,fold,g,gold,h,hold)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
! OpenCLMap ( ["f","g","h","fold","gold","hold","k","j"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1) .and. (k>=1)) then
        fd = f(i,j,k)
        gd = g(i,j,k)
        hd = h(i,j,k)
        f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
        g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
        h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
        fold(i,j,k) = fd
        gold(i,j,k) = gd
        hold(i,j,k) = hd
    end if
!}
end subroutine adam

======================


--------------------
press
--------------------
subroutine press_0(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine press_0

======================


--------------------
press
--------------------
subroutine press_1(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine press_1

======================


--------------------
press
--------------------
subroutine press_2(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine press_2

======================


--------------------
press
--------------------
subroutine press_3(dt,dx1,dy1,dzn,f,g,h,rhs,u,v,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt","k","j"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
        rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
    end if
!}    
!}
end subroutine press_3

======================


--------------------
press
--------------------
subroutine press_4(dx1,dy1,dzn,rhs)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: area
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
        area = area+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_4

======================


--------------------
press
--------------------
subroutine press_5(rhs)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
! OpenCLMap ( ["rhsav","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = rhs(i,j,k)-rhsav
    end if
!}
end subroutine press_5

======================


--------------------
press
--------------------
subroutine press_6(dx1,dy1,dzn,p)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
      real(4) :: pco
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
        pco = pco+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_6

======================


--------------------
press
--------------------
subroutine press_7(p)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
! OpenCLMap ( ["pav","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        p(0,i,j,k) = p(0,i,j,k)-pav
    end if
!}
end subroutine press_7

======================


--------------------
press
--------------------
subroutine press_8(p)
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
    if ((j<=301)) then
        p(0,0,j,k) = p(0,1,j,k)
        p(0,301,j,k) = p(0,300,j,k)
    end if
!}    
!}
end subroutine press_8

======================


--------------------
press
--------------------
subroutine press_9(p)
      integer :: i
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i<=301)) then
        p(0,i,0,k) = p(0,i,300,k)
        p(0,i,301,k) = p(0,i,1,k)
    end if
!}    
!}
end subroutine press_9

======================


--------------------
press
--------------------
subroutine press_10(p)
      integer :: i
      integer :: j
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((i<=301) .and. (j<=301)) then
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
    end if
!}    
!}
end subroutine press_10

======================

no. of kernels: 45
 ! ==============================================
 ! Name: velnw_0 Order: 0
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_0(dt,dxs,f,p,ro,u)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_0
 ! ==============================================

 ! ==============================================
 ! Name: velnw_1 Order: 1
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_1(dt,dys,g,p,ro,v)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_1
 ! ==============================================

 ! ==============================================
 ! Name: velnw_2 Order: 2
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
 !	Stream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_2(dt,dzs,h,p,ro,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_2
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_0 Order: 3
 ! Input streams:
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: z2_k array name: z2 type: Float dimensions: [(0,82)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_0(dzn,u,v,w,z2)
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:82), intent(In) :: z2
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=78)) then
        u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
        u(i,j,k) = u_val
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_0
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_1 Order: 4
 ! Input streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_1(u,v,w)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=79) .and. (k<=80)) then
        u(i,j,k) = u(i,j,77)
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_1
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_2 Order: 5
 ! Input streams:
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 ! Output Reduction Variables:
! 	"aaa"
 ! --------------------------------------------
subroutine bondv1_2(u)
      real(4) :: aaa
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        aaa = amax1(aaa,u(300,j,k))
    end if
!}
end subroutine bondv1_2
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_3 Order: 6
 ! Input streams:
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 ! Output Reduction Variables:
! 	"bbb"
 ! --------------------------------------------
subroutine bondv1_3(u)
      real(4) :: bbb
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        bbb = amin1(bbb,u(300,j,k))
    end if
!}
end subroutine bondv1_3
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_4 Order: 7
 ! Input streams:
 !	StencilStream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_4(dt,dxs,u)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_4
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_5 Order: 8
 ! Input streams:
 !	StencilStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_5(dt,dxs,v)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_5
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_6 Order: 9
 ! Input streams:
 !	StencilStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_6(dt,dxs,w)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_6
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_7 Order: 10
 ! Input streams:
 !	StencilStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	Stream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_7(u)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
end subroutine bondv1_7
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_8 Order: 11
 ! Input streams:
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_8(v)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
end subroutine bondv1_8
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_9 Order: 12
 ! Input streams:
 !	StencilStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	Stream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_9(w)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    if ((k>=0) .and. (k<=80)) then
        w(i,0,k) = w(i,300,k)
        w(i,301,k) = w(i,1,k)
    end if
!}    
!}
end subroutine bondv1_9
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_10 Order: 13
 ! Input streams:
 !	StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_10(u)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        u(i,j,0) = -u(i,j,1)
        u(i,j,81) = u(i,j,80)
    end if
!}    
!}
end subroutine bondv1_10
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_11 Order: 14
 ! Input streams:
 !	StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_11(v)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        v(i,j,0) = -v(i,j,1)
        v(i,j,81) = v(i,j,80)
    end if
!}    
!}
end subroutine bondv1_11
 ! ==============================================

 ! ==============================================
 ! Name: bondv1_12 Order: 15
 ! Input streams:
 ! Output streams:
 !	Stream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_12(w)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
end subroutine bondv1_12
 ! ==============================================

 ! ==============================================
 ! Name: velfg_0 Order: 16
 ! Input streams:
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
 !	StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
 !	StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
 !	StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_0(dx1,dy1,dzn,dzs,f,u,v,w)
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
        diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        cov1_i = nou1_*diu1_
        nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
        diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
        cov1_ip1 = nou1_ip1*diu1_ip1
        if (i==300) then
                cov1_ip1 = cov1_i
        end if
        nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2_j = nou2_*diu2_
        nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov2_jp1 = nou2_jp1*diu2_jp1
        if (j==300) then
                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                cov2_jp1 = nou2_*diu2_
        end if
        nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
        diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3_k = nou3_*diu3_
        nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
        cov3_kp1 = nou3_kp1*diu3_kp1
        if (k==1) then
                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov3_k = nou3_*diu3_
        end if
        covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
        covy1 = (cov2_j+cov2_jp1)/2.
        covz1 = (cov3_k+cov3_kp1)/2.
        covc = covx1+covy1+covz1
        f(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_0
 ! ==============================================

 ! ==============================================
 ! Name: velfg_1 Order: 17
 ! Input streams:
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
 !	StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 !	StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_1(dx1,dy1,dzn,dzs,g,u,v,w)
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4_i = (nou4_-0)*diu4_
        nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov4_ip1 = (nou4_ip1-0)*diu4_ip1
        if (i==300) then
                cov4_ip1 = cov4_i
        end if
        nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
        diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        cov5_j = nou5_*diu5_
        nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
        diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
        cov5_jp1 = nou5_jp1*diu5_jp1
        if (j==300) then
                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                cov5_jp1 = nou5_*diu5_
        end if
        nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
        diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6_k = nou6_*diu6_
        nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
        cov6_kp1 = nou6_kp1*diu6_kp1
        if (k==1) then
                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov6_k = nou6_*diu6_
        end if
        covx1 = (cov4_i+cov4_ip1)/2.
        covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
        covz1 = (cov6_k+cov6_kp1)/2.
        covc = covx1+covy1+covz1
        g(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_1
 ! ==============================================

 ! ==============================================
 ! Name: velfg_2 Order: 18
 ! Input streams:
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
 !	StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 ! Output streams:
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_2(dx1,dy1,dzn,h,u,v,w)
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn","k","j"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7_i = (nou7_-0)*diu7_
        nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov7_ip1 = (nou7_-0)*diu7_
        if (i==300) then
                cov7_ip1 = cov7_i
        end if
        nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8_j = nou8_*diu8_
        nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov8_jp1 = nou8_jp1*diu8_jp1
        if (j==300) then
                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                cov8_jp1 = nou8_*diu8_
        end if
        nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
        diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov9_k = nou9_*diu9_
        nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
        diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
        cov9_kp1 = nou9_kp1*diu9_kp1
        covx1 = (cov7_i+cov7_ip1)/2.
        covy1 = (cov8_j+cov8_jp1)/2.
        covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
        h(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_2
 ! ==============================================

 ! ==============================================
 ! Name: velfg_3 Order: 19
 ! Input streams:
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_3(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine velfg_3
 ! ==============================================

 ! ==============================================
 ! Name: velfg_4 Order: 20
 ! Input streams:
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_4(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine velfg_4
 ! ==============================================

 ! ==============================================
 ! Name: velfg_5 Order: 21
 ! Input streams:
 ! Output streams:
 !	Stream: h_i_j array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_5(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine velfg_5
 ! ==============================================

 ! ==============================================
 ! Name: feedbf Order: 22
 ! Input streams:
 !	Stream: bmask1_i_j_k array name: bmask1 type: Float dimensions: [(-1,301),(0,301),(0,81)]
 !	Stream: cmask1_i_j_k array name: cmask1 type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: dmask1_i_j_k array name: dmask1 type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine feedbf(alpha,beta,bmask1,cmask1,dmask1,dt,f,fx,fy,fz,g,h,u,usum,v,vsum,w,wsum)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta","k","j","fx","fy","fz"],["fx","fy","fz","g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
        vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
        wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
        f1x = alpha*usum(i,j,k)*dt
        f1y = alpha*vsum(i,j,k)*dt
        f1z = alpha*wsum(i,j,k)*dt
        f2x = beta*u(i,j,k)*bmask1(i,j,k)
        f2y = beta*v(i,j,k)*cmask1(i,j,k)
        f2z = beta*w(i,j,k)*dmask1(i,j,k)
        fx(i,j,k) = f1x+f2x
        fy(i,j,k) = f1y+f2y
        fz(i,j,k) = f1z+f2z
        f(i,j,k) = f(i,j,k)+fx(i,j,k)
        g(i,j,k) = g(i,j,k)+fy(i,j,k)
        h(i,j,k) = h(i,j,k)+fz(i,j,k)
    end if
!}
end subroutine feedbf
 ! ==============================================

 ! ==============================================
 ! Name: les_0 Order: 23
 ! Input streams:
 !	Stream: dx1 array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1 array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	Stream: delx1_k array name: delx1 type: Float dimensions: [(1,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_0(delx1,dx1,dy1,dzn)
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: k
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    if ((k>=1) .and. (k<=80)) then
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end if
!}
end subroutine les_0
 ! ==============================================

 ! ==============================================
 ! Name: les_1 Order: 24
 ! Input streams:
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
 !	Stream: delx1_k array name: delx1 type: Float dimensions: [(1,80)]
 !	Stream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]
 !	Stream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]
 !	Stream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]
 ! Output streams:
 !	Stream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_1(delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm)
      real(4) :: csx1
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9","k","j"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        dudxx1 = diu1(i,j,k)
        dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
        dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
        dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
        dvdyx1 = diu5(i,j,k)
        dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
        dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
        dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
        dwdzx1 = diu9(i,j,k)
        csx1 = 0.14
        sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)&
&**2)
    end if
!}    
!}
end subroutine les_1
 ! ==============================================

 ! ==============================================
 ! Name: les_2 Order: 25
 ! Input streams:
 !	StencilStream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
 ! Output streams:
 !	Stream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_2(sm)
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}    
!}
end subroutine les_2
 ! ==============================================

 ! ==============================================
 ! Name: les_3 Order: 26
 ! Input streams:
 !	StencilStream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	Stream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_3(sm)
      integer :: i
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,301,k) = sm(i,300,k)
        sm(i,0,k) = sm(i,1,k)
    end if
!}    
!}
end subroutine les_3
 ! ==============================================

 ! ==============================================
 ! Name: les_4 Order: 27
 ! Input streams:
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	Stream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_4(sm)
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,j,0) = -sm(i,j,1)
        sm(i,j,81) = sm(i,j,80)
    end if
!}    
!}
end subroutine les_4
 ! ==============================================

 ! ==============================================
 ! Name: les_5 Order: 28
 ! Input streams:
 !	StencilStream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_5(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","k","j"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsx2 = sm(i+1,j,k)
        evsx1 = sm(i,j,k)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visux2 = (evsx2)*2.*diu1(i+1,j,k)
        visux1 = (evsx1)*2.*diu1(i,j,k)
        visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
        visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
        f(i,j,k) = (f(i,j,k)+vfu)
    end if
!}    
!}
end subroutine les_5
 ! ==============================================

 ! ==============================================
 ! Name: les_6 Order: 29
 ! Input streams:
 !	StencilStream: diu1_i_j array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
 !	StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
 !	StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
 !	Stream: diu3_i_j array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: diu7_i_j array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: uspd_i_j array name: uspd type: Float dimensions: [(0,301),(0,301)]
 ! Output streams:
 !	Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_6(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm,u,uspd)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","j"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsx2 = sm(i+1,j,1)
        evsx1 = sm(i,j,1)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,&
&j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visux2 = (evsx2)*2.*diu1(i+1,j,1)
        visux1 = (evsx1)*2.*diu1(i,j,1)
        visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
        visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
        visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
        f(i,j,1) = (f(i,j,1)+vfu)
    end if
!}    
!}
end subroutine les_6
 ! ==============================================

 ! ==============================================
 ! Name: les_7 Order: 30
 ! Input streams:
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
 !	StencilStream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_7(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","k","j"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsy2 = sm(i,j+1,k)
        evsy1 = sm(i,j,k)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+&
&1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
        visvy2 = (evsy2)*2.*diu5(i,j+1,k)
        visvy1 = (evsy1)*2.*diu5(i,j,k)
        visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
        g(i,j,k) = (g(i,j,k)+vfv)
    end if
!}    
!}
end subroutine les_7
 ! ==============================================

 ! ==============================================
 ! Name: les_8 Order: 31
 ! Input streams:
 !	StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
 !	StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
 !	StencilStream: diu5_i_j array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
 !	Stream: diu6_i_j array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: diu8_i_j array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vspd_i_j array name: vspd type: Float dimensions: [(0,301),(0,301)]
 ! Output streams:
 !	Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_8(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm,v,vspd)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","j"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsy2 = sm(i,j+1,1)
        evsy1 = sm(i,j,1)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+&
&1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
        visvy2 = (evsy2)*2.*diu5(i,j+1,1)
        visvy1 = (evsy1)*2.*diu5(i,j,1)
        visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
        visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
        g(i,j,1) = (g(i,j,1)+vfv)
    end if
!}    
!}
end subroutine les_8
 ! ==============================================

 ! ==============================================
 ! Name: les_9 Order: 32
 ! Input streams:
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
 !	StencilStream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_9(diu3,diu6,diu7,diu8,diu9,dx1,dy1,dzn,h,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfw
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        evsz2 = sm(i,j,k+1)
        evsz1 = sm(i,j,k)
        evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,&
&k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
        evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,&
&k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
        evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,&
&k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
        viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
        viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
        viswz2 = (evsz2)*2.*diu9(i,j,k+1)
        viswz1 = (evsz1)*2.*diu9(i,j,k)
        vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
        h(i,j,k) = (h(i,j,k)+vfw)
    end if
!}    
!}
end subroutine les_9
 ! ==============================================

 ! ==============================================
 ! Name: adam Order: 33
 ! Input streams:
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
 ! Output streams:
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine adam(f,fold,g,gold,h,hold)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
! OpenCLMap ( ["f","g","h","fold","gold","hold","k","j"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1) .and. (k>=1)) then
        fd = f(i,j,k)
        gd = g(i,j,k)
        hd = h(i,j,k)
        f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
        g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
        h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
        fold(i,j,k) = fd
        gold(i,j,k) = gd
        hold(i,j,k) = hd
    end if
!}
end subroutine adam
 ! ==============================================

 ! ==============================================
 ! Name: press_0 Order: 34
 ! Input streams:
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_0(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine press_0
 ! ==============================================

 ! ==============================================
 ! Name: press_1 Order: 35
 ! Input streams:
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_1(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine press_1
 ! ==============================================

 ! ==============================================
 ! Name: press_2 Order: 36
 ! Input streams:
 ! Output streams:
 !	Stream: h_i_j array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_2(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine press_2
 ! ==============================================

 ! ==============================================
 ! Name: press_3 Order: 37
 ! Input streams:
 !	StencilStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
 !	StencilStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
 !	StencilStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
 !	StencilStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
 !	StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_3(dt,dx1,dy1,dzn,f,g,h,rhs,u,v,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt","k","j"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
        rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
    end if
!}    
!}
end subroutine press_3
 ! ==============================================

 ! ==============================================
 ! Name: press_4 Order: 38
 ! Input streams:
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 ! Output Reduction Variables:
! 	"rhsav"
! 	"area"
 ! --------------------------------------------
subroutine press_4(dx1,dy1,dzn,rhs)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: area
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
        area = area+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_4
 ! ==============================================

 ! ==============================================
 ! Name: press_5 Order: 39
 ! Input streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_5(rhs)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
! OpenCLMap ( ["rhsav","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = rhs(i,j,k)-rhsav
    end if
!}
end subroutine press_5
 ! ==============================================

 ! ==============================================
 ! Name: press_6 Order: 40
 ! Input streams:
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 ! Output Reduction Variables:
! 	"pav"
! 	"pco"
 ! --------------------------------------------
subroutine press_6(dx1,dy1,dzn,p)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
      real(4) :: pco
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
        pco = pco+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_6
 ! ==============================================

 ! ==============================================
 ! Name: press_7 Order: 41
 ! Input streams:
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_7(p)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
! OpenCLMap ( ["pav","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        p(0,i,j,k) = p(0,i,j,k)-pav
    end if
!}
end subroutine press_7
 ! ==============================================

 ! ==============================================
 ! Name: press_8 Order: 42
 ! Input streams:
 !	StencilStream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
 ! Output streams:
 !	Stream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_8(p)
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
    if ((j<=301)) then
        p(0,0,j,k) = p(0,1,j,k)
        p(0,301,j,k) = p(0,300,j,k)
    end if
!}    
!}
end subroutine press_8
 ! ==============================================

 ! ==============================================
 ! Name: press_9 Order: 43
 ! Input streams:
 !	StencilStream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
 ! Output streams:
 !	Stream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_9(p)
      integer :: i
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i<=301)) then
        p(0,i,0,k) = p(0,i,300,k)
        p(0,i,301,k) = p(0,i,1,k)
    end if
!}    
!}
end subroutine press_9
 ! ==============================================

 ! ==============================================
 ! Name: press_10 Order: 44
 ! Input streams:
 !	StencilStream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
 ! Output streams:
 !	Stream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_10(p)
      integer :: i
      integer :: j
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((i<=301) .and. (j<=301)) then
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
    end if
!}    
!}
end subroutine press_10
 ! ==============================================


p_i_j is largest stream size = 15056676
BEFORE
velnw_1 requires:
StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
velnw_1 requires:
Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
velnw_1 requires:
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
velnw_1 requires:
Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
velnw_2 requires:
StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
velnw_2 requires:
Stream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]
velnw_2 requires:
Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
velnw_2 requires:
Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
bondv1_0 requires:
Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
bondv1_0 requires:
Stream: z2_k array name: z2 type: Float dimensions: [(0,82)]
bondv1_1 requires:
Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
bondv1_2 requires:
Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
bondv1_3 requires:
Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
bondv1_4 requires:
StencilStream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
bondv1_4 requires:
Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
bondv1_5 requires:
StencilStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
bondv1_5 requires:
Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
bondv1_6 requires:
StencilStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
bondv1_6 requires:
Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
bondv1_7 requires:
StencilStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
bondv1_8 requires:
StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
bondv1_9 requires:
StencilStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
bondv1_10 requires:
StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
bondv1_11 requires:
StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
velfg_0 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
velfg_0 requires:
StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
velfg_0 requires:
StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
velfg_0 requires:
StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
velfg_0 requires:
StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
velfg_0 requires:
Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
velfg_1 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
velfg_1 requires:
StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
velfg_1 requires:
StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
velfg_1 requires:
StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
velfg_1 requires:
StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
velfg_1 requires:
StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
velfg_1 requires:
Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
velfg_2 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
velfg_2 requires:
StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
velfg_2 requires:
StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
velfg_2 requires:
StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
velfg_2 requires:
StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
velfg_2 requires:
StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
velfg_3 requires:
Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
velfg_4 requires:
Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: bmask1_i_j_k array name: bmask1 type: Float dimensions: [(-1,301),(0,301),(0,81)]
feedbf requires:
Stream: cmask1_i_j_k array name: cmask1 type: Float dimensions: [(0,301),(-1,301),(0,81)]
feedbf requires:
Stream: dmask1_i_j_k array name: dmask1 type: Float dimensions: [(0,301),(0,301),(0,81)]
feedbf requires:
Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
feedbf requires:
Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
feedbf requires:
Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
feedbf requires:
Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
feedbf requires:
Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
les_0 requires:
Stream: dx1 array name: dx1 type: Float dimensions: [(-1,301)]
les_0 requires:
Stream: dy1 array name: dy1 type: Float dimensions: [(0,301)]
les_0 requires:
Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
les_1 requires:
StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
les_1 requires:
StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
les_1 requires:
StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
les_1 requires:
StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
les_1 requires:
StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
les_1 requires:
StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
les_1 requires:
Stream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]
les_1 requires:
Stream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]
les_1 requires:
Stream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]
les_2 requires:
StencilStream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
les_3 requires:
StencilStream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
les_4 requires:
StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
les_5 requires:
StencilStream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
les_5 requires:
StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
les_5 requires:
StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
les_5 requires:
StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
les_5 requires:
StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
les_5 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
les_5 requires:
StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
les_5 requires:
StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
les_5 requires:
StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
les_5 requires:
Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
les_5 requires:
Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
les_6 requires:
StencilStream: diu1_i_j array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
les_6 requires:
StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
les_6 requires:
StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
les_6 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
les_6 requires:
StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
les_6 requires:
StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
les_6 requires:
StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
les_6 requires:
Stream: diu3_i_j array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]
les_6 requires:
Stream: diu7_i_j array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]
les_6 requires:
Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
les_6 requires:
Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
les_6 requires:
Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
les_6 requires:
Stream: uspd_i_j array name: uspd type: Float dimensions: [(0,301),(0,301)]
les_7 requires:
StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
les_7 requires:
StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
les_7 requires:
StencilStream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
les_7 requires:
StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
les_7 requires:
StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
les_7 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
les_7 requires:
StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
les_7 requires:
StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
les_7 requires:
StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
les_7 requires:
Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
les_7 requires:
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
les_8 requires:
StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
les_8 requires:
StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
les_8 requires:
StencilStream: diu5_i_j array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
les_8 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
les_8 requires:
StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
les_8 requires:
StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
les_8 requires:
StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
les_8 requires:
Stream: diu6_i_j array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]
les_8 requires:
Stream: diu8_i_j array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]
les_8 requires:
Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
les_8 requires:
Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
les_8 requires:
Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
les_8 requires:
Stream: vspd_i_j array name: vspd type: Float dimensions: [(0,301),(0,301)]
les_9 requires:
StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
les_9 requires:
StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
les_9 requires:
StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
les_9 requires:
StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
les_9 requires:
StencilStream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
les_9 requires:
StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
les_9 requires:
StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
les_9 requires:
StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
les_9 requires:
StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
les_9 requires:
Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
adam requires:
Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
adam requires:
Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
adam requires:
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
adam requires:
Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
adam requires:
Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
press_0 requires:
Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
press_1 requires:
Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
press_3 requires:
StencilStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
press_3 requires:
StencilStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
press_3 requires:
StencilStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
press_3 requires:
StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
press_3 requires:
StencilStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
press_3 requires:
StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
press_3 requires:
Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
press_3 requires:
Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
press_3 requires:
Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
press_3 requires:
Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
press_4 requires:
Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
press_4 requires:
Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
press_4 requires:
Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
press_5 requires:
Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
press_6 requires:
Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
press_6 requires:
Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
press_6 requires:
Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
press_6 requires:
Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
press_7 requires:
Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
press_8 requires:
StencilStream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
press_9 requires:
StencilStream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
press_10 requires:
StencilStream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]


--------------------------------------------------------------------------------

Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_0
Consumed at: bondv1_1
Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_1
Consumed at: bondv1_2
Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_1
Consumed at: bondv1_3
TransitStream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_1
Consumed at: bondv1_4
TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_1
Consumed at: bondv1_5
TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
Produced at: bondv1_1
Consumed at: bondv1_6
TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_4
Consumed at: bondv1_7
TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_5
Consumed at: bondv1_8
TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
Produced at: bondv1_6
Consumed at: bondv1_9
TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_7
Consumed at: bondv1_10
TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_8
Consumed at: bondv1_11
TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_10
Consumed at: velfg_0
TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_11
Consumed at: velfg_0
TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_10
Consumed at: velfg_1
TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_11
Consumed at: velfg_1
TransitStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
Produced at: bondv1_12
Consumed at: velfg_1
TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_10
Consumed at: velfg_2
TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_11
Consumed at: velfg_2
TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
Produced at: bondv1_12
Consumed at: velfg_2
Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: velfg_0
Consumed at: velfg_3
Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: velfg_1
Consumed at: velfg_4
Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: velfg_3
Consumed at: feedbf
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: velfg_4
Consumed at: feedbf
Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: velfg_5
Consumed at: feedbf
Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_10
Consumed at: feedbf
Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_11
Consumed at: feedbf
Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
Produced at: bondv1_12
Consumed at: feedbf
TransitStream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_1
Consumed at: les_2
TransitStream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_2
Consumed at: les_3
TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_3
Consumed at: les_4
TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_4
Consumed at: les_5
Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: feedbf
Consumed at: les_5
TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_4
Consumed at: les_6
Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: les_5
Consumed at: les_6
Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_10
Consumed at: les_6
TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_4
Consumed at: les_7
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: feedbf
Consumed at: les_7
TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_4
Consumed at: les_8
Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: les_7
Consumed at: les_8
Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_11
Consumed at: les_8
TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
Produced at: les_4
Consumed at: les_9
Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: feedbf
Consumed at: les_9
Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: les_6
Consumed at: adam
Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: les_8
Consumed at: adam
Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: adam
Consumed at: press_0
Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: adam
Consumed at: press_1
TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: press_0
Consumed at: press_3
TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: press_1
Consumed at: press_3
TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
Produced at: press_2
Consumed at: press_3
TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_10
Consumed at: press_3
TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
Produced at: bondv1_11
Consumed at: press_3
TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
Produced at: bondv1_12
Consumed at: press_3
Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
Produced at: press_3
Consumed at: press_5
TransitStream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
Produced at: press_7
Consumed at: press_8
TransitStream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
Produced at: press_8
Consumed at: press_9
TransitStream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
Produced at: press_9
Consumed at: press_10

Transit Streams Added
 ! ==============================================
 ! Name: velnw_0 Order: 0
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_0(dt,dxs,f,p,ro,u)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_0
 ! ==============================================


 ! ==============================================
 ! Name: velnw_1 Order: 1
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_1(dt,dys,g,p,ro,v)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_1
 ! ==============================================


 ! ==============================================
 ! Name: velnw_2 Order: 2
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
 !	Stream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_2(dt,dzs,h,p,ro,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_2
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_0 Order: 3
 ! Input streams:
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: z2_k array name: z2 type: Float dimensions: [(0,82)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_0(dzn,u,v,w,z2)
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:82), intent(In) :: z2
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=78)) then
        u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
        u(i,j,k) = u_val
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_0
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_1 Order: 4
 ! Input streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_1(u,v,w)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=79) .and. (k<=80)) then
        u(i,j,k) = u(i,j,77)
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_1
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_2 Order: 5
 ! Input streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
! 	"aaa"
 ! --------------------------------------------
subroutine bondv1_2(u)
      real(4) :: aaa
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        aaa = amax1(aaa,u(300,j,k))
    end if
!}
end subroutine bondv1_2
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_3 Order: 6
 ! Input streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
! 	"bbb"
 ! --------------------------------------------
subroutine bondv1_3(u)
      real(4) :: bbb
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        bbb = amin1(bbb,u(300,j,k))
    end if
!}
end subroutine bondv1_3
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_4 Order: 7
 ! Input streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_4(dt,dxs,u)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_4
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_5 Order: 8
 ! Input streams:
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	StencilStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_5(dt,dxs,v)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_5
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_6 Order: 9
 ! Input streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_6(dt,dxs,w)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_6
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_7 Order: 10
 ! Input streams:
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_7(u)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
end subroutine bondv1_7
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_8 Order: 11
 ! Input streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_8(v)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
end subroutine bondv1_8
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_9 Order: 12
 ! Input streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_9(w)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    if ((k>=0) .and. (k<=80)) then
        w(i,0,k) = w(i,300,k)
        w(i,301,k) = w(i,1,k)
    end if
!}    
!}
end subroutine bondv1_9
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_10 Order: 13
 ! Input streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_10(u)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        u(i,j,0) = -u(i,j,1)
        u(i,j,81) = u(i,j,80)
    end if
!}    
!}
end subroutine bondv1_10
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_11 Order: 14
 ! Input streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_11(v)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((j>=0)) then
        v(i,j,0) = -v(i,j,1)
        v(i,j,81) = v(i,j,80)
    end if
!}    
!}
end subroutine bondv1_11
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_12 Order: 15
 ! Input streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_12(w)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
end subroutine bondv1_12
 ! ==============================================


 ! ==============================================
 ! Name: velfg_0 Order: 16
 ! Input streams:
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
 !	StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
 !	StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
 !	StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	TransitStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_0(dx1,dy1,dzn,dzs,f,u,v,w)
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
        diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        cov1_i = nou1_*diu1_
        nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
        diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
        cov1_ip1 = nou1_ip1*diu1_ip1
        if (i==300) then
                cov1_ip1 = cov1_i
        end if
        nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2_j = nou2_*diu2_
        nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov2_jp1 = nou2_jp1*diu2_jp1
        if (j==300) then
                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                cov2_jp1 = nou2_*diu2_
        end if
        nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
        diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3_k = nou3_*diu3_
        nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
        cov3_kp1 = nou3_kp1*diu3_kp1
        if (k==1) then
                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov3_k = nou3_*diu3_
        end if
        covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
        covy1 = (cov2_j+cov2_jp1)/2.
        covz1 = (cov3_k+cov3_kp1)/2.
        covc = covx1+covy1+covz1
        f(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_0
 ! ==============================================


 ! ==============================================
 ! Name: velfg_1 Order: 17
 ! Input streams:
 !	TransitStream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
 !	StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 !	StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_1(dx1,dy1,dzn,dzs,g,u,v,w)
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4_i = (nou4_-0)*diu4_
        nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov4_ip1 = (nou4_ip1-0)*diu4_ip1
        if (i==300) then
                cov4_ip1 = cov4_i
        end if
        nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
        diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        cov5_j = nou5_*diu5_
        nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
        diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
        cov5_jp1 = nou5_jp1*diu5_jp1
        if (j==300) then
                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                cov5_jp1 = nou5_*diu5_
        end if
        nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
        diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6_k = nou6_*diu6_
        nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
        cov6_kp1 = nou6_kp1*diu6_kp1
        if (k==1) then
                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov6_k = nou6_*diu6_
        end if
        covx1 = (cov4_i+cov4_ip1)/2.
        covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
        covz1 = (cov6_k+cov6_kp1)/2.
        covc = covx1+covy1+covz1
        g(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_1
 ! ==============================================


 ! ==============================================
 ! Name: velfg_2 Order: 18
 ! Input streams:
 !	TransitStream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
 !	StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_2(dx1,dy1,dzn,h,u,v,w)
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn","k","j"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7_i = (nou7_-0)*diu7_
        nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov7_ip1 = (nou7_-0)*diu7_
        if (i==300) then
                cov7_ip1 = cov7_i
        end if
        nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8_j = nou8_*diu8_
        nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov8_jp1 = nou8_jp1*diu8_jp1
        if (j==300) then
                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                cov8_jp1 = nou8_*diu8_
        end if
        nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
        diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov9_k = nou9_*diu9_
        nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
        diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
        cov9_kp1 = nou9_kp1*diu9_kp1
        covx1 = (cov7_i+cov7_ip1)/2.
        covy1 = (cov8_j+cov8_jp1)/2.
        covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
        h(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_2
 ! ==============================================


 ! ==============================================
 ! Name: velfg_3 Order: 19
 ! Input streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_3(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine velfg_3
 ! ==============================================


 ! ==============================================
 ! Name: velfg_4 Order: 20
 ! Input streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_4(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine velfg_4
 ! ==============================================


 ! ==============================================
 ! Name: velfg_5 Order: 21
 ! Input streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_5(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine velfg_5
 ! ==============================================


 ! ==============================================
 ! Name: feedbf Order: 22
 ! Input streams:
 !	Stream: bmask1_i_j_k array name: bmask1 type: Float dimensions: [(-1,301),(0,301),(0,81)]
 !	Stream: cmask1_i_j_k array name: cmask1 type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: dmask1_i_j_k array name: dmask1 type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: bmask1_i_j_k array name: bmask1 type: Float dimensions: [(-1,301),(0,301),(0,81)]
 !	Stream: cmask1_i_j_k array name: cmask1 type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: dmask1_i_j_k array name: dmask1 type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine feedbf(alpha,beta,bmask1,cmask1,dmask1,dt,f,fx,fy,fz,g,h,u,usum,v,vsum,w,wsum)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta","k","j","fx","fy","fz"],["fx","fy","fz","g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
        vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
        wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
        f1x = alpha*usum(i,j,k)*dt
        f1y = alpha*vsum(i,j,k)*dt
        f1z = alpha*wsum(i,j,k)*dt
        f2x = beta*u(i,j,k)*bmask1(i,j,k)
        f2y = beta*v(i,j,k)*cmask1(i,j,k)
        f2z = beta*w(i,j,k)*dmask1(i,j,k)
        fx(i,j,k) = f1x+f2x
        fy(i,j,k) = f1y+f2y
        fz(i,j,k) = f1z+f2z
        f(i,j,k) = f(i,j,k)+fx(i,j,k)
        g(i,j,k) = g(i,j,k)+fy(i,j,k)
        h(i,j,k) = h(i,j,k)+fz(i,j,k)
    end if
!}
end subroutine feedbf
 ! ==============================================


 ! ==============================================
 ! Name: les_0 Order: 23
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: dx1 array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1 array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: dx1 array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1 array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_0(delx1,dx1,dy1,dzn)
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: k
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    if ((k>=1) .and. (k<=80)) then
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end if
!}
end subroutine les_0
 ! ==============================================


 ! ==============================================
 ! Name: les_1 Order: 24
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
 !	Stream: delx1_k array name: delx1 type: Float dimensions: [(1,80)]
 !	Stream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]
 !	Stream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]
 !	Stream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_1(delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm)
      real(4) :: csx1
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9","k","j"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        dudxx1 = diu1(i,j,k)
        dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
        dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
        dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
        dvdyx1 = diu5(i,j,k)
        dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
        dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
        dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
        dwdzx1 = diu9(i,j,k)
        csx1 = 0.14
        sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)&
&**2)
    end if
!}    
!}
end subroutine les_1
 ! ==============================================


 ! ==============================================
 ! Name: les_2 Order: 25
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_2(sm)
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}    
!}
end subroutine les_2
 ! ==============================================


 ! ==============================================
 ! Name: les_3 Order: 26
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_3(sm)
      integer :: i
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,301,k) = sm(i,300,k)
        sm(i,0,k) = sm(i,1,k)
    end if
!}    
!}
end subroutine les_3
 ! ==============================================


 ! ==============================================
 ! Name: les_4 Order: 27
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_4(sm)
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    if ((i>=0)) then
        sm(i,j,0) = -sm(i,j,1)
        sm(i,j,81) = sm(i,j,80)
    end if
!}    
!}
end subroutine les_4
 ! ==============================================


 ! ==============================================
 ! Name: les_5 Order: 28
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_5(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","k","j"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsx2 = sm(i+1,j,k)
        evsx1 = sm(i,j,k)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visux2 = (evsx2)*2.*diu1(i+1,j,k)
        visux1 = (evsx1)*2.*diu1(i,j,k)
        visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
        visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
        f(i,j,k) = (f(i,j,k)+vfu)
    end if
!}    
!}
end subroutine les_5
 ! ==============================================


 ! ==============================================
 ! Name: les_6 Order: 29
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu1_i_j array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
 !	StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
 !	StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
 !	Stream: diu3_i_j array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: diu7_i_j array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: uspd_i_j array name: uspd type: Float dimensions: [(0,301),(0,301)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_6(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm,u,uspd)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","j"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsx2 = sm(i+1,j,1)
        evsx1 = sm(i,j,1)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,&
&j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visux2 = (evsx2)*2.*diu1(i+1,j,1)
        visux1 = (evsx1)*2.*diu1(i,j,1)
        visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
        visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
        visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
        f(i,j,1) = (f(i,j,1)+vfu)
    end if
!}    
!}
end subroutine les_6
 ! ==============================================


 ! ==============================================
 ! Name: les_7 Order: 30
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
 !	StencilStream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_7(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","k","j"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsy2 = sm(i,j+1,k)
        evsy1 = sm(i,j,k)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+&
&1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
        visvy2 = (evsy2)*2.*diu5(i,j+1,k)
        visvy1 = (evsy1)*2.*diu5(i,j,k)
        visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
        g(i,j,k) = (g(i,j,k)+vfv)
    end if
!}    
!}
end subroutine les_7
 ! ==============================================


 ! ==============================================
 ! Name: les_8 Order: 31
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
 !	StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
 !	StencilStream: diu5_i_j array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
 !	Stream: diu6_i_j array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: diu8_i_j array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vspd_i_j array name: vspd type: Float dimensions: [(0,301),(0,301)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_8(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm,v,vspd)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","j"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsy2 = sm(i,j+1,1)
        evsy1 = sm(i,j,1)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+&
&1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
        visvy2 = (evsy2)*2.*diu5(i,j+1,1)
        visvy1 = (evsy1)*2.*diu5(i,j,1)
        visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
        visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
        g(i,j,1) = (g(i,j,1)+vfv)
    end if
!}    
!}
end subroutine les_8
 ! ==============================================


 ! ==============================================
 ! Name: les_9 Order: 32
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
 !	StencilStream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_9(diu3,diu6,diu7,diu8,diu9,dx1,dy1,dzn,h,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfw
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        evsz2 = sm(i,j,k+1)
        evsz1 = sm(i,j,k)
        evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,&
&k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
        evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,&
&k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
        evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,&
&k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
        viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
        viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
        viswz2 = (evsz2)*2.*diu9(i,j,k+1)
        viswz1 = (evsz1)*2.*diu9(i,j,k)
        vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
        h(i,j,k) = (h(i,j,k)+vfw)
    end if
!}    
!}
end subroutine les_9
 ! ==============================================


 ! ==============================================
 ! Name: adam Order: 33
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine adam(f,fold,g,gold,h,hold)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
! OpenCLMap ( ["f","g","h","fold","gold","hold","k","j"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1) .and. (k>=1)) then
        fd = f(i,j,k)
        gd = g(i,j,k)
        hd = h(i,j,k)
        f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
        g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
        h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
        fold(i,j,k) = fd
        gold(i,j,k) = gd
        hold(i,j,k) = hd
    end if
!}
end subroutine adam
 ! ==============================================


 ! ==============================================
 ! Name: press_0 Order: 34
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_0(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine press_0
 ! ==============================================


 ! ==============================================
 ! Name: press_1 Order: 35
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_1(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine press_1
 ! ==============================================


 ! ==============================================
 ! Name: press_2 Order: 36
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_2(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine press_2
 ! ==============================================


 ! ==============================================
 ! Name: press_3 Order: 37
 ! Input streams:
 !	StencilStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
 !	StencilStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
 !	StencilStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
 !	StencilStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
 !	StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_3(dt,dx1,dy1,dzn,f,g,h,rhs,u,v,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt","k","j"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
        rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
    end if
!}    
!}
end subroutine press_3
 ! ==============================================


 ! ==============================================
 ! Name: press_4 Order: 38
 ! Input streams:
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
! 	"rhsav"
! 	"area"
 ! --------------------------------------------
subroutine press_4(dx1,dy1,dzn,rhs)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: area
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
        area = area+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_4
 ! ==============================================


 ! ==============================================
 ! Name: press_5 Order: 39
 ! Input streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_5(rhs)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
! OpenCLMap ( ["rhsav","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = rhs(i,j,k)-rhsav
    end if
!}
end subroutine press_5
 ! ==============================================


 ! ==============================================
 ! Name: press_6 Order: 40
 ! Input streams:
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 ! Output Reduction Variables:
! 	"pav"
! 	"pco"
 ! --------------------------------------------
subroutine press_6(dx1,dy1,dzn,p)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
      real(4) :: pco
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
        pco = pco+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_6
 ! ==============================================


 ! ==============================================
 ! Name: press_7 Order: 41
 ! Input streams:
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_7(p)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
! OpenCLMap ( ["pav","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        p(0,i,j,k) = p(0,i,j,k)-pav
    end if
!}
end subroutine press_7
 ! ==============================================


 ! ==============================================
 ! Name: press_8 Order: 42
 ! Input streams:
 !	StencilStream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
 ! Output streams:
 !	Stream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_8(p)
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
    if ((j<=301)) then
        p(0,0,j,k) = p(0,1,j,k)
        p(0,301,j,k) = p(0,300,j,k)
    end if
!}    
!}
end subroutine press_8
 ! ==============================================


 ! ==============================================
 ! Name: press_9 Order: 43
 ! Input streams:
 !	StencilStream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
 ! Output streams:
 !	Stream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_9(p)
      integer :: i
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    if ((i<=301)) then
        p(0,i,0,k) = p(0,i,300,k)
        p(0,i,301,k) = p(0,i,1,k)
    end if
!}    
!}
end subroutine press_9
 ! ==============================================


 ! ==============================================
 ! Name: press_10 Order: 44
 ! Input streams:
 !	StencilStream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
 ! Output streams:
 !	Stream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_10(p)
      integer :: i
      integer :: j
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    if ((i<=301) .and. (j<=301)) then
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
    end if
!}    
!}
end subroutine press_10
 ! ==============================================



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 With Synthesised Loop Vars 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ! ==============================================
 ! Name: velnw_0 Order: 0
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_0(dt,dxs,f,p,ro,u)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/81, 301)
    k = count/24381
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_0
 ! ==============================================


 ! ==============================================
 ! Name: velnw_1 Order: 1
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_1(dt,dys,g,p,ro,v)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/81, 301)
    k = count/24381
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_1
 ! ==============================================


 ! ==============================================
 ! Name: velnw_2 Order: 2
 ! Input streams:
 !	StencilStream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
 !	Stream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_2(dt,dzs,h,p,ro,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/84, 301)
    k = count/25284
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_2
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_0 Order: 3
 ! Input streams:
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: z2_k array name: z2 type: Float dimensions: [(0,82)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_0(dzn,u,v,w,z2)
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:82), intent(In) :: z2
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    i = count/25452
    j = mod(count, 303)
    k = mod(count/84, 84)
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=78)) then
        u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
        u(i,j,k) = u_val
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_0
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_1 Order: 4
 ! Input streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_1(u,v,w)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    i = count/24846
    j = mod(count, 303)
    k = mod(count/82, 82)
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=79) .and. (k<=80)) then
        u(i,j,k) = u(i,j,77)
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_1
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_2 Order: 5
 ! Input streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
! 	"aaa"
 ! --------------------------------------------
subroutine bondv1_2(u)
      real(4) :: aaa
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        aaa = amax1(aaa,u(300,j,k))
    end if
!}
end subroutine bondv1_2
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_3 Order: 6
 ! Input streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
! 	"bbb"
 ! --------------------------------------------
subroutine bondv1_3(u)
      real(4) :: bbb
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        bbb = amin1(bbb,u(300,j,k))
    end if
!}
end subroutine bondv1_3
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_4 Order: 7
 ! Input streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_4(dt,dxs,u)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_4
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_5 Order: 8
 ! Input streams:
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	StencilStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_5(dt,dxs,v)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_5
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_6 Order: 9
 ! Input streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 ! Output streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_6(dt,dxs,w)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 303)
    k = count/83
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_6
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_7 Order: 10
 ! Input streams:
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_7(u)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    k = count/82
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
end subroutine bondv1_7
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_8 Order: 11
 ! Input streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_8(v)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    k = count/82
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
end subroutine bondv1_8
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_9 Order: 12
 ! Input streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_9(w)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    k = count/83
    if ((k>=0) .and. (k<=80)) then
        w(i,0,k) = w(i,300,k)
        w(i,301,k) = w(i,1,k)
    end if
!}    
!}
end subroutine bondv1_9
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_10 Order: 13
 ! Input streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_10(u)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    j = count/303
    if ((j>=0)) then
        u(i,j,0) = -u(i,j,1)
        u(i,j,81) = u(i,j,80)
    end if
!}    
!}
end subroutine bondv1_10
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_11 Order: 14
 ! Input streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_11(v)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    j = count/303
    if ((j>=0)) then
        v(i,j,0) = -v(i,j,1)
        v(i,j,81) = v(i,j,80)
    end if
!}    
!}
end subroutine bondv1_11
 ! ==============================================


 ! ==============================================
 ! Name: bondv1_12 Order: 15
 ! Input streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_12(w)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    j = count/303
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
end subroutine bondv1_12
 ! ==============================================


 ! ==============================================
 ! Name: velfg_0 Order: 16
 ! Input streams:
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
 !	StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
 !	StencilStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
 !	StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	TransitStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_0(dx1,dy1,dzn,dzs,f,u,v,w)
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
        diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        cov1_i = nou1_*diu1_
        nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
        diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
        cov1_ip1 = nou1_ip1*diu1_ip1
        if (i==300) then
                cov1_ip1 = cov1_i
        end if
        nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2_j = nou2_*diu2_
        nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov2_jp1 = nou2_jp1*diu2_jp1
        if (j==300) then
                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                cov2_jp1 = nou2_*diu2_
        end if
        nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
        diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3_k = nou3_*diu3_
        nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
        cov3_kp1 = nou3_kp1*diu3_kp1
        if (k==1) then
                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov3_k = nou3_*diu3_
        end if
        covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
        covy1 = (cov2_j+cov2_jp1)/2.
        covz1 = (cov3_k+cov3_kp1)/2.
        covc = covx1+covy1+covz1
        f(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_0
 ! ==============================================


 ! ==============================================
 ! Name: velfg_1 Order: 17
 ! Input streams:
 !	TransitStream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzs: [[0],[-1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
 !	StencilStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 !	StencilStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_1(dx1,dy1,dzn,dzs,g,u,v,w)
      real(4) :: cov4_i
      real(4) :: cov5_j
      real(4) :: cov6_k
      real(4) :: cov4_ip1
      real(4) :: cov5_jp1
      real(4) :: cov6_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu4_
      real(4) :: diu5_
      real(4) :: diu6_
      real(4) :: diu4_ip1
      real(4) :: diu5_jp1
      real(4) :: diu6_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou4_
      real(4) :: nou5_
      real(4) :: nou6_
      real(4) :: nou4_ip1
      real(4) :: nou5_jp1
      real(4) :: nou6_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	4 point stencil on 3D array u: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	10 point stencil on 3D array v: [[1,0,0],[0,C=1,0],[0,C=2,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array w: [[0,1,C=1],[0,1,0],[0,1,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dy1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou4_ = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4_i = (nou4_-0)*diu4_
        nou4_ip1 = (dy1(j+1)*u(i,j,k)+dy1(j)*u(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu4_ip1 = 2.*(-v(i,j,k)+v(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov4_ip1 = (nou4_ip1-0)*diu4_ip1
        if (i==300) then
                cov4_ip1 = cov4_i
        end if
        nou5_ = (v(i,j-1,k)+v(i,j,k))/2.
        diu5_ = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        cov5_j = nou5_*diu5_
        nou5_jp1 = (v(i,j,k)+v(i,j+1,k))/2.
        diu5_jp1 = (-v(i,j,k)+v(i,j+1,k))/dy1(j+1)
        cov5_jp1 = nou5_jp1*diu5_jp1
        if (j==300) then
                nou5_ = (v(i,1,k)+v(i,2,k))/2.
                diu5_ = (-v(i,1,k)+v(i,2,k))/dy1(j)
                cov5_jp1 = nou5_*diu5_
        end if
        nou6_ = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1))/(dy1(j)+dy1(j+1))
        diu6_ = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6_k = nou6_*diu6_
        nou6_kp1 = (dy1(j+1)*w(i,j,k)+dy1(j)*w(i,j+1,k))/(dy1(j)+dy1(j+1))
        diu6_kp1 = (-v(i,j,k)+v(i,j,k+1))/dzs(k)
        cov6_kp1 = nou6_kp1*diu6_kp1
        if (k==1) then
                nou6_ = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
                diu6_ = 0.4*v(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov6_k = nou6_*diu6_
        end if
        covx1 = (cov4_i+cov4_ip1)/2.
        covy1 = (dy1(j+1)*cov5_j+dy1(j)*cov5_jp1)/(dy1(j)+dy1(j+1))
        covz1 = (cov6_k+cov6_kp1)/2.
        covc = covx1+covy1+covz1
        g(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_1
 ! ==============================================


 ! ==============================================
 ! Name: velfg_2 Order: 18
 ! Input streams:
 !	TransitStream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1 array name: dy1 type: Float dimensions: [(0,301)]!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
 !	StencilStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
 !	StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_2(dx1,dy1,dzn,h,u,v,w)
      real(4) :: cov7_i
      real(4) :: cov8_j
      real(4) :: cov9_k
      real(4) :: cov7_ip1
      real(4) :: cov8_jp1
      real(4) :: cov9_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu7_
      real(4) :: diu8_
      real(4) :: diu9_
      real(4) :: diu7_ip1
      real(4) :: diu8_jp1
      real(4) :: diu9_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou7_
      real(4) :: nou8_
      real(4) :: nou9_
      real(4) :: nou7_ip1
      real(4) :: nou8_jp1
      real(4) :: nou9_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	4 point stencil on 3D array u: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	6 point stencil on 3D array v: [[0,C=0,0],[0,C=0,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	9 point stencil on 3D array w: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["dzn","k","j"],[],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        nou7_ = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7_i = (nou7_-0)*diu7_
        nou7_ip1 = (dzn(k+1)*u(i,j,k)+dzn(k)*u(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu7_ip1 = 2.*(-w(i,j,k)+w(i+1,j,k))/(dx1(i)+dx1(i+1))
        cov7_ip1 = (nou7_-0)*diu7_
        if (i==300) then
                cov7_ip1 = cov7_i
        end if
        nou8_ = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1))/(dzn(k)+dzn(k+1))
        diu8_ = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8_j = nou8_*diu8_
        nou8_jp1 = (dzn(k+1)*v(i,j,k)+dzn(k)*v(i,j,k+1))/(dzn(k)+dzn(k+1))
        diu8_jp1 = 2.*(-w(i,j,k)+w(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov8_jp1 = nou8_jp1*diu8_jp1
        if (j==300) then
                nou8_ = (dzn(k+1)*v(i,0,k)+dzn(k)*v(i,0,k+1))/(dzn(k)+dzn(k+1))
                diu8_ = 2.*(-w(i,0,k)+w(i,1,k))/(dy1(0)+dy1(1))
                cov8_jp1 = nou8_*diu8_
        end if
        nou9_ = (w(i,j,k-1)+w(i,j,k))/2.
        diu9_ = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov9_k = nou9_*diu9_
        nou9_kp1 = (w(i,j,k)+w(i,j,k+1))/2.
        diu9_kp1 = (-w(i,j,k)+w(i,j,k+1))/dzn(k+1)
        cov9_kp1 = nou9_kp1*diu9_kp1
        covx1 = (cov7_i+cov7_ip1)/2.
        covy1 = (cov8_j+cov8_jp1)/2.
        covz1 = (dzn(k+1)*cov9_k+dzn(k)*cov9_kp1)/(dzn(k)+dzn(k+1))
        covc = covx1+covy1+covz1
        h(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_2
 ! ==============================================


 ! ==============================================
 ! Name: velfg_3 Order: 19
 ! Input streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_3(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 301)
    k = count/81
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine velfg_3
 ! ==============================================


 ! ==============================================
 ! Name: velfg_4 Order: 20
 ! Input streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_4(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    k = count/81
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine velfg_4
 ! ==============================================


 ! ==============================================
 ! Name: velfg_5 Order: 21
 ! Input streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_5(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = count/301
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine velfg_5
 ! ==============================================


 ! ==============================================
 ! Name: feedbf Order: 22
 ! Input streams:
 !	Stream: bmask1_i_j_k array name: bmask1 type: Float dimensions: [(-1,301),(0,301),(0,81)]
 !	Stream: cmask1_i_j_k array name: cmask1 type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: dmask1_i_j_k array name: dmask1 type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	Stream: bmask1_i_j_k array name: bmask1 type: Float dimensions: [(-1,301),(0,301),(0,81)]
 !	Stream: cmask1_i_j_k array name: cmask1 type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: dmask1_i_j_k array name: dmask1 type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fx_i_j_k array name: fx type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fy_i_j_k array name: fy type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fz_i_j_k array name: fz type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: usum_i_j_k array name: usum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vsum_i_j_k array name: vsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: wsum_i_j_k array name: wsum type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine feedbf(alpha,beta,bmask1,cmask1,dmask1,dt,f,fx,fy,fz,g,h,u,usum,v,vsum,w,wsum)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:301,0:301,0:81), intent(In) :: bmask1
      real(4), dimension(0:301,-1:301,0:81), intent(In) :: cmask1
      real(4), dimension(0:301,0:301,0:81), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: f1x
      real(4) :: f1y
      real(4) :: f1z
      real(4) :: f2x
      real(4) :: f2y
      real(4) :: f2z
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fx
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fy
      real(4), dimension(0:300,0:300,0:80), intent(Out) :: fz
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: usum
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: vsum
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: wsum
! OpenCLMap ( ["bmask1","cmask1","dmask1","alpha","dt","beta","k","j","fx","fy","fz"],["fx","fy","fz","g"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/82, 302)
    k = count/24764
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
        vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
        wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
        f1x = alpha*usum(i,j,k)*dt
        f1y = alpha*vsum(i,j,k)*dt
        f1z = alpha*wsum(i,j,k)*dt
        f2x = beta*u(i,j,k)*bmask1(i,j,k)
        f2y = beta*v(i,j,k)*cmask1(i,j,k)
        f2z = beta*w(i,j,k)*dmask1(i,j,k)
        fx(i,j,k) = f1x+f2x
        fy(i,j,k) = f1y+f2y
        fz(i,j,k) = f1z+f2z
        f(i,j,k) = f(i,j,k)+fx(i,j,k)
        g(i,j,k) = g(i,j,k)+fy(i,j,k)
        h(i,j,k) = h(i,j,k)+fz(i,j,k)
    end if
!}
end subroutine feedbf
 ! ==============================================


 ! ==============================================
 ! Name: les_0 Order: 23
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: dx1 array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1 array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: dx1 array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1 array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_0(delx1,dx1,dy1,dzn)
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: k
! OpenCLMap ( [],[],["(k,1,80,1)"],[]) {
    k = count/1
    if ((k>=1) .and. (k<=80)) then
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end if
!}
end subroutine les_0
 ! ==============================================


 ! ==============================================
 ! Name: les_1 Order: 24
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
 !	Stream: delx1_k array name: delx1 type: Float dimensions: [(1,80)]
 !	Stream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]
 !	Stream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]
 !	Stream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_1(delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm)
      real(4) :: csx1
      real(4), dimension(), intent(Out) :: delx1
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4) :: dudxx1
      real(4) :: dudyx1
      real(4) :: dudzx1
      real(4) :: dvdxx1
      real(4) :: dvdyx1
      real(4) :: dvdzx1
      real(4) :: dwdxx1
      real(4) :: dwdyx1
      real(4) :: dwdzx1
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!	4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!	4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!	4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!	4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!	4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["diu1","diu5","diu9","k","j"],["sm"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 304)
    j = mod(count/80, 303)
    k = count/24240
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        dudxx1 = diu1(i,j,k)
        dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
        dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
        dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
        dvdyx1 = diu5(i,j,k)
        dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
        dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
        dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
        dwdzx1 = diu9(i,j,k)
        csx1 = 0.14
        sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)&
&**2)
    end if
!}    
!}
end subroutine les_1
 ! ==============================================


 ! ==============================================
 ! Name: les_2 Order: 25
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_2(sm)
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[C=1,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(j,-1,301,1)"],[]) {
    j = mod(count, 303)
    k = count/82
    sm(0,j,k) = sm(1,j,k)
    sm(301,j,k) = sm(300,j,k)
!}    
!}
end subroutine les_2
 ! ==============================================


 ! ==============================================
 ! Name: les_3 Order: 26
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_i_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_3(sm)
      integer :: i
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["sm"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    i = mod(count, 303)
    k = count/82
    if ((i>=0)) then
        sm(i,301,k) = sm(i,300,k)
        sm(i,0,k) = sm(i,1,k)
    end if
!}    
!}
end subroutine les_3
 ! ==============================================


 ! ==============================================
 ! Name: les_4 Order: 27
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_4(sm)
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
! OpenCLStencil (
!	2 point stencil on 3D array sm: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["sm"],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 303)
    j = count/303
    if ((i>=0)) then
        sm(i,j,0) = -sm(i,j,1)
        sm(i,j,81) = sm(i,j,80)
    end if
!}    
!}
end subroutine les_4
 ! ==============================================


 ! ==============================================
 ! Name: les_5 Order: 28
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: diu1_i_j_k array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_5(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!	2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","k","j"],[],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 304)
    j = mod(count/83, 303)
    k = count/25149
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsx2 = sm(i+1,j,k)
        evsx1 = sm(i,j,k)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visux2 = (evsx2)*2.*diu1(i+1,j,k)
        visux1 = (evsx1)*2.*diu1(i,j,k)
        visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
        visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
        f(i,j,k) = (f(i,j,k)+vfu)
    end if
!}    
!}
end subroutine les_5
 ! ==============================================


 ! ==============================================
 ! Name: les_6 Order: 29
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu1_i_j array name: diu1 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
 !	StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
 !	StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	2 point stencil on 1D array dx1: [[0],[1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
 !	Stream: diu3_i_j array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: diu7_i_j array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: uspd_i_j array name: uspd type: Float dimensions: [(0,301),(0,301)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: f_i_j array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_6(diu1,diu2,diu3,diu4,diu7,dx1,dxs,dy1,dzn,f,sm,u,uspd)
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu1
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,0:301), intent(In) :: uspd
      real(4) :: vfu
      real(4) :: visux2
      real(4) :: visux1
      real(4) :: visuy2
      real(4) :: visuy1
      real(4) :: visuz2
      real(4) :: visuz1
! OpenCLStencil (
!	2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!	2 point stencil on 1D array dx1: [[0],[1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["sm","diu1","dxs","dy1","dzn","j"],["f"],["(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 304)
    j = count/303
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsx2 = sm(i+1,j,1)
        evsx1 = sm(i,j,1)
        evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,&
&j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visux2 = (evsx2)*2.*diu1(i+1,j,1)
        visux1 = (evsx1)*2.*diu1(i,j,1)
        visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
        visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
        visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(u(i,j,1)/uspd(i,j))
        vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
        f(i,j,1) = (f(i,j,1)+vfu)
    end if
!}    
!}
end subroutine les_6
 ! ==============================================


 ! ==============================================
 ! Name: les_7 Order: 30
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	StencilStream: diu2_i_j_k array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
 !	StencilStream: diu4_i_j_k array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
 !	StencilStream: diu5_i_j_k array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_7(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!	2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	3 point stencil on 1D array dzn: [[0],[1],[-1]]
!	10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","k","j"],["g"],["(k,2,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/83, 303)
    k = count/25149
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=2) .and. (k<=80)) then
        evsy2 = sm(i,j+1,k)
        evsy1 = sm(i,j,k)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+&
&1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+&
&1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,&
&j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
        visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
        visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
        visvy2 = (evsy2)*2.*diu5(i,j+1,k)
        visvy1 = (evsy1)*2.*diu5(i,j,k)
        visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
        g(i,j,k) = (g(i,j,k)+vfv)
    end if
!}    
!}
end subroutine les_7
 ! ==============================================


 ! ==============================================
 ! Name: les_8 Order: 31
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu2_i_j array name: diu2 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
 !	StencilStream: diu4_i_j array name: diu4 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
 !	StencilStream: diu5_i_j array name: diu5 type: Float dimensions: [(-1,302),(0,302),(0,82)]!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	2 point stencil on 1D array dy1: [[0],[1]]
 !	StencilStream: dzn array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
 !	StencilStream: sm_i_j array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
 !	Stream: diu6_i_j array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: diu8_i_j array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: vspd_i_j array name: vspd type: Float dimensions: [(0,301),(0,301)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]
 !	Stream: g_i_j array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_8(diu2,diu4,diu5,diu6,diu8,dx1,dy1,dys,dzn,g,sm,v,vspd)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu2
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu4
      real(4), dimension(-1:302,0:302,0:82), intent(In) :: diu5
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4) :: vfv
      real(4) :: visvx2
      real(4) :: visvx1
      real(4) :: visvy2
      real(4) :: visvy1
      real(4) :: visvz2
      real(4) :: visvz1
      real(4), dimension(0:301,0:301), intent(In) :: vspd
! OpenCLStencil (
!	2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!	2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!	2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	2 point stencil on 1D array dy1: [[0],[1]]
!	2 point stencil on 1D array dzn: [[C=1],[C=2]]
!	8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["sm","diu5","dx1","dys","dzn","j"],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = count/303
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300)) then
        evsy2 = sm(i,j+1,1)
        evsy1 = sm(i,j,1)
        evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+&
&1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
        evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+&
&1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
        evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/&
&(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
        visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
        visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
        visvy2 = (evsy2)*2.*diu5(i,j+1,1)
        visvy1 = (evsy1)*2.*diu5(i,j,1)
        visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
        visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*(v(i,j,1)/vspd(i,j))
        vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
        g(i,j,1) = (g(i,j,1)+vfv)
    end if
!}    
!}
end subroutine les_8
 ! ==============================================


 ! ==============================================
 ! Name: les_9 Order: 32
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	StencilStream: diu3_i_j_k array name: diu3 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
 !	StencilStream: diu6_i_j_k array name: diu6 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
 !	StencilStream: diu7_i_j_k array name: diu7 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
 !	StencilStream: diu8_i_j_k array name: diu8 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
 !	StencilStream: diu9_i_j_k array name: diu9 type: Float dimensions: [(0,302),(0,302),(0,82)]!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
 !	StencilStream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
 !	StencilStream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
 !	StencilStream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]!	2 point stencil on 1D array dzn: [[0],[1]]
 !	StencilStream: sm_i_j_k array name: sm type: Float dimensions: [(-1,301),(-1,301),(0,81)]!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine les_9(diu3,diu6,diu7,diu8,diu9,dx1,dy1,dzn,h,sm)
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu3
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu6
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu7
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu8
      real(4), dimension(0:302,0:302,0:82), intent(In) :: diu9
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4) :: evsx2
      real(4) :: evsx1
      real(4) :: evsy2
      real(4) :: evsy1
      real(4) :: evsz2
      real(4) :: evsz1
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(-1:301,-1:301,0:81), intent(Out) :: sm
      real(4) :: vfw
      real(4) :: viswx2
      real(4) :: viswx1
      real(4) :: viswy2
      real(4) :: viswy1
      real(4) :: viswz2
      real(4) :: viswz1
! OpenCLStencil (
!	2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!	2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!	2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!	2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!	2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!	3 point stencil on 1D array dx1: [[0],[1],[-1]]
!	3 point stencil on 1D array dy1: [[0],[1],[-1]]
!	2 point stencil on 1D array dzn: [[0],[1]]
!	10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["sm","diu9","dx1","dy1","dzn","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/83, 303)
    k = count/25149
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        evsz2 = sm(i,j,k+1)
        evsz1 = sm(i,j,k)
        evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,&
&k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
        evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,&
&k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
        evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,&
&k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
        evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,&
&k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
        viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
        viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
        viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
        viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
        viswz2 = (evsz2)*2.*diu9(i,j,k+1)
        viswz1 = (evsz1)*2.*diu9(i,j,k)
        vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
        h(i,j,k) = (h(i,j,k)+vfw)
    end if
!}    
!}
end subroutine les_9
 ! ==============================================


 ! ==============================================
 ! Name: adam Order: 33
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: fold_i_j_k array name: fold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: gold_i_j_k array name: gold type: Float dimensions: [(1,300),(1,300),(1,80)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: hold_i_j_k array name: hold type: Float dimensions: [(1,300),(1,300),(1,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine adam(f,fold,g,gold,h,hold)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4) :: fd
      real(4) :: gd
      real(4) :: hd
      real(4), dimension(,,), intent(InOut) :: fold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(,,), intent(InOut) :: gold
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      real(4), dimension(,,), intent(InOut) :: hold
      integer :: i
      integer :: j
      integer :: k
! OpenCLMap ( ["f","g","h","fold","gold","hold","k","j"],["f","g","h"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/81, 301)
    k = count/24381
    if ((i>=1) .and. (j>=1) .and. (k>=1)) then
        fd = f(i,j,k)
        gd = g(i,j,k)
        hd = h(i,j,k)
        f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
        g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
        h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
        fold(i,j,k) = fd
        gold(i,j,k) = gd
        hold(i,j,k) = hd
    end if
!}
end subroutine adam
 ! ==============================================


 ! ==============================================
 ! Name: press_0 Order: 34
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: f_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_0(f)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: j
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 301)
    k = count/81
    if ((j>=1) .and. (k>=1)) then
        f(0,j,k) = f(1,j,k)
    end if
!}
end subroutine press_0
 ! ==============================================


 ! ==============================================
 ! Name: press_1 Order: 35
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: g_i_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_1(g)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: k
! OpenCLMap ( ["k"],[],["(k,1,80,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    k = count/81
    if ((i>=1) .and. (k>=1)) then
        g(i,0,k) = g(i,300,k)
    end if
!}
end subroutine press_1
 ! ==============================================


 ! ==============================================
 ! Name: press_2 Order: 36
 ! Input streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output streams:
 !	TransitStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	TransitStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_2(h)
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
! OpenCLMap ( [],[],["(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = count/301
    if ((i>=1) .and. (j>=1)) then
        h(i,j,0) = 0.0
        h(i,j,80) = 0.0
    end if
!}
end subroutine press_2
 ! ==============================================


 ! ==============================================
 ! Name: press_3 Order: 37
 ! Input streams:
 !	StencilStream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
 !	StencilStream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
 !	StencilStream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
 !	StencilStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
 !	StencilStream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
 !	StencilStream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_3(dt,dx1,dy1,dzn,f,g,h,rhs,u,v,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!	2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!	2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!	2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dy1","dzn","dt","k","j"],["rhs"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
        rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
    end if
!}    
!}
end subroutine press_3
 ! ==============================================


 ! ==============================================
 ! Name: press_4 Order: 38
 ! Input streams:
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
! 	"rhsav"
! 	"area"
 ! --------------------------------------------
subroutine press_4(dx1,dy1,dzn,rhs)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
      real(4) :: area
! OpenCLReduce ( ["dx1","dy1","dzn","rhs","i","j","k"],["rhsav","area"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
        area = area+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_4
 ! ==============================================


 ! ==============================================
 ! Name: press_5 Order: 39
 ! Input streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output streams:
 !	Stream: rhs_i_j_k array name: rhs type: Float dimensions: [(0,301),(0,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_5(rhs)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,0:301,0:81), intent(Out) :: rhs
      real(4) :: rhsav
! OpenCLMap ( ["rhsav","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 302)
    j = mod(count/82, 302)
    k = count/24764
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        rhs(i,j,k) = rhs(i,j,k)-rhsav
    end if
!}
end subroutine press_5
 ! ==============================================


 ! ==============================================
 ! Name: press_6 Order: 40
 ! Input streams:
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 ! Output Reduction Variables:
! 	"pav"
! 	"pco"
 ! --------------------------------------------
subroutine press_6(dx1,dy1,dzn,p)
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
      real(4) :: pco
! OpenCLReduce ( ["p","dx1","dy1","dzn","i","j","k"],["pav","pco"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pav = pav+p(0,i,j,k)*dx1(i)*dy1(j)*dzn(k)
        pco = pco+dx1(i)*dy1(j)*dzn(k)
    end if
!}
end subroutine press_6
 ! ==============================================


 ! ==============================================
 ! Name: press_7 Order: 41
 ! Input streams:
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 !	Stream: p_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_7(p)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pav
! OpenCLMap ( ["pav","k","j"],["p"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/82, 303)
    k = count/24846
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        p(0,i,j,k) = p(0,i,j,k)-pav
    end if
!}
end subroutine press_7
 ! ==============================================


 ! ==============================================
 ! Name: press_8 Order: 42
 ! Input streams:
 !	StencilStream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
 ! Output streams:
 !	Stream: p_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_8(p)
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,C=1,0,0],[C=0,C=300,0,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(j,0,301,1)"],[]) {
    j = mod(count, 303)
    k = count/82
    if ((j<=301)) then
        p(0,0,j,k) = p(0,1,j,k)
        p(0,301,j,k) = p(0,300,j,k)
    end if
!}    
!}
end subroutine press_8
 ! ==============================================


 ! ==============================================
 ! Name: press_9 Order: 43
 ! Input streams:
 !	StencilStream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
 ! Output streams:
 !	Stream: p_i_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_9(p)
      integer :: i
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,C=1,0],[C=0,0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["p"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    i = mod(count, 303)
    k = count/82
    if ((i<=301)) then
        p(0,i,0,k) = p(0,i,300,k)
        p(0,i,301,k) = p(0,i,1,k)
    end if
!}    
!}
end subroutine press_9
 ! ==============================================


 ! ==============================================
 ! Name: press_10 Order: 44
 ! Input streams:
 !	StencilStream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
 ! Output streams:
 !	Stream: p_i_j array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine press_10(p)
      integer :: i
      integer :: j
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,C=1],[C=0,0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 303)
    j = count/303
    if ((i<=301) .and. (j<=301)) then
        p(0,i,j,0) = p(0,i,j,1)
        p(0,i,j,81) = p(0,i,j,80)
    end if
!}    
!}
end subroutine press_10
 ! ==============================================



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 With Smart Caches 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

"------------------------------------------"
 ! ==============================================
 ! Name: velnw_0 Order: 0
 ! Input streams:
 !	Stream: dxs_i array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: p_0_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 !	Stream: p_0_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_0(dt,dxs,f,p,ro,u)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,1,0,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dxs","dt","k","j","u"],["u"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/81, 301)
    k = count/24381
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_0
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: velnw_1 Order: 1
 ! Input streams:
 !	Stream: dys_j array name: dys type: Float dimensions: [(0,300)]
 !	Stream: g_i_j_k array name: g type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: p_0_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 !	Stream: p_0_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_1(dt,dys,g,p,ro,v)
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dys
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: g
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,1,0],[C=0,0,0,0]]
!    ){
! OpenCLMap ( ["ro","dys","dt","k","j"],["v"],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/81, 301)
    k = count/24381
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        pz = (-p(0,i,j,k)+p(0,i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_1
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: velnw_2 Order: 2
 ! Input streams:
 !	Stream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]
 !	Stream: h_i_j_k array name: h type: Float dimensions: [(0,300),(0,300),(0,80)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: p_0_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 !	Stream: p_0_i_j_k array name: p type: Float dimensions: [(0,1),(0,302),(0,302),(0,81)]
 ! Output streams:
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velnw_2(dt,dzs,h,p,ro,w)
      real(4), intent(In) :: dt
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: h
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:1,0:302,0:302,0:81) :: p
      real(4) :: pz
      real(4), intent(In) :: ro
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 4D array p: [[C=0,0,0,0],[C=0,0,0,1]]
!    ){
! OpenCLMap ( ["ro","dzs","dt","k","j"],["w"],["(k,1,79,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 301)
    j = mod(count/84, 301)
    k = count/25284
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=79)) then
        pz = (-p(0,i,j,k)+p(0,i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
    end if
!}    
!}
end subroutine velnw_2
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_0 Order: 3
 ! Input streams:
 !	Stream: dzn_k array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: z2_k array name: z2 type: Float dimensions: [(0,82)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_0(dzn,u,v,w,z2)
      real(4), dimension(-1:82), intent(In) :: dzn
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
      real(4), dimension(0:82), intent(In) :: z2
! OpenCLMap ( [],["u","w","v"],["(i,0,1,1)","(k,1,78,1)","(j,1,300,1)"],[]) {
    i = count/25452
    j = mod(count, 303)
    k = mod(count/84, 84)
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=78)) then
        u_val = 5.*((z2(k)+0.5*dzn(k))/600.)**0.2
        u(i,j,k) = u_val
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_0
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_1 Order: 4
 ! Input streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_1(u,v,w)
      integer :: i
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( ["i"],["u","v","w"],["(i,0,1,1)","(k,79,80,1)","(j,1,300,1)"],[]) {
    i = count/24846
    j = mod(count, 303)
    k = mod(count/82, 82)
    if ((i<=1) .and. (j>=1) .and. (j<=300) .and. (k>=79) .and. (k<=80)) then
        u(i,j,k) = u(i,j,77)
        v(i,j,k) = 0.0
        w(i,j,k) = 0.0
    end if
!}
end subroutine bondv1_1
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_2 Order: 5
 ! Input streams:
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
! 	"aaa"
 ! --------------------------------------------
subroutine bondv1_2(u)
      real(4) :: aaa
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["aaa"],["(k,1,80,1)","(j,1,300,1)"],[],["(aaa,0.0)"]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        aaa = amax1(aaa,u(300,j,k))
    end if
!}
end subroutine bondv1_2
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_3 Order: 6
 ! Input streams:
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
! 	"bbb"
 ! --------------------------------------------
subroutine bondv1_3(u)
      real(4) :: bbb
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLReduce ( ["u"],["bbb"],["(k,1,80,1)","(j,1,300,1)"],[],["(bbb,1e38)"]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        bbb = amin1(bbb,u(300,j,k))
    end if
!}
end subroutine bondv1_3
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_4 Order: 7
 ! Input streams:
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_299_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_300_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_4(dt,dxs,u)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[C=299,0,0],[C=300,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["u"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        u(300,j,k) = u(300,j,k)-dt*uout*(u(300,j,k)-u(299,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_4
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_5 Order: 8
 ! Input streams:
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_300_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_301_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_5(dt,dxs,v)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["v"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 303)
    k = count/82
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        v(301,j,k) = v(301,j,k)-dt*uout*(v(301,j,k)-v(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_5
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_6 Order: 9
 ! Input streams:
 !	Stream: dxs array name: dxs type: Float dimensions: [(0,300)]
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_300_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_301_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_6(dt,dxs,w)
      real(4) :: uout
      real(4), intent(In) :: dt
      real(4), dimension(0:300), intent(In) :: dxs
      integer :: j
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[C=300,0,0],[C=301,0,0]]
!    ){
! OpenCLMap ( ["dt","uout","dxs","k"],["w"],["(k,1,80,1)","(j,1,300,1)"],[]) {
    j = mod(count, 303)
    k = count/83
    if ((j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        w(301,j,k) = w(301,j,k)-dt*uout*(w(301,j,k)-w(300,j,k))/dxs(300)
    end if
!}    
!}
end subroutine bondv1_6
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_7 Order: 10
 ! Input streams:
 !	Stream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_1_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_300_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_7(u)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["u"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    k = count/82
    u(i,0,k) = u(i,300,k)
    u(i,301,k) = u(i,1,k)
!}    
!}
end subroutine bondv1_7
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_8 Order: 11
 ! Input streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_1_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_300_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_8(v)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],["v"],["(k,0,81,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    k = count/82
    v(i,0,k) = v(i,300,k)
    v(i,301,k) = v(i,1,k)
!}    
!}
end subroutine bondv1_8
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_9 Order: 12
 ! Input streams:
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_1_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_i_300_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_9(w)
      integer :: i
      integer :: k
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 3D array w: [[0,C=1,0],[0,C=300,0]]
!    ){
! OpenCLMap ( ["k"],[],["(k,0,80,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    k = count/83
    if ((k>=0) .and. (k<=80)) then
        w(i,0,k) = w(i,300,k)
        w(i,301,k) = w(i,1,k)
    end if
!}    
!}
end subroutine bondv1_9
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_10 Order: 13
 ! Input streams:
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_1 array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_80 array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_10(u)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
! OpenCLStencil (
!	2 point stencil on 3D array u: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],[],["(j,0,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    j = count/303
    if ((j>=0)) then
        u(i,j,0) = -u(i,j,1)
        u(i,j,81) = u(i,j,80)
    end if
!}    
!}
end subroutine bondv1_10
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_11 Order: 14
 ! Input streams:
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_1 array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_80 array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_11(v)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
! OpenCLStencil (
!	2 point stencil on 3D array v: [[0,0,C=1],[0,0,C=80]]
!    ){
! OpenCLMap ( ["j"],["v"],["(j,0,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    j = count/303
    if ((j>=0)) then
        v(i,j,0) = -v(i,j,1)
        v(i,j,81) = v(i,j,80)
    end if
!}    
!}
end subroutine bondv1_11
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: bondv1_12 Order: 15
 ! Input streams:
 !	Stream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output streams:
 !	TransitStream: v_i_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine bondv1_12(w)
      integer :: i
      integer :: j
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLMap ( [],[],["(j,-1,301,1)","(i,0,301,1)"],[]) {
    i = mod(count, 302)
    j = count/303
    w(i,j,0) = 0.0
    w(i,j,80) = 0.0
!}
end subroutine bondv1_12
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: velfg_0 Order: 16
 ! Input streams:
 !	Stream: dzn array name: dzn type: Float dimensions: [(-1,82)]
 !	Stream: dx1_ip1 array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dx1_i array name: dx1 type: Float dimensions: [(-1,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dy1_j array name: dy1 type: Float dimensions: [(0,301)]
 !	Stream: dzs_k array name: dzs type: Float dimensions: [(-1,82)]
 !	Stream: dzs_km1 array name: dzs type: Float dimensions: [(-1,82)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: v_i_j_k array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	Stream: w_i_j_k array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 ! Output streams:
 !	TransitStream: w_i_j array name: w type: Float dimensions: [(0,301),(-1,301),(-1,81)]
 !	TransitStream: v_i_j array name: v type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	TransitStream: u_i_j_k array name: u type: Float dimensions: [(0,301),(-1,301),(0,81)]
 !	Stream: f_i_j_k array name: f type: Float dimensions: [(0,300),(0,300),(0,80)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine velfg_0(dx1,dy1,dzn,dzs,f,u,v,w)
      real(4) :: cov1_i
      real(4) :: cov2_j
      real(4) :: cov3_k
      real(4) :: cov1_ip1
      real(4) :: cov2_jp1
      real(4) :: cov3_kp1
      real(4) :: covc
      real(4) :: covx1
      real(4) :: covy1
      real(4) :: covz1
      real(4) :: diu1_
      real(4) :: diu2_
      real(4) :: diu3_
      real(4) :: diu1_ip1
      real(4) :: diu2_jp1
      real(4) :: diu3_kp1
      real(4), dimension(-1:301), intent(In) :: dx1
      real(4), dimension(0:301), intent(In) :: dy1
      real(4), dimension(-1:82), intent(In) :: dzn
      real(4), dimension(-1:82), intent(In) :: dzs
      real(4), dimension(0:300,0:300,0:80), intent(InOut) :: f
      integer :: i
      integer :: j
      integer :: k
      real(4) :: nou1_
      real(4) :: nou2_
      real(4) :: nou3_
      real(4) :: nou1_ip1
      real(4) :: nou2_jp1
      real(4) :: nou3_kp1
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: u
      real(4), dimension(0:301,-1:301,0:81), intent(InOut) :: v
      real(4), dimension(0:301,-1:301,-1:81), intent(InOut) :: w
! OpenCLStencil (
!	2 point stencil on 1D array dx1: [[0],[1]]
!	5 point stencil on 1D array dy1: [[C=0],[C=1],[0],[1],[-1]]
!	2 point stencil on 1D array dzs: [[0],[-1]]
!	10 point stencil on 3D array u: [[1,0,0],[0,C=0,0],[0,C=1,0],[0,1,0],[0,0,C=1],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!	6 point stencil on 3D array v: [[1,C=0,0],[1,0,0],[1,-1,0],[0,C=0,0],[0,0,0],[0,-1,0]]
!	6 point stencil on 3D array w: [[1,0,C=1],[1,0,0],[1,0,-1],[0,0,C=1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["dx1","dzs","k","j"],[],["(k,1,80,1)","(j,1,300,1)","(i,1,300,1)"],[]) {
    i = mod(count, 303)
    j = mod(count/84, 302)
    k = count/25368
    if ((i>=1) .and. (i<=300) .and. (j>=1) .and. (j<=300) .and. (k>=1) .and. (k<=80)) then
        nou1_ = (u(i-1,j,k)+u(i,j,k))/2.
        diu1_ = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        cov1_i = nou1_*diu1_
        nou1_ip1 = (u(i,j,k)+u(i+1,j,k))/2.
        diu1_ip1 = (-u(i,j,k)+u(i+1,j,k))/dx1(i+1)
        cov1_ip1 = nou1_ip1*diu1_ip1
        if (i==300) then
                cov1_ip1 = cov1_i
        end if
        nou2_ = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k))/(dx1(i)+dx1(i+1))
        diu2_ = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2_j = nou2_*diu2_
        nou2_jp1 = (dx1(i+1)*v(i,j,k)+dx1(i)*v(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu2_jp1 = 2.*(-u(i,j,k)+u(i,j+1,k))/(dy1(j)+dy1(j+1))
        cov2_jp1 = nou2_jp1*diu2_jp1
        if (j==300) then
                nou2_ = (dx1(i+1)*v(i,0,k)+dx1(i)*v(i+1,0,k))/(dx1(i)+dx1(i+1))
                diu2_ = 2.*(-u(i,0,k)+u(i,1,k))/(dy1(0)+dy1(1))
                cov2_jp1 = nou2_*diu2_
        end if
        nou3_ = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1))/(dx1(i)+dx1(i+1))
        diu3_ = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3_k = nou3_*diu3_
        nou3_kp1 = (dx1(i+1)*w(i,j,k)+dx1(i)*w(i+1,j,k))/(dx1(i)+dx1(i+1))
        diu3_kp1 = (-u(i,j,k)+u(i,j,k+1))/dzs(k)
        cov3_kp1 = nou3_kp1*diu3_kp1
        if (k==1) then
                nou3_ = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
                diu3_ = 0.4*u(i,j,1)/(alog(5.0*dzn(1))*0.2*dzn(1))
                cov3_k = nou3_*diu3_
        end if
        covx1 = (dx1(i+1)*cov1_i+dx1(i)*cov1_ip1)/(dx1(i)+dx1(i+1))
        covy1 = (cov2_j+cov2_jp1)/2.
        covz1 = (cov3_k+cov3_kp1)/2.
        covc = covx1+covy1+covz1
        f(i,j,k) = (-covc)
    end if
!}    
!}
end subroutine velfg_0
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
