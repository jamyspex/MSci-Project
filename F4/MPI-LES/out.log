./src/grid_tmp.f95:53:9: warning: missing terminating ' character
 !WV: let's set the *whole* array to this value!
         ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
./src/velnw_tmp.f95:23:17: warning: missing terminating ' character
 ! Which means it's the values of f,g,h that are changing. g seems fine.
                 ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
callsOfInterest: main: ["velnw","bondv1","velfg","feedbf","les","adam","press"]

./src/velnw_tmp.f95:23:17: warning: missing terminating ' character
 ! Which means it's the values of f,g,h that are changing. g seems fine.
                 ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
callsOfInterest: adam: []
bondv1: []
feedbf: []
les: []
main: ["velnw","bondv1","velfg","feedbf","les","adam","press"]
press: []
velfg: []
velnw: []

callsOfInterest: adam: []
bondv1: []
feedbf: []
les: []
main: ["velnw","bondv1","velfg","feedbf","les","adam","press"]
press: []
velfg: []
velnw: []


================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	adam
	bondv1
	feedbf
	les
	press
	velfg
	velnw
File containing main subroutine: 
	main.f95
Source directory:
	./src
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: WV_OPENCL, WV_NEW, NO_GLOBAL_SOR, INLINE_BOUND_CALCS, WV_TEST, TWINNED_BUFFER, NO_IO, IFBF=1, IADAM=0, 
CPP Excludes:

cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/main_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/init_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/grid_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/set_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/timdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/aveflow_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/ifdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/main.f95
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velfg_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/adam.f95
Parsing ./src/bondv1.f95
Parsing ./src/feedbf.f95
Parsing ./src/les.f95
Parsing ./src/press.f95
Parsing ./src/velfg.f95
Parsing ./src/velnw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velfg->
	    call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "cov1", argument = VarName (fromList []) "cov1"}
	ArgTrans {parameter = ArgName (fromList []) "cov2", argument = VarName (fromList []) "cov2"}
	ArgTrans {parameter = ArgName (fromList []) "cov3", argument = VarName (fromList []) "cov3"}
	ArgTrans {parameter = ArgName (fromList []) "dfu1", argument = VarName (fromList []) "dfu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "cov4", argument = VarName (fromList []) "cov4"}
	ArgTrans {parameter = ArgName (fromList []) "cov5", argument = VarName (fromList []) "cov5"}
	ArgTrans {parameter = ArgName (fromList []) "cov6", argument = VarName (fromList []) "cov6"}
	ArgTrans {parameter = ArgName (fromList []) "dfv1", argument = VarName (fromList []) "dfv1"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "cov7", argument = VarName (fromList []) "cov7"}
	ArgTrans {parameter = ArgName (fromList []) "cov8", argument = VarName (fromList []) "cov8"}
	ArgTrans {parameter = ArgName (fromList []) "cov9", argument = VarName (fromList []) "cov9"}
	ArgTrans {parameter = ArgName (fromList []) "dfw1", argument = VarName (fromList []) "dfw1"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "nou1", argument = VarName (fromList []) "nou1"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "nou5", argument = VarName (fromList []) "nou5"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "nou9", argument = VarName (fromList []) "nou9"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "nou2", argument = VarName (fromList []) "nou2"}
	ArgTrans {parameter = ArgName (fromList []) "nou3", argument = VarName (fromList []) "nou3"}
	ArgTrans {parameter = ArgName (fromList []) "nou4", argument = VarName (fromList []) "nou4"}
	ArgTrans {parameter = ArgName (fromList []) "nou6", argument = VarName (fromList []) "nou6"}
	ArgTrans {parameter = ArgName (fromList []) "nou7", argument = VarName (fromList []) "nou7"}
	ArgTrans {parameter = ArgName (fromList []) "nou8", argument = VarName (fromList []) "nou8"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: adam
Filename: ./src/adam.f95
Source:
subroutine adam(n,nmax,data21,fold,im,jm,km,gold,hold,fghold,f,g,h)
      character*70, intent(In) :: data21
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
end subroutine adam

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: bondv1
Filename: ./src/bondv1.f95
Source:
subroutine bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      integer, intent(In) :: im,jm,km,n
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:kp+2), intent(In) :: z2
      real(4) :: u_val
      integer :: i,j,k
      real(4) :: aaa,bbb,uout
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: feedbf
Filename: ./src/feedbf.f95
Source:
subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,dt,beta,fx,fy,fz,f,g,h)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
end subroutine feedbf

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: les
Filename: ./src/les.f95
Source:
subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,uspd,vspd,dxs,dys)
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
end subroutine les

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: press
Filename: ./src/press.f95
Source:
subroutine press(km,jm,im,rhs,u,dx1,v,dy1,w,dzn,f,g,h,dt,cn1,cn2l,p,cn2s,cn3l,cn3s,cn4l,cn4s,n,nmax,data20,usum,vsum,wsum)
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: wsum
      integer :: nn
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 88, col = 12},{<unknown>, line = 88, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine press

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velfg
Filename: ./src/velfg.f95
Source:
subroutine velfg(km,jm,im,dx1,cov1,cov2,cov3,dfu1,diu1,diu2,dy1,diu3,dzn,vn,f,cov4,cov5,cov6,dfv1,diu4,diu5,diu6,g,cov7,cov8,cov9,dfw1,diu7,diu8,diu9,dzs,h,nou1,u,nou5,v,nou9,w,nou2,nou3,nou4,nou6,nou7,nou8,uspd,vspd)
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov9
      real(4), dimension(0:ip,jp,kp), intent(Out) :: dfu1
      real(4), dimension(ip,0:jp,kp), intent(Out) :: dfv1
      real(4), dimension(ip,jp,kp), intent(Out) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu9
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou9
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), intent(In) :: vn
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: uspd
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: vspd
    call vel2(km, jm, im, nou1, u, diu1, dx1, nou5, v, diu5, dy1, nou9, w, diu9, dzn, cov1, cov5, cov9, nou2, diu2, cov2, nou3, diu3, dzs, cov3, nou4, diu4, cov4, nou6, diu6, cov6, nou7, diu7, cov7, nou8, diu8, cov8, uspd, vspd)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k))/(dx1(i)+dx1(i+1))
                                covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
                                covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
                                covc = covx1+covy1+covz1
                                dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))+(-diu2(i,j,k)+diu2(i,j+1,k))/dy1(j)+(-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
                                df = vn*dfu1(i,j,k)
                                f(i,j,k) = (-covc+df)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
                                covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k))/(dy1(j)+dy1(j+1))
                                covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
                                covc = covx1+covy1+covz1
                                dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)+2.*(-diu5(i,j,k)+diu5(i,j+1,k))/(dy1(j)+dy1(j+1))+(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
                                df = vn*dfv1(i,j,k)
                                g(i,j,k) = (-covc+df)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
                                covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
                                covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1))/(dzn(k)+dzn(k+1))
                                covc = covx1+covy1+covz1
                                dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)+(-diu8(i,j,k)+diu8(i,j+1,k))/dy1(j)+(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
                                df = vn*dfw1(i,j,k)
                                h(i,j,k) = (-covc+df)
                end do
        end do
    end do
    return 
end subroutine velfg

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw
Filename: ./src/velnw.f95
Source:
subroutine velnw(km,jm,im,p,ro,dxs,u,dt,f,dys,v,g,dzs,w,h)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(In) :: p
      real(4), intent(In) :: ro
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
end subroutine velnw

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velfg->
	    call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "cov1", argument = VarName (fromList []) "cov1"}
	ArgTrans {parameter = ArgName (fromList []) "cov2", argument = VarName (fromList []) "cov2"}
	ArgTrans {parameter = ArgName (fromList []) "cov3", argument = VarName (fromList []) "cov3"}
	ArgTrans {parameter = ArgName (fromList []) "dfu1", argument = VarName (fromList []) "dfu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "cov4", argument = VarName (fromList []) "cov4"}
	ArgTrans {parameter = ArgName (fromList []) "cov5", argument = VarName (fromList []) "cov5"}
	ArgTrans {parameter = ArgName (fromList []) "cov6", argument = VarName (fromList []) "cov6"}
	ArgTrans {parameter = ArgName (fromList []) "dfv1", argument = VarName (fromList []) "dfv1"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "cov7", argument = VarName (fromList []) "cov7"}
	ArgTrans {parameter = ArgName (fromList []) "cov8", argument = VarName (fromList []) "cov8"}
	ArgTrans {parameter = ArgName (fromList []) "cov9", argument = VarName (fromList []) "cov9"}
	ArgTrans {parameter = ArgName (fromList []) "dfw1", argument = VarName (fromList []) "dfw1"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "nou1", argument = VarName (fromList []) "nou1"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "nou5", argument = VarName (fromList []) "nou5"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "nou9", argument = VarName (fromList []) "nou9"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "nou2", argument = VarName (fromList []) "nou2"}
	ArgTrans {parameter = ArgName (fromList []) "nou3", argument = VarName (fromList []) "nou3"}
	ArgTrans {parameter = ArgName (fromList []) "nou4", argument = VarName (fromList []) "nou4"}
	ArgTrans {parameter = ArgName (fromList []) "nou6", argument = VarName (fromList []) "nou6"}
	ArgTrans {parameter = ArgName (fromList []) "nou7", argument = VarName (fromList []) "nou7"}
	ArgTrans {parameter = ArgName (fromList []) "nou8", argument = VarName (fromList []) "nou8"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,cov1,cov2,cov3,cov4,cov5,cov6,cov7,cov8,cov9,data20,data21,delx1,dfu1,dfv1,dfw1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,nou1,nou2,nou3,nou4,nou5,nou6,nou7,nou8,nou9,p,rhs,ro,sm,u,uspd,usum,v,vn,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov9
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(0:ip,jp,kp), intent(Out) :: dfu1
      real(4), dimension(ip,0:jp,kp), intent(Out) :: dfv1
      real(4), dimension(ip,jp,kp), intent(Out) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), intent(In) :: vn
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
    call vel2(km, jm, im, nou1, u, diu1, dx1, nou5, v, diu5, dy1, nou9, w, diu9, dzn, cov1, cov5, cov9, nou2, diu2, cov2, nou3, diu3, dzs, cov3, nou4, diu4, cov4, nou6, diu6, cov6, nou7, diu7, cov7, nou8, diu8, cov8, uspd, vspd)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k))/(dx1(i)+dx1(i+1))
                                covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
                                covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
                                covc = covx1+covy1+covz1
                                dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))+(-diu2(i,j,k)+diu2(i,j+1,k))/dy1(j)+(-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
                                df = vn*dfu1(i,j,k)
                                f(i,j,k) = (-covc+df)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
                                covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k))/(dy1(j)+dy1(j+1))
                                covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
                                covc = covx1+covy1+covz1
                                dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)+2.*(-diu5(i,j,k)+diu5(i,j+1,k))/(dy1(j)+dy1(j+1))+(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
                                df = vn*dfv1(i,j,k)
                                g(i,j,k) = (-covc+df)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
                                covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
                                covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1))/(dzn(k)+dzn(k+1))
                                covc = covx1+covy1+covz1
                                dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)+(-diu8(i,j,k)+diu8(i,j+1,k))/dy1(j)+(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
                                df = vn*dfw1(i,j,k)
                                h(i,j,k) = (-covc+df)
                end do
        end do
    end do
    return 
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 88, col = 12},{<unknown>, line = 88, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

end module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map + Fold Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,cov1,cov2,cov3,cov4,cov5,cov6,cov7,cov8,cov9,data20,data21,delx1,dfu1,dfv1,dfw1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,nou1,nou2,nou3,nou4,nou5,nou6,nou7,nou8,nou9,p,rhs,ro,sm,u,uspd,usum,v,vn,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov9
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(0:ip,jp,kp), intent(Out) :: dfu1
      real(4), dimension(ip,0:jp,kp), intent(Out) :: dfv1
      real(4), dimension(ip,jp,kp), intent(Out) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), intent(In) :: vn
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
    call vel2(km, jm, im, nou1, u, diu1, dx1, nou5, v, diu5, dy1, nou9, w, diu9, dzn, cov1, cov5, cov9, nou2, diu2, cov2, nou3, diu3, dzs, cov3, nou4, diu4, cov4, nou6, diu6, cov6, nou7, diu7, cov7, nou8, diu8, cov8, uspd, vspd)
! OpenCLMap ( ["km","dy1","dzn","vn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dy1","dzn","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dy1","dzn","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k))/(dx1(i)+dx1(i+1))
    covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
    covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
    covc = covx1+covy1+covz1
    dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))+(-diu2(i,j,k)+diu2(i,j+1,k))/dy1(j)+(-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
    df = vn*dfu1(i,j,k)
    f(i,j,k) = (-covc+df)
!}
!}
!}
! OpenCLMap ( ["km","dx1","dzn","vn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dzn","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dzn","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
    covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k))/(dy1(j)+dy1(j+1))
    covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
    covc = covx1+covy1+covz1
    dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)+2.*(-diu5(i,j,k)+diu5(i,j+1,k))/(dy1(j)+dy1(j+1))+(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
    df = vn*dfv1(i,j,k)
    g(i,j,k) = (-covc+df)
!}
!}
!}
! OpenCLMap ( ["km","dx1","dy1","dzs","vn"],[],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzs","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzs","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
    covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
    covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1))/(dzn(k)+dzn(k+1))
    covc = covx1+covy1+covz1
    dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)+(-diu8(i,j,k)+diu8(i,j+1,k))/dy1(j)+(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
    df = vn*dfw1(i,j,k)
    h(i,j,k) = (-covc+df)
!}
!}
!}
    return 
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 1.0
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}
    call boundsm(km, jm, sm, im)
! OpenCLMap ( ["km","sm","dxs"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu1","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu1","uspd","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","uspd","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    F(i,j,1) = (F(i,j,1)+vfu)
!}
!}
! OpenCLMap ( ["km","sm","diu5","dx1","dys","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu5","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu5","vspd","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","vspd","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    G(i,j,1) = (G(i,j,1)+vfv)
!}
!}
! OpenCLMap ( ["km","sm","diu9","dx1","dy1","dzn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu9","dx1","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu9","dx1","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}
!}
!}
    return 
! OpenCLMap ( ["km","f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,im,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
    call bondfg(km, jm, f, im, g, h)
! OpenCLMap ( ["km","dx1","dy1","dzn","dt"],["rhs"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzn","dt"],["rhs"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzn","dt"],["rhs"],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["rhs"],["rhsav","area"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(j,1,jm,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["km","rhsav"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","rhsav"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","rhsav"],[],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50.0, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLReduce ( [],["p","sor"],["(k,1,km,1)","(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( [],["p","sor"],["(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( ["k","j","nrd"],["p","sor"],["(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
                reltmp = 1.0*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                p(i,j,k) = p(i,j,k)+reltmp
                sor = sor+reltmp*reltmp
!}
!}
!}
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<1.0e-4) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 88, col = 12},{<unknown>, line = 88, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(j,1,jm,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["km","pav"],["p"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","pav"],["p"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","pav"],["p"],["(i,1,im,1)"],[]) {
    p(i,j,k) = p(i,j,k)-pav
!}
!}
!}
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

end module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Stencil Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velfg->
	    call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "cov1", argument = VarName (fromList []) "cov1"}
	ArgTrans {parameter = ArgName (fromList []) "cov2", argument = VarName (fromList []) "cov2"}
	ArgTrans {parameter = ArgName (fromList []) "cov3", argument = VarName (fromList []) "cov3"}
	ArgTrans {parameter = ArgName (fromList []) "dfu1", argument = VarName (fromList []) "dfu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "cov4", argument = VarName (fromList []) "cov4"}
	ArgTrans {parameter = ArgName (fromList []) "cov5", argument = VarName (fromList []) "cov5"}
	ArgTrans {parameter = ArgName (fromList []) "cov6", argument = VarName (fromList []) "cov6"}
	ArgTrans {parameter = ArgName (fromList []) "dfv1", argument = VarName (fromList []) "dfv1"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "cov7", argument = VarName (fromList []) "cov7"}
	ArgTrans {parameter = ArgName (fromList []) "cov8", argument = VarName (fromList []) "cov8"}
	ArgTrans {parameter = ArgName (fromList []) "cov9", argument = VarName (fromList []) "cov9"}
	ArgTrans {parameter = ArgName (fromList []) "dfw1", argument = VarName (fromList []) "dfw1"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "nou1", argument = VarName (fromList []) "nou1"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "nou5", argument = VarName (fromList []) "nou5"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "nou9", argument = VarName (fromList []) "nou9"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "nou2", argument = VarName (fromList []) "nou2"}
	ArgTrans {parameter = ArgName (fromList []) "nou3", argument = VarName (fromList []) "nou3"}
	ArgTrans {parameter = ArgName (fromList []) "nou4", argument = VarName (fromList []) "nou4"}
	ArgTrans {parameter = ArgName (fromList []) "nou6", argument = VarName (fromList []) "nou6"}
	ArgTrans {parameter = ArgName (fromList []) "nou7", argument = VarName (fromList []) "nou7"}
	ArgTrans {parameter = ArgName (fromList []) "nou8", argument = VarName (fromList []) "nou8"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,cov1,cov2,cov3,cov4,cov5,cov6,cov7,cov8,cov9,data20,data21,delx1,dfu1,dfv1,dfw1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,nou1,nou2,nou3,nou4,nou5,nou6,nou7,nou8,nou9,p,rhs,ro,sm,u,uspd,usum,v,vn,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov9
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(0:ip,jp,kp), intent(Out) :: dfu1
      real(4), dimension(ip,0:jp,kp), intent(Out) :: dfv1
      real(4), dimension(ip,jp,kp), intent(Out) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), intent(In) :: vn
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLStencil (
!        2 point stencil on 3D array p: [[1,0,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,1,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,0,0],[0,0,1]]
!    ){
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}    
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
    call vel2(km, jm, im, nou1, u, diu1, dx1, nou5, v, diu5, dy1, nou9, w, diu9, dzn, cov1, cov5, cov9, nou2, diu2, cov2, nou3, diu3, dzs, cov3, nou4, diu4, cov4, nou6, diu6, cov6, nou7, diu7, cov7, nou8, diu8, cov8, uspd, vspd)
! OpenCLStencil (
!        2 point stencil on 3D array cov1: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array cov2: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array cov3: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["km","dy1","dzn","vn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","dy1","dzn","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["im","dy1","dzn","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k))/(dx1(i)+dx1(i+1))
    covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
    covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
    covc = covx1+covy1+covz1
    dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))+(-diu2(i,j,k)+diu2(i,j+1,k))/dy1(j)+(-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
    df = vn*dfu1(i,j,k)
    f(i,j,k) = (-covc+df)
!}    
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array cov4: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array cov5: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array cov6: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["km","dx1","dzn","vn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","dx1","dzn","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dzn","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
    covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k))/(dy1(j)+dy1(j+1))
    covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
    covc = covx1+covy1+covz1
    dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)+2.*(-diu5(i,j,k)+diu5(i,j+1,k))/(dy1(j)+dy1(j+1))+(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
    df = vn*dfv1(i,j,k)
    g(i,j,k) = (-covc+df)
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array cov7: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array cov8: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array cov9: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!        2 point stencil on 1D array dzn: [[0],[1]]
!    ){
! OpenCLMap ( ["km","dx1","dy1","dzs","vn"],[],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzs","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzs","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
    covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
    covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1))/(dzn(k)+dzn(k+1))
    covc = covx1+covy1+covz1
    dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)+(-diu8(i,j,k)+diu8(i,j+1,k))/dy1(j)+(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
    df = vn*dfw1(i,j,k)
    h(i,j,k) = (-covc+df)
!}
!}
!}    
!}
    return 
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!        4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!        4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!        4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!        4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!        4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!        4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 1.0
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}    
!}
    call boundsm(km, jm, sm, im)
! OpenCLStencil (
!        2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!        2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        3 point stencil on 1D array dzn: [[0],[1],[-1]]
!        10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["km","sm","dxs"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","sm","diu1","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["im","sm","diu1","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}    
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!        2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!        2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!        8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["jm","sm","diu1","uspd","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!    ){
! OpenCLMap ( ["im","sm","diu1","uspd","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    F(i,j,1) = (F(i,j,1)+vfu)
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!        2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        3 point stencil on 1D array dzn: [[0],[1],[-1]]
!        10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["km","sm","diu5","dx1","dys","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","sm","diu5","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!    ){
! OpenCLMap ( ["im","sm","diu5","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}    
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!        2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!        2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!        8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["jm","sm","diu5","vspd","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!    ){
! OpenCLMap ( ["im","sm","diu5","vspd","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    G(i,j,1) = (G(i,j,1)+vfv)
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!        2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!        2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        3 point stencil on 1D array dy1: [[0],[1],[-1]]
!        2 point stencil on 1D array dzn: [[0],[1]]
!        10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["km","sm","diu9","dx1","dy1","dzn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        3 point stencil on 1D array dy1: [[0],[1],[-1]]
!    ){
! OpenCLMap ( ["jm","sm","diu9","dx1","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!    ){
! OpenCLMap ( ["im","sm","diu9","dx1","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}    
!}
!}    
!}
!}    
!}
    return 
! OpenCLMap ( ["km","f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,im,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
    call bondfg(km, jm, f, im, g, h)
! OpenCLStencil (
!        2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!        2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!        2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!        2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!        2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!        2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","dx1","dy1","dzn","dt"],["rhs"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzn","dt"],["rhs"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzn","dt"],["rhs"],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}    
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["rhs"],["rhsav","area"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(j,1,jm,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["km","rhsav"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","rhsav"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","rhsav"],[],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50.0, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLStencil (
!                                7 point stencil on 3D array p: [[1,0,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!                ){
! OpenCLReduce ( [],["p","sor"],["(k,1,km,1)","(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( [],["p","sor"],["(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( ["k","j","nrd"],["p","sor"],["(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
                reltmp = 1.0*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                p(i,j,k) = p(i,j,k)+reltmp
                sor = sor+reltmp*reltmp
!}
!}
!}                
!}
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<1.0e-4) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 88, col = 12},{<unknown>, line = 88, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(j,1,jm,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["km","pav"],["p"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","pav"],["p"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","pav"],["p"],["(i,1,im,1)"],[]) {
    p(i,j,k) = p(i,j,k)-pav
!}
!}
!}
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

end module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Combined 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velfg->
	    call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "cov1", argument = VarName (fromList []) "cov1"}
	ArgTrans {parameter = ArgName (fromList []) "cov2", argument = VarName (fromList []) "cov2"}
	ArgTrans {parameter = ArgName (fromList []) "cov3", argument = VarName (fromList []) "cov3"}
	ArgTrans {parameter = ArgName (fromList []) "dfu1", argument = VarName (fromList []) "dfu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "cov4", argument = VarName (fromList []) "cov4"}
	ArgTrans {parameter = ArgName (fromList []) "cov5", argument = VarName (fromList []) "cov5"}
	ArgTrans {parameter = ArgName (fromList []) "cov6", argument = VarName (fromList []) "cov6"}
	ArgTrans {parameter = ArgName (fromList []) "dfv1", argument = VarName (fromList []) "dfv1"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "cov7", argument = VarName (fromList []) "cov7"}
	ArgTrans {parameter = ArgName (fromList []) "cov8", argument = VarName (fromList []) "cov8"}
	ArgTrans {parameter = ArgName (fromList []) "cov9", argument = VarName (fromList []) "cov9"}
	ArgTrans {parameter = ArgName (fromList []) "dfw1", argument = VarName (fromList []) "dfw1"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "nou1", argument = VarName (fromList []) "nou1"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "nou5", argument = VarName (fromList []) "nou5"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "nou9", argument = VarName (fromList []) "nou9"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "nou2", argument = VarName (fromList []) "nou2"}
	ArgTrans {parameter = ArgName (fromList []) "nou3", argument = VarName (fromList []) "nou3"}
	ArgTrans {parameter = ArgName (fromList []) "nou4", argument = VarName (fromList []) "nou4"}
	ArgTrans {parameter = ArgName (fromList []) "nou6", argument = VarName (fromList []) "nou6"}
	ArgTrans {parameter = ArgName (fromList []) "nou7", argument = VarName (fromList []) "nou7"}
	ArgTrans {parameter = ArgName (fromList []) "nou8", argument = VarName (fromList []) "nou8"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_velfg_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,cov1,cov2,cov3,cov4,cov5,cov6,cov7,cov8,cov9,data20,data21,delx1,dfu1,dfv1,dfw1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,nou1,nou2,nou3,nou4,nou5,nou6,nou7,nou8,nou9,p,rhs,ro,sm,u,uspd,usum,v,vn,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: cov9
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(0:ip,jp,kp), intent(Out) :: dfu1
      real(4), dimension(ip,0:jp,kp), intent(Out) :: dfv1
      real(4), dimension(ip,jp,kp), intent(Out) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(Out) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), intent(In) :: vn
      real(4), dimension(0:ip+1,0:jp+1), intent(Out) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLStencil (
!        2 point stencil on 3D array p: [[1,0,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dxs","dt","jm","im"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,1,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dys","dt","jm","im"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,0,0],[0,0,1]]
!    ){
! OpenCLMap ( ["km","ro","dzs","w","dt","jm","im"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}    
!}
    return 
! OpenCLMap ( ["jm"],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
! OpenCLMap ( ["km","jm"],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w","jm","im"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u","jm"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs","jm"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
! OpenCLMap ( ["km","jm","im"],["u","v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
    if (k<km) then
        w(i,0,k) = w(i,jm,k)
        w(i,jm+1,k) = w(i,1,k)
    end if
!}
! OpenCLMap ( ["jm","km","im"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
! OpenCLMap ( ["jm","im"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
    call vel2(km, jm, im, nou1, u, diu1, dx1, nou5, v, diu5, dy1, nou9, w, diu9, dzn, cov1, cov5, cov9, nou2, diu2, cov2, nou3, diu3, dzs, cov3, nou4, diu4, cov4, nou6, diu6, cov6, nou7, diu7, cov7, nou8, diu8, cov8, uspd, vspd)
! OpenCLStencil (
!        2 point stencil on 3D array cov1: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array cov2: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array cov3: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["km","dy1","dzn","vn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","dy1","dzn","vn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["im","dy1","dzn","vn"],[],["(i,1,im,1)"],[]) {
    covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k))/(dx1(i)+dx1(i+1))
    covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
    covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
    covc = covx1+covy1+covz1
    dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1))+(-diu2(i,j,k)+diu2(i,j+1,k))/dy1(j)+(-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
    df = vn*dfu1(i,j,k)
    f(i,j,k) = (-covc+df)
!}    
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array cov4: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array cov5: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array cov6: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["km","dx1","dzn","vn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","dx1","dzn","vn","im"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
    covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
    covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k))/(dy1(j)+dy1(j+1))
    covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
    covc = covx1+covy1+covz1
    dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i)+2.*(-diu5(i,j,k)+diu5(i,j+1,k))/(dy1(j)+dy1(j+1))+(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
    df = vn*dfv1(i,j,k)
    g(i,j,k) = (-covc+df)
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array cov7: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array cov8: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array cov9: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!        2 point stencil on 1D array dzn: [[0],[1]]
!    ){
! OpenCLMap ( ["km","dx1","dy1","dzs","vn","jm","im"],[],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
    covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
    covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1))/(dzn(k)+dzn(k+1))
    covc = covx1+covy1+covz1
    dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i)+(-diu8(i,j,k)+diu8(i,j+1,k))/dy1(j)+(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
    df = vn*dfw1(i,j,k)
    h(i,j,k) = (-covc+df)
!}    
!}
    return 
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta","jm","im","fx","fy","fz"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!        4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!        4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!        4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!        4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!        4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!        4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","diu1","diu5","diu9","jm","im"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 1.0
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}    
!}
    call boundsm(km, jm, sm, im)
! OpenCLStencil (
!        2 point stencil on 3D array diu1: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu2: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu3: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu4: [[1,0,0],[1,-1,0]]
!        2 point stencil on 3D array diu7: [[1,0,0],[1,0,-1]]
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        3 point stencil on 1D array dzn: [[0],[1],[-1]]
!        10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0]]
!    ){
! OpenCLMap ( ["km","sm","dxs"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","sm","diu1","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!    ){
! OpenCLMap ( ["im","sm","diu1","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}    
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu1: [[1,0,C=1],[0,0,C=1]]
!        2 point stencil on 3D array diu2: [[0,1,C=1],[0,0,C=1]]
!        2 point stencil on 3D array diu4: [[1,0,C=1],[1,-1,C=1]]
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!        8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[1,-1,C=1],[0,1,C=1],[0,0,C=1],[0,0,C=2],[0,-1,C=1]]
!    ){
! OpenCLMap ( ["jm","sm","diu1","uspd","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        2 point stencil on 1D array dx1: [[0],[1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!    ){
! OpenCLMap ( ["im","sm","diu1","uspd","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    F(i,j,1) = (F(i,j,1)+vfu)
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu2: [[0,1,0],[-1,1,0]]
!        2 point stencil on 3D array diu4: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu5: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu6: [[0,0,0],[0,0,1]]
!        2 point stencil on 3D array diu8: [[0,1,0],[0,1,-1]]
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        3 point stencil on 1D array dzn: [[0],[1],[-1]]
!        10 point stencil on 3D array sm: [[1,1,0],[1,0,0],[1,0,1],[1,0,-1],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[-1,1,0],[-1,0,0]]
!    ){
! OpenCLMap ( ["km","sm","diu5","dx1","dys","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!    ){
! OpenCLMap ( ["jm","sm","diu5","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!    ){
! OpenCLMap ( ["im","sm","diu5","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}    
!}
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu2: [[0,1,C=1],[-1,1,C=1]]
!        2 point stencil on 3D array diu4: [[1,0,C=1],[0,0,C=1]]
!        2 point stencil on 3D array diu5: [[0,1,C=1],[0,0,C=1]]
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dy1: [[0],[1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!        8 point stencil on 3D array sm: [[1,1,C=1],[1,0,C=1],[1,0,C=2],[0,1,C=1],[0,0,C=1],[0,0,C=2],[-1,1,C=1],[-1,0,C=1]]
!    ){
! OpenCLMap ( ["jm","sm","diu5","vspd","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        2 point stencil on 1D array dzn: [[C=1],[C=2]]
!    ){
! OpenCLMap ( ["im","sm","diu5","vspd","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    G(i,j,1) = (G(i,j,1)+vfv)
!}    
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array diu3: [[0,0,1],[-1,0,1]]
!        2 point stencil on 3D array diu6: [[0,0,1],[0,-1,1]]
!        2 point stencil on 3D array diu7: [[1,0,0],[0,0,0]]
!        2 point stencil on 3D array diu8: [[0,1,0],[0,0,0]]
!        2 point stencil on 3D array diu9: [[0,0,0],[0,0,1]]
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        3 point stencil on 1D array dy1: [[0],[1],[-1]]
!        2 point stencil on 1D array dzn: [[0],[1]]
!        10 point stencil on 3D array sm: [[1,0,0],[1,0,1],[0,1,0],[0,1,1],[0,0,0],[0,0,1],[0,-1,0],[0,-1,1],[-1,0,0],[-1,0,1]]
!    ){
! OpenCLMap ( ["km","sm","diu9","dx1","dy1","dzn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!        3 point stencil on 1D array dy1: [[0],[1],[-1]]
!    ){
! OpenCLMap ( ["jm","sm","diu9","dx1","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLStencil (
!        3 point stencil on 1D array dx1: [[0],[1],[-1]]
!    ){
! OpenCLMap ( ["im","sm","diu9","dx1","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}    
!}
!}    
!}
!}    
!}
    return 
! OpenCLMap ( ["km","f","g","h","fold","gold","hold","jm","im"],["f","g","h"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
    call bondfg(km, jm, f, im, g, h)
! OpenCLStencil (
!        2 point stencil on 3D array f: [[0,0,0],[-1,0,0]]
!        2 point stencil on 3D array g: [[0,0,0],[0,-1,0]]
!        2 point stencil on 3D array h: [[0,0,0],[0,0,-1]]
!        2 point stencil on 3D array u: [[0,0,0],[-1,0,0]]
!        2 point stencil on 3D array v: [[0,0,0],[0,-1,0]]
!        2 point stencil on 3D array w: [[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","dx1","dy1","dzn","dt","jm","im"],["rhs"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}    
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["rhs","dx1","dy1","dzn"],["rhsav","area"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
    rhsav = rhsav/area
! OpenCLMap ( ["km","rhsav","jm","im"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
    do l = 1, 50.0, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLStencil (
!                                7 point stencil on 3D array p: [[1,0,0],[0,1,0],[0,0,0],[0,0,1],[0,0,-1],[0,-1,0],[-1,0,0]]
!                ){
! OpenCLReduce ( ["k","j","nrd"],["p","sor"],["(k,1,km,1)","(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
                reltmp = 1.0*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                p(i,j,k) = p(i,j,k)+reltmp
                sor = sor+reltmp*reltmp
!}                
!}
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<1.0e-4) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 88, col = 12},{<unknown>, line = 88, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
    pav = pav/pco
! OpenCLMap ( ["km","pav","jm","im"],["p"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)"],[]) {
    p(i,j,k) = p(i,j,k)-pav
!}
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_velfg_feedbf_les_adam_press_merged

end module module_velnw_bondv1_velfg_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

