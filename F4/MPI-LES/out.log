
================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	adam
	bondv1
	feedbf
	les
	press
	velFG
	velnw
File containing main subroutine: 
	main.f95
Source directory:
	./src
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: WV_OPENCL, WV_NEW, NO_GLOBAL_SOR, INLINE_BOUND_CALCS, WV_TEST, TWINNED_BUFFER, NO_IO, IFBF=1, IADAM=0, 
CPP Excludes:

cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/main_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/init_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/grid_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/set_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/timdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/aveflow_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/ifdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_data24_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/communication_helper_mpi_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/communication_common_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/fortran_helper_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/main.f95
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/adam.f95
Parsing ./src/bondv1.f95
Parsing ./src/feedbf.f95
Parsing ./src/les.f95
Parsing ./src/press.f95
Parsing ./src/velnw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: adam
Filename: ./src/adam.f95
Source:
subroutine adam(n,nmax,data21,fold,im,jm,km,gold,hold,fghold,f,g,h)
      character*70, intent(In) :: data21
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
end subroutine adam

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: bondv1
Filename: ./src/bondv1.f95
Source:
subroutine bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      integer, intent(In) :: im,jm,km,n
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:kp+2), intent(In) :: z2
      real(4) :: u_val
      integer :: i,j,k
      real(4) :: aaa,bbb,uout
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: feedbf
Filename: ./src/feedbf.f95
Source:
subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,dt,beta,fx,fy,fz,f,g,h)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
end subroutine feedbf

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: les
Filename: ./src/les.f95
Source:
subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,uspd,vspd,dxs,dys)
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
end subroutine les

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: press
Filename: ./src/press.f95
Source:
subroutine press(km,jm,im,rhs,u,dx1,v,dy1,w,dzn,f,g,h,dt,cn1,cn2l,p,cn2s,cn3l,cn3s,cn4l,cn4s,n,nmax,data20,usum,vsum,wsum)
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: wsum
      integer :: nn
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine press

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw
Filename: ./src/velnw.f95
Source:
subroutine velnw(km,jm,im,p,ro,dxs,u,dt,f,dys,v,g,dzs,w,h)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(In) :: p
      real(4), intent(In) :: ro
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
end subroutine velnw

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_feedbf_les_adam_press_merged

end module module_velnw_bondv1_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map + Fold Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 1.0
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}
    call boundsm(km, jm, sm, im)
! OpenCLMap ( ["km","sm","diu1","dxs","dy1","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu1","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu1","uspd","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","uspd","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    F(i,j,1) = (F(i,j,1)+vfu)
!}
!}
! OpenCLMap ( ["km","sm","diu5","dx1","dys","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu5","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu5","vspd","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","vspd","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    G(i,j,1) = (G(i,j,1)+vfv)
!}
!}
! OpenCLMap ( ["km","sm","diu9","dx1","dy1","dzn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu9","dx1","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu9","dx1","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}
!}
!}
    return 
! OpenCLMap ( ["km","f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,im,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
    call bondfg(km, jm, f, im, g, h)
! OpenCLMap ( ["km","dx1","dy1","dzn","dt"],["rhs"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzn","dt"],["rhs"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzn","dt"],["rhs"],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(j,1,jm,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["km","rhsav"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","rhsav"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","rhsav"],[],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50.0, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLReduce ( [],["p","sor"],["(k,1,km,1)","(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( [],["p","sor"],["(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( ["k","j","nrd"],["p","sor"],["(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
                reltmp = 1.0*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                p(i,j,k) = p(i,j,k)+reltmp
                sor = sor+reltmp*reltmp
!}
!}
!}
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<1.0e-4) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(j,1,jm,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["km","pav"],["p"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","pav"],["p"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","pav"],["p"],["(i,1,im,1)"],[]) {
    p(i,j,k) = p(i,j,k)-pav
!}
!}
!}
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_feedbf_les_adam_press_merged

end module module_velnw_bondv1_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Stencil Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLStencil (
!        2 point stencil on 3D array p: [[1,0,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,1,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,0,0],[0,0,1]]
!    ){
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}    
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!        4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!        4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!        4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!        4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!        4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!        4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+./src/grid_tmp.f95:53:9: warning: missing terminating ' character
 !WV: let's set the *whole* array to this value!
         ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’

================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	adam
	bondv1
	feedbf
	les
	press
	velFG
	velnw
File containing main subroutine: 
	main.f95
Source directory:
	./src
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: WV_OPENCL, WV_NEW, NO_GLOBAL_SOR, INLINE_BOUND_CALCS, WV_TEST, TWINNED_BUFFER, NO_IO, IFBF=1, IADAM=0, 
CPP Excludes:

cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/main_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/init_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/grid_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/set_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/timdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/aveflow_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/ifdata_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | gr./src/velnw_tmp.f95:23:17: warning: missing terminating ' character
 ! Which means it's the values of f,g,h that are changing. g seems fine.
                 ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
ep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_data24_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/communication_helper_mpi_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/communication_common_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/fortran_helper_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW["adam","bondv1","feedbf","les","press","velFG","velnw"]
./src/velnw_tmp.f95:23:17: warning: missing terminating ' character
 ! Which means it's the values of f,g,h that are changing. g seems fine.
                 ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
["adam","bondv1","feedbf","les","press","velFG","velnw"]
 -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/main.f95
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./src/adam.f95
Parsing ./src/bondv1.f95
Parsing ./src/feedbf.f95
Parsing ./src/les.f95
Parsing ./src/press.f95
Parsing ./src/velnw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_["adam","bondv1","feedbf","les","press","velFG","velnw"]
x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: adam
Filename: ./src/adam.f95
Source:
subroutine adam(n,nmax,data21,fold,im,jm,km,gold,hold,fghold,f,g,h)
      character*70, intent(In) :: data21
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
end subroutine adam

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: bondv1
Filename: ./src/bondv1.f95
Source:
subroutine bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      integer, intent(In) :: im,jm,km,n
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:kp+2), intent(In) :: z2
      real(4) :: u_val
      integer :: i,j,k
      real(4) :: aaa,bbb,uout
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: feedbf
Filename: ./src/feedbf.f95
Source:
subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,dt,beta,fx,fy,fz,f,g,h)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
end subroutine feedbf

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: les
Filename: ./src/les.f95
Source:
subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,uspd,vspd,dxs,dys)
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
end subroutine les

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: press
Filename: ./src/press.f95
Source:
subroutine press(km,jm,im,rhs,u,dx1,v,dy1,w,dzn,f,g,h,dt,cn1,cn2l,p,cn2s,cn3l,cn3s,cn4l,cn4s,n,nmax,data20,usum,vsum,wsum)
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: wsum
      integer :: nn
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine press

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw
Filename: ./src/velnw.f95
Source:
subroutine velnw(km,jm,im,p,ro,dxs,u,dt,f,dys,v,g,dzs,w,h)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(In) :: p
      real(4), intent(In) :: ro
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
end subroutine velnw

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_feedbf_les_adam_press_merged

end module module_velnw_bondv1_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map + Fold Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 1.0
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}
    call boundsm(km, jm, sm, im)
! OpenCLMap ( ["km","sm","diu1","dxs","dy1","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu1","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu1","uspd","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","uspd","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    F(i,j,1) = (F(i,j,1)+vfu)
!}
!}
! OpenCLMap ( ["km","sm","diu5","dx1","dys","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu5","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu5","vspd","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","vspd","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    G(i,j,1) = (G(i,j,1)+vfv)
!}
!}
! OpenCLMap ( ["km","sm","diu9","dx1","dy1","dzn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu9","dx1","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu9","dx1","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}
!}
!}
    return 
! OpenCLMap ( ["km","f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,im,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
    call bondfg(km, jm, f, im, g, h)
! OpenCLMap ( ["km","dx1","dy1","dzn","dt"],["rhs"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzn","dt"],["rhs"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzn","dt"],["rhs"],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(j,1,jm,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["km","rhsav"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","rhsav"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","rhsav"],[],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50.0, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLReduce ( [],["p","sor"],["(k,1,km,1)","(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( [],["p","sor"],["(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( ["k","j","nrd"],["p","sor"],["(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
                reltmp = 1.0*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                p(i,j,k) = p(i,j,k)+reltmp
                sor = sor+reltmp*reltmp
!}
!}
!}
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<1.0e-4) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(j,1,jm,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["km","pav"],["p"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","pav"],["p"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","pav"],["p"],["(i,1,im,1)"],[]) {
    p(i,j,k) = p(i,j,k)-pav
!}
!}
!}
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_feedbf_les_adam_press_merged

end module module_velnw_bondv1_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Stencil Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLStencil (
!        2 point stencil on 3D array p: [[1,0,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,1,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,0,0],[0,0,1]]
!    ){
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}    
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!        4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!        4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!        4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!        4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!        4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!        4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+F4-exe: Unimplemented Fortran Statement OpenCLStencil (fromList []) (No source location,No source location) [Stencil (fromList []) 1 2 [[0],[1]] (VarName (fromList [("msak",[])]) "dx1")] (OpenCLMap (fromList [("ParallelFortran: Map at 56:6",[""])]) ({generated, line = 56, col = 6},{generated, line = 79, col = 12}) [VarName (fromList [("msak",[])]) "im",VarName (fromList [("msak",[])]) "sm",VarName (fromList [("msak",[])]) "diu1",VarName (fromList [("msak",[])]) "dxs",VarName (fromList [("msak",[])]) "dy1",VarName (fromList [("msak",[])]) "dzn"] [] [(VarName (fromList []) "i",Con (fromList []) ({<unknown>, line = 56, col = 13},{<unknown>, line = 56, col = 14}) "1",Var (fromList []) ({<unknown>, line = 56, col = 15},{<unknown>, line = 56, col = 17}) [(VarName (fromList [("msak",[])]) "im",[])],Con (fromList []) ({<unknown>, line = 56, col = 17},{<unknown>, line = 56, col = 17}) "1")] [] (FSeq (fromList []) ({<unknown>, line = 57, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 57, col = 6},{<unknown>, line = 57, col = 25}) (Var (fromList []) ({<unknown>, line = 57, col = 6},{<unknown>, line = 57, col = 12}) [(VarName (fromList []) "evsx2",[])]) (Var (fromList []) ({<unknown>, line = 57, col = 14},{<unknown>, line = 57, col = 25}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 57, col = 17},{<unknown>, line = 57, col = 20}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 57, col = 17},{<unknown>, line = 57, col = 18}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 57, col = 19},{<unknown>, line = 57, col = 20}) "1"),Var (fromList []) ({<unknown>, line = 57, col = 21},{<unknown>, line = 57, col = 22}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 57, col = 23},{<unknown>, line = 57, col = 24}) [(VarName (fromList []) "k",[])]])])) (FSeq (fromList []) ({<unknown>, line = 58, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 58, col = 6},{<unknown>, line = 58, col = 23}) (Var (fromList []) ({<unknown>, line = 58, col = 6},{<unknown>, line = 58, col = 12}) [(VarName (fromList []) "evsx1",[])]) (Var (fromList []) ({<unknown>, line = 58, col = 14},{<unknown>, line = 58, col = 23}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 58, col = 17},{<unknown>, line = 58, col = 18}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 58, col = 19},{<unknown>, line = 58, col = 20}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 58, col = 21},{<unknown>, line = 58, col = 22}) [(VarName (fromList []) "k",[])]])])) (FSeq (fromList []) ({<unknown>, line = 59, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 59, col = 6},{<unknown>, line = 61, col = 49}) (Var (fromList []) ({<unknown>, line = 59, col = 6},{<unknown>, line = 59, col = 12}) [(VarName (fromList []) "evsy2",[])]) (Bin (fromList []) ({<unknown>, line = 59, col = 14},{<unknown>, line = 61, col = 49}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 59, col = 14},{<unknown>, line = 61, col = 31}) (Bin (fromList []) ({<unknown>, line = 59, col = 15},{<unknown>, line = 61, col = 29}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 59, col = 15},{<unknown>, line = 60, col = 30}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 15},{<unknown>, line = 59, col = 23}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 59, col = 19},{<unknown>, line = 59, col = 22}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 19},{<unknown>, line = 59, col = 20}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 59, col = 21},{<unknown>, line = 59, col = 22}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 59, col = 24},{<unknown>, line = 60, col = 30}) (Bin (fromList []) ({<unknown>, line = 59, col = 25},{<unknown>, line = 60, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 59, col = 25},{<unknown>, line = 60, col = 10}) (Bin (fromList []) ({<unknown>, line = 59, col = 26},{<unknown>, line = 60, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 59, col = 26},{<unknown>, line = 59, col = 44}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 26},{<unknown>, line = 59, col = 34}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 59, col = 30},{<unknown>, line = 59, col = 33}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 30},{<unknown>, line = 59, col = 31}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 59, col = 32},{<unknown>, line = 59, col = 33}) "1")])]) (Var (fromList []) ({<unknown>, line = 59, col = 35},{<unknown>, line = 59, col = 44}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 59, col = 38},{<unknown>, line = 59, col = 39}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 59, col = 40},{<unknown>, line = 59, col = 41}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 59, col = 42},{<unknown>, line = 59, col = 43}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 59, col = 45},{<unknown>, line = 60, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 45},{<unknown>, line = 59, col = 51}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 59, col = 49},{<unknown>, line = 59, col = 50}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 59, col = 52},{<unknown>, line = 60, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 59, col = 55},{<unknown>, line = 59, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 55},{<unknown>, line = 59, col = 56}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 59, col = 57},{<unknown>, line = 59, col = 58}) "1"),Var (fromList []) ({<unknown>, line = 59, col = 59},{<unknown>, line = 59, col = 60}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 60, col = 6},{<unknown>, line = 60, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 60, col = 11},{<unknown>, line = 60, col = 28}) (Bin (fromList []) ({<unknown>, line = 60, col = 12},{<unknown>, line = 60, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 12},{<unknown>, line = 60, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 60, col = 16},{<unknown>, line = 60, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 60, col = 19},{<unknown>, line = 60, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 60, col = 23},{<unknown>, line = 60, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 23},{<unknown>, line = 60, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 25},{<unknown>, line = 60, col = 26}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 60, col = 31},{<unknown>, line = 61, col = 29}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 31},{<unknown>, line = 60, col = 37}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 60, col = 35},{<unknown>, line = 60, col = 36}) [(VarName (fromList []) "j",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 60, col = 38},{<unknown>, line = 61, col = 29}) (Bin (fromList []) ({<unknown>, line = 60, col = 39},{<unknown>, line = 61, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 60, col = 39},{<unknown>, line = 61, col = 10}) (Bin (fromList []) ({<unknown>, line = 60, col = 40},{<unknown>, line = 61, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 60, col = 40},{<unknown>, line = 60, col = 60}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 40},{<unknown>, line = 60, col = 48}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 60, col = 44},{<unknown>, line = 60, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 44},{<unknown>, line = 60, col = 45}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 46},{<unknown>, line = 60, col = 47}) "1")])]) (Var (fromList []) ({<unknown>, line = 60, col = 49},{<unknown>, line = 60, col = 60}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 60, col = 52},{<unknown>, line = 60, col = 53}) [(VarName (fromList []) "i",[])],Bin (fromList []) ({<unknown>, line = 60, col = 54},{<unknown>, line = 60, col = 57}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 54},{<unknown>, line = 60, col = 55}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 56},{<unknown>, line = 60, col = 57}) "1"),Var (fromList []) ({<unknown>, line = 60, col = 58},{<unknown>, line = 60, col = 59}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 60, col = 61},{<unknown>, line = 61, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 61},{<unknown>, line = 60, col = 67}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 60, col = 65},{<unknown>, line = 60, col = 66}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 60, col = 68},{<unknown>, line = 61, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 60, col = 71},{<unknown>, line = 60, col = 74}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 71},{<unknown>, line = 60, col = 72}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 73},{<unknown>, line = 60, col = 74}) "1"),Bin (fromList []) ({<unknown>, line = 60, col = 75},{<unknown>, line = 60, col = 78}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 75},{<unknown>, line = 60, col = 76}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 77},{<unknown>, line = 60, col = 78}) "1"),Var (fromList []) ({<unknown>, line = 61, col = 6},{<unknown>, line = 61, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 61, col = 11},{<unknown>, line = 61, col = 28}) (Bin (fromList []) ({<unknown>, line = 61, col = 12},{<unknown>, line = 61, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 12},{<unknown>, line = 61, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 61, col = 16},{<unknown>, line = 61, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 61, col = 19},{<unknown>, line = 61, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 61, col = 23},{<unknown>, line = 61, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 23},{<unknown>, line = 61, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 61, col = 25},{<unknown>, line = 61, col = 26}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 61, col = 32},{<unknown>, line = 61, col = 49}) (Bin (fromList []) ({<unknown>, line = 61, col = 33},{<unknown>, line = 61, col = 48}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 33},{<unknown>, line = 61, col = 39}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 61, col = 37},{<unknown>, line = 61, col = 38}) [(VarName (fromList []) "j",[])]])]) (Var (fromList []) ({<unknown>, line = 61, col = 40},{<unknown>, line = 61, col = 48}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 61, col = 44},{<unknown>, line = 61, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 44},{<unknown>, line = 61, col = 45}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 61, col = 46},{<unknown>, line = 61, col = 47}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 62, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 62, col = 6},{<unknown>, line = 64, col = 49}) (Var (fromList []) ({<unknown>, line = 62, col = 6},{<unknown>, line = 62, col = 12}) [(VarName (fromList []) "evsy1",[])]) (Bin (fromList []) ({<unknown>, line = 62, col = 14},{<unknown>, line = 64, col = 49}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 62, col = 14},{<unknown>, line = 64, col = 31}) (Bin (fromList []) ({<unknown>, line = 62, col = 15},{<unknown>, line = 64, col = 29}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 62, col = 15},{<unknown>, line = 63, col = 30}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 15},{<unknown>, line = 62, col = 23}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 62, col = 19},{<unknown>, line = 62, col = 22}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 19},{<unknown>, line = 62, col = 20}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 21},{<unknown>, line = 62, col = 22}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 62, col = 24},{<unknown>, line = 63, col = 30}) (Bin (fromList []) ({<unknown>, line = 62, col = 25},{<unknown>, line = 63, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 62, col = 25},{<unknown>, line = 63, col = 10}) (Bin (fromList []) ({<unknown>, line = 62, col = 26},{<unknown>, line = 63, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 62, col = 26},{<unknown>, line = 62, col = 46}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 26},{<unknown>, line = 62, col = 34}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 62, col = 30},{<unknown>, line = 62, col = 33}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 30},{<unknown>, line = 62, col = 31}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 32},{<unknown>, line = 62, col = 33}) "1")])]) (Var (fromList []) ({<unknown>, line = 62, col = 35},{<unknown>, line = 62, col = 46}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 62, col = 38},{<unknown>, line = 62, col = 39}) [(VarName (fromList []) "i",[])],Bin (fromList []) ({<unknown>, line = 62, col = 40},{<unknown>, line = 62, col = 43}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 40},{<unknown>, line = 62, col = 41}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 42},{<unknown>, line = 62, col = 43}) "1"),Var (fromList []) ({<unknown>, line = 62, col = 44},{<unknown>, line = 62, col = 45}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 62, col = 47},{<unknown>, line = 63, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 47},{<unknown>, line = 62, col = 53}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 62, col = 51},{<unknown>, line = 62, col = 52}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 62, col = 54},{<unknown>, line = 63, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 62, col = 57},{<unknown>, line = 62, col = 60}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 57},{<unknown>, line = 62, col = 58}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 59},{<unknown>, line = 62, col = 60}) "1"),Bin (fromList []) ({<unknown>, line = 62, col = 61},{<unknown>, line = 62, col = 64}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 61},{<unknown>, line = 62, col = 62}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 63},{<unknown>, line = 62, col = 64}) "1"),Var (fromList []) ({<unknown>, line = 63, col = 6},{<unknown>, line = 63, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 63, col = 11},{<unknown>, line = 63, col = 28}) (Bin (fromList []) ({<unknown>, line = 63, col = 12},{<unknown>, line = 63, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 12},{<unknown>, line = 63, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 63, col = 16},{<unknown>, line = 63, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 63, col = 19},{<unknown>, line = 63, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 63, col = 23},{<unknown>, line = 63, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 23},{<unknown>, line = 63, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 63, col = 25},{<unknown>, line = 63, col = 26}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 63, col = 31},{<unknown>, line = 64, col = 29}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 31},{<unknown>, line = 63, col = 37}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 63, col = 35},{<unknown>, line = 63, col = 36}) [(VarName (fromList []) "j",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 63, col = 38},{<unknown>, line = 64, col = 29}) (Bin (fromList []) ({<unknown>, line = 63, col = 39},{<unknown>, line = 64, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 63, col = 39},{<unknown>, line = 64, col = 10}) (Bin (fromList []) ({<unknown>, line = 63, col = 40},{<unknown>, line = 64, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 63, col = 40},{<unknown>, line = 63, col = 58}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 40},{<unknown>, line = 63, col = 48}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 63, col = 44},{<unknown>, line = 63, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 44},{<unknown>, line = 63, col = 45}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 63, col = 46},{<unknown>, line = 63, col = 47}) "1")])]) (Var (fromList []) ({<unknown>, line = 63, col = 49},{<unknown>, line = 63, col = 58}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 63, col = 52},{<unknown>, line = 63, col = 53}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 63, col = 54},{<unknown>, line = 63, col = 55}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 63, col = 56},{<unknown>, line = 63, col = 57}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 63, col = 59},{<unknown>, line = 64, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 59},{<unknown>, line = 63, col = 65}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 63, col = 63},{<unknown>, line = 63, col = 64}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 63, col = 66},{<unknown>, line = 64, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 63, col = 69},{<unknown>, line = 63, col = 72}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 69},{<unknown>, line = 63, col = 70}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 63, col = 71},{<unknown>, line = 63, col = 72}) "1"),Var (fromList []) ({<unknown>, line = 63, col = 73},{<unknown>, line = 63, col = 74}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 64, col = 6},{<unknown>, line = 64, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 64, col = 11},{<unknown>, line = 64, col = 28}) (Bin (fromList []) ({<unknown>, line = 64, col = 12},{<unknown>, line = 64, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 12},{<unknown>, line = 64, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 64, col = 16},{<unknown>, line = 64, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 64, col = 19},{<unknown>, line = 64, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 64, col = 23},{<unknown>, line = 64, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 23},{<unknown>, line = 64, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 64, col = 25},{<unknown>, line = 64, col = 26}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 64, col = 32},{<unknown>, line = 64, col = 49}) (Bin (fromList []) ({<unknown>, line = 64, col = 33},{<unknown>, line = 64, col = 48}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 33},{<unknown>, line = 64, col = 39}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 64, col = 37},{<unknown>, line = 64, col = 38}) [(VarName (fromList []) "j",[])]])]) (Var (fromList []) ({<unknown>, line = 64, col = 40},{<unknown>, line = 64, col = 48}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 64, col = 44},{<unknown>, line = 64, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 44},{<unknown>, line = 64, col = 45}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 64, col = 46},{<unknown>, line = 64, col = 47}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 65, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 65, col = 6},{<unknown>, line = 67, col = 51}) (Var (fromList []) ({<unknown>, line = 65, col = 6},{<unknown>, line = 65, col = 12}) [(VarName (fromList []) "evsz2",[])]) (Bin (fromList []) ({<unknown>, line = 65, col = 14},{<unknown>, line = 67, col = 51}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 65, col = 14},{<unknown>, line = 67, col = 33}) (Bin (fromList []) ({<unknown>, line = 65, col = 15},{<unknown>, line = 67, col = 31}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 65, col = 15},{<unknown>, line = 66, col = 30}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 15},{<unknown>, line = 65, col = 23}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 65, col = 19},{<unknown>, line = 65, col = 22}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 19},{<unknown>, line = 65, col = 20}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 65, col = 21},{<unknown>, line = 65, col = 22}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 65, col = 24},{<unknown>, line = 66, col = 30}) (Bin (fromList []) ({<unknown>, line = 65, col = 25},{<unknown>, line = 66, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 65, col = 25},{<unknown>, line = 66, col = 10}) (Bin (fromList []) ({<unknown>, line = 65, col = 26},{<unknown>, line = 66, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 65, col = 26},{<unknown>, line = 65, col = 44}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 26},{<unknown>, line = 65, col = 34}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 65, col = 30},{<unknown>, line = 65, col = 33}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 30},{<unknown>, line = 65, col = 31}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 65, col = 32},{<unknown>, line = 65, col = 33}) "1")])]) (Var (fromList []) ({<unknown>, line = 65, col = 35},{<unknown>, line = 65, col = 44}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 65, col = 38},{<unknown>, line = 65, col = 39}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 65, col = 40},{<unknown>, line = 65, col = 41}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 65, col = 42},{<unknown>, line = 65, col = 43}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 65, col = 45},{<unknown>, line = 66, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 45},{<unknown>, line = 65, col = 51}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 65, col = 49},{<unknown>, line = 65, col = 50}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 65, col = 52},{<unknown>, line = 66, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 65, col = 55},{<unknown>, line = 65, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 55},{<unknown>, line = 65, col = 56}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 65, col = 57},{<unknown>, line = 65, col = 58}) "1"),Var (fromList []) ({<unknown>, line = 65, col = 59},{<unknown>, line = 65, col = 60}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 66, col = 6},{<unknown>, line = 66, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 66, col = 11},{<unknown>, line = 66, col = 28}) (Bin (fromList []) ({<unknown>, line = 66, col = 12},{<unknown>, line = 66, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 12},{<unknown>, line = 66, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 66, col = 16},{<unknown>, line = 66, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 66, col = 19},{<unknown>, line = 66, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 66, col = 23},{<unknown>, line = 66, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 23},{<unknown>, line = 66, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 25},{<unknown>, line = 66, col = 26}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 66, col = 31},{<unknown>, line = 67, col = 31}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 31},{<unknown>, line = 66, col = 37}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 66, col = 35},{<unknown>, line = 66, col = 36}) [(VarName (fromList []) "k",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 66, col = 38},{<unknown>, line = 67, col = 31}) (Bin (fromList []) ({<unknown>, line = 66, col = 39},{<unknown>, line = 67, col = 30}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 66, col = 39},{<unknown>, line = 67, col = 12}) (Bin (fromList []) ({<unknown>, line = 66, col = 40},{<unknown>, line = 67, col = 10}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 66, col = 40},{<unknown>, line = 66, col = 60}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 40},{<unknown>, line = 66, col = 48}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 66, col = 44},{<unknown>, line = 66, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 44},{<unknown>, line = 66, col = 45}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 46},{<unknown>, line = 66, col = 47}) "1")])]) (Var (fromList []) ({<unknown>, line = 66, col = 49},{<unknown>, line = 66, col = 60}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 66, col = 52},{<unknown>, line = 66, col = 53}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 66, col = 54},{<unknown>, line = 66, col = 55}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 66, col = 56},{<unknown>, line = 66, col = 59}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 56},{<unknown>, line = 66, col = 57}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 58},{<unknown>, line = 66, col = 59}) "1")])])) (Bin (fromList []) ({<unknown>, line = 66, col = 61},{<unknown>, line = 67, col = 10}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 61},{<unknown>, line = 66, col = 67}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 66, col = 65},{<unknown>, line = 66, col = 66}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 66, col = 68},{<unknown>, line = 67, col = 10}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 66, col = 71},{<unknown>, line = 66, col = 74}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 71},{<unknown>, line = 66, col = 72}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 73},{<unknown>, line = 66, col = 74}) "1"),Var (fromList []) ({<unknown>, line = 66, col = 75},{<unknown>, line = 66, col = 76}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 67, col = 6},{<unknown>, line = 67, col = 9}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 6},{<unknown>, line = 67, col = 7}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 67, col = 8},{<unknown>, line = 67, col = 9}) "1")])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 67, col = 13},{<unknown>, line = 67, col = 30}) (Bin (fromList []) ({<unknown>, line = 67, col = 14},{<unknown>, line = 67, col = 29}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 14},{<unknown>, line = 67, col = 20}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 67, col = 18},{<unknown>, line = 67, col = 19}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 67, col = 21},{<unknown>, line = 67, col = 29}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 67, col = 25},{<unknown>, line = 67, col = 28}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 25},{<unknown>, line = 67, col = 26}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 67, col = 27},{<unknown>, line = 67, col = 28}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 67, col = 34},{<unknown>, line = 67, col = 51}) (Bin (fromList []) ({<unknown>, line = 67, col = 35},{<unknown>, line = 67, col = 50}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 35},{<unknown>, line = 67, col = 41}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 67, col = 39},{<unknown>, line = 67, col = 40}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 67, col = 42},{<unknown>, line = 67, col = 50}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 67, col = 46},{<unknown>, line = 67, col = 49}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 46},{<unknown>, line = 67, col = 47}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 67, col = 48},{<unknown>, line = 67, col = 49}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 68, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 68, col = 6},{<unknown>, line = 70, col = 49}) (Var (fromList []) ({<unknown>, line = 68, col = 6},{<unknown>, line = 68, col = 12}) [(VarName (fromList []) "evsz1",[])]) (Bin (fromList []) ({<unknown>, line = 68, col = 14},{<unknown>, line = 70, col = 49}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 68, col = 14},{<unknown>, line = 70, col = 31}) (Bin (fromList []) ({<unknown>, line = 68, col = 15},{<unknown>, line = 70, col = 29}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 68, col = 15},{<unknown>, line = 69, col = 32}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 15},{<unknown>, line = 68, col = 21}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 68, col = 19},{<unknown>, line = 68, col = 20}) [(VarName (fromList []) "k",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 68, col = 22},{<unknown>, line = 69, col = 32}) (Bin (fromList []) ({<unknown>, line = 68, col = 23},{<unknown>, line = 69, col = 30}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 68, col = 23},{<unknown>, line = 69, col = 12}) (Bin (fromList []) ({<unknown>, line = 68, col = 24},{<unknown>, line = 69, col = 10}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 68, col = 24},{<unknown>, line = 68, col = 44}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 24},{<unknown>, line = 68, col = 32}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 68, col = 28},{<unknown>, line = 68, col = 31}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 28},{<unknown>, line = 68, col = 29}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 68, col = 30},{<unknown>, line = 68, col = 31}) "1")])]) (Var (fromList []) ({<unknown>, line = 68, col = 33},{<unknown>, line = 68, col = 44}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 68, col = 36},{<unknown>, line = 68, col = 37}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 68, col = 38},{<unknown>, line = 68, col = 39}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 68, col = 40},{<unknown>, line = 68, col = 43}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 40},{<unknown>, line = 68, col = 41}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 68, col = 42},{<unknown>, line = 68, col = 43}) "1")])])) (Bin (fromList []) ({<unknown>, line = 68, col = 45},{<unknown>, line = 69, col = 10}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 45},{<unknown>, line = 68, col = 51}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 68, col = 49},{<unknown>, line = 68, col = 50}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 68, col = 52},{<unknown>, line = 69, col = 10}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 68, col = 55},{<unknown>, line = 68, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 55},{<unknown>, line = 68, col = 56}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 68, col = 57},{<unknown>, line = 68, col = 58}) "1"),Var (fromList []) ({<unknown>, line = 68, col = 59},{<unknown>, line = 68, col = 60}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 69, col = 6},{<unknown>, line = 69, col = 9}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 6},{<unknown>, line = 69, col = 7}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 8},{<unknown>, line = 69, col = 9}) "1")])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 69, col = 13},{<unknown>, line = 69, col = 30}) (Bin (fromList []) ({<unknown>, line = 69, col = 14},{<unknown>, line = 69, col = 29}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 14},{<unknown>, line = 69, col = 20}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 69, col = 18},{<unknown>, line = 69, col = 19}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 69, col = 21},{<unknown>, line = 69, col = 29}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 69, col = 25},{<unknown>, line = 69, col = 28}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 25},{<unknown>, line = 69, col = 26}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 27},{<unknown>, line = 69, col = 28}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 69, col = 33},{<unknown>, line = 70, col = 29}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 33},{<unknown>, line = 69, col = 41}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 69, col = 37},{<unknown>, line = 69, col = 40}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 37},{<unknown>, line = 69, col = 38}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 39},{<unknown>, line = 69, col = 40}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 69, col = 42},{<unknown>, line = 70, col = 29}) (Bin (fromList []) ({<unknown>, line = 69, col = 43},{<unknown>, line = 70, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 69, col = 43},{<unknown>, line = 70, col = 10}) (Bin (fromList []) ({<unknown>, line = 69, col = 44},{<unknown>, line = 70, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 69, col = 44},{<unknown>, line = 69, col = 62}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 44},{<unknown>, line = 69, col = 52}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 69, col = 48},{<unknown>, line = 69, col = 51}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 48},{<unknown>, line = 69, col = 49}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 50},{<unknown>, line = 69, col = 51}) "1")])]) (Var (fromList []) ({<unknown>, line = 69, col = 53},{<unknown>, line = 69, col = 62}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 69, col = 56},{<unknown>, line = 69, col = 57}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 69, col = 58},{<unknown>, line = 69, col = 59}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 69, col = 60},{<unknown>, line = 69, col = 61}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 69, col = 63},{<unknown>, line = 70, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 63},{<unknown>, line = 69, col = 69}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 69, col = 67},{<unknown>, line = 69, col = 68}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 69, col = 70},{<unknown>, line = 70, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 69, col = 73},{<unknown>, line = 69, col = 76}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 73},{<unknown>, line = 69, col = 74}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 75},{<unknown>, line = 69, col = 76}) "1"),Var (fromList []) ({<unknown>, line = 69, col = 77},{<unknown>, line = 69, col = 78}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 70, col = 6},{<unknown>, line = 70, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 70, col = 11},{<unknown>, line = 70, col = 28}) (Bin (fromList []) ({<unknown>, line = 70, col = 12},{<unknown>, line = 70, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 12},{<unknown>, line = 70, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 70, col = 16},{<unknown>, line = 70, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 70, col = 19},{<unknown>, line = 70, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 70, col = 23},{<unknown>, line = 70, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 23},{<unknown>, line = 70, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 70, col = 25},{<unknown>, line = 70, col = 26}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 70, col = 32},{<unknown>, line = 70, col = 49}) (Bin (fromList []) ({<unknown>, line = 70, col = 33},{<unknown>, line = 70, col = 48}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 33},{<unknown>, line = 70, col = 41}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 70, col = 37},{<unknown>, line = 70, col = 40}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 37},{<unknown>, line = 70, col = 38}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 70, col = 39},{<unknown>, line = 70, col = 40}) "1")])]) (Var (fromList []) ({<unknown>, line = 70, col = 42},{<unknown>, line = 70, col = 48}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 70, col = 46},{<unknown>, line = 70, col = 47}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 71, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 71, col = 6},{<unknown>, line = 71, col = 41}) (Var (fromList []) ({<unknown>, line = 71, col = 6},{<unknown>, line = 71, col = 13}) [(VarName (fromList []) "visux2",[])]) (Bin (fromList []) ({<unknown>, line = 71, col = 15},{<unknown>, line = 71, col = 41}) (Mul (fromList [])) (Bin (fromList []) ({<unknown>, line = 71, col = 15},{<unknown>, line = 71, col = 25}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 71, col = 15},{<unknown>, line = 71, col = 22}) (Var (fromList []) ({<unknown>, line = 71, col = 16},{<unknown>, line = 71, col = 21}) [(VarName (fromList []) "evsx2",[])])) (Con (fromList []) ({<unknown>, line = 71, col = 23},{<unknown>, line = 71, col = 25}) "2.")) (Var (fromList []) ({<unknown>, line = 71, col = 26},{<unknown>, line = 71, col = 41}) [(VarName (fromList [("msak",[])]) "diu1",[Bin (fromList []) ({<unknown>, line = 71, col = 31},{<unknown>, line = 71, col = 34}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 71, col = 31},{<unknown>, line = 71, col = 32}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 71, col = 33},{<unknown>, line = 71, col = 34}) "1"),Var (fromList []) ({<unknown>, line = 71, col = 35},{<unknown>, line = 71, col = 37}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 71, col = 38},{<unknown>, line = 71, col = 40}) [(VarName (fromList []) "k",[])]])]))) (FSeq (fromList []) ({<unknown>, line = 72, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 72, col = 6},{<unknown>, line = 72, col = 40}) (Var (fromList []) ({<unknown>, line = 72, col = 6},{<unknown>, line = 72, col = 13}) [(VarName (fromList []) "visux1",[])]) (Bin (fromList []) ({<unknown>, line = 72, col = 15},{<unknown>, line = 72, col = 40}) (Mul (fromList [])) (Bin (fromList []) ({<unknown>, line = 72, col = 15},{<unknown>, line = 72, col = 25}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 72, col = 15},{<unknown>, line = 72, col = 22}) (Var (fromList []) ({<unknown>, line = 72, col = 16},{<unknown>, line = 72, col = 21}) [(VarName (fromList []) "evsx1",[])])) (Con (fromList []) ({<unknown>, line = 72, col = 23},{<unknown>, line = 72, col = 25}) "2.")) (Var (fromList []) ({<unknown>, line = 72, col = 26},{<unknown>, line = 72, col = 40}) [(VarName (fromList [("msak",[])]) "diu1",[Var (fromList []) ({<unknown>, line = 72, col = 31},{<unknown>, line = 72, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 72, col = 34},{<unknown>, line = 72, col = 35}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 72, col = 37},{<unknown>, line = 72, col = 39}) [(VarName (fromList []) "k",[])]])]))) (FSeq (fromList []) ({<unknown>, line = 73, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 73, col = 6},{<unknown>, line = 73, col = 59}) (Var (fromList []) ({<unknown>, line = 73, col = 6},{<unknown>, line = 73, col = 13}) [(VarName (fromList []) "visuy2",[])]) (Bin (fromList []) ({<unknown>, line = 73, col = 15},{<unknown>, line = 73, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 73, col = 15},{<unknown>, line = 73, col = 22}) (Var (fromList []) ({<unknown>, line = 73, col = 16},{<unknown>, line = 73, col = 21}) [(VarName (fromList []) "evsy2",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 73, col = 24},{<unknown>, line = 73, col = 59}) (Bin (fromList []) ({<unknown>, line = 73, col = 26},{<unknown>, line = 73, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 73, col = 26},{<unknown>, line = 73, col = 41}) [(VarName (fromList [("msak",[])]) "diu2",[Var (fromList []) ({<unknown>, line = 73, col = 31},{<unknown>, line = 73, col = 33}) [(VarName (fromList []) "i",[])],Bin (fromList []) ({<unknown>, line = 73, col = 34},{<unknown>, line = 73, col = 37}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 73, col = 34},{<unknown>, line = 73, col = 35}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 73, col = 36},{<unknown>, line = 73, col = 37}) "1"),Var (fromList []) ({<unknown>, line = 73, col = 38},{<unknown>, line = 73, col = 40}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 73, col = 42},{<unknown>, line = 73, col = 58}) [(VarName (fromList [("msak",[])]) "diu4",[Bin (fromList []) ({<unknown>, line = 73, col = 47},{<unknown>, line = 73, col = 50}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 73, col = 47},{<unknown>, line = 73, col = 48}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 73, col = 49},{<unknown>, line = 73, col = 50}) "1"),Var (fromList []) ({<unknown>, line = 73, col = 51},{<unknown>, line = 73, col = 53}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 73, col = 54},{<unknown>, line = 73, col = 56}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 74, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 74, col = 6},{<unknown>, line = 74, col = 59}) (Var (fromList []) ({<unknown>, line = 74, col = 6},{<unknown>, line = 74, col = 13}) [(VarName (fromList []) "visuy1",[])]) (Bin (fromList []) ({<unknown>, line = 74, col = 15},{<unknown>, line = 74, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 74, col = 15},{<unknown>, line = 74, col = 22}) (Var (fromList []) ({<unknown>, line = 74, col = 16},{<unknown>, line = 74, col = 21}) [(VarName (fromList []) "evsy1",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 74, col = 24},{<unknown>, line = 74, col = 59}) (Bin (fromList []) ({<unknown>, line = 74, col = 26},{<unknown>, line = 74, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 74, col = 26},{<unknown>, line = 74, col = 40}) [(VarName (fromList [("msak",[])]) "diu2",[Var (fromList []) ({<unknown>, line = 74, col = 31},{<unknown>, line = 74, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 74, col = 34},{<unknown>, line = 74, col = 36}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 74, col = 37},{<unknown>, line = 74, col = 39}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 74, col = 41},{<unknown>, line = 74, col = 58}) [(VarName (fromList [("msak",[])]) "diu4",[Bin (fromList []) ({<unknown>, line = 74, col = 46},{<unknown>, line = 74, col = 49}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 74, col = 46},{<unknown>, line = 74, col = 47}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 74, col = 48},{<unknown>, line = 74, col = 49}) "1"),Bin (fromList []) ({<unknown>, line = 74, col = 50},{<unknown>, line = 74, col = 53}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 74, col = 50},{<unknown>, line = 74, col = 51}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 74, col = 52},{<unknown>, line = 74, col = 53}) "1"),Var (fromList []) ({<unknown>, line = 74, col = 54},{<unknown>, line = 74, col = 56}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 75, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 75, col = 6},{<unknown>, line = 75, col = 59}) (Var (fromList []) ({<unknown>, line = 75, col = 6},{<unknown>, line = 75, col = 13}) [(VarName (fromList []) "visuz2",[])]) (Bin (fromList []) ({<unknown>, line = 75, col = 15},{<unknown>, line = 75, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 75, col = 15},{<unknown>, line = 75, col = 22}) (Var (fromList []) ({<unknown>, line = 75, col = 16},{<unknown>, line = 75, col = 21}) [(VarName (fromList []) "evsz2",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 75, col = 24},{<unknown>, line = 75, col = 59}) (Bin (fromList []) ({<unknown>, line = 75, col = 26},{<unknown>, line = 75, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 75, col = 26},{<unknown>, line = 75, col = 41}) [(VarName (fromList [("msak",[])]) "diu3",[Var (fromList []) ({<unknown>, line = 75, col = 31},{<unknown>, line = 75, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 75, col = 34},{<unknown>, line = 75, col = 36}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 75, col = 37},{<unknown>, line = 75, col = 40}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 75, col = 37},{<unknown>, line = 75, col = 38}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 75, col = 39},{<unknown>, line = 75, col = 40}) "1")])]) (Var (fromList []) ({<unknown>, line = 75, col = 42},{<unknown>, line = 75, col = 58}) [(VarName (fromList [("msak",[])]) "diu7",[Bin (fromList []) ({<unknown>, line = 75, col = 47},{<unknown>, line = 75, col = 50}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 75, col = 47},{<unknown>, line = 75, col = 48}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 75, col = 49},{<unknown>, line = 75, col = 50}) "1"),Var (fromList []) ({<unknown>, line = 75, col = 51},{<unknown>, line = 75, col = 53}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 75, col = 54},{<unknown>, line = 75, col = 56}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 76, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 76, col = 6},{<unknown>, line = 76, col = 59}) (Var (fromList []) ({<unknown>, line = 76, col = 6},{<unknown>, line = 76, col = 13}) [(VarName (fromList []) "visuz1",[])]) (Bin (fromList []) ({<unknown>, line = 76, col = 15},{<unknown>, line = 76, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 76, col = 15},{<unknown>, line = 76, col = 22}) (Var (fromList []) ({<unknown>, line = 76, col = 16},{<unknown>, line = 76, col = 21}) [(VarName (fromList []) "evsz1",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 76, col = 24},{<unknown>, line = 76, col = 59}) (Bin (fromList []) ({<unknown>, line = 76, col = 26},{<unknown>, line = 76, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 76, col = 26},{<unknown>, line = 76, col = 40}) [(VarName (fromList [("msak",[])]) "diu3",[Var (fromList []) ({<unknown>, line = 76, col = 31},{<unknown>, line = 76, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 76, col = 34},{<unknown>, line = 76, col = 36}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 76, col = 37},{<unknown>, line = 76, col = 39}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 76, col = 41},{<unknown>, line = 76, col = 58}) [(VarName (fromList [("msak",[])]) "diu7",[Bin (fromList []) ({<unknown>, line = 76, col = 46},{<unknown>, line = 76, col = 49}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 76, col = 46},{<unknown>, line = 76, col = 47}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 76, col = 48},{<unknown>, line = 76, col = 49}) "1"),Var (fromList []) ({<unknown>, line = 76, col = 50},{<unknown>, line = 76, col = 52}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 76, col = 53},{<unknown>, line = 76, col = 56}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 76, col = 53},{<unknown>, line = 76, col = 54}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 76, col = 55},{<unknown>, line = 76, col = 56}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 77, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 77, col = 6},{<unknown>, line = 77, col = 82}) (Var (fromList []) ({<unknown>, line = 77, col = 6},{<unknown>, line = 77, col = 10}) [(VarName (fromList []) "vfu",[])]) (Bin (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 82}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 59}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 35}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 27}) (Bin (fromList []) ({<unknown>, line = 77, col = 13},{<unknown>, line = 77, col = 26}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 77, col = 13},{<unknown>, line = 77, col = 19}) [(VarName (fromList []) "visux2",[])]) (Var (fromList []) ({<unknown>, line = 77, col = 20},{<unknown>, line = 77, col = 26}) [(VarName (fromList []) "visux1",[])]))) (Var (fromList []) ({<unknown>, line = 77, col = 28},{<unknown>, line = 77, col = 35}) [(VarName (fromList [("msak",[])]) "dxs",[Var (fromList []) ({<unknown>, line = 77, col = 32},{<unknown>, line = 77, col = 33}) [(VarName (fromList []) "i",[])]])])) (Bin (fromList []) ({<unknown>, line = 77, col = 36},{<unknown>, line = 77, col = 59}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 77, col = 36},{<unknown>, line = 77, col = 51}) (Bin (fromList []) ({<unknown>, line = 77, col = 37},{<unknown>, line = 77, col = 50}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 77, col = 37},{<unknown>, line = 77, col = 43}) [(VarName (fromList []) "visuy2",[])]) (Var (fromList []) ({<unknown>, line = 77, col = 44},{<unknown>, line = 77, col = 50}) [(VarName (fromList []) "visuy1",[])]))) (Var (fromList []) ({<unknown>, line = 77, col = 52},{<unknown>, line = 77, col = 59}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 77, col = 56},{<unknown>, line = 77, col = 57}) [(VarName (fromList []) "j",[])]])]))) (Bin (fromList []) ({<unknown>, line = 77, col = 60},{<unknown>, line = 77, col = 82}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 77, col = 60},{<unknown>, line = 77, col = 75}) (Bin (fromList []) ({<unknown>, line = 77, col = 61},{<unknown>, line = 77, col = 74}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 77, col = 61},{<unknown>, line = 77, col = 67}) [(VarName (fromList []) "visuz2",[])]) (Var (fromList []) ({<unknown>, line = 77, col = 68},{<unknown>, line = 77, col = 74}) [(VarName (fromList []) "visuz1",[])]))) (Var (fromList []) ({<unknown>, line = 77, col = 76},{<unknown>, line = 77, col = 82}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 77, col = 80},{<unknown>, line = 77, col = 81}) [(VarName (fromList []) "k",[])]])])))) (FSeq (fromList []) ({<unknown>, line = 78, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 78, col = 6},{<unknown>, line = 78, col = 31}) (Var (fromList []) ({<unknown>, line = 78, col = 6},{<unknown>, line = 78, col = 31}) [(VarName (fromList [("msak",[])]) "f",[Var (fromList []) ({<unknown>, line = 78, col = 8},{<unknown>, line = 78, col = 9}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 78, col = 10},{<unknown>, line = 78, col = 11}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 78, col = 12},{<unknown>, line = 78, col = 13}) [(VarName (fromList []) "k",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 78, col = 17},{<unknown>, line = 78, col = 31}) (Bin (fromList []) ({<unknown>, line = 78, col = 18},{<unknown>, line = 78, col = 30}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 78, col = 18},{<unknown>, line = 78, col = 26}) [(VarName (fromList [("msak",[])]) "f",[Var (fromList []) ({<unknown>, line = 78, col = 20},{<unknown>, line = 78, col = 21}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 78, col = 22},{<unknown>, line = 78, col = 23}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 78, col = 24},{<unknown>, line = 78, col = 25}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 78, col = 27},{<unknown>, line = 78, col = 30}) [(VarName (fromList []) "vfu",[])])))) (NullStmt (fromList []) ({<unknown>, line = 79, col = 12},{<unknown>, line = 79, col = 12})))))))))))))))))
CallStack (from HasCallStack):
  error, called at src/StencilDetection.hs:204:38 in F4-0.1.0.0-D7RDINYaNhyFjCMhEfJGtk:StencilDetection

================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	adam
	bondv1
	feedbf
	les
	press
	velFG
	velnw
File containing main subroutine: 
	main.f95
Source directory:
	./src
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: WV_OPENCL, WV_NEW, NO_GLOBAL_SOR, INLINE_BOUND_CALCS, WV_TEST, TWINNED_BUFFER, NO_IO, IFBF=1, IADAM=0, 
CPP Excludes:

cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/main_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_init.f95 False
Test2: ./src/init.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/init_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_feedbfm.f95 False
Test2: ./src/feedbfm.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_feedbfm
 contains
subroutine feedbfm(km,jm,im,amask1,bmask1,cmask1,dmask1,zbm,z2,dzn)
    use common_sn 
      implicit none
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: amask1
    real(kind=4), dimension(-1:ip+1,0:jp+1,0:kp+1) , intent(Out) :: bmask1
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: cmask1
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: dmask1
    real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:kp+2) , intent(In) :: z2
    real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(InOut) :: zbm
    integer :: i, j, k
    real(kind=4), dimension(-1:3001,-1:751) :: dsm,dem
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                amask1(i,j,k) = 1.
                bmask1(i,j,k) = 0.
                cmask1(i,j,k) = 0.
                dmask1(i,j,k) = 0.
            end do
        end do
    end do
        print*, 'zbm sum - file getting read'
      open(70,file='./GIS/DEM_LES_GIS.txt',form='formatted',status='unknown')
      do j=1,750
        do i=1,3000
          read(70,*) dem(i,j)
        end do
      end do
      close(70)
      open(71,file='./GIS/DSM_LES_GIS.txt',form='formatted',status='unknown')
      do j=1,750
        do i=1,3000
          read(71,*) dsm(i,j)
        end do
      end do
      close(71)
      do j=1,250
        do i=1,2750
          zbm(i+125,j+25)=dsm(i+250,j+138)-dem(i+250,j+138)
        end do
      end do
    do j = 1,jm
        do i = 1,im
            do k = 1,km
                if(zbm(i,j) > z2(k)+0.5*dzn(k)) then
                    amask1(i,j,k) = 0.0
                end if
            end do
        end do
    end do
    if (isMaster()) then
      do k=1,km
        write(*,*) 'z2=',z2(k)
      end do
    end if
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                if(amask1(i,j,k) == 0.0) then
                    bmask1(i,j,k) = 1.0
                    cmask1(i,j,k) = 1.0
                    dmask1(i,j,k) = 1.0
                end if
            end do
        end do
    end do
end subroutine feedbfm
end module module_feedbfm

Test3: False       use module_feedbfm 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_init
      use module_feedbfm 
 contains
      subroutine init(km,jm,im,u,v,w,p,cn2s,dxs,cn2l,cn3s,dys,cn3l,dzs,cn4s,cn4l,cn1,amask1, &
      bmask1,cmask1,dmask1,zbm,z2,dzn)
      use common_sn 
        real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: amask1
        real(kind=4), dimension(-1:ip+1,0:jp+1,0:kp+1) , intent(Out) :: bmask1
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: cmask1
        real(kind=4), dimension(ip,jp,kp) , intent(Out) :: cn1
        real(kind=4), dimension(ip) , intent(Out) :: cn2l
        real(kind=4), dimension(ip) , intent(Out) :: cn2s
        real(kind=4), dimension(jp) , intent(Out) :: cn3l
        real(kind=4), dimension(jp) , intent(Out) :: cn3s
        real(kind=4), dimension(kp) , intent(Out) :: cn4l
        real(kind=4), dimension(kp) , intent(Out) :: cn4s
        real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: dmask1
        real(kind=4), dimension(0:ip) , intent(In) :: dxs
        real(kind=4), dimension(0:jp) , intent(In) :: dys
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(Out) :: p
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: u
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: v
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(Out) :: w
        real(kind=4), dimension(kp+2) , intent(In) :: z2
        real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(InOut) :: zbm
      do k = 0,kp+1
      do j = 0,jp+2
      do i = 0,ip+2
          p(i,j,k) = 0.0
      end do
      end do
      end do
      do k = 0,kp+1
      do j = -1,jp+1
      do i = 0,ip+1
        u(i,j,k) = 0.0
        v(i,j,k) = 0.0
      end do
      end do
      end do
      do k = -1,kp+1
      do j = -1,jp+1
      do i = 0,ip+1
        w(i,j,k) = 0.0
      end do
      end do
      end do
      call feedbfm(km,jm,im,amask1,bmask1,cmask1,dmask1,zbm,z2,dzn)
      do i = 1,im
      cn2s(i) = 2./(dxs(i-1)*(dxs(i-1)+dxs(i)))
      cn2l(i) = 2./(dxs(i)*(dxs(i-1)+dxs(i))./src/grid_tmp.f95:53:9: warning: missing terminating ' character
 !WV: let's set the *whole* array to this value!
         ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
)
      end do
      do j = 1,jm
      cn3s(j) = 2./(dys(j-1)*(dys(j-1)+dys(j)))
      cn3l(j) = 2./(dys(j)*(dys(j-1)+dys(j)))
      end do
      do k = 1,km
          dz1 = dzs(k-1)
          dz2 = dzs(k)
          cn4s(k) = 2./(dz1*(dz1+dz2))
          cn4l(k) = 2./(dz2*(dz1+dz2))
      do j = 1,jm
      do i = 1,im
          cn1(i,j,k) = &
      2./(dxs(i-1)*dxs(i)) + &
      2./(dys(j-1)*dys(j)) + &
      2./(dz1*dz2) 
          cn1(i,j,k) = 1./cn1(i,j,k)
      end do
      end do
      end do
      return
      end subroutine init
end module module_init

Test3: False     use module_init
Test1: ./src/module_grid.f95 False
Test2: ./src/grid.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/grid_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_grid
 contains
      subroutine grid(dx1,dxl,dy1,dyl,z2,dzn,dzs,dxs,dys)
      use common_sn 
        real(kind=4), dimension(-1:ip+1) , intent(Out) :: dx1
        real(kind=4), dimension(0:ip) , intent(Out) :: dxl
        real(kind=4), dimension(0:ip) , intent(Out) :: dxs
        real(kind=4), dimension(0:jp+1) , intent(Out) :: dy1
        real(kind=4), dimension(0:jp) , intent(Out) :: dyl
        real(kind=4), dimension(0:jp) , intent(Out) :: dys
        real(kind=4), dimension(-1:kp+2) , intent(Out) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(Out) :: dzs
        real(kind=4), dimension(0:kp+2) , intent(Out) :: z2
      do i = -1,ip+1
       dx1(i) = 4.
      end do
      dxl(0) = 0.
      do i = 1,ip
       dxl(i) = dxl(i-1)+dx1(i)
      end do
      do j = 0,jp+1
       dy1(j) = 4.
      end do
      dyl(0) = 0.
      do j = 1,jp
       dyl(j) = dyl(j-1)+dy1(j)
      end do
        z2(0)= 1.
        dzn(0)= 1.
        z2(1)= 1.
        dzn(1)= 1.
      do k=2,15
        dzn(k)=dzn(k-1)*1.1
        write(*,*) 'dzn=',dzn(k)
      end do
      do k=16,44
        dzn(k)=4.
      end do
      do k=45,58
        dzn(k)=dzn(k-1)*1.1
      end do
      do k=59,kp+1
        dzn(k)=16.
      enddo
      do k=2,kp+2
        z2(k)=z2(k-1)+dzn(k) 
      end do
    if (isMaster()) then
      do k=1,kp
        write(*,*) 'z2grid=',z2(k)
      end do
    end if
      dzn(kp+1) = dzn(kp)
      dzn(kp+2) = dzn(kp+1)
      dzn(0) = dzn(1)
      dzn(-1)=dzn(0)
      do k = 0,kp
        dzs(k) = dzn(k+1)/2.+dzn(k)/2.
      end do
      do i=0, ip
        dxs(i) = dx1(i)/2.+dx1(i+1)/2.
      end do
      do j = 0,jp
        dys(j) = dy1(j)/2.+dy1(j+1)/2.
      end do
      dzs(kp+1) = dzs(kp)
      dzs(kp+2) = dzs(kp+1) 
      dzs(-1) = dzs(0) 
      return
      end subroutine grid
end module module_grid

Test3: False     use module_grid
Test1: ./src/module_set.f95 False
Test2: ./src/set.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/set_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_set
 contains
      subroutine set(data10,data11,data20,data21,data22,data23,data24,data25,data26,data27,data30, &
      data31,im,jm,km,ifbf,ianime,ical,n0,n1,nmax,dt,ro,vn,alpha,beta,data12,data13,data14,idata24,nspec,jdata24)
      use common_sn 
        real(kind=4), intent(Out) :: alpha
        real(kind=4), intent(Out) :: beta
        character(len=70), intent(InOut) :: data10
        character(len=70), intent(InOut) :: data11
        character(len=70), intent(InOut) :: data12
        character(len=70), intent(InOut) :: data13
        character(len=70), intent(InOut) :: data14
        character(len=70), intent(InOut) :: data20
        character(len=70), intent(InOut) :: data21
        character(len=70), intent(InOut) :: data22
        character(len=70), intent(InOut) :: data23
        character(len=70), intent(InOut) :: data24
        character(len=70), intent(InOut) :: data25
        character(len=70), intent(InOut) :: data26
        character(len=70), intent(InOut) :: data27
        character(len=70), intent(InOut) :: data30
        character(len=70), intent(InOut) :: data31
        real(kind=4), intent(Out) :: dt
        integer, intent(Out) :: ianime
        integer, intent(Out) :: ical
        integer, intent(Out) :: ifbf
        integer, intent(Out) :: im
        integer, intent(Out) :: jm
        integer, intent(Out) :: km
        integer, intent(Out) :: n0
        integer, intent(Out) :: n1
        integer, intent(Out) :: nmax
        real(kind=4), intent(Out) :: ro
        real(kind=4), intent(Out) :: vn
        integer, intent(Out) :: idata24
        integer, intent(Out) :: jdata24
      data10 = './data/data10'
      data11 = './data/data11'
      data12 = './data/data12'
      data13 = './data/data13'
      data14 = './data/data14'
      data20 = './data/data20'
      data21 = './data/data21'
      data22 = './data/data22'
      data23 = './data/data23'
      data24 = './data/data24'
      data25 = './data/data25'
      data26 = './data/data26'
      data27 = './data/data27'
      data30 = './data/data30'
      data31 = './data/data31'
      im = ip
      jm = jp
      km = kp
      ifbf = 1
      ianime = 0
      ical = 0
      n0 = 1
      n1 = 1
      nmax = 10
      nspec = 10
      dt = 0.05
      ro = 1.1763
      vn = 15.83*10.**(-6.)
      alpha = -10.
      beta = -1.
      if(((-beta-(beta*beta-2.*alpha)**(0.5))/alpha) < dt) then
      write(6,*) 'CHECK parameter alpha beta of IBM method'
      write(6,*) 'IBM parameter, dt=' ,((-beta-(beta*beta-2.*alpha)**(0.5))/alpha),dt
      stop
      endif
      idata24 = 0
      jdata24 = 0
      return
      end subroutine set
end module module_set

Test3: False     use module_set
Test1: ./src/module_timdata.f95 False
Test2: ./src/timdata.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/timdata_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_timdata
 contains
      subroutine timdata()
      use common_sn 
      open(50,file='winddata.dat')
      return
      end subroutine timdata
end module module_timdata

Test3: False     use module_timdata
Test1: ./src/module_aveflow.f95 False
Test2: ./src/aveflow.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/aveflow_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_aveflow
 contains
subroutine aveflow(n,n1,km,jm,im,aveu,avev,avew,avep,avel,aveuu,avevv,aveww,avesm,avesmsm, &
      uwfx,avesu,avesv,avesw,avesuu,avesvv,avesww,u,v,w,p,sm,nmax,uwfxs,data10,time,data11,data13,data14,amask1)
    use common_sn 
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: avel
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: avep
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: avesm
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: avesmsm
    real(kind=4), dimension(ip,kp) , intent(Out) :: avesu
    real(kind=4), dimension(ip,kp) , intent(Out) :: avesuu
    real(kind=4), dimension(ip,kp) , intent(Out) :: avesv
    real(kind=4), dimension(ip,kp) , intent(Out) :: avesvv
    real(kind=4), dimension(ip,kp) , intent(Out) :: avesw
    real(kind=4), dimension(ip,kp) , intent(Out) :: avesww
    real(kind=4), dimension(ip,jp,0:kp) , intent(Out) :: aveu
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: aveuu
    real(kind=4), dimension(ip,jp,0:kp) , intent(Out) :: avev
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: avevv
    real(kind=4), dimension(ip+1,jp,0:kp+2) , intent(Out) :: avew
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: aveww
    character(len=70), intent(In) :: data10
    character(len=70), intent(In) :: data11
    character(len=70), intent(In) :: data13
    character(len=70), intent(In) :: data14
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    integer, intent(In) :: n
    integer, intent(In) :: n1
    integer, intent(In) :: nmax
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(In) :: p
    real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(In) :: sm
    real(kind=4), intent(In) :: time
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
    real(kind=4), dimension(ip,jp,kp) , intent(Out) :: uwfx
    real(kind=4), dimension(ip,kp) , intent(InOut) :: uwfxs
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(In) :: amask1
    real(kind=4), dimension(0:ipmax+1,0:jpmax+1,0:kp+1) :: amask1a
    real(kind=4),allocatable :: aveua(:,:,:)
    real(kind=4),allocatable :: aveva(:,:,:)
    real(kind=4),allocatable :: avewa(:,:,:)
    real(kind=4),allocatable :: aveuua(:,:,:)
    real(kind=4),allocatable :: avevva(:,:,:)
    real(kind=4),allocatable :: avewwa(:,:,:)
    real(kind=4),allocatable :: uwfxa(:,:,:)
    if(n == n1) then
        do k = 1,km
            do j = 1,jm
                do i = 1,im
                    avev(i,j,k) = 0.0
                    avep(i,j,k) = 0.0
                    avel(i,j,k) = 0.0
                    aveuu(i,j,k) = 0.0
                    avevv(i,j,k) = 0.0
                    aveww(i,j,k) = 0.0
                    avesm(i,j,k) = 0.0
                    avesmsm(i,j,k) = 0.0
                    uwfx(i,j,k) = 0.0
                end do
            end do
        end do
        do k = 0,km
            do j = 1,jm
                do i = 1,im
                    aveu(i,j,k) = 0.0
                end do
            end do
        end do
        do k = 0,km
            do j = 1,jm
                do i = 1,im+1
                    avew(i,j,k) = 0.0
                end do
            end do
        end do
    end if
    if(n >= n1) then
        do k = 1,km
            do j = 1,jm
                do i = 1,im
                    avev(i,j,k) = avev(i,j,k)+v(i,j,k)
                    avep(i,j,k) = avep(i,j,k)+p(i,j,k)
                    aveuu(i,j,k) = aveuu(i,j,k)+u(i,j,k)**2
                    avevv(i,j,k) = avevv(i,j,k)+v(i,j,k)**2
                    aveww(i,j,k) = aveww(i,j,k)+w(i,j,k)**2
                    avesm(i,j,k) = avesm(i,j,k)+sm(i,j,k)
                    avesmsm(i,j,k) = avesmsm(i,j,k)+sm(i,j,k)**2
                    uwfx(i,j,k) = uwfx(i,j,k)+0.5*(u(i,j,k-1)+u(i,j,k)) * &
                                  0.5*(w(i,j,k-1)+w(i+1,j,k-1))
                end do
            end do
        end do
        do k = 0,km
            do j = 1,jm
                do i = 1,im
                    aveu(i,j,k) = aveu(i,j,k)+u(i,j,k)
                end do
            end do
        end do
        do k = 0,km
            do j = 1,jm
                do i = 1,im+1
                    avew(i,j,k) = avew(i,j,k)+w(i,j,k)
                end do
            end do
        end do
  endif
  if(n == nmax) then
      do k = 1,km
          do j = 1,jm
              do i = 1,im
                  avev(i,j,k) = avev(i,j,k)/float(nmax-n1+1)
                  avep(i,j,k) = avep(i,j,k)/float(nmax-n1+1)
                  avel(i,j,k) = avel(i,j,k)/float(nmax-n1+1)
                  aveuu(i,j,k) = aveuu(i,j,k)/float(nmax-n1+1)
                  avevv(i,j,k) = avevv(i,j,k)/float(nmax-n1+1)
                  aveww(i,j,k) = aveww(i,j,k)/float(nmax-n1+1)
                  avesm(i,j,k) = avesm(i,j,k)/float(nmax-n1+1)
                  avesmsm(i,j,k) = avesmsm(i,j,k)/float(nmax-n1+1)
              end do
      end do
    end do
        do k = 0,km
            do j = 1,jm
                do i = 1,im
                    aveu(i,j,k) = aveu(i,j,k)/float(nmax-n1+1)
                end do
            end do
        end do
        do k = 0,km
            do j = 1,jm
                do i = 1,im+1
                    avew(i,j,k) = avew(i,j,k)/float(nmax-n1+1)
                end do
            end do
        end do
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                uwfx(i,j,k) = uwfx(i,j,k)/float(nmax-n1+1) - &
                              0.5*(aveu(i,j,k-1)+aveu(i,j,k)) * &
                              0.5*(avew(i,j, k-1)+avew(i+1,j,k-1))
            end do
        end do
    end do
      do k = 1,km
        do j = 1,jm
            do i = 1,im
                aveuu(i,j,k) = sqrt(abs(aveuu(i,j,k)-aveu(i,j,k)**2))
                avevv(i,j,k) = sqrt(abs(avevv(i,j,k)-avev(i,j,k)**2))
                aveww(i,j,k) = sqrt(abs(aveww(i,j,k)-avew(i,j,k)**2))
            end do
        end do
        end do
       if (isMaster()) then
    open(unit=10,file=data10,form='unformatted',status='unknown')
       end if
      allocate(aveua(0:ipmax,0:jpmax,0:kp))
      call distributeaveu(aveua, aveu, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    aveua(i,j,k) = aveu(i,j,k)
                end do
            end do
        end do
        write(10) (((aveua(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       end if
       deallocate(aveua)
      allocate(avewa(ipmax+1,jpmax,0:kp+2))
      call distributeavew(avewa, avew, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    avewa(i,j,k) = avew(i,j,k)
                end do
            end do
        end do
        write(10) (((avewa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       end if
       deallocate(avewa)
      allocate(aveva(0:ipmax,0:jpmax,0:kp))
      call distributeaveu(aveva, avev, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    aveva(i,j,k) = avev(i,j,k)
                end do
            end do
        end do
        write(10) (((aveva(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       close(10)
       end if
       deallocate(aveva)
       if (isMaster()) then
       open(unit=11,file=data11,form='unformatted',status='unknown')
       end if
      allocate(aveuua(0:ipmax,0:jpmax,0:kp))
      call distributeaveuu(aveuua, aveuu, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    aveuua(i,j,k) = aveuu(i,j,k)
                end do
            end do
        end do
        write(11) (((aveuua(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       end if
       deallocate(aveuua)
      allocate(avewwa(0:ipmax,0:jpmax,0:kp))
      call distributeaveuu(avewwa, aveww, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    avewwa(i,j,k) = aveww(i,j,k)
                end do
            end do
        end do
        write(11) (((avewwa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       end if
       deallocate(avewwa)
      allocate(avevva(0:ipmax,0:jpmax,0:kp))
      call distributeaveuu(avevva, avevv, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    avevva(i,j,k) = avevv(i,j,k)
                end do
            end do
        end do
        write(11) (((avevva(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       end if
       deallocate(avevva)
      allocate(uwfxa(0:ipmax,0:jpmax,0:kp))
      call distributeaveuu(uwfxa, uwfx, ip, jp, kp, ipmax, jpmax, procPerRow)
       if (isMaster()) then
          do k = 1,km
            do j = 1,jm
                do i = 1,im
                    uwfxa(i,j,k) = uwfx(i,j,k)
                end do
            end do
        end do
        write(11) (((uwfxa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
       close(11)
       end if
       deallocate(uwfxa)
    endif
end subroutine aveflow
end module module_aveflow

Test3: False     use module_aveflow
Test1: ./src/module_ifdata.f95 False
Test2: ./src/ifdata.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/ifdata_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_bondv1.f95 False
Test2: ./src/bondv1.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_bondv1
 contains
subroutine bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
    use common_sn 
      implicit none
    real(kind=4), intent(In) :: dt
    real(kind=4), dimension(0:ip) , intent(In) :: dxs
    real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
    integer, intent(In) :: im, jm, km, n
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: u
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: v
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(InOut) :: w
    real(kind=4), dimension(0:kp+2) , intent(In) :: z2
    real(kind=4) :: u_val
    integer :: i, j, k
    real(kind=4) :: aaa, bbb, uout
        do i = 0,1
            do k = 1,78 
                do j = 1,jm
                    u(i,j,k) = 5.0
                    v(i,j,k) = 0.0
                    w(i,j,k) = 0.0
                end do
            end do
        end do
        do i = 0,1
            do k = 79,km
                do j = 1,jm
                    u(i,j,k) = u(i,j,77)
                    v(i,j,k) = 0.0
                    w(i,j,k) = 0.0
                end do
            end do
        end do
    if(n == 1) then
        do k = 1,km
            do j = 1,jm
                do i = 2, im
                    u(i,j,k) = u(1,j,k)
                    v(i,j,k) = v(1,j,k)
                    w(i,j,k) = w(1,j,k)
                end do
            end do
        end do
    endif
    aaa = 0.0
    bbb = 0.0
    do k = 1,km
        do j = 1,jm
            aaa = amax1(aaa,u(im,j,k))
            bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1,km
        do j = 1,jm
            u(im,j,k) = u(im,j,k)-dt*uout *(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1,km
        do j = 1,jm
            v(im+1,j,k) = v(im+1,j,k)-dt*uout *(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1,km
        do j = 1,jm
            w(im+1,j,k) = w(im+1,j,k)-dt*uout *(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0,km+1
        do i = 0,im+1
            u(i, 0,k) = u(i,jm ,k)
            u(i,jm+1,k) = u(i, 1,k)
        end do
    end do
    do k = 0,km+1
        do i = 0,im+1
            v(i, 0,k) = v(i,jm ,k)
            v(i,jm+1,k) = v(i, 1,k)
        end do
    end do
    do k = 0,km
        do i = 0,im+1
            w(i, 0,k) = w(i,jm ,k)
            w(i,jm+1,k) = w(i, 1,k)
        end do
    end do
    do j = 0,jm+1
        do i = 0,im+1
            u(i,j, 0) = -u(i,j, 1)
            u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0,jm+1
        do i = 0,im+1
            v(i,j, 0) = -v(i,j, 1)
            v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1,jm+1 
        do i = 0,im+1
            w(i,j, 0) = 0.0
            w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1
end module module_bondv1

Test3: False       use module_bondv1
Test1: ./src/module_velFG.f95 False
Test2: ./src/velFG.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velFG_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_vel2.f95 False
Test2: ./src/vel2.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_vel2
 contains
      subroutine vel2(km,jm,im,nou1,u,diu1,dx1,nou5,v,diu5,dy1,nou9,w,diu9,dzn,cov1,cov5,cov9,nou2, &
      diu2,cov2,nou3,diu3,dzs,cov3,nou4,diu4,cov4,nou6,diu6,cov6,nou7,diu7,cov7,nou8,diu8,cov8,uspd,vspd)
      use common_sn 
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov9
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu9
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: uspd
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: vspd
      integer, parameter :: u0 = 0
      do j=1,jm
        do i=1,im
         uspd(i,j)=(u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)&
     +0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(i)+dx1(i+1)))**2)**0.5
        end do
        end do
        do j=1,jm
        do i=1,im
         vspd(i,j)=(v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)&
     +0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(j)+dy1(j+1)))**2)**0.5
        end do
        end do
       if (isMaster()) then
        write(6,*) 'CHK_uspd=',uspd(im/2,jm/2),vspd(im/2,jm/2)
       end if
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        nou1(i,j,k) = (u(i-1,j,k)+u(i,j,k))/2.
        diu1(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        nou5(i,j,k) = (v(i,j-1,k)+v(i,j,k))/2.
        diu5(i,j,k) = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        nou9(i,j,k) = (w(i,j,k-1)+w(i,j,k))/2.
        diu9(i,j,k) = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov1(i,j,k) = nou1(i,j,k)*diu1(i,j,k)
        cov5(i,j,k) = nou5(i,j,k)*diu5(i,j,k)
        cov9(i,j,k) = nou9(i,j,k)*diu9(i,j,k)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        nou2(i,j,k) = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k)) /(dx1(i)+dx1(i+1))
        diu2(i,j,k) = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2(i,j,k) = nou2(i,j,k)*diu2(i,j,k)
      end do
      end do
      end do
      do k = 2,km+1
      do j = 1,jm
      do i = 1,im
        nou3(i,j,k) = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1)) /(dx1(i)+dx1(i+1))
        diu3(i,j,k) = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3(i,j,k) = nou3(i,j,k)*diu3(i,j,k)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
       nou3(i,j,1) = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
       diu3(i,j,1)=uspd(i,j)*0.4/alog(0.5*dzn(1)/0.1)/(0.5*dzn(1))/0.4*u(i,j,1)/uspd(i,j)
       cov3(i,j,1) = nou3(i,j,1)*diu3(i,j,1)
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        nou4(i,j,k) = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k)) /(dy1(j)+dy1(j+1))
        diu4(i,j,k) = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4(i,j,k) = (nou4(i,j,k)-u0)*diu4(i,j,k)
      end do
      end do
      end do
      do k = 2,km+1
      do j = 1,jm
      do i = 1,im
        nou6(i,j,k) = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1)) /(dy1(j)+dy1(j+1))
        diu6(i,j,k) = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6(i,j,k) = nou6(i,j,k)*diu6(i,j,k)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
       nou6(i,j,1) = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
       diu6(i,j,1)=vspd(i,j)*0.4/alog(0.5*dzn(1)/0.1)/(0.5*dzn(1))/0.4*v(i,j,1)/vspd(i,j)
       cov6(i,j,1) = nou6(i,j,1)*diu6(i,j,1)
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
        nou7(i,j,k) = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1)) /(dzn(k)+dzn(k+1))
        diu7(i,j,k) = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7(i,j,k) = (nou7(i,j,k)-u0)*diu7(i,j,k)
      end do
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
        nou8(i,j,k) = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1)) /(dzn(k)+dzn(k+1))
        diu8(i,j,k) = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8(i,j,k) = nou8(i,j,k)*diu8(i,j,k)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
        nou1(im+1,j,k) = nou1(im,j,k)
        diu1(im+1,j,k) = diu1(im,j,k)
        cov1(im+1,j,k) = cov1(im,j,k)
      end do
      end do
      do k = 1,km
      do i = 1,im
        nou2(i,0,k) = nou2(i,jm,k)
        diu2(i,0,k) = diu2(i,jm,k)
        cov2(i,0,k) = cov2(i,jm,k)
        nou2(i,jm+1,k) = nou2(i,1,k)
        diu2(i,jm+1,k) = diu2(i,1,k)
        cov2(i,jm+1,k) = cov2(i,1,k)
      end do
      end do
      do k = 1,km
      do j = 1,jm
        nou4(im+1,j,k) = nou4(im,j,k)
        diu4(im+1,j,k) = diu4(im,j,k)
        cov4(im+1,j,k) = cov4(im,j,k)
      end do
      end do
      do k = 1,km
      do i = 1,im
        nou5(i,0,k) = nou5(i,jm,k)
        diu5(i,0,k) = diu5(i,jm,k)
        cov5(i,0,k) = cov5(i,jm,k)
        nou5(i,jm+1,k) = nou5(i,1,k)
        diu5(i,jm+1,k) = diu5(i,1,k)
        cov5(i,jm+1,k) = cov5(i,1,k)
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
        nou7(im+1,j,k) = nou7(im,j,k)
        diu7(im+1,j,k) = diu7(im,j,k)
        cov7(im+1,j,k) = cov7(im,j,k)
      end do
      end do
      do k = 1,km-1
      do i = 1,im
        nou8(i,0,k) = nou8(i,jm,k)
        diu8(i,0,k) = diu8(i,jm,k)
        cov8(i,0,k) = cov8(i,jm,k)
        nou8(i,jm+1,k) = nou8(i,1,k)
        diu8(i,jm+1,k) = diu8(i,1,k)
        cov8(i,jm+1,k) = cov8(i,1,k)
      end do
      end do
      do k = 1,km+1
      do j = 1,jm+1
        diu2(im+1,j,k) = diu2(im,j,k)
        diu3(im+1,j,k) = diu3(im,j,k)
      end do
      end do
      do k = 1,km+1
      do i = 1,im+1
        diu4(i,0,k) = diu4(i,jm,k)
        diu6(i,0,k) = diu6(i,jm,k)
      end do
      end do
        do j=1,jm
        do i=1,im
         uspd(i,j)=u(i,j,1)/uspd(i,j)
         vspd(i,j)=v(i,j,1)/vspd(i,j)
        end do
        end do
end subroutine vel2
end module module_vel2

Test3: False       use module_vel2 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_velFG
      use module_vel2 
 contains
      subroutine velfg(km,jm,im,dx1,cov1,cov2,cov3,dfu1,diu1,diu2,dy1,diu3,dzn,vn,f,cov4,cov5,cov6, &
      dfv1,diu4,diu5,diu6,g,cov7,cov8,cov9,dfw1,diu7,diu8,diu9,dzs,h,nou1,u,nou5,v,nou9,w,nou2, &
      nou3,nou4,nou6,nou7,nou8,uspd,vspd)
      use common_sn 
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov9
        real(kind=4), dimension(0:ip,jp,kp) , intent(Out) :: dfu1
        real(kind=4), dimension(ip,0:jp,kp) , intent(Out) :: dfv1
        real(kind=4), dimension(ip,jp,kp) , intent(Out) :: dfw1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu9
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: f
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: g
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: h
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
        real(kind=4), intent(In) :: vn
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: uspd
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: vspd
      call vel2(km,jm,im,nou1,u,diu1,dx1,nou5,v,diu5,dy1,nou9,w,diu9,dzn,cov1,cov5,cov9,nou2,diu2, &
           cov2,nou3,diu3,dzs,cov3,nou4,diu4,cov4,nou6,diu6,cov6,nou7,diu7,cov7,nou8,diu8,cov8,uspd,vspd)
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k)) /(dx1(i)+dx1(i+1))
        covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
        covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
        covc = covx1+covy1+covz1
        dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1)) + (-diu2(i,j,k)+diu2(i, &
      j+1,k))/dy1(j) + (-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
        df = vn*dfu1(i,j,k)
        f(i,j,k) = (-covc+df)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
        covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k)) /(dy1(j)+dy1(j+1))
        covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
        covc = covx1+covy1+covz1
        dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i) +2.*(-diu5(i,j,k)+diu5(i,j+1, &
      k))/(dy1(j)+dy1(j+1)) +(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
        df = vn*dfv1(i,j,k)
        g(i,j,k) = (-covc+df)
      end do
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
       covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
       covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
       covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1)) /(dzn(k)+dzn(k+1))
       covc = covx1+covy1+covz1
        dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i) +(-diu8(i,j,k)+diu8(i,j+1, &
      k))/dy1(j) +(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
        df = vn*dfw1(i,j,k)
        h(i,j,k) = (-covc+df)
      end do
      end do
      end do
      return
      end subroutine velFG
end module module_velFG

Test3: False       use module_velFG
Test1: ./src/module_les.f95 False
Test2: ./src/les.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_boundsm.f95 False
Test2: ./src/boundsm.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_boundsm
 contains
subroutine boundsm(km,jm,sm,im)
    use common_sn 
      implicit none
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: sm
    integer :: i, j, k
        do k = 0,km+1
            do j = -1,jm+1
                    sm( 0,j,k) = sm(1 ,j,k) 
                    sm(im+1,j,k) = sm(im,j,k)
            end do
        end do
        do k = 0,km+1
            do i = 0,im+1
                    sm(i,jm+1,k) = sm(i,jm ,k)
                    sm(i,0,k) = sm(i,1 ,k) 
            end do
        end do
    do j = -1,jm+1
        do i = 0,im+1
            sm(i,j, 0) = -sm(i,j, 1)
            sm(i,j,km+1) = sm(i,j,km)
        end do
    end do
end subroutine boundsm
end module module_boundsm

Test3: False       use module_boundsm 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_les
      use module_boundsm 
 contains
      subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g, &
      h,uspd,vspd,dxs,dys)
      use common_sn 
        real(kind=4), dimension(kp) , intent(Out) :: delx1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu9
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: h
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: sm
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(in) :: uspd
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(in) :: vspd
        real(kind=4), dimension(0:ip) , intent(in) :: dxs
        real(kind=4), dimension(0:jp) , intent(in) :: dys
      cs0 = .1
        do k = 1,km
          delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
        end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
      dudxx1 = diu1(i,j,k)
      dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k) +diu2(i ,j,k)+diu2(i ,j+1,k) ) *.25
      dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1) +diu3(i ,j,k)+diu3(i ,j,k+1) ) *.25
      dvdxx1 = (diu4(i ,j,k)+diu4(i ,j-1,k) +diu4(i+1,j,k)+diu4(i+1,j-1,k) ) *.25
      dvdyx1 = diu5(i,j,k)
      dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1) +diu6(i,j ,k)+diu6(i,j ,k+1) ) *.25
      dwdxx1 = (diu7(i ,j,k)+diu7(i ,j,k-1) +diu7(i+1,j,k)+diu7(i+1,j,k-1) ) *.25
      dwdyx1 = (diu8(i,j ,k)+diu8(i,j ,k-1) +diu8(i,j+1,k)+diu8(i,j+1,k-1) ) *.25
      dwdzx1 = diu9(i,j,k)
      csx1 = cs0
      sm(i,j,k) = ( csx1*delx1(k) )**2 * sqrt( 2.*( dudxx1**2+dvdyx1**2+dwdzx1**2 ) +( dudyx1+dvdxx1 )**2 &
      +( dwdyx1+dvdzx1 )**2 +( dudzx1+dwdxx1 )**2 )
      end do
      end do
      end do
      call boundsm(km,jm,sm,im)
      do k = 2,km
      do j = 1,jm
      do i = 1,im
      evsx2 = sm(i+1,j,k)
      evsx1 = sm(i,j,k)
      evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1, &
      k)) /(dx1(i)+dx1(i+1)))) /(dy1(j)+dy1(j+1))
      evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1, &
      k)) /(dx1(i)+dx1(i+1))) +dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1)))) /(dy1(j)+dy1(j+1))
      evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j, &
      k+1)) /(dx1(i)+dx1(i+1)))) /(dzn(k)+dzn(k+1))
      evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j, &
      k-1)) /(dx1(i)+dx1(i+1))) +dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1)))) /(dzn(k-1)+dzn(k))
      visux2 = (evsx2)*2.*diu1(i+1,j ,k )
      visux1 = (evsx1)*2.*diu1(i ,j, k )
      visuy2 = (evsy2)* ( diu2(i ,j+1,k )+diu4(i+1,j ,k ) )
      visuy1 = (evsy1)* ( diu2(i ,j ,k )+diu4(i+1,j-1,k ) )
      visuz2 = (evsz2)* ( diu3(i ,j ,k+1)+diu7(i+1,j ,k ) )
      visuz1 = (evsz1)* ( diu3(i ,j ,k )+diu7(i+1,j ,k-1) )
      vfu = (visux2-visux1)/dxs(i) +(visuy2-visuy1)/dy1(j) +(visuz2-visuz1)/dzn(k)
      f(i,j,k) = (f(i,j,k)+vfu)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
      evsx2=sm(i+1,j,1)
      evsx1=sm(i,j,1)
      evsy2=(dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
      evsy1=(dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))&
      +dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
      evsz2=(dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
      visux2=(evsx2)*2.*diu1(i+1,j ,1 )
      visux1=(evsx1)*2.*diu1(i ,j, 1 )
      visuy2=(evsy2)* ( diu2(i ,j+1,1 )+diu4(i+1,j ,1 ) )
      visuy1=(evsy1)* ( diu2(i ,j ,1 )+diu4(i+1,j-1,1 ) )
      visuz2=(evsz2)* ( diu3(i ,j ,2 )+diu7(i+1,j ,1 ) )
      visuz1=(0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
      vfu= (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
      F(i,j,1)=(F(i,j,1)+vfu)
      end do
      end do
      do k = 2,km
      do j = 1,jm
      do i = 1,im
      evsy2 = sm(i,j+1,k)
      evsy1 = sm(i,j,k)
      evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1, &
      k)) /(dx1(i)+dx1(i+1)))) /(dy1(j)+dy1(j+1))
      evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j, &
      k)) /(dx1(i-1)+dx1(i))) +dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1, &
      k)) /(dx1(i-1)+dx1(i)))) /(dy1(j)+dy1(j+1))
      evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j, &
      k+1)) /(dx1(i)+dx1(i+1)))) /(dzn(k)+dzn(k+1))
      evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j, &
      k-1)) /(dx1(i)+dx1(i+1))) +dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1)))) /(dzn(k-1)+dzn(k))
      visvx2 = (evsx2)* ( diu2(i ,j+1,k )+diu4(i+1,j ,k ) )
      visvx1 = (evsx1)* ( diu2(i-1,j+1,k )+diu4(i ,j ,k ) )
      visvy2 = (evsy2)*2.*diu5(i ,j+1,k )
      visvy1 = (evsy1)*2.*diu5(i ,j ,k )
      visvz2 = (evsz2)* ( diu6(i ,j ,k+1)+diu8(i ,j+1,k ) )
      visvz1 = (evsz1)* ( diu6(i ,j ,k )+diu8(i ,j+1,k-1) )
      vfv = (visvx2-visvx1)/dx1(i) +(visvy2-visvy1)/dys(j) +(visvz2-visvz1)/dzn(k)
      g(i,j,k) = (g(i,j,k)+vfv)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
      evsy2=sm(i,j+1,1)
      evsy1=sm(i,j,1)
      evsx2=(dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
      evsx1=(dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))&
      +dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
      evsz2=(dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
      visvx2=(evsx2)* ( diu2(i ,j+1,1 )+diu4(i+1,j ,1 ) )
      visvx1=(evsx1)* ( diu2(i-1,j+1,1 )+diu4(i ,j ,1 ) )
      visvy2=(evsy2)*2.*diu5(i ,j+1,1 )
      visvy1=(evsy1)*2.*diu5(i ,j ,1 )
      visvz2=(evsz2)* ( diu6(i ,j ,2 )+diu8(i ,j+1,1 ) )
      visvz1=(0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
      vfv=(visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
      G(i,j,1)=(G(i,j,1)+vfv)
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
      evsz2 = sm(i,j,k+1)
      evsz1 = sm(i,j,k)
      evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j, &
      k+1)) /(dx1(i)+dx1(i+1)))) /(dzn(k)+dzn(k+1))
      evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j, &
      k)) /(dx1(i-1)+dx1(i))) +dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j, &
      k+1)) /(dx1(i-1)+dx1(i)))) /(dzn(k)+dzn(k+1))
      evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1, &
      k)) /(dy1(j)+dy1(j+1))) +dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1, &
      k+1)) /(dy1(j)+dy1(j+1)))) /(dzn(k)+dzn(k+1))
      evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j, &
      k)) /(dy1(j-1)+dy1(j))) +dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j, &
      k+1)) /(dy1(j-1)+dy1(j)))) /(dzn(k)+dzn(k+1))
      viswx2 = (evsx2)* ( diu3(i ,j ,k+1)+diu7(i+1,j ,k ) )
      viswx1 = (evsx1)* ( diu3(i-1,j ,k+1)+diu7(i ,j ,k ) )
      viswy2 = (evsy2)* ( diu6(i ,j ,k+1)+diu8(i ,j+1,k ) )
      viswy1 = (evsy1)* ( diu6(i ,j-1,k+1)+diu8(i ,j ,k ) )
      viswz2 = (evsz2)*2.*diu9(i ,j ,k+1)
      viswz1 = (evsz1)*2.*diu9(i ,j ,k )
      vfw = (viswx2-viswx1)/dx1(i) +(viswy2-viswy1)/dy1(j) +(viswz2-viswz1)/dzn(k)
      h(i,j,k) = (h(i,j,k)+vfw)
      end do
      end do
      end do
      return
      end subroutine les
end module module_les

Test3: False       use module_les
Test1: ./src/module_boundp.f95 False
Test2: ./src/boundp.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_boundp
 contains
subroutine boundp2(jm,im,p,km)
    use common_sn 
      implicit none
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    integer :: i, j
    do j = 0,jm+1
        do i = 0,im+1
            p(i,j, 0) = p(i,j,1)
            p(i,j,km+1) = p(i,j,km)
        end do
    end do
end subroutine boundp2
subroutine boundp1(km,jm,p,im)
    use common_sn 
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    integer :: i, j, k
        do k = 0,km+1
            do j = 0,jm+1
                    p( 0,j,k) = p(1 ,j,k)
                    p(im+1,j,k) = p(im,j,k)
            end do
        end do
    do k = 0,km+1
        do i = 0,im+1
            p(i, 0,k) = p(i,jm,k) 
            p(i,jm+1,k) = p(i, 1,k) 
        end do
    end do
end subroutine boundp1
end module module_boundp

Test3: False       use module_boundp
Test1: ./src/module_feedbfm.f95 False
Test2: ./src/feedbfm.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbfm_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_feedbfm
 contains
subroutine feedbfm(km,jm,im,amask1,bmask1,cmask1,dmask1,zbm,z2,dzn)
    use common_sn 
      implicit none
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: amask1
    real(kind=4), dimension(-1:ip+1,0:jp+1,0:kp+1) , intent(Out) :: bmask1
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: cmask1
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: dmask1
    real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:kp+2) , intent(In) :: z2
    real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(InOut) :: zbm
    integer :: i, j, k
    real(kind=4), dimension(-1:3001,-1:751) :: dsm,dem
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                amask1(i,j,k) = 1.
                bmask1(i,j,k) = 0.
                cmask1(i,j,k) = 0.
                dmask1(i,j,k) = 0.
            end do
        end do
    end do
        print*, 'zbm sum - file getting read'
      open(70,file='./GIS/DEM_LES_GIS.txt',form='formatted',status='unknown')
      do j=1,750
        do i=1,3000
          read(70,*) dem(i,j)
        end do
      end do
      close(70)
      open(71,file='./GIS/DSM_LES_GIS.txt',form='formatted',status='unknown')
      do j=1,750
        do i=1,3000
          read(71,*) dsm(i,j)
        end do
      end do
      close(71)
      do j=1,250
        do i=1,2750
          zbm(i+125,j+25)=dsm(i+250,j+138)-dem(i+250,j+138)
        end do
      end do
    do j = 1,jm
        do i = 1,im
            do k = 1,km
                if(zbm(i,j) > z2(k)+0.5*dzn(k)) then
                    amask1(i,j,k) = 0.0
                end if
            end do
        end do
    end do
    if (isMaster()) then
      do k=1,km
        write(*,*) 'z2=',z2(k)
      end do
    end if
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                if(amask1(i,j,k) == 0.0) then
                    bmask1(i,j,k) = 1.0
                    cmask1(i,j,k) = 1.0
                    dmask1(i,j,k) = 1.0
                end if
            end do
        end do
    end do
end subroutine feedbfm
end module module_feedbfm

Test3: False       use module_feedbfm
Test1: ./src/module_feedbf.f95 False
Test2: ./src/feedbf.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_feedbf
 contains
subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,&
                  dt,beta,fx,fy,fz,f,g,h)
    use common_sn 
    real(kind=4), intent(In) :: alpha
    real(kind=4), intent(In) :: beta
    real(kind=4), dimension(-1:ip+1,0:jp+1,0:kp+1) , intent(In) :: bmask1
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: cmask1
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(In) :: dmask1
    real(kind=4), intent(In) :: dt
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fx
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fy
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fz
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: h
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: usum
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: vsum
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: wsum
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                f1x = alpha*usum(i,j,k)*dt
                f1y = alpha*vsum(i,j,k)*dt
                f1z = alpha*wsum(i,j,k)*dt
                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                fx(i,j,k) = f1x+f2x
                fy(i,j,k) = f1y+f2y
                fz(i,j,k) = f1z+f2z
            end do
        end do
    end do
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                h(i,j,k) = h(i,j,k)+fz(i,j,k)
            end do
        end do
    end do
end subroutine feedbf
end module module_feedbf

Test3: False       use module_feedbf
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_ifdata
      use module_bondv1
      use module_velFG
      use module_les
      use module_boundp
      use module_feedbfm
      use module_feedbf
 contains
      subroutine zero_arrays(cov1,cov2,cov3,cov4,cov5,cov6,cov7,cov8,cov9, &
              dfu1, dfv1, dfw1, &
              diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9, &
              nou1,nou2,nou3,nou4,nou5,nou6,nou7,nou8,nou9 &
              )
      use common_sn
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov9
        real(kind=4), dimension(0:ip,jp,kp) , intent(Out) :: dfu1
        real(kind=4), dimension(ip,0:jp,kp) , intent(Out) :: dfv1
        real(kind=4), dimension(ip,jp,kp) , intent(Out) :: dfw1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu9
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
          do k = 0,kp+1
          do j = 0,jp+2
          do i = -1,ip+2
              cov1(i,j,k) = 0.0
              cov5(i,j,k) = 0.0
              diu1(i,j,k) = 0.0
              diu5(i,j,k) = 0.0
              nou1(i,j,k) = 0.0
              nou5(i,j,k) = 0.0
          end do
          end do
          end do
          do k = 0,kp+1
          do j = 0,jp+2
          do i = 0,ip+2
              cov2(i,j,k) = 0.0
              cov3(i,j,k) = 0.0
              cov4(i,j,k) = 0.0
              cov6(i,j,k) = 0.0
              cov7(i,j,k) = 0.0
              cov8(i,j,k) = 0.0
              cov9(i,j,k) = 0.0
              diu2(i,j,k) = 0.0
              diu3(i,j,k) = 0.0
              diu4(i,j,k) = 0.0
              diu6(i,j,k) = 0.0
              diu7(i,j,k) = 0.0
              diu8(i,j,k) = 0.0
              diu9(i,j,k) = 0.0
              nou2(i,j,k) = 0.0
              nou3(i,j,k) = 0.0
              nou4(i,j,k) = 0.0
              nou6(i,j,k) = 0.0
              nou7(i,j,k) = 0.0
              nou8(i,j,k) = 0.0
              nou9(i,j,k) = 0.0
          end do
          end do
          end do
          do k = 1,kp
          do j = 1,jp
          do i = 0,ip
              dfu1(i,j,k) = 0.0
          end do
          end do
          end do
          do k = 1,kp
          do j = 0,jp
          do i = 1,ip
              dfv1(i,j,k) = 0.0
          end do
          end do
          end do
          do k = 1,kp
          do j = 1,jp
          do i = 1,ip
              dfw1(i,j,k) = 0.0
          end do
          end do
          end do
      end subroutine
      subroutine ifdata( &
      data30,data31, fold,gold,hold,fghold, time, &
      n,u,im,jm,km,v,w,p,usum,vsum,wsum, &
      delx1,dx1,dy1,dzn,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,z2,dt, &
      dxs,cov1,cov2,cov3,dfu1,vn,cov4,cov5,cov6,dfv1,cov7,cov8,cov9,dfw1,dzs,nou1,nou5,nou9,nou2, &
      nou3,nou4,nou6,nou7,nou8,bmask1,cmask1,dmask1,alpha,beta,fx,fy,fz,amask1,zbm,ical)
      use common_sn 
        character(len=70), intent(In) :: data30
        character(len=70), intent(In) :: data31
        real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: fghold
        real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: fold
        real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: gold
        real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: hold
        real(kind=4), intent(InOut) :: time
        integer, intent(In) :: ical
        real(kind=4), intent(In) :: alpha
        real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: amask1
        real(kind=4), intent(In) :: beta
        real(kind=4), dimension(-1:ip+1,0:jp+1,0:kp+1) , intent(InOut) :: bmask1
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: cmask1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov9
        real(kind=4), dimension(kp) , intent(Out) :: delx1
        real(kind=4), dimension(0:ip,jp,kp) , intent(Out) :: dfu1
        real(kind=4), dimension(ip,0:jp,kp) , intent(Out) :: dfv1
        real(kind=4), dimension(ip,jp,kp) , intent(Out) :: dfw1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu9
        real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(InOut) :: dmask1
        real(kind=4), intent(In) :: dt
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:ip) , intent(In) :: dxs
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: f
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fx
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fy
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fz
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: g
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: h
        integer, intent(InOut) :: im
        integer, intent(InOut) :: jm
        integer, intent(InOut) :: km
        integer, intent(InOut) :: n
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
        real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: sm
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: u
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: usum
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: v
        real(kind=4), intent(In) :: vn
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: vsum
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(InOut) :: w
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: wsum
        real(kind=4), dimension(0:kp+2) , intent(In) :: z2
        real(kind=4), dimension(-1:ipmax+1,-1:jpmax+1) , intent(InOut) :: zbm
    real(kind=4),allocatable :: ua(:,:,:)
    real(kind=4),allocatable :: va(:,:,:)
    real(kind=4),allocatable :: wa(:,:,:)
    real(kind=4),allocatable :: usuma(:,:,:)
    real(kind=4),allocatable :: vsuma(:,:,:)
    real(kind=4),allocatable :: wsuma(:,:,:)
    real(kind=4),allocatable :: pa(:,:,:)
    real(kind=4),allocatable :: fa(:,:,:)
    real(kind=4),allocatable :: ga(:,:,:)
    real(kind=4),allocatable :: ha(:,:,:)
    real(kind=4),allocatable :: folda(:,:,:)
    real(kind=4),allocatable :: golda(:,:,:)
    real(kind=4),allocatable :: holda(:,:,:)
    if ((im/=ip) .or. (jm/=jp) .or. (km/=kp)) then
            print *, "im,km,km is different from ip,jp,kp, aborting
            call exit(-1)
    end if
       if(ical == 1) then
        if (isMaster()) then
        open(unit=30,file='data30048000.dat',form='unformatted',status='unknown')
        read(30) n,time
        end if
        allocate(ua(0:ipmax+1,-1:jpmax+1,0:kp+1))
        if (isMaster()) then
        read(30) (((ua(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifu(ua, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         u(i,j,k)=ua(i,j,k)
        end do
        end do
        end do
        deallocate(ua)
        allocate(va(0:ipmax+1,-1:jpmax+1,0:kp+1))
        if (isMaster()) then
        read(30) (((va(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifu(va, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         v(i,j,k)=va(i,j,k)
        end do
        end do
        end do
        deallocate(va)
        allocate(wa(0:ipmax+1,-1:jpmax+1,-1:kp+1))
        if (isMaster()) then
        read(30) (((wa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifw(wa, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         w(i,j,k)=wa(i,j,k)
        end do
        end do
        end do
        deallocate(wa)
        allocate(pa(0:ipmax+2,0:jpmax+2,0:kp+1))
        if (isMaster()) then
        read(30) (((pa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifp(pa, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         p(i,j,k)=pa(i,j,k)
        end do
        end do
        end do
        deallocate(pa)
        allocate(usuma(0:ipmax,0:jpmax,0:kp))
        if (isMaster()) then
        read(30) (((usuma(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifusum(usuma, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         usum(i,j,k)=usuma(i,j,k)
        end do
        end do
        end do
        deallocate(usuma)
        allocate(vsuma(0:ipmax,0:jpmax,0:kp))
        if (isMaster()) then
        read(30) (((vsuma(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifusum(vsuma, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         vsum(i,j,k)=vsuma(i,j,k)
        end do
        end do
        end do
        deallocate(vsuma)
        allocate(wsuma(0:ipmax,0:jpmax,0:kp))
        if (isMaster()) then
        read(30) (((wsuma(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeifusum(wsuma, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         wsum(i,j,k)=wsuma(i,j,k)
        end do
        end do
        end do
        deallocate(wsuma)
        if (isMaster()) then
        close(30)
        end if
        if (isMaster()) then
        open(unit=31,file='data31048000.dat',form='unformatted',status='unknown')
        end if
        allocate(fa(0:ipmax,0:jpmax,0:kp))
        if (isMaster()) then
        read(31) (((fa(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeiff(fa, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         f(i,j,k)=fa(i,j,k)
        end do
        end do
        end do
        deallocate(fa)
        allocate(ga(0:ipmax,0:jpmax,0:kp))
        if (isMaster()) then
        read(31) (((ga(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeiff(ga, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         g(i,j,k)=ga(i,j,k)
        end do
        end do
        end do
        deallocate(ga)
        allocate(ha(0:ipmax,0:jpmax,0:kp))
        if (isMaster()) then
        read(31) (((ha(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeiff(ha, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         h(i,j,k)=ha(i,j,k)
        end do
        end do
        end do
        deallocate(ha)
        allocate(folda(ipmax,jpmax,kp))
        if (isMaster()) then
        read(31) (((folda(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeiffold(folda, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         fold(i,j,k)=folda(i./src/velnw_tmp.f95:23:17: warning: missing terminating ' character
 ! Which means it's the values of f,g,h that are changing. g seems fine.
                 ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
,j,k)
        end do
        end do
        end do
        deallocate(folda)
        allocate(golda(ipmax,jpmax,kp))
        if (isMaster()) then
        read(31) (((golda(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeiffold(golda, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         gold(i,j,k)=golda(i,j,k)
        end do
        end do
        end do
        deallocate(golda)
        allocate(holda(ipmax,jpmax,kp))
        if (isMaster()) then
        read(31) (((holda(i,j,k),i=1,ipmax),j=1,jpmax),k=1,km)
        end if
        call distributeiffold(holda, ip, jp, kp, ipmax, jpmax, procPerRow)
        do k=1,km
        do j=1,jm
        do i=1,im
         hold(i,j,k)=holda(i,j,k)
        end do
        end do
        end do
        deallocate(holda)
        if (isMaster()) then
        close(31)
        end if
        call zero_arrays( &
              cov1,cov2,cov3,cov4,cov5,cov6,cov7,cov8,cov9, &
              dfu1, dfv1, dfw1, &
              diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9, &
              nou1,nou2,nou3,nou4,nou5,nou6,nou7,nou8,nou9 &
         )
     end if
      end subroutine ifdata
end module module_ifdata

Test3: False     use module_ifdata
Test1: ./src/module_velnw.f95 False
Test2: ./src/velnw.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_velnw
 contains
      subroutine velnw(km,jm,im,p,ro,dxs,u,dt,f,dys,v,g,dzs,w,h)
      use common_sn 
        real(kind=4), intent(In) :: dt
        real(kind=4), dimension(0:ip) , intent(In) :: dxs
        real(kind=4), dimension(0:jp) , intent(In) :: dys
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In) :: f
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In) :: g
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In) :: h
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(In) :: p
        real(kind=4), intent(In) :: ro
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: u
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: v
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(InOut) :: w
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
        u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
        v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
      end do
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
        pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
        w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
      end do
      end do
      end do
      return
      end subroutine velnw
end module module_velnw

Test3: False     use module_velnw
Test1: ./src/module_bondv1.f95 False
Test2: ./src/bondv1.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_bondv1
 contains
subroutine bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
    use common_sn 
      implicit none
    real(kind=4), intent(In) :: dt
    real(kind=4), dimension(0:ip) , intent(In) :: dxs
    real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
    integer, intent(In) :: im, jm, km, n
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: u
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: v
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(InOut) :: w
    real(kind=4), dimension(0:kp+2) , intent(In) :: z2
    real(kind=4) :: u_val
    integer :: i, j, k
    real(kind=4) :: aaa, bbb, uout
        do i = 0,1
            do k = 1,78 
                do j = 1,jm
                    u(i,j,k) = 5.0
                    v(i,j,k) = 0.0
                    w(i,j,k) = 0.0
                end do
            end do
        end do
        do i = 0,1
            do k = 79,km
                do j = 1,jm
                    u(i,j,k) = u(i,j,77)
                    v(i,j,k) = 0.0
                    w(i,j,k) = 0.0
                end do
            end do
        end do
    if(n == 1) then
        do k = 1,km
            do j = 1,jm
                do i = 2, im
                    u(i,j,k) = u(1,j,k)
                    v(i,j,k) = v(1,j,k)
                    w(i,j,k) = w(1,j,k)
                end do
            end do
        end do
    endif
    aaa = 0.0
    bbb = 0.0
    do k = 1,km
        do j = 1,jm
            aaa = amax1(aaa,u(im,j,k))
            bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1,km
        do j = 1,jm
            u(im,j,k) = u(im,j,k)-dt*uout *(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1,km
        do j = 1,jm
            v(im+1,j,k) = v(im+1,j,k)-dt*uout *(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1,km
        do j = 1,jm
            w(im+1,j,k) = w(im+1,j,k)-dt*uout *(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0,km+1
        do i = 0,im+1
            u(i, 0,k) = u(i,jm ,k)
            u(i,jm+1,k) = u(i, 1,k)
        end do
    end do
    do k = 0,km+1
        do i = 0,im+1
            v(i, 0,k) = v(i,jm ,k)
            v(i,jm+1,k) = v(i, 1,k)
        end do
    end do
    do k = 0,km
        do i = 0,im+1
            w(i, 0,k) = w(i,jm ,k)
            w(i,jm+1,k) = w(i, 1,k)
        end do
    end do
    do j = 0,jm+1
        do i = 0,im+1
            u(i,j, 0) = -u(i,j, 1)
            u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0,jm+1
        do i = 0,im+1
            v(i,j, 0) = -v(i,j, 1)
            v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1,jm+1 
        do i = 0,im+1
            w(i,j, 0) = 0.0
            w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1
end module module_bondv1

Test3: False     use module_bondv1
Test1: ./src/module_bondv1_data24.f95 False
Test2: ./src/bondv1_data24.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_data24_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/communication_helper_mpi.f95 True
Test2: ./src/communication_helper_mpi.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/communication_helper_mpi_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/communication_common.f95 True
Test2: ./src/communication_common.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/communication_common_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/fortran_helper.f95 True
Test2: ./src/fortran_helper.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/fortran_helper_tmp.f95 | grep -v -E '^\s*$' 
Module content module fortran_helper
 contains
subroutine zero3DReal4Array(array)
      implicit none
    real(kind=4), dimension(:,:,:), intent(inout) :: array
    integer :: i, j, k
    do i=1, size(array,1)
        do j=1, size(array,2)
            do k=1, size(array,3)
                array(i,j,k) = 0.0
            end do
        end do
    end do
end subroutine zero3DReal4Array
subroutine zero2DReal4Array(array)
    real(kind=4), dimension(:,:), intent(inout) :: array
    integer :: i, j
    do i=1, size(array,1)
        do j=1, size(array,2)
            array(i,j) = 0.0
        end do
    end do
end subroutine zero2DReal4Array
subroutine zero1DReal4Array(array)
    real(kind=4), dimension(:), intent(inout) :: array
    integer :: i
    do i=1, size(array,1)
        array(i) = 0.0
    end do
end subroutine zero1DReal4Array
subroutine outputArray(array)
    integer, dimension(:,:), intent(in) :: array
    integer :: col, row
    do row = 1, size(array, 1)
        do col = 1, size(array,2)
            if (array(row, col) .ne. -1) then
                write(*,"(I4)",advance="no") array(row,col)
            else
                write(*,"(A4)",advance="no") '-'
            end if
        end do
        write (*,*)
    end do
    write (*,*)
end subroutine outputArray
subroutine outputArrayReal(array)
    real(kind=4), dimension(:,:), intent(in) :: array
    integer :: col, row
    do row = 1, size(array, 1)
        do col = 1, size(array,2)
            if (array(row, col) .ne. -1.0) then
                write(*,"(F6.2)",advance="no") array(row,col)
            else
                write(*,"(A6)", advance="no") '-'
            end if
        end do
        write (*,*)
    end do
    write (*,*)
end subroutine outputArrayReal
end module fortran_helper

Test3: False use fortran_helper
Module content module communication_common
use fortran_helper
integer, parameter :: topTag = 1, bottomTag = 2, leftTag = 3, rightTag = 4
integer, parameter :: zbmTag = 5
integer, parameter :: leftSideTag = 6, rightSideTag = 7
integer, parameter :: dxTag = 8, dyTag = 9, collect3DReal4Tag = 10
integer, parameter :: topLeftTag = 11, topRightTag = 12, bottomLeftTag = 13, bottomRightTag = 14
integer, parameter :: globalSumTag = 15, globalMaxTag = 16, globalMinTag = 17
integer, parameter :: leftNeighbour = 1, rightNeighbour = 2, topNeighbour = 3, bottomNeighbour = 4
end module

Test3: True use communication_common
Test1: ./src/mpi.f95 False
Test2: ./src/mpi.f95 False
Module content 
Test3: True use mpi
Module content module communication_helper_mpi
      implicit none
integer, parameter :: topTag = 1, bottomTag = 2, leftTag = 3, rightTag = 4
integer, parameter :: zbmTag = 5
integer, parameter :: leftSideTag = 6, rightSideTag = 7
integer, parameter :: dxTag = 8, dyTag = 9, collect3DReal4Tag = 10
integer, parameter :: topLeftTag = 11, topRightTag = 12, bottomLeftTag = 13, bottomRightTag = 14
integer, parameter :: globalSumTag = 15, globalMaxTag = 16, globalMinTag = 17
integer, parameter :: leftNeighbour = 1, rightNeighbour = 2, topNeighbour = 3, bottomNeighbour = 4
integer(kind=4) :: rank, cartRank, mpi_size, ierror, status(MPI_STATUS_SIZE)
integer :: communicator, cartTopComm
 contains
subroutine initialise_mpi()
    logical :: alreadyInitialised
    communicator = MPI_COMM_WORLD
    call MPI_Initialized(alreadyInitialised, ierror)
    call checkMPIError()
    if (.not. alreadyInitialised) then
        call MPI_Init(ierror)
        call checkMPIError()
    end if
    call MPI_COMM_Rank(communicator, rank, ierror)
    call checkMPIError()
    call MPI_COMM_Size(communicator, mpi_size, ierror)
    call checkMPIError()
end subroutine initialise_mpi
subroutine finalise_mpi()
    call MPI_Finalize(ierror)
    call checkMPIError()
end subroutine
subroutine checkMPIError()
    integer :: abortError
    if (ierror .ne. MPI_SUCCESS) then
        print*, ierror, " MPI error
        call MPI_Abort(communicator, ierror, abortError)
    end if
end subroutine checkMPIError
subroutine setupCartesianVirtualTopology(dimensions, dimensionSizes, periodicDimensions, coordinates, neighbours, reorder)
    integer, intent(in) :: dimensions
    integer, intent(in) :: dimensionSizes(dimensions)
    logical, intent(in) :: periodicDimensions(dimensions)
    integer, intent(out) :: coordinates(dimensions)
    integer, intent(out) :: neighbours(2*dimensions)
    logical, intent(in) :: reorder
    call MPI_Cart_Create(communicator, dimensions, dimensionSizes, &
                         periodicDimensions, reorder, cartTopComm, ierror)
    call checkMPIError()
    call MPI_Comm_Rank(cartTopComm, cartRank, ierror)
    call checkMPIError()
    call MPI_Cart_Coords(cartTopComm, cartRank, dimensions, coordinates, ierror)
    call checkMPIError()
    call MPI_Cart_Shift(cartTopComm, 0, 1, neighbours(topNeighbour), neighbours(bottomNeighbour), ierror)
    call checkMPIError()
    call MPI_Cart_Shift(cartTopComm, 1, 1, neighbours(leftNeighbour), neighbours(rightNeighbour), ierror)
end subroutine setupCartesianVirtualTopology
logical function isMaster()
    isMaster = rank .eq. 0
end function isMaster
logical function isTopRow(procPerRow)
    integer, intent(in) :: procPerRow
    isTopRow = rank .lt. procPerRow
end function isTopRow
logical function isTopRowNeighbours(neighbours)
    integer, dimension(:), intent(in) :: neighbours
    isTopRowNeighbours = neighbours(topNeighbour) .eq. -1
end function isTopRowNeighbours
logical function isBottomRow(procPerRow)
    integer, intent(in) :: procPerRow
    isBottomRow = rank .gt. (mpi_size - procPerRow - 1)
end function isBottomRow
logical function isBottomRowNeighbours(neighbours)
    integer, dimension(:), intent(in) :: neighbours
    isBottomRowNeighbours = neighbours(bottomNeighbour) .eq. -1
end function isBottomRowNeighbours
logical function isLeftmostColumn(procPerRow)
    integer, intent(in) :: procPerRow
    isLeftmostColumn = modulo(rank, procPerRow) .eq. 0
end function isLeftmostColumn
logical function isLeftmostColumnNeighbours(neighbours)
    integer, dimension(:), intent(in) :: neighbours
    isLeftmostColumnNeighbours = neighbours(leftNeighbour) .eq. -1
end function isLeftmostColumnNeighbours
logical function isRightmostColumn(procPerRow)
    integer, intent(in) :: procPerRow
    isRightmostColumn = modulo(rank, procPerRow) .eq. (procPerRow - 1)
end function isRightmostColumn
logical function isRightmostColumnNeighbours(neighbours)
    integer, dimension(:), intent(in) :: neighbours
    isRightmostColumnNeighbours = neighbours(rightNeighbour) .eq. -1
end function isRightmostColumnNeighbours
integer function topLeftRowValue(process, procPerRow, rowCount)
    integer, intent(in) :: process, procPerRow, rowCount
    topLeftRowValue = process / procPerRow * rowCount
end function topLeftRowValue
integer function topLeftColValue(process, procPerRow, colCount)
    integer, intent(in) :: process, procPerRow, colCount
    topLeftColValue = modulo(process, procPerRow) * colCount
end function topLeftColValue
end module

Test3: False use communication_helper_mpi
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_bondv1_data24
use communication_helper_mpi
 contains
subroutine bondv1_data24(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
    use common_sn 
      implicit none
    real(kind=4), intent(In) :: dt
    real(kind=4), dimension(0:ip) , intent(In) :: dxs
    real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
    integer, intent(In) :: im, jm, km, n
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: u
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: v
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(InOut) :: w
    real(kind=4), dimension(kp+2) , intent(In) :: z2
    real(kind=4) :: u_val
    integer :: i, j, k
    real(kind=4) :: aaa, bbb, uout
       if (isMaster()) then
       write(filename,'("/hdd2/yoshida/b33394/MPI-LES/driver/driver_1_MPI-LES/3_src/data24_out",i6.6, ".dat")') n+48000
      open(unit=40,file=filename,form='unformatted',status='old',access='direct',recl=4*1200)
      irec=1
        do k=1,km
        read(40,rec=irec) (ub(1,j,k),j=1,1200)
      irec=irec+1
        end do
        do k=1,km
        read(40,rec=irec) (wb(1,j,k),j=1,1200)
      irec=irec+1
        end do
        do k=1,km
        read(40,rec=irec) (vb(1,j,k),j=1,1200)
      irec=irec+1
        end do
        close(40)
      end if
      do k=1,km
      do j=1,jpmax
       ua(1,j,k)=ub(1,400+j,k)
       va(1,j,k)=vb(1,400+j,k)
       wa(1,j,k)=wb(1,400+j,k)
      end do
      end do
    if (isTopRow(procPerRow)) then
  call distributebondu(ua, ip, jp, kp, ipmax, jpmax, procPerRow)
  call distributebondv(va, ip, jp, kp, ipmax, jpmax, procPerRow)
  call distributebondw(wa, ip, jp, kp, ipmax, jpmax, procPerRow)
      do k=1,km
      do j=1,jm
      do i=0,1
       u(i,j,k)=ua(1,j,k)
       v(i,j,k)=va(1,j,k)
       w(i,j,k)=wa(1,j,k)
      end do
      end do
      end do
   end if
    if(n == 1) then
        do k = 1,km
            do j = 1,jm
                do i = 2, im
                    u(i,j,k) = u(1,j,k)
                    v(i,j,k) = v(1,j,k)
                    w(i,j,k) = w(1,j,k)
                end do
            end do
        end do
    endif
    aaa = 0.0
    bbb = 0.0
    do k = 1,km
        do j = 1,jm
            aaa = amax1(aaa,u(im,j,k))
            bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1,km
        do j = 1,jm
            u(im,j,k) = u(im,j,k)-dt*uout *(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1,km
        do j = 1,jm
            v(im+1,j,k) = v(im+1,j,k)-dt*uout *(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1,km
        do j = 1,jm
            w(im+1,j,k) = w(im+1,j,k)-dt*uout *(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0,km+1
        do i = 0,im+1
            u(i, 0,k) = u(i,jm ,k)
            u(i,jm+1,k) = u(i, 1,k)
        end do
    end do
    do k = 0,km+1
        do i = 0,im+1
            v(i, 0,k) = v(i,jm ,k)
            v(i,jm+1,k) = v(i, 1,k)
        end do
    end do
    do k = 0,km
        do i = 0,im+1
            w(i, 0,k) = w(i,jm ,k)
            w(i,jm+1,k) = w(i, 1,k)
        end do
    end do
    do j = 0,jm+1
        do i = 0,im+1
            u(i,j, 0) = -u(i,j, 1)
            u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0,jm+1
        do i = 0,im+1
            v(i,j, 0) = -v(i,j, 1)
            v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1,jm+1 
        do i = 0,im+1
            w(i,j, 0) = 0.0
            w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1_data24
end module module_bondv1_data24

Test3: False     use module_bondv1_data24
Test1: ./src/module_velFG.f95 False
Test2: ./src/velFG.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velFG_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_vel2.f95 False
Test2: ./src/vel2.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/vel2_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_vel2
 contains
      subroutine vel2(km,jm,im,nou1,u,diu1,dx1,nou5,v,diu5,dy1,nou9,w,diu9,dzn,cov1,cov5,cov9,nou2, &
      diu2,cov2,nou3,diu3,dzs,cov3,nou4,diu4,cov4,nou6,diu6,cov6,nou7,diu7,cov7,nou8,diu8,cov8,uspd,vspd)
      use common_sn 
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov9
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu9
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: uspd
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: vspd
      integer, parameter :: u0 = 0
      do j=1,jm
        do i=1,im
         uspd(i,j)=(u(i,j,1)**2+((0.5*(v(i,j-1,1)+v(i,j,1))*dx1(i+1)&
     +0.5*(v(i+1,j-1,1)+v(i+1,j,1))*dx1(i))/(dx1(i)+dx1(i+1)))**2)**0.5
        end do
        end do
        do j=1,jm
        do i=1,im
         vspd(i,j)=(v(i,j,1)**2+((0.5*(u(i-1,j,1)+u(i,j,1))*dy1(j+1)&
     +0.5*(u(i-1,j+1,1)+u(i,j+1,1))*dy1(j))/(dy1(j)+dy1(j+1)))**2)**0.5
        end do
        end do
       if (isMaster()) then
        write(6,*) 'CHK_uspd=',uspd(im/2,jm/2),vspd(im/2,jm/2)
       end if
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        nou1(i,j,k) = (u(i-1,j,k)+u(i,j,k))/2.
        diu1(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)
        nou5(i,j,k) = (v(i,j-1,k)+v(i,j,k))/2.
        diu5(i,j,k) = (-v(i,j-1,k)+v(i,j,k))/dy1(j)
        nou9(i,j,k) = (w(i,j,k-1)+w(i,j,k))/2.
        diu9(i,j,k) = (-w(i,j,k-1)+w(i,j,k))/dzn(k)
        cov1(i,j,k) = nou1(i,j,k)*diu1(i,j,k)
        cov5(i,j,k) = nou5(i,j,k)*diu5(i,j,k)
        cov9(i,j,k) = nou9(i,j,k)*diu9(i,j,k)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        nou2(i,j,k) = (dx1(i+1)*v(i,j-1,k)+dx1(i)*v(i+1,j-1,k)) /(dx1(i)+dx1(i+1))
        diu2(i,j,k) = 2.*(-u(i,j-1,k)+u(i,j,k))/(dy1(j-1)+dy1(j))
        cov2(i,j,k) = nou2(i,j,k)*diu2(i,j,k)
      end do
      end do
      end do
      do k = 2,km+1
      do j = 1,jm
      do i = 1,im
        nou3(i,j,k) = (dx1(i+1)*w(i,j,k-1)+dx1(i)*w(i+1,j,k-1)) /(dx1(i)+dx1(i+1))
        diu3(i,j,k) = (-u(i,j,k-1)+u(i,j,k))/dzs(k-1)
        cov3(i,j,k) = nou3(i,j,k)*diu3(i,j,k)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
       nou3(i,j,1) = 0.5*(dx1(i+1)*w(i,j,1)+dx1(i)*w(i+1,j,1))/(dx1(i)+dx1(i+1))
       diu3(i,j,1)=uspd(i,j)*0.4/alog(0.5*dzn(1)/0.1)/(0.5*dzn(1))/0.4*u(i,j,1)/uspd(i,j)
       cov3(i,j,1) = nou3(i,j,1)*diu3(i,j,1)
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        nou4(i,j,k) = (dy1(j+1)*u(i-1,j,k)+dy1(j)*u(i-1,j+1,k)) /(dy1(j)+dy1(j+1))
        diu4(i,j,k) = 2.*(-v(i-1,j,k)+v(i,j,k))/(dx1(i-1)+dx1(i))
        cov4(i,j,k) = (nou4(i,j,k)-u0)*diu4(i,j,k)
      end do
      end do
      end do
      do k = 2,km+1
      do j = 1,jm
      do i = 1,im
        nou6(i,j,k) = (dy1(j+1)*w(i,j,k-1)+dy1(j)*w(i,j+1,k-1)) /(dy1(j)+dy1(j+1))
        diu6(i,j,k) = (-v(i,j,k-1)+v(i,j,k))/dzs(k-1)
        cov6(i,j,k) = nou6(i,j,k)*diu6(i,j,k)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
       nou6(i,j,1) = 0.5*(dy1(j+1)*w(i,j,1)+dy1(j)*w(i,j+1,1))/(dy1(j)+dy1(j+1))
       diu6(i,j,1)=vspd(i,j)*0.4/alog(0.5*dzn(1)/0.1)/(0.5*dzn(1))/0.4*v(i,j,1)/vspd(i,j)
       cov6(i,j,1) = nou6(i,j,1)*diu6(i,j,1)
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
        nou7(i,j,k) = (dzn(k+1)*u(i-1,j,k)+dzn(k)*u(i-1,j,k+1)) /(dzn(k)+dzn(k+1))
        diu7(i,j,k) = 2.*(-w(i-1,j,k)+w(i,j,k))/(dx1(i-1)+dx1(i))
        cov7(i,j,k) = (nou7(i,j,k)-u0)*diu7(i,j,k)
      end do
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
        nou8(i,j,k) = (dzn(k+1)*v(i,j-1,k)+dzn(k)*v(i,j-1,k+1)) /(dzn(k)+dzn(k+1))
        diu8(i,j,k) = 2.*(-w(i,j-1,k)+w(i,j,k))/(dy1(j-1)+dy1(j))
        cov8(i,j,k) = nou8(i,j,k)*diu8(i,j,k)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
        nou1(im+1,j,k) = nou1(im,j,k)
        diu1(im+1,j,k) = diu1(im,j,k)
        cov1(im+1,j,k) = cov1(im,j,k)
      end do
      end do
      do k = 1,km
      do i = 1,im
        nou2(i,0,k) = nou2(i,jm,k)
        diu2(i,0,k) = diu2(i,jm,k)
        cov2(i,0,k) = cov2(i,jm,k)
        nou2(i,jm+1,k) = nou2(i,1,k)
        diu2(i,jm+1,k) = diu2(i,1,k)
        cov2(i,jm+1,k) = cov2(i,1,k)
      end do
      end do
      do k = 1,km
      do j = 1,jm
        nou4(im+1,j,k) = nou4(im,j,k)
        diu4(im+1,j,k) = diu4(im,j,k)
        cov4(im+1,j,k) = cov4(im,j,k)
      end do
      end do
      do k = 1,km
      do i = 1,im
        nou5(i,0,k) = nou5(i,jm,k)
        diu5(i,0,k) = diu5(i,jm,k)
        cov5(i,0,k) = cov5(i,jm,k)
        nou5(i,jm+1,k) = nou5(i,1,k)
        diu5(i,jm+1,k) = diu5(i,1,k)
        cov5(i,jm+1,k) = cov5(i,1,k)
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
        nou7(im+1,j,k) = nou7(im,j,k)
        diu7(im+1,j,k) = diu7(im,j,k)
        cov7(im+1,j,k) = cov7(im,j,k)
      end do
      end do
      do k = 1,km-1
      do i = 1,im
        nou8(i,0,k) = nou8(i,jm,k)
        diu8(i,0,k) = diu8(i,jm,k)
        cov8(i,0,k) = cov8(i,jm,k)
        nou8(i,jm+1,k) = nou8(i,1,k)
        diu8(i,jm+1,k) = diu8(i,1,k)
        cov8(i,jm+1,k) = cov8(i,1,k)
      end do
      end do
      do k = 1,km+1
      do j = 1,jm+1
        diu2(im+1,j,k) = diu2(im,j,k)
        diu3(im+1,j,k) = diu3(im,j,k)
      end do
      end do
      do k = 1,km+1
      do i = 1,im+1
        diu4(i,0,k) = diu4(i,jm,k)
        diu6(i,0,k) = diu6(i,jm,k)
      end do
      end do
        do j=1,jm
        do i=1,im
         uspd(i,j)=u(i,j,1)/uspd(i,j)
         vspd(i,j)=v(i,j,1)/vspd(i,j)
        end do
        end do
end subroutine vel2
end module module_vel2

Test3: False       use module_vel2 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_velFG
      use module_vel2 
 contains
      subroutine velfg(km,jm,im,dx1,cov1,cov2,cov3,dfu1,diu1,diu2,dy1,diu3,dzn,vn,f,cov4,cov5,cov6, &
      dfv1,diu4,diu5,diu6,g,cov7,cov8,cov9,dfw1,diu7,diu8,diu9,dzs,h,nou1,u,nou5,v,nou9,w,nou2, &
      nou3,nou4,nou6,nou7,nou8,uspd,vspd)
      use common_sn 
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: cov9
        real(kind=4), dimension(0:ip,jp,kp) , intent(Out) :: dfu1
        real(kind=4), dimension(ip,0:jp,kp) , intent(Out) :: dfv1
        real(kind=4), dimension(ip,jp,kp) , intent(Out) :: dfw1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: diu9
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzs
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: f
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: g
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: h
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(Out) :: nou9
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
        real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
        real(kind=4), intent(In) :: vn
        real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: uspd
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(out) :: vspd
      call vel2(km,jm,im,nou1,u,diu1,dx1,nou5,v,diu5,dy1,nou9,w,diu9,dzn,cov1,cov5,cov9,nou2,diu2, &
           cov2,nou3,diu3,dzs,cov3,nou4,diu4,cov4,nou6,diu6,cov6,nou7,diu7,cov7,nou8,diu8,cov8,uspd,vspd)
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        covx1 = (dx1(i+1)*cov1(i,j,k)+dx1(i)*cov1(i+1,j,k)) /(dx1(i)+dx1(i+1))
        covy1 = (cov2(i,j,k)+cov2(i,j+1,k))/2.
        covz1 = (cov3(i,j,k)+cov3(i,j,k+1))/2.
        covc = covx1+covy1+covz1
        dfu1(i,j,k) = 2.*(-diu1(i,j,k)+diu1(i+1,j,k))/(dx1(i)+dx1(i+1)) + (-diu2(i,j,k)+diu2(i, &
      j+1,k))/dy1(j) + (-diu3(i,j,k)+diu3(i,j,k+1))/dzn(k)
        df = vn*dfu1(i,j,k)
        f(i,j,k) = (-covc+df)
      end do
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
        covx1 = (cov4(i,j,k)+cov4(i+1,j,k))/2.
        covy1 = (dy1(j+1)*cov5(i,j,k)+dy1(j)*cov5(i,j+1,k)) /(dy1(j)+dy1(j+1))
        covz1 = (cov6(i,j,k)+cov6(i,j,k+1))/2.
        covc = covx1+covy1+covz1
        dfv1(i,j,k) = (-diu4(i,j,k)+diu4(i+1,j,k))/dx1(i) +2.*(-diu5(i,j,k)+diu5(i,j+1, &
      k))/(dy1(j)+dy1(j+1)) +(-diu6(i,j,k)+diu6(i,j,k+1))/dzn(k)
        df = vn*dfv1(i,j,k)
        g(i,j,k) = (-covc+df)
      end do
      end do
      end do
      do k = 1,km-1
      do j = 1,jm
      do i = 1,im
       covx1 = (cov7(i,j,k)+cov7(i+1,j,k))/2.
       covy1 = (cov8(i,j,k)+cov8(i,j+1,k))/2.
       covz1 = (dzn(k+1)*cov9(i,j,k)+dzn(k)*cov9(i,j,k+1)) /(dzn(k)+dzn(k+1))
       covc = covx1+covy1+covz1
        dfw1(i,j,k) = (-diu7(i,j,k)+diu7(i+1,j,k))/dx1(i) +(-diu8(i,j,k)+diu8(i,j+1, &
      k))/dy1(j) +(-diu9(i,j,k)+diu9(i,j,k+1))/dzs(k)
        df = vn*dfw1(i,j,k)
        h(i,j,k) = (-covc+df)
      end do
      end do
      end do
      return
      end subroutine velFG
end module module_velFG

Test3: False     use module_velFG
Test1: ./src/module_feedbf.f95 False
Test2: ./src/feedbf.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_feedbf
 contains
subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,&
                  dt,beta,fx,fy,fz,f,g,h)
    use common_sn 
    real(kind=4), intent(In) :: alpha
    real(kind=4), intent(In) :: beta
    real(kind=4), dimension(-1:ip+1,0:jp+1,0:kp+1) , intent(In) :: bmask1
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: cmask1
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(In) :: dmask1
    real(kind=4), intent(In) :: dt
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fx
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fy
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: fz
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: h
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: usum
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: vsum
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: wsum
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                f1x = alpha*usum(i,j,k)*dt
                f1y = alpha*vsum(i,j,k)*dt
                f1z = alpha*wsum(i,j,k)*dt
                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                fx(i,j,k) = f1x+f2x
                fy(i,j,k) = f1y+f2y
                fz(i,j,k) = f1z+f2z
            end do
        end do
    end do
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                h(i,j,k) = h(i,j,k)+fz(i,j,k)
            end do
        end do
    end do
end subroutine feedbf
end module module_feedbf

Test3: False     use module_feedbf
Test1: ./src/module_les.f95 False
Test2: ./src/les.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_boundsm.f95 False
Test2: ./src/boundsm.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_boundsm
 contains
subroutine boundsm(km,jm,sm,im)
    use common_sn 
      implicit none
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: sm
    integer :: i, j, k
        do k = 0,km+1
            do j = -1,jm+1
                    sm( 0,j,k) = sm(1 ,j,k) 
                    sm(im+1,j,k) = sm(im,j,k)
            end do
        end do
        do k = 0,km+1
            do i = 0,im+1
                    sm(i,jm+1,k) = sm(i,jm ,k)
                    sm(i,0,k) = sm(i,1 ,k) 
            end do
        end do
    do j = -1,jm+1
        do i = 0,im+1
            sm(i,j, 0) = -sm(i,j, 1)
            sm(i,j,km+1) = sm(i,j,km)
        end do
    end do
end subroutine boundsm
end module module_boundsm

Test3: False       use module_boundsm 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Module content module module_les
      use module_boundsm 
 contains
      subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g, &
      h,uspd,vspd,dxs,dys)
      use common_sn 
        real(kind=4), dimension(kp) , intent(Out) :: delx1
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu1
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu2
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu3
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu4
        real(kind=4), dimension(-1:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu5
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu6
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu7
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu8
        real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+2) , intent(In) :: diu9
        real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
        real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
        real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
        real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: h
        integer, intent(In) :: im
        integer, intent(In) :: jm
        integer, intent(In) :: km
        real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(Out) :: sm
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(in) :: uspd
        real(kind=4), dimension(0:ip+1,0:jp+1) , intent(in) :: vspd
        real(kind=4), dimension(0:ip) , intent(in) :: dxs
        real(kind=4), dimension(0:jp) , intent(in) :: dys
      cs0 = .1
        do k = 1,km
          delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
        end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
      dudxx1 = diu1(i,j,k)
      dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k) +diu2(i ,j,k)+diu2(i ,j+1,k) ) *.25
      dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1) +diu3(i ,j,k)+diu3(i ,j,k+1) ) *.25
      dvdxx1 = (diu4(i ,j,k)+diu4(i ,j-1,k) +diu4(i+1,j,k)+diu4(i+1,j-1,k) ) *.25
      dvdyx1 = diu5(i,j,k)
      dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1) +diu6(i,j ,k)+diu6(i,j ,k+1) ) *.25
      dwdxx1 = (diu7(i ,j,k)+diu7(i ,j,k-1) +diu7(i+1,j,k)+diu7(i+1,j,k-1) ) *.25
      dwdyx1 = (diu8(i,j ,k)+diu8(i,j ,k-1) +diu8(i,j+1,k)+diu8(i,j+1,k-1) ) *.25
      dwdzx1 = diu9(i,j,k)
      csx1 = cs0
      sm(i,j,k) = ( csx1*delx1(k) )**2 * sqrt( 2.*( dudxx1**2+dvdyx1**2+dwdzx1**2 ) +( dudyx1+dvdxx1 )**2 &
      +( dwdyx1+dvdzx1 )**2 +( dudzx1+dwdxx1 )**2 )
      end do
      end do
      end do
      call boundsm(km,jm,sm,im)
      do k = 2,km
      do j = 1,jm
      do i = 1,im
      evsx2 = sm(i+1,j,k)
      evsx1 = sm(i,j,k)
      evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1, &
      k)) /(dx1(i)+dx1(i+1)))) /(dy1(j)+dy1(j+1))
      evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1, &
      k)) /(dx1(i)+dx1(i+1))) +dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1)))) /(dy1(j)+dy1(j+1))
      evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j, &
      k+1)) /(dx1(i)+dx1(i+1)))) /(dzn(k)+dzn(k+1))
      evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j, &
      k-1)) /(dx1(i)+dx1(i+1))) +dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1)))) /(dzn(k-1)+dzn(k))
      visux2 = (evsx2)*2.*diu1(i+1,j ,k )
      visux1 = (evsx1)*2.*diu1(i ,j, k )
      visuy2 = (evsy2)* ( diu2(i ,j+1,k )+diu4(i+1,j ,k ) )
      visuy1 = (evsy1)* ( diu2(i ,j ,k )+diu4(i+1,j-1,k ) )
      visuz2 = (evsz2)* ( diu3(i ,j ,k+1)+diu7(i+1,j ,k ) )
      visuz1 = (evsz1)* ( diu3(i ,j ,k )+diu7(i+1,j ,k-1) )
      vfu = (visux2-visux1)/dxs(i) +(visuy2-visuy1)/dy1(j) +(visuz2-visuz1)/dzn(k)
      f(i,j,k) = (f(i,j,k)+vfu)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
      evsx2=sm(i+1,j,1)
      evsx1=sm(i,j,1)
      evsy2=(dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
      evsy1=(dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))&
      +dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
      evsz2=(dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
      visux2=(evsx2)*2.*diu1(i+1,j ,1 )
      visux1=(evsx1)*2.*diu1(i ,j, 1 )
      visuy2=(evsy2)* ( diu2(i ,j+1,1 )+diu4(i+1,j ,1 ) )
      visuy1=(evsy1)* ( diu2(i ,j ,1 )+diu4(i+1,j-1,1 ) )
      visuz2=(evsz2)* ( diu3(i ,j ,2 )+diu7(i+1,j ,1 ) )
      visuz1=(0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
      vfu= (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
      F(i,j,1)=(F(i,j,1)+vfu)
      end do
      end do
      do k = 2,km
      do j = 1,jm
      do i = 1,im
      evsy2 = sm(i,j+1,k)
      evsy1 = sm(i,j,k)
      evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1, &
      k)) /(dx1(i)+dx1(i+1)))) /(dy1(j)+dy1(j+1))
      evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j, &
      k)) /(dx1(i-1)+dx1(i))) +dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1, &
      k)) /(dx1(i-1)+dx1(i)))) /(dy1(j)+dy1(j+1))
      evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j, &
      k+1)) /(dx1(i)+dx1(i+1)))) /(dzn(k)+dzn(k+1))
      evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j, &
      k-1)) /(dx1(i)+dx1(i+1))) +dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1)))) /(dzn(k-1)+dzn(k))
      visvx2 = (evsx2)* ( diu2(i ,j+1,k )+diu4(i+1,j ,k ) )
      visvx1 = (evsx1)* ( diu2(i-1,j+1,k )+diu4(i ,j ,k ) )
      visvy2 = (evsy2)*2.*diu5(i ,j+1,k )
      visvy1 = (evsy1)*2.*diu5(i ,j ,k )
      visvz2 = (evsz2)* ( diu6(i ,j ,k+1)+diu8(i ,j+1,k ) )
      visvz1 = (evsz1)* ( diu6(i ,j ,k )+diu8(i ,j+1,k-1) )
      vfv = (visvx2-visvx1)/dx1(i) +(visvy2-visvy1)/dys(j) +(visvz2-visvz1)/dzn(k)
      g(i,j,k) = (g(i,j,k)+vfv)
      end do
      end do
      end do
      do j=1,jm
      do i=1,im
      evsy2=sm(i,j+1,1)
      evsy1=sm(i,j,1)
      evsx2=(dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
      evsx1=(dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))&
      +dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
      evsz2=(dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))&
      +dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
      visvx2=(evsx2)* ( diu2(i ,j+1,1 )+diu4(i+1,j ,1 ) )
      visvx1=(evsx1)* ( diu2(i-1,j+1,1 )+diu4(i ,j ,1 ) )
      visvy2=(evsy2)*2.*diu5(i ,j+1,1 )
      visvy1=(evsy1)*2.*diu5(i ,j ,1 )
      visvz2=(evsz2)* ( diu6(i ,j ,2 )+diu8(i ,j+1,1 ) )
      visvz1=(0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
      vfv=(visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
      G(i,j,1)=(G(i,j,1)+vfv)
      end do
      end do
      do k = 1,km
      do j = 1,jm
      do i = 1,im
      evsz2 = sm(i,j,k+1)
      evsz1 = sm(i,j,k)
      evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j, &
      k)) /(dx1(i)+dx1(i+1))) +dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j, &
      k+1)) /(dx1(i)+dx1(i+1)))) /(dzn(k)+dzn(k+1))
      evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j, &
      k)) /(dx1(i-1)+dx1(i))) +dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j, &
      k+1)) /(dx1(i-1)+dx1(i)))) /(dzn(k)+dzn(k+1))
      evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1, &
      k)) /(dy1(j)+dy1(j+1))) +dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1, &
      k+1)) /(dy1(j)+dy1(j+1)))) /(dzn(k)+dzn(k+1))
      evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j, &
      k)) /(dy1(j-1)+dy1(j))) +dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j, &
      k+1)) /(dy1(j-1)+dy1(j)))) /(dzn(k)+dzn(k+1))
      viswx2 = (evsx2)* ( diu3(i ,j ,k+1)+diu7(i+1,j ,k ) )
      viswx1 = (evsx1)* ( diu3(i-1,j ,k+1)+diu7(i ,j ,k ) )
      viswy2 = (evsy2)* ( diu6(i ,j ,k+1)+diu8(i ,j+1,k ) )
      viswy1 = (evsy1)* ( diu6(i ,j-1,k+1)+diu8(i ,j ,k ) )
      viswz2 = (evsz2)*2.*diu9(i ,j ,k+1)
      viswz1 = (evsz1)*2.*diu9(i ,j ,k )
      vfw = (viswx2-viswx1)/dx1(i) +(viswy2-viswy1)/dy1(j) +(viswz2-viswz1)/dzn(k)
      h(i,j,k) = (h(i,j,k)+vfw)
      end do
      end do
      end do
      return
      end subroutine les
end module module_les

Test3: False     use module_les
Test1: ./src/module_press.f95 False
Test2: ./src/press.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_bondFG.f95 False
Test2: ./src/bondFG.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_bondFG
 contains
subroutine bondfg(km,jm,f,im,g,h)
    use common_sn 
      implicit none
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: h
    integer, intent(In) :: im, jm, km
    integer :: i, j, k
        do k = 1,km
            do j = 1,jm
                f( 0,j,k) = f(1 ,j,k)
            end do
        end do
    do k = 1,km
        do i = 1,im
            g(i, 0,k) = g(i,jm ,k) 
        end do
    end do
    do j = 1,jm
        do i = 1,im
            h(i,j, 0) = 0.0
            h(i,j,km) = 0.0
        end do
    end do
end subroutine bondFG
end module module_bondFG

Test3: False     use module_bondFG 
Test1: ./src/module_boundp.f95 False
Test2: ./src/boundp.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_boundp
 contains
subroutine boundp2(jm,im,p,km)
    use common_sn 
      implicit none
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    integer :: i, j
    do j = 0,jm+1
        do i = 0,im+1
            p(i,j, 0) = p(i,j,1)
            p(i,j,km+1) = p(i,j,km)
        end do
    end do
end subroutine boundp2
subroutine boundp1(km,jm,p,im)
    use common_sn 
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    integer :: i, j, k
        do k = 0,km+1
            do j = 0,jm+1
                    p( 0,j,k) = p(1 ,j,k)
                    p(im+1,j,k) = p(im,j,k)
            end do
        end do
    do k = 0,km+1
        do i = 0,im+1
            p(i, 0,k) = p(i,jm,k) 
            p(i,jm+1,k) = p(i, 1,k) 
        end do
    end do
end subroutine boundp1
end module module_boundp

Test3: False     use module_boundp 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_press
    use module_bondFG 
    use module_boundp 
 contains
subroutine press(km,jm,im,rhs,u,dx1,v,dy1,w,dzn,f,g,h,dt,cn1,cn2l,p,cn2s,cn3l,cn3s,cn4l,cn4s, &
                 n,nmax,data20,usum,vsum,wsum)
    use common_sn 
    real(kind=4), dimension(ip,jp,kp) , intent(In) :: cn1
    real(kind=4), dimension(ip) , intent(In) :: cn2l
    real(kind=4), dimension(ip) , intent(In) :: cn2s
    real(kind=4), dimension(jp) , intent(In) :: cn3l
    real(kind=4), dimension(jp) , intent(In) :: cn3s
    real(kind=4), dimension(kp) , intent(In) :: cn4l
    real(kind=4), dimension(kp) , intent(In) :: cn4s
    character(len=70), intent(In) :: data20
    real(kind=4), intent(In) :: dt
    real(kind=4), dimension(-1:ip+1) , intent(In) :: dx1
    real(kind=4), dimension(0:jp+1) , intent(In) :: dy1
    real(kind=4), dimension(-1:kp+2) , intent(In) :: dzn
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: h
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    integer, intent(In) :: n
    integer, intent(In) :: nmax
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    real(kind=4), dimension(0:ip+1,0:jp+1,0:kp+1) , intent(Out) :: rhs
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: u
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In) :: usum
    real(kind=4), dimension(0:ip+1,-1:jp+1,0:kp+1) , intent(In) :: v
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In) :: vsum
    real(kind=4), dimension(0:ip+1,-1:jp+1,-1:kp+1) , intent(In) :: w
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(In) :: wsum
    integer :: nn
    real, parameter :: pjuge = 0.0001
    integer, parameter :: nmaxp = 50 
    real, parameter :: omega = 1.
    call bondfg(km,jm,f,im,g,h)
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i) +(-v(i,j-1,k)+ &
                             v(i,j,k))/dy1(j) +(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i) +(g(i,j,k)- &
                              g(i,j-1,k))/dy1(j) +(h(i,j,k)-h(i,j,k-1))/dzn(k) &
                              +rhs(i,j,k)/dt
            end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                area = area +dx1(i)*dy1(j)*dzn(k)
            end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                rhs(i,j,k) = rhs(i,j,k)-rhsav
            end do
        end do
    end do
    do l = 1,nmaxp
        sor = 0.0
        do nrd = 0,1
            do k = 1,km
                do j = 1,jm
                    do i = 1+mod(k+j+nrd,2),im,2
                        reltmp = omega*(cn1(i,j,k) *(cn2l(i)*p(i+1,j,k) + &
                                 cn2s(i)*p(i-1,j,k) +cn3l(j)*p(i,j+1,k) + &
                                 cn3s(j)*p(i,j-1,k) +cn4l(k)*p(i,j,k+1) + &
                                 cn4s(k)*p(i,j,k-1) -rhs(i,j,k))-p(i,j,k))
                        p(i,j,k) = p(i,j,k) +reltmp
                        sor = sor+reltmp*reltmp
                    end do
                end do
            end do
            call boundp1(km,jm,p,im)
        end do
        call boundp2(jm,im,p,km)
        if (sor < pjuge) then
            exit
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                pco = pco+dx1(i)*dy1(j)*dzn(k)
            end do
        end do
    end do
    pav = pav/pco
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                p(i,j,k) = p(i,j,k)-pav
            end do
        end do
    end do
    call boundp1(km,jm,p,im)
    call boundp2(jm,im,p,km)
    if(mod(n,1000) == 0 .or. n == nmax) then
        nn = n/1000
["adam","bondv1","feedbf","les","press","velFG","velnw"]
        print *, 'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2), &
                'vel at centre: ', &
                u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine press
end module module_press

Test3: False     use module_press
Test1: ./src/module_adam.f95 False
Test2: ./src/adam.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_adam
 contains
subroutine adam(n,nmax,data21,fold,im,jm,km,gold,hold,fghold,f,g,h)
    use common_sn 
    character(len=70), intent(In) :: data21
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
    real(kind=4), dimension(ip,jp,kp) , intent(In) :: fghold
    real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: fold
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
    real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: gold
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: h
    real(kind=4), dimension(ip,jp,kp) , intent(InOut) :: hold
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    integer, intent(In) :: n
    integer, intent(In) :: nmax
    do k = 1,km
        do j = 1,jm
            do i = 1,im
                fd = f(i,j,k)
                gd = g(i,j,k)
                hd = h(i,j,k)
                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                fold(i,j,k) = fd
                gold(i,j,k) = gd
                hold(i,j,k) = hd
            end do
        end do
    end do
end subroutine adam
end module module_adam

Test3: False     use module_adam
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn
Parsing ./src/main.f95
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/adam_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondv1_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/feedbf_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/les_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_boundsm.f95 False
Test2: ./src/boundsm.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundsm_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_boundsm
 contains
subroutine boundsm(km,jm,sm,im)
    use common_sn 
      implicit none
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(-1:ip+1,-1:jp+1,0:kp+1) , intent(InOut) :: sm
    integer :: i, j, k
        do k = 0,km+1
            do j = -1,jm+1
                    sm( 0,j,k) = sm(1 ,j,k) 
                    sm(im+1,j,k) = sm(im,j,k)
            end do
        end do
        do k = 0,km+1
            do i = 0,im+1
                    sm(i,jm+1,k) = sm(i,jm ,k)
                    sm(i,0,k) = sm(i,1 ,k) 
            end do
        end do
    do j = -1,jm+1
        do i = 0,im+1
            sm(i,j, 0) = -sm(i,j, 1)
            sm(i,j,km+1) = sm(i,j,km)
        end do
    end do
end subroutine boundsm
end module module_boundsm

Test3: False       use module_boundsm 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/press_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/module_bondFG.f95 False
Test2: ./src/bondFG.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/bondFG_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_bondFG
 contains
subroutine bondfg(km,jm,f,im,g,h)
    use common_sn 
      implicit none
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: f
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(InOut) :: g
    real(kind=4), dimension(0:ip,0:jp,0:kp) , intent(Out) :: h
    integer, intent(In) :: im, jm, km
    integer :: i, j, k
        do k = 1,km
            do j = 1,jm
                f( 0,j,k) = f(1 ,j,k)
            end do
        end do
    do k = 1,km
        do i = 1,im
            g(i, 0,k) = g(i,jm ,k) 
        end do
    end do
    do j = 1,jm
        do i = 1,im
            h(i,j, 0) = 0.0
            h(i,j,km) = 0.0
        end do
    end do
end subroutine bondFG
end module module_bondFG

Test3: False     use module_bondFG 
Test1: ./src/module_boundp.f95 False
Test2: ./src/boundp.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/boundp_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
Module content module module_boundp
 contains
subroutine boundp2./src/velnw_tmp.f95:23:17: warning: missing terminating ' character
 ! Which means it's the values of f,g,h that are changing. g seems fine.
                 ^
cc1: warning: unrecognized command line option ‘-Wno-invalid-pp-token’
["adam","bondv1","feedbf","les","press","velFG","velnw"]
(jm,im,p,km)
    use common_sn 
      implicit none
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    integer :: i, j
    do j = 0,jm+1
        do i = 0,im+1
            p(i,j, 0) = p(i,j,1)
            p(i,j,km+1) = p(i,j,km)
        end do
    end do
end subroutine boundp2
subroutine boundp1(km,jm,p,im)
    use common_sn 
    integer, intent(In) :: im
    integer, intent(In) :: jm
    integer, intent(In) :: km
    real(kind=4), dimension(0:ip+2,0:jp+2,0:kp+1) , intent(InOut) :: p
    integer :: i, j, k
        do k = 0,km+1
            do j = 0,jm+1
                    p( 0,j,k) = p(1 ,j,k)
                    p(im+1,j,k) = p(im,j,k)
            end do
        end do
    do k = 0,km+1
        do i = 0,im+1
            p(i, 0,k) = p(i,jm,k) 
            p(i,jm+1,k) = p(i, 1,k) 
        end do
    end do
end subroutine boundp1
end module module_boundp

Test3: False     use module_boundp 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False     use common_sn 
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/velnw_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/common_sn.f95 True
Test2: ./src/common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/common_sn_tmp.f95 | grep -v -E '^\s*$' 
Test1: ./src/params_common_sn.f95 True
Test2: ./src/params_common_sn.f95 True
cpp -Wno-invalid-pp-token -P -DWV_OPENCL -DWV_NEW -DNO_GLOBAL_SOR -DINLINE_BOUND_CALCS -DWV_TEST -DTWINNED_BUFFER -DNO_IO -DIFBF=1 -DIADAM=0 ./src/params_common_sn_tmp.f95 | grep -v -E '^\s*$' 
Module content module params_common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
end module params_common_sn

Test3: True     use params_common_sn 
Module content module common_sn
    integer, parameter :: ipmax = 3000, jpmax = 300
    integer, parameter :: ip = 300, jp = 300, kp = 105
    implicit real*4(a-h,o-z)
    implicit integer(i-n)
    real a1(1:ip,1:jp+1,1:kp+1),a2(1:ip,1:jp+1,1:kp+1) ,a3(1:ip,1:jp+1,1:kp+1)
    integer irec
   character(len=70) :: filename
end module common_sn

Test3: False       use common_sn 
Parsing ./src/adam.f95
Parsing ./src/bondv1.f95
Parsing ./src/feedbf.f95
Parsing ./src/les.f95
Parsing ./src/press.f95
Parsing ./src/velnw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou["adam","bondv1","feedbf","les","press","velFG","velnw"]
7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: adam
Filename: ./src/adam.f95
Source:
subroutine adam(n,nmax,data21,fold,im,jm,km,gold,hold,fghold,f,g,h)
      character*70, intent(In) :: data21
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
end subroutine adam

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: bondv1
Filename: ./src/bondv1.f95
Source:
subroutine bondv1(jm,u,z2,dzn,v,w,km,n,im,dt,dxs)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      integer, intent(In) :: im,jm,km,n
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:kp+2), intent(In) :: z2
      real(4) :: u_val
      integer :: i,j,k
      real(4) :: aaa,bbb,uout
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
end subroutine bondv1

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: feedbf
Filename: ./src/feedbf.f95
Source:
subroutine feedbf(km,jm,im,usum,u,bmask1,vsum,v,cmask1,wsum,w,dmask1,alpha,dt,beta,fx,fy,fz,f,g,h)
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
end subroutine feedbf

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: les
Filename: ./src/les.f95
Source:
subroutine les(km,delx1,dx1,dy1,dzn,jm,im,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,sm,f,g,h,uspd,vspd,dxs,dys)
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
end subroutine les

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: press
Filename: ./src/press.f95
Source:
subroutine press(km,jm,im,rhs,u,dx1,v,dy1,w,dzn,f,g,h,dt,cn1,cn2l,p,cn2s,cn3l,cn3s,cn4l,cn4s,n,nmax,data20,usum,vsum,wsum)
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: u
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: v
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(In) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: wsum
      integer :: nn
      real, parameter :: pjuge = 0.0001 
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine press

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw
Filename: ./src/velnw.f95
Source:
subroutine velnw(km,jm,im,p,ro,dxs,u,dt,f,dys,v,g,dzs,w,h)
      real(4), intent(In) :: dt
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: f
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: g
      real(4), dimension(0:ip,0:jp,0:kp), intent(In) :: h
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(In) :: p
      real(4), intent(In) :: ro
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
end subroutine velnw

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
                                u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
                                v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
                end do
        end do
    end do
    do k = 1, km-1, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
                                w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
                end do
        end do
    end do
    return 
    do i = 0, 1, 1
        do k = 1, 78, 1
                do j = 1, jm, 1
                                u(i,j,k) = 5.0
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    do i = 0, 1, 1
        do k = 79, km, 1
                do j = 1, jm, 1
                                u(i,j,k) = u(i,j,77)
                                v(i,j,k) = 0.0
                                w(i,j,k) = 0.0
                end do
        end do
    end do
    if (n==1) then
        do k = 1, km, 1
                do j = 1, jm, 1
                                do i = 2, im, 1
                                                                u(i,j,k) = u(1,j,k)
                                                                v(i,j,k) = v(1,j,k)
                                                                w(i,j,k) = w(1,j,k)
                                end do
                end do
        end do
    end if
    aaa = 0.0
    bbb = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                aaa = amax1(aaa,u(im,j,k))
                bbb = amin1(bbb,u(im,j,k))
        end do
    end do
    uout = (aaa+bbb)/2.
    do k = 1, km, 1
        do j = 1, jm, 1
                u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                u(i,0,k) = u(i,jm,k)
                u(i,jm+1,k) = u(i,1,k)
        end do
    end do
    do k = 0, km+1, 1
        do i = 0, im+1, 1
                v(i,0,k) = v(i,jm,k)
                v(i,jm+1,k) = v(i,1,k)
        end do
    end do
    do k = 0, km, 1
        do i = 0, im+1, 1
                w(i,0,k) = w(i,jm,k)
                w(i,jm+1,k) = w(i,1,k)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                u(i,j,0) = -u(i,j,1)
                u(i,j,km+1) = u(i,j,km)
        end do
    end do
    do j = 0, jm+1, 1
        do i = 0, im+1, 1
                v(i,j,0) = -v(i,j,1)
                v(i,j,km+1) = v(i,j,km)
        end do
    end do
    do j = -1, jm+1, 1
        do i = 0, im+1, 1
                w(i,j,0) = 0.0
                w(i,j,km) = 0.0
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
                                vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
                                wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
                                f1x = alpha*usum(i,j,k)*dt
                                f1y = alpha*vsum(i,j,k)*dt
                                f1z = alpha*wsum(i,j,k)*dt
                                f2x = beta*u(i,j,k)*bmask1(i,j,k)
                                f2y = beta*v(i,j,k)*cmask1(i,j,k)
                                f2z = beta*w(i,j,k)*dmask1(i,j,k)
                                fx(i,j,k) = f1x+f2x
                                fy(i,j,k) = f1y+f2y
                                fz(i,j,k) = f1z+f2z
                end do
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                f(i,j,k) = f(i,j,k)+fx(i,j,k)
                                g(i,j,k) = g(i,j,k)+fy(i,j,k)
                                h(i,j,k) = h(i,j,k)+fz(i,j,k)
                end do
        end do
    end do
    cs0 = .1
    do k = 1, km, 1
        delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                dudxx1 = diu1(i,j,k)
                                dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
                                dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
                                dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
                                dvdyx1 = diu5(i,j,k)
                                dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
                                dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
                                dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
                                dwdzx1 = diu9(i,j,k)
                                csx1 = cs0
                                sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
                end do
        end do
    end do
    call boundsm(km, jm, sm, im)
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsx2 = sm(i+1,j,k)
                                evsx1 = sm(i,j,k)
                                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visux2 = (evsx2)*2.*diu1(i+1,j,k)
                                visux1 = (evsx1)*2.*diu1(i,j,k)
                                visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
                                visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
                                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
                                f(i,j,k) = (f(i,j,k)+vfu)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsx2 = sm(i+1,j,1)
                evsx1 = sm(i,j,1)
                evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visux2 = (evsx2)*2.*diu1(i+1,j,1)
                visux1 = (evsx1)*2.*diu1(i,j,1)
                visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
                visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
                visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
                vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
                F(i,j,1) = (F(i,j,1)+vfu)
        end do
    end do
    do k = 2, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsy2 = sm(i,j+1,k)
                                evsy1 = sm(i,j,k)
                                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                                evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
                                visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
                                visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
                                visvy2 = (evsy2)*2.*diu5(i,j+1,k)
                                visvy1 = (evsy1)*2.*diu5(i,j,k)
                                visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
                                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
                                g(i,j,k) = (g(i,j,k)+vfv)
                end do
        end do
    end do
    do j = 1, jm, 1
        do i = 1, im, 1
                evsy2 = sm(i,j+1,1)
                evsy1 = sm(i,j,1)
                evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
                evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
                evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
                visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
                visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
                visvy2 = (evsy2)*2.*diu5(i,j+1,1)
                visvy1 = (evsy1)*2.*diu5(i,j,1)
                visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
                visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
                vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
                G(i,j,1) = (G(i,j,1)+vfv)
        end do
    end do
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                evsz2 = sm(i,j,k+1)
                                evsz1 = sm(i,j,k)
                                evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
                                evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
                                evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
                                evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
                                viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
                                viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
                                viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
                                viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
                                viswz2 = (evsz2)*2.*diu9(i,j,k+1)
                                viswz1 = (evsz1)*2.*diu9(i,j,k)
                                vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
                                h(i,j,k) = (h(i,j,k)+vfw)
                end do
        end do
    end do
    return 
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                fd = f(i,j,k)
                                gd = g(i,j,k)
                                hd = h(i,j,k)
                                f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
                                g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
                                h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
                                fold(i,j,k) = fd
                                gold(i,j,k) = gd
                                hold(i,j,k) = hd
                end do
        end do
    end do
    call bondfg(km, jm, f, im, g, h)
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
                                rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
                end do
        end do
    end do
    rhsav = 0.0
    area = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
                                area = area+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    rhsav = rhsav/area
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                rhs(i,j,k) = rhs(i,j,k)-rhsav
                end do
        end do
    end do
    do l = 1, nmaxp, 1
        sor = 0.0
        do nrd = 0, 1, 1
                do k = 1, km, 1
                                do j = 1, jm, 1
                                                                do i = 1+mod(k+j+nrd,2), im, 2
                                                                                                                                reltmp = omega*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                                                                                                                                p(i,j,k) = p(i,j,k)+reltmp
                                                                                                                                sor = sor+reltmp*reltmp
                                                                end do
                                end do
                end do
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<pjuge) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
                                pco = pco+dx1(i)*dy1(j)*dzn(k)
                end do
        end do
    end do
    pav = pav/pco
    do k = 1, km, 1
        do j = 1, jm, 1
                do i = 1, im, 1
                                p(i,j,k) = p(i,j,k)-pav
                end do
        end do
    end do
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_feedbf_les_adam_press_merged

end module module_velnw_bondv1_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map + Fold Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+1))*.25
    dvdxx1 = (diu4(i,j,k)+diu4(i,j-1,k)+diu4(i+1,j,k)+diu4(i+1,j-1,k))*.25
    dvdyx1 = diu5(i,j,k)
    dvdzx1 = (diu6(i,j-1,k)+diu6(i,j-1,k+1)+diu6(i,j,k)+diu6(i,j,k+1))*.25
    dwdxx1 = (diu7(i,j,k)+diu7(i,j,k-1)+diu7(i+1,j,k)+diu7(i+1,j,k-1))*.25
    dwdyx1 = (diu8(i,j,k)+diu8(i,j,k-1)+diu8(i,j+1,k)+diu8(i,j+1,k-1))*.25
    dwdzx1 = diu9(i,j,k)
    csx1 = 1.0
    sm(i,j,k) = (csx1*delx1(k))**2*sqrt(2.*(dudxx1**2+dvdyx1**2+dwdzx1**2)+(dudyx1+dvdxx1)**2+(dwdyx1+dvdzx1)**2+(dudzx1+dwdxx1)**2)
!}
!}
!}
    call boundsm(km, jm, sm, im)
! OpenCLMap ( ["km","sm","diu1","dxs","dy1","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu1","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,k)
    evsx1 = sm(i,j,k)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,k)+dx1(i)*sm(i+1,j-1,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visux2 = (evsx2)*2.*diu1(i+1,j,k)
    visux1 = (evsx1)*2.*diu1(i,j,k)
    visuy2 = (evsy2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visuy1 = (evsy1)*(diu2(i,j,k)+diu4(i+1,j-1,k))
    visuz2 = (evsz2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    visuz1 = (evsz1)*(diu3(i,j,k)+diu7(i+1,j,k-1))
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(k)
    f(i,j,k) = (f(i,j,k)+vfu)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu1","uspd","dxs","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu1","uspd","dxs","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsx2 = sm(i+1,j,1)
    evsx1 = sm(i,j,1)
    evsy2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsy1 = (dy1(j+1)*((dx1(i+1)*sm(i,j-1,1)+dx1(i)*sm(i+1,j-1,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visux2 = (evsx2)*2.*diu1(i+1,j,1)
    visux1 = (evsx1)*2.*diu1(i,j,1)
    visuy2 = (evsy2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visuy1 = (evsy1)*(diu2(i,j,1)+diu4(i+1,j-1,1))
    visuz2 = (evsz2)*(diu3(i,j,2)+diu7(i+1,j,1))
    visuz1 = (0.4*uspd(i,j)/alog(0.5*dzn(1)/0.1))**2*uspd(i,j)
    vfu = (visux2-visux1)/dxs(i)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)+(visuy2-visuy1)/dy1(j)+(visuz2-visuz1)/dzn(1)
    F(i,j,1) = (F(i,j,1)+vfu)
!}
!}
! OpenCLMap ( ["km","sm","diu5","dx1","dys","dzn"],[],["(k,2,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu5","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,k)
    evsy1 = sm(i,j,k)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,k)+dx1(i)*sm(i+1,j+1,k))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,k)+dx1(i-1)*sm(i,j+1,k))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsz1 = (dzn(k)*((dx1(i+1)*sm(i,j,k-1)+dx1(i)*sm(i+1,j,k-1))/(dx1(i)+dx1(i+1)))+dzn(k-1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1))))/(dzn(k-1)+dzn(k))
    visvx2 = (evsx2)*(diu2(i,j+1,k)+diu4(i+1,j,k))
    visvx1 = (evsx1)*(diu2(i-1,j+1,k)+diu4(i,j,k))
    visvy2 = (evsy2)*2.*diu5(i,j+1,k)
    visvy1 = (evsy1)*2.*diu5(i,j,k)
    visvz2 = (evsz2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    visvz1 = (evsz1)*(diu6(i,j,k)+diu8(i,j+1,k-1))
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(k)
    g(i,j,k) = (g(i,j,k)+vfv)
!}
!}
!}
! OpenCLMap ( ["jm","sm","diu5","vspd","dx1","dys","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu5","vspd","dx1","dys","dzn"],[],["(i,1,im,1)"],[]) {
    evsy2 = sm(i,j+1,1)
    evsy1 = sm(i,j,1)
    evsx2 = (dy1(j+1)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dy1(j)*((dx1(i+1)*sm(i,j+1,1)+dx1(i)*sm(i+1,j+1,1))/(dx1(i)+dx1(i+1))))/(dy1(j)+dy1(j+1))
    evsx1 = (dy1(j+1)*((dx1(i)*sm(i-1,j,1)+dx1(i-1)*sm(i,j,1))/(dx1(i-1)+dx1(i)))+dy1(j)*((dx1(i)*sm(i-1,j+1,1)+dx1(i-1)*sm(i,j+1,1))/(dx1(i-1)+dx1(i))))/(dy1(j)+dy1(j+1))
    evsz2 = (dzn(2)*((dx1(i+1)*sm(i,j,1)+dx1(i)*sm(i+1,j,1))/(dx1(i)+dx1(i+1)))+dzn(1)*((dx1(i+1)*sm(i,j,2)+dx1(i)*sm(i+1,j,2))/(dx1(i)+dx1(i+1))))/(dzn(1)+dzn(2))
    visvx2 = (evsx2)*(diu2(i,j+1,1)+diu4(i+1,j,1))
    visvx1 = (evsx1)*(diu2(i-1,j+1,1)+diu4(i,j,1))
    visvy2 = (evsy2)*2.*diu5(i,j+1,1)
    visvy1 = (evsy1)*2.*diu5(i,j,1)
    visvz2 = (evsz2)*(diu6(i,j,2)+diu8(i,j+1,1))
    visvz1 = (0.4*vspd(i,j)/alog(0.5*dzn(1)/0.1))**2*vspd(i,j)
    vfv = (visvx2-visvx1)/dx1(i)+(visvy2-visvy1)/dys(j)+(visvz2-visvz1)/dzn(1)
    G(i,j,1) = (G(i,j,1)+vfv)
!}
!}
! OpenCLMap ( ["km","sm","diu9","dx1","dy1","dzn"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","sm","diu9","dx1","dy1","dzn"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","sm","diu9","dx1","dy1","dzn"],[],["(i,1,im,1)"],[]) {
    evsz2 = sm(i,j,k+1)
    evsz1 = sm(i,j,k)
    evsx2 = (dzn(k+1)*((dx1(i+1)*sm(i,j,k)+dx1(i)*sm(i+1,j,k))/(dx1(i)+dx1(i+1)))+dzn(k)*((dx1(i+1)*sm(i,j,k+1)+dx1(i)*sm(i+1,j,k+1))/(dx1(i)+dx1(i+1))))/(dzn(k)+dzn(k+1))
    evsx1 = (dzn(k+1)*((dx1(i)*sm(i-1,j,k)+dx1(i-1)*sm(i,j,k))/(dx1(i-1)+dx1(i)))+dzn(k)*((dx1(i)*sm(i-1,j,k+1)+dx1(i-1)*sm(i,j,k+1))/(dx1(i-1)+dx1(i))))/(dzn(k)+dzn(k+1))
    evsy2 = (dzn(k+1)*((dy1(j+1)*sm(i,j,k)+dy1(j)*sm(i,j+1,k))/(dy1(j)+dy1(j+1)))+dzn(k)*((dy1(j+1)*sm(i,j,k+1)+dy1(j)*sm(i,j+1,k+1))/(dy1(j)+dy1(j+1))))/(dzn(k)+dzn(k+1))
    evsy1 = (dzn(k+1)*((dy1(j)*sm(i,j-1,k)+dy1(j-1)*sm(i,j,k))/(dy1(j-1)+dy1(j)))+dzn(k)*((dy1(j)*sm(i,j-1,k+1)+dy1(j-1)*sm(i,j,k+1))/(dy1(j-1)+dy1(j))))/(dzn(k)+dzn(k+1))
    viswx2 = (evsx2)*(diu3(i,j,k+1)+diu7(i+1,j,k))
    viswx1 = (evsx1)*(diu3(i-1,j,k+1)+diu7(i,j,k))
    viswy2 = (evsy2)*(diu6(i,j,k+1)+diu8(i,j+1,k))
    viswy1 = (evsy1)*(diu6(i,j-1,k+1)+diu8(i,j,k))
    viswz2 = (evsz2)*2.*diu9(i,j,k+1)
    viswz1 = (evsz1)*2.*diu9(i,j,k)
    vfw = (viswx2-viswx1)/dx1(i)+(viswy2-viswy1)/dy1(j)+(viswz2-viswz1)/dzn(k)
    h(i,j,k) = (h(i,j,k)+vfw)
!}
!}
!}
    return 
! OpenCLMap ( ["km","f","g","h","fold","gold","hold"],["f","g","h"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","f","g","h","fold","gold","hold"],["f","g","h"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","f","g","h","fold","gold","hold"],["f","g","h"],["(i,1,im,1)"],[]) {
    fd = f(i,j,k)
    gd = g(i,j,k)
    hd = h(i,j,k)
    f(i,j,k) = 1.5*f(i,j,k)-0.5*fold(i,j,k)
    g(i,j,k) = 1.5*g(i,j,k)-0.5*gold(i,j,k)
    h(i,j,k) = 1.5*h(i,j,k)-0.5*hold(i,j,k)
    fold(i,j,k) = fd
    gold(i,j,k) = gd
    hold(i,j,k) = hd
!}
!}
!}
    call bondfg(km, jm, f, im, g, h)
! OpenCLMap ( ["km","dx1","dy1","dzn","dt"],["rhs"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","dx1","dy1","dzn","dt"],["rhs"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","dx1","dy1","dzn","dt"],["rhs"],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = (-u(i-1,j,k)+u(i,j,k))/dx1(i)+(-v(i,j-1,k)+v(i,j,k))/dy1(j)+(-w(i,j,k-1)+w(i,j,k))/dzn(k)
    rhs(i,j,k) = (f(i,j,k)-f(i-1,j,k))/dx1(i)+(g(i,j,k)-g(i,j-1,k))/dy1(j)+(h(i,j,k)-h(i,j,k-1))/dzn(k)+rhs(i,j,k)/dt
!}
!}
!}
    rhsav = 0.0
    area = 0.0
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(j,1,jm,1)","(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
! OpenCLReduce ( ["dx1","dy1","dzn","rhs"],["rhsav","area"],["(i,1,im,1)"],[],["(rhsav,0.0)","(area,0.0)"]) {
    rhsav = rhsav+dx1(i)*dy1(j)*dzn(k)*rhs(i,j,k)
    area = area+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    rhsav = rhsav/area
! OpenCLMap ( ["km","rhsav"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","rhsav"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","rhsav"],[],["(i,1,im,1)"],[]) {
    rhs(i,j,k) = rhs(i,j,k)-rhsav
!}
!}
!}
    do l = 1, 50.0, 1
        sor = 0.0
        do nrd = 0, 1, 1
! OpenCLReduce ( [],["p","sor"],["(k,1,km,1)","(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( [],["p","sor"],["(j,1,jm,1)","(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
! OpenCLReduce ( ["k","j","nrd"],["p","sor"],["(i,1+mod(k+j+nrd,2),im,2)"],["nrd","l"],["(sor,0.0)"]) {
                reltmp = 1.0*(cn1(i,j,k)*(cn2l(i)*p(i+1,j,k)+cn2s(i)*p(i-1,j,k)+cn3l(j)*p(i,j+1,k)+cn3s(j)*p(i,j-1,k)+cn4l(k)*p(i,j,k+1)+cn4s(k)*p(i,j,k-1)-rhs(i,j,k))-p(i,j,k))
                p(i,j,k) = p(i,j,k)+reltmp
                sor = sor+reltmp*reltmp
!}
!}
!}
                call boundp1(km, jm, p, im)
        end do
        call boundp2(jm, im, p, km)
        if (sor<1.0e-4) then
! UNSUPPORTED in miniPPF ! Exit (fromList []) ({<unknown>, line = 89, col = 12},{<unknown>, line = 89, col = 16}) ""
        end if
    end do
    pav = 0.0
    pco = 0.0
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(j,1,jm,1)","(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
! OpenCLReduce ( ["p","dx1","dy1","dzn"],["pav","pco"],["(i,1,im,1)"],[],["(pav,0.0)","(pco,0.0)"]) {
    pav = pav+p(i,j,k)*dx1(i)*dy1(j)*dzn(k)
    pco = pco+dx1(i)*dy1(j)*dzn(k)
!}
!}
!}
    pav = pav/pco
! OpenCLMap ( ["km","pav"],["p"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","pav"],["p"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","pav"],["p"],["(i,1,im,1)"],[]) {
    p(i,j,k) = p(i,j,k)-pav
!}
!}
!}
    call boundp1(km, jm, p, im)
    call boundp2(jm, im, p, km)
    if (mod(n,1000)==0 .or. n==nmax) then
        nn = n/1000
        print *, *'timestep: ',nn,' pressure at centre: ',p(ip/2,jp/2,kp/2),'vel at centre: ',u(ip/2,jp/2,kp/2),v(ip/2,jp/2,kp/2),w(ip/2,jp/2,kp/2)
    end if
end subroutine velnw_bondv1_feedbf_les_adam_press_merged

end module module_velnw_bondv1_feedbf_les_adam_press_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Stencil Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: main
Filename: ./src/main.f95
Source:
program main
      real(4) :: alpha
      integer :: ianime
      integer :: ical
      integer :: ifbf
      integer :: im
      integer :: jm
      integer :: km
      integer :: n
      integer :: n0
      integer :: n1
      integer :: nmax
      real(4) :: beta
      character*70 :: data10
      character*70 :: data11
      character*70 :: data12
      character*70 :: data13
      character*70 :: data14
      character*70 :: data20
      character*70 :: data21
      character*70 :: data22
      character*70 :: data23
      character*70 :: data24
      character*70 :: data25
      character*70 :: data26
      character*70 :: data27
      character*70 :: data30
      character*70 :: data31
      real(4) :: dt
      real(4) :: ro
      real(4) :: time
      real(4) :: vn
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: amask1
      real(4), dimension(ip,jp,kp) :: avel
      real(4), dimension(ip,jp,kp) :: avep
      real(4), dimension(ip,jp,kp) :: avesm
      real(4), dimension(ip,jp,kp) :: avesmsm
      real(4), dimension(ip,kp) :: avesu
      real(4), dimension(ip,kp) :: avesuu
      real(4), dimension(ip,kp) :: avesv
      real(4), dimension(ip,kp) :: avesvv
      real(4), dimension(ip,kp) :: avesw
      real(4), dimension(ip,kp) :: avesww
      real(4), dimension(ip,jp,0:kp) :: aveu
      real(4), dimension(ip,jp,kp) :: aveuu
      real(4), dimension(ip,jp,0:kp) :: avev
      real(4), dimension(ip,jp,kp) :: avevv
      real(4), dimension(ip+1,jp,0:kp+2) :: avew
      real(4), dimension(ip,jp,kp) :: aveww
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: cmask1
      real(4), dimension(ip,jp,kp) :: cn1
      real(4), dimension(ip) :: cn2l
      real(4), dimension(ip) :: cn2s
      real(4), dimension(jp) :: cn3l
      real(4), dimension(jp) :: cn3s
      real(4), dimension(kp) :: cn4l
      real(4), dimension(kp) :: cn4s
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: cov5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: cov9
      real(4), dimension(kp) :: delx1
      real(4), dimension(0:ip,jp,kp) :: dfu1
      real(4), dimension(ip,0:jp,kp) :: dfv1
      real(4), dimension(ip,jp,kp) :: dfw1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: dmask1
      real(4), dimension(-1:ip+1) :: dx1
      real(4), dimension(0:ip) :: dxl
      real(4), dimension(0:ip) :: dxs
      real(4), dimension(0:jp+1) :: dy1
      real(4), dimension(0:jp) :: dyl
      real(4), dimension(0:jp) :: dys
      real(4), dimension(-1:kp+2) :: dzn
      real(4), dimension(-1:kp+2) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp) :: f
      real(4), dimension(ip,jp,kp) :: fold
      real(4), dimension(0:ip,0:jp,0:kp) :: fx
      real(4), dimension(0:ip,0:jp,0:kp) :: fy
      real(4), dimension(0:ip,0:jp,0:kp) :: fz
      real(4), dimension(0:ip,0:jp,0:kp) :: g
      real(4), dimension(ip,jp,kp) :: gold
      real(4), dimension(0:ip,0:jp,0:kp) :: h
      real(4), dimension(ip,jp,kp) :: hold
      real(4), dimension(ip,jp,kp) :: fghold
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2) :: nou5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2) :: nou9
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1) :: rhs
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: u
      real(4), dimension(0:ip,0:jp,0:kp) :: usum
      real(4), dimension(ip,jp,kp) :: uwfx
      real(4), dimension(ip,kp) :: uwfxs
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1) :: v
      real(4), dimension(0:ip,0:jp,0:kp) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1) :: w
      real(4), dimension(0:ip,0:jp,0:kp) :: wsum
      real(4), dimension(0:kp+2) :: z2
      real(4), dimension(-1:ipmax+1,-1:jpmax+1) :: zbm
      real(4), dimension(0:ip+1,0:jp+1) :: uspd
      real(4), dimension(0:ip+1,0:jp+1) :: vspd
      integer :: idata24
      integer :: jdata24
      integer :: nspec
      real(4), dimension(1,1,36001,kp) :: ut_x1_2
      real(4), dimension(1,1,36001,kp) :: ut_x2_2
      real(4), dimension(1,1,36001,kp) :: vt_x1_2
      real(4), dimension(1,1,36001,kp) :: vt_x2_2
      real(4), dimension(1,1,36001,kp) :: wt_x1_2
      real(4), dimension(1,1,36001,kp) :: wt_x2_2
      real(4), dimension(1,kp,36001) :: u_spany2
      real(4), dimension(1,kp,36001) :: v_spany2
      real(4), dimension(1,kp,36001) :: w_spany2
      real(4), dimension(1,kp,36001) :: u_spany3
      real(4), dimension(1,kp,36001) :: v_spany3
      real(4), dimension(1,kp,36001) :: w_spany3
      real(4), dimension(19,kp,36001) :: u_x1_19_spany2
      real(4), dimension(19,kp,36001) :: v_x1_19_spany2
      real(4), dimension(19,kp,36001) :: w_x1_19_spany2
      real(4), dimension(19,kp,36001) :: u_x1_19_spany3
      real(4), dimension(19,kp,36001) :: v_x1_19_spany3
      real(4), dimension(19,kp,36001) :: w_x1_19_spany3
    call set(data10, data11, data20, data21, data22, data23, data24, data25, data26, data27, data30, data31, im, jm, km, ifbf, ianime, ical, n0, n1, nmax, dt, ro, vn, alpha, beta, data12, data13, data14, idata24, nspec, jdata24)
    call grid(dx1, dxl, dy1, dyl, z2, dzn, dzs, dxs, dys)
    call timdata()
    call init(km, jm, im, u, v, w, p, cn2s, dxs, cn2l, cn3s, dys, cn3l, dzs, cn4s, cn4l, cn1, amask1, bmask1, cmask1, dmask1, zbm, z2, dzn)
    call ifdata(data30, data31, fold, gold, hold, fghold, time, n, u, im, jm, km, v, w, p, usum, vsum, wsum, delx1, dx1, dy1, dzn, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, z2, dt, dxs, cov1, cov2, cov3, dfu1, vn, cov4, cov5, cov6, dfv1, cov7, cov8, cov9, dfw1, dzs, nou1, nou5, nou9, nou2, nou3, nou4, nou6, nou7, nou8, bmask1, cmask1, dmask1, alpha, beta, fx, fy, fz, amask1, zbm, ical)
    do n = n0, nmax, 1
        time = float(n-1)*dt
        call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
        if (jdata24==0) then
                call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        else
                call bondv1_data24(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
        end if
        call velfg(km, jm, im, dx1, cov1, cov2, cov3, dfu1, diu1, diu2, dy1, diu3, dzn, vn, f, cov4, cov5, cov6, dfv1, diu4, diu5, diu6, g, cov7, cov8, cov9, dfw1, diu7, diu8, diu9, dzs, h, nou1, u, nou5, v, nou9, w, nou2, nou3, nou4, nou6, nou7, nou8, uspd, vspd)
        call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
        call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
        call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
        call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
        call ifdata_out(n, n0, n1, nmax, time, km, jm, im, u, w, v, p, usum, vsum, wsum, f, g, h, fold, gold, hold)
        call aveflow(n, n1, km, jm, im, aveu, avev, avew, avep, avel, aveuu, avevv, aveww, avesm, avesmsm, uwfx, avesu, avesv, avesw, avesuu, avesvv, avesww, u, v, w, p, sm, nmax, uwfxs, data10, time, data11, data13, data14, amask1)
        call timestep_out_all_k(n, n0, n1, nmax, km, jm, im, z2, data22, data23, u, w, v, amask1, ut_x1_2, vt_x1_2, wt_x1_2, ut_x2_2, vt_x2_2, wt_x2_2, nspec, u_spany2, v_spany2, w_spany2, u_spany3, v_spany3, w_spany3, u_x1_19_spany2, v_x1_19_spany2, w_x1_19_spany2, u_x1_19_spany3, v_x1_19_spany3, w_x1_19_spany3)
    end do

end program main
Argument translations:
	adam->
	    call adam(n, nmax, data21, fold, im, jm, km, gold, hold, fghold, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data21", argument = VarName (fromList []) "data21"}
	ArgTrans {parameter = ArgName (fromList []) "fold", argument = VarName (fromList []) "fold"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "gold", argument = VarName (fromList []) "gold"}
	ArgTrans {parameter = ArgName (fromList []) "hold", argument = VarName (fromList []) "hold"}
	ArgTrans {parameter = ArgName (fromList []) "fghold", argument = VarName (fromList []) "fghold"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	bondv1->
	    call bondv1(jm, u, z2, dzn, v, w, km, n, im, dt, dxs)
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "z2", argument = VarName (fromList []) "z2"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	feedbf->
	    call feedbf(km, jm, im, usum, u, bmask1, vsum, v, cmask1, wsum, w, dmask1, alpha, dt, beta, fx, fy, fz, f, g, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "bmask1", argument = VarName (fromList []) "bmask1"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "cmask1", argument = VarName (fromList []) "cmask1"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dmask1", argument = VarName (fromList []) "dmask1"}
	ArgTrans {parameter = ArgName (fromList []) "alpha", argument = VarName (fromList []) "alpha"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "beta", argument = VarName (fromList []) "beta"}
	ArgTrans {parameter = ArgName (fromList []) "fx", argument = VarName (fromList []) "fx"}
	ArgTrans {parameter = ArgName (fromList []) "fy", argument = VarName (fromList []) "fy"}
	ArgTrans {parameter = ArgName (fromList []) "fz", argument = VarName (fromList []) "fz"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	les->
	    call les(km, delx1, dx1, dy1, dzn, jm, im, diu1, diu2, diu3, diu4, diu5, diu6, diu7, diu8, diu9, sm, f, g, h, uspd, vspd, dxs, dys)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "delx1", argument = VarName (fromList []) "delx1"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "diu1", argument = VarName (fromList []) "diu1"}
	ArgTrans {parameter = ArgName (fromList []) "diu2", argument = VarName (fromList []) "diu2"}
	ArgTrans {parameter = ArgName (fromList []) "diu3", argument = VarName (fromList []) "diu3"}
	ArgTrans {parameter = ArgName (fromList []) "diu4", argument = VarName (fromList []) "diu4"}
	ArgTrans {parameter = ArgName (fromList []) "diu5", argument = VarName (fromList []) "diu5"}
	ArgTrans {parameter = ArgName (fromList []) "diu6", argument = VarName (fromList []) "diu6"}
	ArgTrans {parameter = ArgName (fromList []) "diu7", argument = VarName (fromList []) "diu7"}
	ArgTrans {parameter = ArgName (fromList []) "diu8", argument = VarName (fromList []) "diu8"}
	ArgTrans {parameter = ArgName (fromList []) "diu9", argument = VarName (fromList []) "diu9"}
	ArgTrans {parameter = ArgName (fromList []) "sm", argument = VarName (fromList []) "sm"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "uspd", argument = VarName (fromList []) "uspd"}
	ArgTrans {parameter = ArgName (fromList []) "vspd", argument = VarName (fromList []) "vspd"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	press->
	    call press(km, jm, im, rhs, u, dx1, v, dy1, w, dzn, f, g, h, dt, cn1, cn2l, p, cn2s, cn3l, cn3s, cn4l, cn4s, n, nmax, data20, usum, vsum, wsum)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "rhs", argument = VarName (fromList []) "rhs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dx1", argument = VarName (fromList []) "dx1"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "dy1", argument = VarName (fromList []) "dy1"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "dzn", argument = VarName (fromList []) "dzn"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "cn1", argument = VarName (fromList []) "cn1"}
	ArgTrans {parameter = ArgName (fromList []) "cn2l", argument = VarName (fromList []) "cn2l"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "cn2s", argument = VarName (fromList []) "cn2s"}
	ArgTrans {parameter = ArgName (fromList []) "cn3l", argument = VarName (fromList []) "cn3l"}
	ArgTrans {parameter = ArgName (fromList []) "cn3s", argument = VarName (fromList []) "cn3s"}
	ArgTrans {parameter = ArgName (fromList []) "cn4l", argument = VarName (fromList []) "cn4l"}
	ArgTrans {parameter = ArgName (fromList []) "cn4s", argument = VarName (fromList []) "cn4s"}
	ArgTrans {parameter = ArgName (fromList []) "n", argument = VarName (fromList []) "n"}
	ArgTrans {parameter = ArgName (fromList []) "nmax", argument = VarName (fromList []) "nmax"}
	ArgTrans {parameter = ArgName (fromList []) "data20", argument = VarName (fromList []) "data20"}
	ArgTrans {parameter = ArgName (fromList []) "usum", argument = VarName (fromList []) "usum"}
	ArgTrans {parameter = ArgName (fromList []) "vsum", argument = VarName (fromList []) "vsum"}
	ArgTrans {parameter = ArgName (fromList []) "wsum", argument = VarName (fromList []) "wsum"}
	velnw->
	    call velnw(km, jm, im, p, ro, dxs, u, dt, f, dys, v, g, dzs, w, h)
	ArgTrans {parameter = ArgName (fromList []) "km", argument = VarName (fromList []) "km"}
	ArgTrans {parameter = ArgName (fromList []) "jm", argument = VarName (fromList []) "jm"}
	ArgTrans {parameter = ArgName (fromList []) "im", argument = VarName (fromList []) "im"}
	ArgTrans {parameter = ArgName (fromList []) "p", argument = VarName (fromList []) "p"}
	ArgTrans {parameter = ArgName (fromList []) "ro", argument = VarName (fromList []) "ro"}
	ArgTrans {parameter = ArgName (fromList []) "dxs", argument = VarName (fromList []) "dxs"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "f", argument = VarName (fromList []) "f"}
	ArgTrans {parameter = ArgName (fromList []) "dys", argument = VarName (fromList []) "dys"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "dzs", argument = VarName (fromList []) "dzs"}
	ArgTrans {parameter = ArgName (fromList []) "w", argument = VarName (fromList []) "w"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: velnw_bondv1_feedbf_les_adam_press_merged
Filename: 
Source:
module module_velnw_bondv1_feedbf_les_adam_press_merged
contains
subroutine velnw_bondv1_feedbf_les_adam_press_merged(alpha,beta,bmask1,cmask1,cn1,cn2l,cn2s,cn3l,cn3s,cn4l,cn4s,data20,data21,delx1,diu1,diu2,diu3,diu4,diu5,diu6,diu7,diu8,diu9,dmask1,dt,dx1,dxs,dy1,dys,dzn,dzs,f,fghold,fold,fx,fy,fz,g,gold,h,hold,im,jm,km,n,nmax,p,rhs,ro,sm,u,uspd,usum,v,vspd,vsum,w,wsum,z2)
      integer, parameter :: nmaxp = 50 
      real, parameter :: omega = 1. 
      real, parameter :: pjuge = 0.0001 
      real(4) :: aaa,bbb,uout
      real(4), intent(In) :: alpha
      real(4), intent(In) :: beta
      real(4), dimension(-1:ip+1,0:jp+1,0:kp+1), intent(In) :: bmask1
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(In) :: cmask1
      real(4), dimension(ip,jp,kp), intent(In) :: cn1
      real(4), dimension(ip), intent(In) :: cn2l
      real(4), dimension(ip), intent(In) :: cn2s
      real(4), dimension(jp), intent(In) :: cn3l
      real(4), dimension(jp), intent(In) :: cn3s
      real(4), dimension(kp), intent(In) :: cn4l
      real(4), dimension(kp), intent(In) :: cn4s
      character*70, intent(In) :: data20
      character*70, intent(In) :: data21
      real(4), dimension(kp), intent(Out) :: delx1
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu1
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu2
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu3
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu4
      real(4), dimension(-1:ip+2,0:jp+2,0:kp+2), intent(In) :: diu5
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu6
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu7
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu8
      real(4), dimension(0:ip+2,0:jp+2,0:kp+2), intent(In) :: diu9
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(In) :: dmask1
      real(4), intent(In) :: dt
      real(4), dimension(-1:ip+1), intent(In) :: dx1
      real(4), dimension(0:ip), intent(In) :: dxs
      real(4), dimension(0:jp+1), intent(In) :: dy1
      real(4), dimension(0:jp), intent(In) :: dys
      real(4), dimension(-1:kp+2), intent(In) :: dzn
      real(4), dimension(-1:kp+2), intent(In) :: dzs
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: f
      real(4), dimension(ip,jp,kp), intent(In) :: fghold
      real(4), dimension(ip,jp,kp), intent(InOut) :: fold
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fx
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fy
      real(4), dimension(0:ip,0:jp,0:kp), intent(Out) :: fz
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: g
      real(4), dimension(ip,jp,kp), intent(InOut) :: gold
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: h
      real(4), dimension(ip,jp,kp), intent(InOut) :: hold
      integer :: i,j,k
      integer, intent(In) :: im
      integer, intent(In) :: jm
      integer, intent(In) :: km
      integer, intent(In) :: n
      integer, intent(In) :: nmax
      integer :: nn
      real(4), dimension(0:ip+2,0:jp+2,0:kp+1), intent(InOut) :: p
      real(4), dimension(0:ip+1,0:jp+1,0:kp+1), intent(Out) :: rhs
      real(4), intent(In) :: ro
      real(4), dimension(-1:ip+1,-1:jp+1,0:kp+1), intent(Out) :: sm
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: u
      real(4) :: u_val
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: uspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: usum
      real(4), dimension(0:ip+1,-1:jp+1,0:kp+1), intent(InOut) :: v
      real(4), dimension(0:ip+1,0:jp+1), intent(In) :: vspd
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: vsum
      real(4), dimension(0:ip+1,-1:jp+1,-1:kp+1), intent(InOut) :: w
      real(4), dimension(0:ip,0:jp,0:kp), intent(InOut) :: wsum
      real(4), dimension(0:kp+2), intent(In) :: z2
! OpenCLStencil (
!        2 point stencil on 3D array p: [[1,0,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dxs","dt"],["u"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dxs","dt"],["u"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dxs","dt"],["u"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i+1,j,k))/ro/dxs(i)
    u(i,j,k) = u(i,j,k)+dt*(f(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,1,0],[0,0,0]]
!    ){
! OpenCLMap ( ["km","ro","dys","dt"],["v"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dys","dt"],["v"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dys","dt"],["v"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j+1,k))/ro/dys(j)
    v(i,j,k) = v(i,j,k)+dt*(g(i,j,k)-pz)
!}
!}
!}    
!}
! OpenCLStencil (
!        2 point stencil on 3D array p: [[0,0,0],[0,0,1]]
!    ){
! OpenCLMap ( ["km","ro","dzs","w","dt"],["w"],["(k,1,km-1,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","ro","dzs","w","dt"],["w"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","ro","dzs","w","dt"],["w"],["(i,1,im,1)"],[]) {
    pz = (-p(i,j,k)+p(i,j,k+1))/ro/dzs(k)
    w(i,j,k) = w(i,j,k)+dt*(h(i,j,k)-pz)
!}
!}
!}    
!}
    return 
! OpenCLMap ( [],["u"],["(i,0,1,1)","(k,1,78,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( [],["u"],["(k,1,78,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = 5.0
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
! OpenCLMap ( [],["u","v","w"],["(i,0,1,1)","(k,79,km,1)","(j,1,jm,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["km"],["u","v","w"],["(k,79,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm"],["u","v","w"],["(j,1,jm,1)"],[]) {
    u(i,j,k) = u(i,j,77)
    v(i,j,k) = 0.0
    w(i,j,k) = 0.0
!}
!}
!}
    if (n==1) then
! OpenCLMap ( ["km","u","v","w"],["u","v","w"],["(k,1,km,1)","(j,1,jm,1)","(i,2,im,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["jm","v","w"],["u","v","w"],["(j,1,jm,1)","(i,2,im,1)"],[]) {
! OpenCLMap ( ["im","w"],["u","v","w"],["(i,2,im,1)"],[]) {
        u(i,j,k) = u(1,j,k)
        v(i,j,k) = v(1,j,k)
        w(i,j,k) = w(1,j,k)
!}
!}
!}
    end if
    aaa = 0.0
    bbb = 0.0
! OpenCLMap ( ["km","u"],[],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","u"],[],["(j,1,jm,1)"],[]) {
    aaa = amax1(aaa,u(im,j,k))
    bbb = amin1(bbb,u(im,j,k))
!}
!}
    uout = (aaa+bbb)/2.
! OpenCLMap ( ["km","im","dt","uout","dxs"],["u"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","im","dt","uout","dxs"],["u"],["(j,1,jm,1)"],[]) {
    u(im,j,k) = u(im,j,k)-dt*uout*(u(im,j,k)-u(im-1,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["v"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["v"],["(j,1,jm,1)"],[]) {
    v(im+1,j,k) = v(im+1,j,k)-dt*uout*(v(im+1,j,k)-v(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","dt","uout","im","dxs"],["w"],["(k,1,km,1)","(j,1,jm,1)"],[]) {
! OpenCLMap ( ["jm","dt","uout","im","dxs"],["w"],["(j,1,jm,1)"],[]) {
    w(im+1,j,k) = w(im+1,j,k)-dt*uout*(w(im+1,j,k)-w(im,j,k))/dxs(im)
!}
!}
! OpenCLMap ( ["km","jm"],["u"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["u"],["(i,0,im+1,1)"],[]) {
    u(i,0,k) = u(i,jm,k)
    u(i,jm+1,k) = u(i,1,k)
!}
!}
! OpenCLMap ( ["km","jm"],["v"],["(k,0,km+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","jm"],["v"],["(i,0,im+1,1)"],[]) {
    v(i,0,k) = v(i,jm,k)
    v(i,jm+1,k) = v(i,1,k)
!}
!}
! OpenCLMap ( ["km"],[],["(k,0,km,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,0,k) = w(i,jm,k)
    w(i,jm+1,k) = w(i,1,k)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    u(i,j,0) = -u(i,j,1)
    u(i,j,km+1) = u(i,j,km)
!}
!}
! OpenCLMap ( ["jm","km"],[],["(j,0,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im","km"],[],["(i,0,im+1,1)"],[]) {
    v(i,j,0) = -v(i,j,1)
    v(i,j,km+1) = v(i,j,km)
!}
!}
! OpenCLMap ( ["jm"],[],["(j,-1,jm+1,1)","(i,0,im+1,1)"],[]) {
! OpenCLMap ( ["im"],[],["(i,0,im+1,1)"],[]) {
    w(i,j,0) = 0.0
    w(i,j,km) = 0.0
!}
!}
! OpenCLMap ( ["km","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","bmask1","cmask1","dmask1","alpha","dt","beta"],["fx","fy","fz"],["(i,1,im,1)"],[]) {
    usum(i,j,k) = (usum(i,j,k)+u(i,j,k))*bmask1(i,j,k)
    vsum(i,j,k) = (vsum(i,j,k)+v(i,j,k))*cmask1(i,j,k)
    wsum(i,j,k) = (wsum(i,j,k)+w(i,j,k))*dmask1(i,j,k)
    f1x = alpha*usum(i,j,k)*dt
    f1y = alpha*vsum(i,j,k)*dt
    f1z = alpha*wsum(i,j,k)*dt
    f2x = beta*u(i,j,k)*bmask1(i,j,k)
    f2y = beta*v(i,j,k)*cmask1(i,j,k)
    f2z = beta*w(i,j,k)*dmask1(i,j,k)
    fx(i,j,k) = f1x+f2x
    fy(i,j,k) = f1y+f2y
    fz(i,j,k) = f1z+f2z
!}
!}
!}
! OpenCLMap ( ["km","fx","fy","fz"],[],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","fx","fy","fz"],[],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","fx","fy","fz"],[],["(i,1,im,1)"],[]) {
    f(i,j,k) = f(i,j,k)+fx(i,j,k)
    g(i,j,k) = g(i,j,k)+fy(i,j,k)
    h(i,j,k) = h(i,j,k)+fz(i,j,k)
!}
!}
!}
    cs0 = .1
! OpenCLMap ( ["km"],[],["(k,1,km,1)"],[]) {
    delx1(k) = (dx1(0)*dy1(0)*dzn(k))**(1./3.)
!}
! OpenCLStencil (
!        4 point stencil on 3D array diu2: [[0,1,0],[0,0,0],[-1,1,0],[-1,0,0]]
!        4 point stencil on 3D array diu3: [[0,0,0],[0,0,1],[-1,0,0],[-1,0,1]]
!        4 point stencil on 3D array diu4: [[1,0,0],[1,-1,0],[0,0,0],[0,-1,0]]
!        4 point stencil on 3D array diu6: [[0,0,0],[0,0,1],[0,-1,0],[0,-1,1]]
!        4 point stencil on 3D array diu7: [[1,0,0],[1,0,-1],[0,0,0],[0,0,-1]]
!        4 point stencil on 3D array diu8: [[0,1,0],[0,1,-1],[0,0,0],[0,0,-1]]
!    ){
! OpenCLMap ( ["km","diu1","diu5","diu9"],["sm"],["(k,1,km,1)","(j,1,jm,1)","(i,1,im,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["jm","diu1","diu5","diu9"],["sm"],["(j,1,jm,1)","(i,1,im,1)"],[]) {
! OpenCLMap ( ["im","diu1","diu5","diu9"],["sm"],["(i,1,im,1)"],[]) {
    dudxx1 = diu1(i,j,k)
    dudyx1 = (diu2(i-1,j,k)+diu2(i-1,j+1,k)+diu2(i,j,k)+diu2(i,j+1,k))*.25
    dudzx1 = (diu3(i-1,j,k)+diu3(i-1,j,k+1)+diu3(i,j,k)+diu3(i,j,k+F4-exe: Unimplemented Fortran Statement OpenCLStencil (fromList []) (No source location,No source location) [Stencil (fromList []) 1 2 [[0],[1]] (VarName (fromList [("msak",[])]) "dx1")] (OpenCLMap (fromList [("ParallelFortran: Map at 56:6",[""])]) ({generated, line = 56, col = 6},{generated, line = 79, col = 12}) [VarName (fromList [("msak",[])]) "im",VarName (fromList [("msak",[])]) "sm",VarName (fromList [("msak",[])]) "diu1",VarName (fromList [("msak",[])]) "dxs",VarName (fromList [("msak",[])]) "dy1",VarName (fromList [("msak",[])]) "dzn"] [] [(VarName (fromList []) "i",Con (fromList []) ({<unknown>, line = 56, col = 13},{<unknown>, line = 56, col = 14}) "1",Var (fromList []) ({<unknown>, line = 56, col = 15},{<unknown>, line = 56, col = 17}) [(VarName (fromList [("msak",[])]) "im",[])],Con (fromList []) ({<unknown>, line = 56, col = 17},{<unknown>, line = 56, col = 17}) "1")] [] (FSeq (fromList []) ({<unknown>, line = 57, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 57, col = 6},{<unknown>, line = 57, col = 25}) (Var (fromList []) ({<unknown>, line = 57, col = 6},{<unknown>, line = 57, col = 12}) [(VarName (fromList []) "evsx2",[])]) (Var (fromList []) ({<unknown>, line = 57, col = 14},{<unknown>, line = 57, col = 25}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 57, col = 17},{<unknown>, line = 57, col = 20}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 57, col = 17},{<unknown>, line = 57, col = 18}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 57, col = 19},{<unknown>, line = 57, col = 20}) "1"),Var (fromList []) ({<unknown>, line = 57, col = 21},{<unknown>, line = 57, col = 22}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 57, col = 23},{<unknown>, line = 57, col = 24}) [(VarName (fromList []) "k",[])]])])) (FSeq (fromList []) ({<unknown>, line = 58, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 58, col = 6},{<unknown>, line = 58, col = 23}) (Var (fromList []) ({<unknown>, line = 58, col = 6},{<unknown>, line = 58, col = 12}) [(VarName (fromList []) "evsx1",[])]) (Var (fromList []) ({<unknown>, line = 58, col = 14},{<unknown>, line = 58, col = 23}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 58, col = 17},{<unknown>, line = 58, col = 18}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 58, col = 19},{<unknown>, line = 58, col = 20}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 58, col = 21},{<unknown>, line = 58, col = 22}) [(VarName (fromList []) "k",[])]])])) (FSeq (fromList []) ({<unknown>, line = 59, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 59, col = 6},{<unknown>, line = 61, col = 49}) (Var (fromList []) ({<unknown>, line = 59, col = 6},{<unknown>, line = 59, col = 12}) [(VarName (fromList []) "evsy2",[])]) (Bin (fromList []) ({<unknown>, line = 59, col = 14},{<unknown>, line = 61, col = 49}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 59, col = 14},{<unknown>, line = 61, col = 31}) (Bin (fromList []) ({<unknown>, line = 59, col = 15},{<unknown>, line = 61, col = 29}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 59, col = 15},{<unknown>, line = 60, col = 30}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 15},{<unknown>, line = 59, col = 23}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 59, col = 19},{<unknown>, line = 59, col = 22}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 19},{<unknown>, line = 59, col = 20}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 59, col = 21},{<unknown>, line = 59, col = 22}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 59, col = 24},{<unknown>, line = 60, col = 30}) (Bin (fromList []) ({<unknown>, line = 59, col = 25},{<unknown>, line = 60, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 59, col = 25},{<unknown>, line = 60, col = 10}) (Bin (fromList []) ({<unknown>, line = 59, col = 26},{<unknown>, line = 60, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 59, col = 26},{<unknown>, line = 59, col = 44}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 26},{<unknown>, line = 59, col = 34}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 59, col = 30},{<unknown>, line = 59, col = 33}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 30},{<unknown>, line = 59, col = 31}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 59, col = 32},{<unknown>, line = 59, col = 33}) "1")])]) (Var (fromList []) ({<unknown>, line = 59, col = 35},{<unknown>, line = 59, col = 44}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 59, col = 38},{<unknown>, line = 59, col = 39}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 59, col = 40},{<unknown>, line = 59, col = 41}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 59, col = 42},{<unknown>, line = 59, col = 43}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 59, col = 45},{<unknown>, line = 60, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 45},{<unknown>, line = 59, col = 51}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 59, col = 49},{<unknown>, line = 59, col = 50}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 59, col = 52},{<unknown>, line = 60, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 59, col = 55},{<unknown>, line = 59, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 59, col = 55},{<unknown>, line = 59, col = 56}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 59, col = 57},{<unknown>, line = 59, col = 58}) "1"),Var (fromList []) ({<unknown>, line = 59, col = 59},{<unknown>, line = 59, col = 60}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 60, col = 6},{<unknown>, line = 60, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 60, col = 11},{<unknown>, line = 60, col = 28}) (Bin (fromList []) ({<unknown>, line = 60, col = 12},{<unknown>, line = 60, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 12},{<unknown>, line = 60, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 60, col = 16},{<unknown>, line = 60, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 60, col = 19},{<unknown>, line = 60, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 60, col = 23},{<unknown>, line = 60, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 23},{<unknown>, line = 60, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 25},{<unknown>, line = 60, col = 26}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 60, col = 31},{<unknown>, line = 61, col = 29}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 31},{<unknown>, line = 60, col = 37}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 60, col = 35},{<unknown>, line = 60, col = 36}) [(VarName (fromList []) "j",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 60, col = 38},{<unknown>, line = 61, col = 29}) (Bin (fromList []) ({<unknown>, line = 60, col = 39},{<unknown>, line = 61, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 60, col = 39},{<unknown>, line = 61, col = 10}) (Bin (fromList []) ({<unknown>, line = 60, col = 40},{<unknown>, line = 61, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 60, col = 40},{<unknown>, line = 60, col = 60}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 40},{<unknown>, line = 60, col = 48}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 60, col = 44},{<unknown>, line = 60, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 44},{<unknown>, line = 60, col = 45}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 46},{<unknown>, line = 60, col = 47}) "1")])]) (Var (fromList []) ({<unknown>, line = 60, col = 49},{<unknown>, line = 60, col = 60}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 60, col = 52},{<unknown>, line = 60, col = 53}) [(VarName (fromList []) "i",[])],Bin (fromList []) ({<unknown>, line = 60, col = 54},{<unknown>, line = 60, col = 57}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 54},{<unknown>, line = 60, col = 55}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 56},{<unknown>, line = 60, col = 57}) "1"),Var (fromList []) ({<unknown>, line = 60, col = 58},{<unknown>, line = 60, col = 59}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 60, col = 61},{<unknown>, line = 61, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 61},{<unknown>, line = 60, col = 67}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 60, col = 65},{<unknown>, line = 60, col = 66}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 60, col = 68},{<unknown>, line = 61, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 60, col = 71},{<unknown>, line = 60, col = 74}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 71},{<unknown>, line = 60, col = 72}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 73},{<unknown>, line = 60, col = 74}) "1"),Bin (fromList []) ({<unknown>, line = 60, col = 75},{<unknown>, line = 60, col = 78}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 60, col = 75},{<unknown>, line = 60, col = 76}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 60, col = 77},{<unknown>, line = 60, col = 78}) "1"),Var (fromList []) ({<unknown>, line = 61, col = 6},{<unknown>, line = 61, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 61, col = 11},{<unknown>, line = 61, col = 28}) (Bin (fromList []) ({<unknown>, line = 61, col = 12},{<unknown>, line = 61, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 12},{<unknown>, line = 61, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 61, col = 16},{<unknown>, line = 61, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 61, col = 19},{<unknown>, line = 61, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 61, col = 23},{<unknown>, line = 61, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 23},{<unknown>, line = 61, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 61, col = 25},{<unknown>, line = 61, col = 26}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 61, col = 32},{<unknown>, line = 61, col = 49}) (Bin (fromList []) ({<unknown>, line = 61, col = 33},{<unknown>, line = 61, col = 48}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 33},{<unknown>, line = 61, col = 39}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 61, col = 37},{<unknown>, line = 61, col = 38}) [(VarName (fromList []) "j",[])]])]) (Var (fromList []) ({<unknown>, line = 61, col = 40},{<unknown>, line = 61, col = 48}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 61, col = 44},{<unknown>, line = 61, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 61, col = 44},{<unknown>, line = 61, col = 45}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 61, col = 46},{<unknown>, line = 61, col = 47}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 62, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 62, col = 6},{<unknown>, line = 64, col = 49}) (Var (fromList []) ({<unknown>, line = 62, col = 6},{<unknown>, line = 62, col = 12}) [(VarName (fromList []) "evsy1",[])]) (Bin (fromList []) ({<unknown>, line = 62, col = 14},{<unknown>, line = 64, col = 49}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 62, col = 14},{<unknown>, line = 64, col = 31}) (Bin (fromList []) ({<unknown>, line = 62, col = 15},{<unknown>, line = 64, col = 29}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 62, col = 15},{<unknown>, line = 63, col = 30}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 15},{<unknown>, line = 62, col = 23}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 62, col = 19},{<unknown>, line = 62, col = 22}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 19},{<unknown>, line = 62, col = 20}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 21},{<unknown>, line = 62, col = 22}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 62, col = 24},{<unknown>, line = 63, col = 30}) (Bin (fromList []) ({<unknown>, line = 62, col = 25},{<unknown>, line = 63, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 62, col = 25},{<unknown>, line = 63, col = 10}) (Bin (fromList []) ({<unknown>, line = 62, col = 26},{<unknown>, line = 63, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 62, col = 26},{<unknown>, line = 62, col = 46}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 26},{<unknown>, line = 62, col = 34}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 62, col = 30},{<unknown>, line = 62, col = 33}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 30},{<unknown>, line = 62, col = 31}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 32},{<unknown>, line = 62, col = 33}) "1")])]) (Var (fromList []) ({<unknown>, line = 62, col = 35},{<unknown>, line = 62, col = 46}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 62, col = 38},{<unknown>, line = 62, col = 39}) [(VarName (fromList []) "i",[])],Bin (fromList []) ({<unknown>, line = 62, col = 40},{<unknown>, line = 62, col = 43}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 40},{<unknown>, line = 62, col = 41}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 42},{<unknown>, line = 62, col = 43}) "1"),Var (fromList []) ({<unknown>, line = 62, col = 44},{<unknown>, line = 62, col = 45}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 62, col = 47},{<unknown>, line = 63, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 47},{<unknown>, line = 62, col = 53}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 62, col = 51},{<unknown>, line = 62, col = 52}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 62, col = 54},{<unknown>, line = 63, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 62, col = 57},{<unknown>, line = 62, col = 60}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 57},{<unknown>, line = 62, col = 58}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 59},{<unknown>, line = 62, col = 60}) "1"),Bin (fromList []) ({<unknown>, line = 62, col = 61},{<unknown>, line = 62, col = 64}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 62, col = 61},{<unknown>, line = 62, col = 62}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 62, col = 63},{<unknown>, line = 62, col = 64}) "1"),Var (fromList []) ({<unknown>, line = 63, col = 6},{<unknown>, line = 63, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 63, col = 11},{<unknown>, line = 63, col = 28}) (Bin (fromList []) ({<unknown>, line = 63, col = 12},{<unknown>, line = 63, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 12},{<unknown>, line = 63, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 63, col = 16},{<unknown>, line = 63, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 63, col = 19},{<unknown>, line = 63, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 63, col = 23},{<unknown>, line = 63, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 23},{<unknown>, line = 63, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 63, col = 25},{<unknown>, line = 63, col = 26}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 63, col = 31},{<unknown>, line = 64, col = 29}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 31},{<unknown>, line = 63, col = 37}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 63, col = 35},{<unknown>, line = 63, col = 36}) [(VarName (fromList []) "j",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 63, col = 38},{<unknown>, line = 64, col = 29}) (Bin (fromList []) ({<unknown>, line = 63, col = 39},{<unknown>, line = 64, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 63, col = 39},{<unknown>, line = 64, col = 10}) (Bin (fromList []) ({<unknown>, line = 63, col = 40},{<unknown>, line = 64, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 63, col = 40},{<unknown>, line = 63, col = 58}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 40},{<unknown>, line = 63, col = 48}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 63, col = 44},{<unknown>, line = 63, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 44},{<unknown>, line = 63, col = 45}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 63, col = 46},{<unknown>, line = 63, col = 47}) "1")])]) (Var (fromList []) ({<unknown>, line = 63, col = 49},{<unknown>, line = 63, col = 58}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 63, col = 52},{<unknown>, line = 63, col = 53}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 63, col = 54},{<unknown>, line = 63, col = 55}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 63, col = 56},{<unknown>, line = 63, col = 57}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 63, col = 59},{<unknown>, line = 64, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 59},{<unknown>, line = 63, col = 65}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 63, col = 63},{<unknown>, line = 63, col = 64}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 63, col = 66},{<unknown>, line = 64, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 63, col = 69},{<unknown>, line = 63, col = 72}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 63, col = 69},{<unknown>, line = 63, col = 70}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 63, col = 71},{<unknown>, line = 63, col = 72}) "1"),Var (fromList []) ({<unknown>, line = 63, col = 73},{<unknown>, line = 63, col = 74}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 64, col = 6},{<unknown>, line = 64, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 64, col = 11},{<unknown>, line = 64, col = 28}) (Bin (fromList []) ({<unknown>, line = 64, col = 12},{<unknown>, line = 64, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 12},{<unknown>, line = 64, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 64, col = 16},{<unknown>, line = 64, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 64, col = 19},{<unknown>, line = 64, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 64, col = 23},{<unknown>, line = 64, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 23},{<unknown>, line = 64, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 64, col = 25},{<unknown>, line = 64, col = 26}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 64, col = 32},{<unknown>, line = 64, col = 49}) (Bin (fromList []) ({<unknown>, line = 64, col = 33},{<unknown>, line = 64, col = 48}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 33},{<unknown>, line = 64, col = 39}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 64, col = 37},{<unknown>, line = 64, col = 38}) [(VarName (fromList []) "j",[])]])]) (Var (fromList []) ({<unknown>, line = 64, col = 40},{<unknown>, line = 64, col = 48}) [(VarName (fromList [("msak",[])]) "dy1",[Bin (fromList []) ({<unknown>, line = 64, col = 44},{<unknown>, line = 64, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 64, col = 44},{<unknown>, line = 64, col = 45}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 64, col = 46},{<unknown>, line = 64, col = 47}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 65, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 65, col = 6},{<unknown>, line = 67, col = 51}) (Var (fromList []) ({<unknown>, line = 65, col = 6},{<unknown>, line = 65, col = 12}) [(VarName (fromList []) "evsz2",[])]) (Bin (fromList []) ({<unknown>, line = 65, col = 14},{<unknown>, line = 67, col = 51}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 65, col = 14},{<unknown>, line = 67, col = 33}) (Bin (fromList []) ({<unknown>, line = 65, col = 15},{<unknown>, line = 67, col = 31}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 65, col = 15},{<unknown>, line = 66, col = 30}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 15},{<unknown>, line = 65, col = 23}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 65, col = 19},{<unknown>, line = 65, col = 22}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 19},{<unknown>, line = 65, col = 20}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 65, col = 21},{<unknown>, line = 65, col = 22}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 65, col = 24},{<unknown>, line = 66, col = 30}) (Bin (fromList []) ({<unknown>, line = 65, col = 25},{<unknown>, line = 66, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 65, col = 25},{<unknown>, line = 66, col = 10}) (Bin (fromList []) ({<unknown>, line = 65, col = 26},{<unknown>, line = 66, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 65, col = 26},{<unknown>, line = 65, col = 44}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 26},{<unknown>, line = 65, col = 34}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 65, col = 30},{<unknown>, line = 65, col = 33}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 30},{<unknown>, line = 65, col = 31}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 65, col = 32},{<unknown>, line = 65, col = 33}) "1")])]) (Var (fromList []) ({<unknown>, line = 65, col = 35},{<unknown>, line = 65, col = 44}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 65, col = 38},{<unknown>, line = 65, col = 39}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 65, col = 40},{<unknown>, line = 65, col = 41}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 65, col = 42},{<unknown>, line = 65, col = 43}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 65, col = 45},{<unknown>, line = 66, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 45},{<unknown>, line = 65, col = 51}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 65, col = 49},{<unknown>, line = 65, col = 50}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 65, col = 52},{<unknown>, line = 66, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 65, col = 55},{<unknown>, line = 65, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 65, col = 55},{<unknown>, line = 65, col = 56}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 65, col = 57},{<unknown>, line = 65, col = 58}) "1"),Var (fromList []) ({<unknown>, line = 65, col = 59},{<unknown>, line = 65, col = 60}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 66, col = 6},{<unknown>, line = 66, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 66, col = 11},{<unknown>, line = 66, col = 28}) (Bin (fromList []) ({<unknown>, line = 66, col = 12},{<unknown>, line = 66, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 12},{<unknown>, line = 66, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 66, col = 16},{<unknown>, line = 66, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 66, col = 19},{<unknown>, line = 66, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 66, col = 23},{<unknown>, line = 66, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 23},{<unknown>, line = 66, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 25},{<unknown>, line = 66, col = 26}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 66, col = 31},{<unknown>, line = 67, col = 31}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 31},{<unknown>, line = 66, col = 37}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 66, col = 35},{<unknown>, line = 66, col = 36}) [(VarName (fromList []) "k",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 66, col = 38},{<unknown>, line = 67, col = 31}) (Bin (fromList []) ({<unknown>, line = 66, col = 39},{<unknown>, line = 67, col = 30}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 66, col = 39},{<unknown>, line = 67, col = 12}) (Bin (fromList []) ({<unknown>, line = 66, col = 40},{<unknown>, line = 67, col = 10}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 66, col = 40},{<unknown>, line = 66, col = 60}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 40},{<unknown>, line = 66, col = 48}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 66, col = 44},{<unknown>, line = 66, col = 47}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 44},{<unknown>, line = 66, col = 45}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 46},{<unknown>, line = 66, col = 47}) "1")])]) (Var (fromList []) ({<unknown>, line = 66, col = 49},{<unknown>, line = 66, col = 60}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 66, col = 52},{<unknown>, line = 66, col = 53}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 66, col = 54},{<unknown>, line = 66, col = 55}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 66, col = 56},{<unknown>, line = 66, col = 59}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 56},{<unknown>, line = 66, col = 57}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 58},{<unknown>, line = 66, col = 59}) "1")])])) (Bin (fromList []) ({<unknown>, line = 66, col = 61},{<unknown>, line = 67, col = 10}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 61},{<unknown>, line = 66, col = 67}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 66, col = 65},{<unknown>, line = 66, col = 66}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 66, col = 68},{<unknown>, line = 67, col = 10}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 66, col = 71},{<unknown>, line = 66, col = 74}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 66, col = 71},{<unknown>, line = 66, col = 72}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 66, col = 73},{<unknown>, line = 66, col = 74}) "1"),Var (fromList []) ({<unknown>, line = 66, col = 75},{<unknown>, line = 66, col = 76}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 67, col = 6},{<unknown>, line = 67, col = 9}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 6},{<unknown>, line = 67, col = 7}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 67, col = 8},{<unknown>, line = 67, col = 9}) "1")])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 67, col = 13},{<unknown>, line = 67, col = 30}) (Bin (fromList []) ({<unknown>, line = 67, col = 14},{<unknown>, line = 67, col = 29}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 14},{<unknown>, line = 67, col = 20}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 67, col = 18},{<unknown>, line = 67, col = 19}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 67, col = 21},{<unknown>, line = 67, col = 29}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 67, col = 25},{<unknown>, line = 67, col = 28}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 25},{<unknown>, line = 67, col = 26}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 67, col = 27},{<unknown>, line = 67, col = 28}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 67, col = 34},{<unknown>, line = 67, col = 51}) (Bin (fromList []) ({<unknown>, line = 67, col = 35},{<unknown>, line = 67, col = 50}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 35},{<unknown>, line = 67, col = 41}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 67, col = 39},{<unknown>, line = 67, col = 40}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 67, col = 42},{<unknown>, line = 67, col = 50}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 67, col = 46},{<unknown>, line = 67, col = 49}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 67, col = 46},{<unknown>, line = 67, col = 47}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 67, col = 48},{<unknown>, line = 67, col = 49}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 68, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 68, col = 6},{<unknown>, line = 70, col = 49}) (Var (fromList []) ({<unknown>, line = 68, col = 6},{<unknown>, line = 68, col = 12}) [(VarName (fromList []) "evsz1",[])]) (Bin (fromList []) ({<unknown>, line = 68, col = 14},{<unknown>, line = 70, col = 49}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 68, col = 14},{<unknown>, line = 70, col = 31}) (Bin (fromList []) ({<unknown>, line = 68, col = 15},{<unknown>, line = 70, col = 29}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 68, col = 15},{<unknown>, line = 69, col = 32}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 15},{<unknown>, line = 68, col = 21}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 68, col = 19},{<unknown>, line = 68, col = 20}) [(VarName (fromList []) "k",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 68, col = 22},{<unknown>, line = 69, col = 32}) (Bin (fromList []) ({<unknown>, line = 68, col = 23},{<unknown>, line = 69, col = 30}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 68, col = 23},{<unknown>, line = 69, col = 12}) (Bin (fromList []) ({<unknown>, line = 68, col = 24},{<unknown>, line = 69, col = 10}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 68, col = 24},{<unknown>, line = 68, col = 44}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 24},{<unknown>, line = 68, col = 32}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 68, col = 28},{<unknown>, line = 68, col = 31}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 28},{<unknown>, line = 68, col = 29}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 68, col = 30},{<unknown>, line = 68, col = 31}) "1")])]) (Var (fromList []) ({<unknown>, line = 68, col = 33},{<unknown>, line = 68, col = 44}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 68, col = 36},{<unknown>, line = 68, col = 37}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 68, col = 38},{<unknown>, line = 68, col = 39}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 68, col = 40},{<unknown>, line = 68, col = 43}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 40},{<unknown>, line = 68, col = 41}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 68, col = 42},{<unknown>, line = 68, col = 43}) "1")])])) (Bin (fromList []) ({<unknown>, line = 68, col = 45},{<unknown>, line = 69, col = 10}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 45},{<unknown>, line = 68, col = 51}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 68, col = 49},{<unknown>, line = 68, col = 50}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 68, col = 52},{<unknown>, line = 69, col = 10}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 68, col = 55},{<unknown>, line = 68, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 68, col = 55},{<unknown>, line = 68, col = 56}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 68, col = 57},{<unknown>, line = 68, col = 58}) "1"),Var (fromList []) ({<unknown>, line = 68, col = 59},{<unknown>, line = 68, col = 60}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 69, col = 6},{<unknown>, line = 69, col = 9}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 6},{<unknown>, line = 69, col = 7}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 8},{<unknown>, line = 69, col = 9}) "1")])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 69, col = 13},{<unknown>, line = 69, col = 30}) (Bin (fromList []) ({<unknown>, line = 69, col = 14},{<unknown>, line = 69, col = 29}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 14},{<unknown>, line = 69, col = 20}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 69, col = 18},{<unknown>, line = 69, col = 19}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 69, col = 21},{<unknown>, line = 69, col = 29}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 69, col = 25},{<unknown>, line = 69, col = 28}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 25},{<unknown>, line = 69, col = 26}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 27},{<unknown>, line = 69, col = 28}) "1")])])))))) (Bin (fromList []) ({<unknown>, line = 69, col = 33},{<unknown>, line = 70, col = 29}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 33},{<unknown>, line = 69, col = 41}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 69, col = 37},{<unknown>, line = 69, col = 40}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 37},{<unknown>, line = 69, col = 38}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 39},{<unknown>, line = 69, col = 40}) "1")])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 69, col = 42},{<unknown>, line = 70, col = 29}) (Bin (fromList []) ({<unknown>, line = 69, col = 43},{<unknown>, line = 70, col = 28}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 69, col = 43},{<unknown>, line = 70, col = 10}) (Bin (fromList []) ({<unknown>, line = 69, col = 44},{<unknown>, line = 70, col = 8}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 69, col = 44},{<unknown>, line = 69, col = 62}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 44},{<unknown>, line = 69, col = 52}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 69, col = 48},{<unknown>, line = 69, col = 51}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 48},{<unknown>, line = 69, col = 49}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 50},{<unknown>, line = 69, col = 51}) "1")])]) (Var (fromList []) ({<unknown>, line = 69, col = 53},{<unknown>, line = 69, col = 62}) [(VarName (fromList [("msak",[])]) "sm",[Var (fromList []) ({<unknown>, line = 69, col = 56},{<unknown>, line = 69, col = 57}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 69, col = 58},{<unknown>, line = 69, col = 59}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 69, col = 60},{<unknown>, line = 69, col = 61}) [(VarName (fromList []) "k",[])]])])) (Bin (fromList []) ({<unknown>, line = 69, col = 63},{<unknown>, line = 70, col = 8}) (Mul (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 63},{<unknown>, line = 69, col = 69}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 69, col = 67},{<unknown>, line = 69, col = 68}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 69, col = 70},{<unknown>, line = 70, col = 8}) [(VarName (fromList [("msak",[])]) "sm",[Bin (fromList []) ({<unknown>, line = 69, col = 73},{<unknown>, line = 69, col = 76}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 69, col = 73},{<unknown>, line = 69, col = 74}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 69, col = 75},{<unknown>, line = 69, col = 76}) "1"),Var (fromList []) ({<unknown>, line = 69, col = 77},{<unknown>, line = 69, col = 78}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 70, col = 6},{<unknown>, line = 70, col = 7}) [(VarName (fromList []) "k",[])]])])))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 70, col = 11},{<unknown>, line = 70, col = 28}) (Bin (fromList []) ({<unknown>, line = 70, col = 12},{<unknown>, line = 70, col = 27}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 12},{<unknown>, line = 70, col = 18}) [(VarName (fromList [("msak",[])]) "dx1",[Var (fromList []) ({<unknown>, line = 70, col = 16},{<unknown>, line = 70, col = 17}) [(VarName (fromList []) "i",[])]])]) (Var (fromList []) ({<unknown>, line = 70, col = 19},{<unknown>, line = 70, col = 27}) [(VarName (fromList [("msak",[])]) "dx1",[Bin (fromList []) ({<unknown>, line = 70, col = 23},{<unknown>, line = 70, col = 26}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 23},{<unknown>, line = 70, col = 24}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 70, col = 25},{<unknown>, line = 70, col = 26}) "1")])])))))))) (ParenthesizedExpr (fromList []) ({<unknown>, line = 70, col = 32},{<unknown>, line = 70, col = 49}) (Bin (fromList []) ({<unknown>, line = 70, col = 33},{<unknown>, line = 70, col = 48}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 33},{<unknown>, line = 70, col = 41}) [(VarName (fromList [("msak",[])]) "dzn",[Bin (fromList []) ({<unknown>, line = 70, col = 37},{<unknown>, line = 70, col = 40}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 70, col = 37},{<unknown>, line = 70, col = 38}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 70, col = 39},{<unknown>, line = 70, col = 40}) "1")])]) (Var (fromList []) ({<unknown>, line = 70, col = 42},{<unknown>, line = 70, col = 48}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 70, col = 46},{<unknown>, line = 70, col = 47}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 71, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 71, col = 6},{<unknown>, line = 71, col = 41}) (Var (fromList []) ({<unknown>, line = 71, col = 6},{<unknown>, line = 71, col = 13}) [(VarName (fromList []) "visux2",[])]) (Bin (fromList []) ({<unknown>, line = 71, col = 15},{<unknown>, line = 71, col = 41}) (Mul (fromList [])) (Bin (fromList []) ({<unknown>, line = 71, col = 15},{<unknown>, line = 71, col = 25}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 71, col = 15},{<unknown>, line = 71, col = 22}) (Var (fromList []) ({<unknown>, line = 71, col = 16},{<unknown>, line = 71, col = 21}) [(VarName (fromList []) "evsx2",[])])) (Con (fromList []) ({<unknown>, line = 71, col = 23},{<unknown>, line = 71, col = 25}) "2.")) (Var (fromList []) ({<unknown>, line = 71, col = 26},{<unknown>, line = 71, col = 41}) [(VarName (fromList [("msak",[])]) "diu1",[Bin (fromList []) ({<unknown>, line = 71, col = 31},{<unknown>, line = 71, col = 34}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 71, col = 31},{<unknown>, line = 71, col = 32}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 71, col = 33},{<unknown>, line = 71, col = 34}) "1"),Var (fromList []) ({<unknown>, line = 71, col = 35},{<unknown>, line = 71, col = 37}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 71, col = 38},{<unknown>, line = 71, col = 40}) [(VarName (fromList []) "k",[])]])]))) (FSeq (fromList []) ({<unknown>, line = 72, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 72, col = 6},{<unknown>, line = 72, col = 40}) (Var (fromList []) ({<unknown>, line = 72, col = 6},{<unknown>, line = 72, col = 13}) [(VarName (fromList []) "visux1",[])]) (Bin (fromList []) ({<unknown>, line = 72, col = 15},{<unknown>, line = 72, col = 40}) (Mul (fromList [])) (Bin (fromList []) ({<unknown>, line = 72, col = 15},{<unknown>, line = 72, col = 25}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 72, col = 15},{<unknown>, line = 72, col = 22}) (Var (fromList []) ({<unknown>, line = 72, col = 16},{<unknown>, line = 72, col = 21}) [(VarName (fromList []) "evsx1",[])])) (Con (fromList []) ({<unknown>, line = 72, col = 23},{<unknown>, line = 72, col = 25}) "2.")) (Var (fromList []) ({<unknown>, line = 72, col = 26},{<unknown>, line = 72, col = 40}) [(VarName (fromList [("msak",[])]) "diu1",[Var (fromList []) ({<unknown>, line = 72, col = 31},{<unknown>, line = 72, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 72, col = 34},{<unknown>, line = 72, col = 35}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 72, col = 37},{<unknown>, line = 72, col = 39}) [(VarName (fromList []) "k",[])]])]))) (FSeq (fromList []) ({<unknown>, line = 73, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 73, col = 6},{<unknown>, line = 73, col = 59}) (Var (fromList []) ({<unknown>, line = 73, col = 6},{<unknown>, line = 73, col = 13}) [(VarName (fromList []) "visuy2",[])]) (Bin (fromList []) ({<unknown>, line = 73, col = 15},{<unknown>, line = 73, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 73, col = 15},{<unknown>, line = 73, col = 22}) (Var (fromList []) ({<unknown>, line = 73, col = 16},{<unknown>, line = 73, col = 21}) [(VarName (fromList []) "evsy2",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 73, col = 24},{<unknown>, line = 73, col = 59}) (Bin (fromList []) ({<unknown>, line = 73, col = 26},{<unknown>, line = 73, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 73, col = 26},{<unknown>, line = 73, col = 41}) [(VarName (fromList [("msak",[])]) "diu2",[Var (fromList []) ({<unknown>, line = 73, col = 31},{<unknown>, line = 73, col = 33}) [(VarName (fromList []) "i",[])],Bin (fromList []) ({<unknown>, line = 73, col = 34},{<unknown>, line = 73, col = 37}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 73, col = 34},{<unknown>, line = 73, col = 35}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 73, col = 36},{<unknown>, line = 73, col = 37}) "1"),Var (fromList []) ({<unknown>, line = 73, col = 38},{<unknown>, line = 73, col = 40}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 73, col = 42},{<unknown>, line = 73, col = 58}) [(VarName (fromList [("msak",[])]) "diu4",[Bin (fromList []) ({<unknown>, line = 73, col = 47},{<unknown>, line = 73, col = 50}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 73, col = 47},{<unknown>, line = 73, col = 48}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 73, col = 49},{<unknown>, line = 73, col = 50}) "1"),Var (fromList []) ({<unknown>, line = 73, col = 51},{<unknown>, line = 73, col = 53}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 73, col = 54},{<unknown>, line = 73, col = 56}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 74, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 74, col = 6},{<unknown>, line = 74, col = 59}) (Var (fromList []) ({<unknown>, line = 74, col = 6},{<unknown>, line = 74, col = 13}) [(VarName (fromList []) "visuy1",[])]) (Bin (fromList []) ({<unknown>, line = 74, col = 15},{<unknown>, line = 74, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 74, col = 15},{<unknown>, line = 74, col = 22}) (Var (fromList []) ({<unknown>, line = 74, col = 16},{<unknown>, line = 74, col = 21}) [(VarName (fromList []) "evsy1",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 74, col = 24},{<unknown>, line = 74, col = 59}) (Bin (fromList []) ({<unknown>, line = 74, col = 26},{<unknown>, line = 74, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 74, col = 26},{<unknown>, line = 74, col = 40}) [(VarName (fromList [("msak",[])]) "diu2",[Var (fromList []) ({<unknown>, line = 74, col = 31},{<unknown>, line = 74, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 74, col = 34},{<unknown>, line = 74, col = 36}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 74, col = 37},{<unknown>, line = 74, col = 39}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 74, col = 41},{<unknown>, line = 74, col = 58}) [(VarName (fromList [("msak",[])]) "diu4",[Bin (fromList []) ({<unknown>, line = 74, col = 46},{<unknown>, line = 74, col = 49}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 74, col = 46},{<unknown>, line = 74, col = 47}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 74, col = 48},{<unknown>, line = 74, col = 49}) "1"),Bin (fromList []) ({<unknown>, line = 74, col = 50},{<unknown>, line = 74, col = 53}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 74, col = 50},{<unknown>, line = 74, col = 51}) [(VarName (fromList []) "j",[])]) (Con (fromList []) ({<unknown>, line = 74, col = 52},{<unknown>, line = 74, col = 53}) "1"),Var (fromList []) ({<unknown>, line = 74, col = 54},{<unknown>, line = 74, col = 56}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 75, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 75, col = 6},{<unknown>, line = 75, col = 59}) (Var (fromList []) ({<unknown>, line = 75, col = 6},{<unknown>, line = 75, col = 13}) [(VarName (fromList []) "visuz2",[])]) (Bin (fromList []) ({<unknown>, line = 75, col = 15},{<unknown>, line = 75, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 75, col = 15},{<unknown>, line = 75, col = 22}) (Var (fromList []) ({<unknown>, line = 75, col = 16},{<unknown>, line = 75, col = 21}) [(VarName (fromList []) "evsz2",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 75, col = 24},{<unknown>, line = 75, col = 59}) (Bin (fromList []) ({<unknown>, line = 75, col = 26},{<unknown>, line = 75, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 75, col = 26},{<unknown>, line = 75, col = 41}) [(VarName (fromList [("msak",[])]) "diu3",[Var (fromList []) ({<unknown>, line = 75, col = 31},{<unknown>, line = 75, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 75, col = 34},{<unknown>, line = 75, col = 36}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 75, col = 37},{<unknown>, line = 75, col = 40}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 75, col = 37},{<unknown>, line = 75, col = 38}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 75, col = 39},{<unknown>, line = 75, col = 40}) "1")])]) (Var (fromList []) ({<unknown>, line = 75, col = 42},{<unknown>, line = 75, col = 58}) [(VarName (fromList [("msak",[])]) "diu7",[Bin (fromList []) ({<unknown>, line = 75, col = 47},{<unknown>, line = 75, col = 50}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 75, col = 47},{<unknown>, line = 75, col = 48}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 75, col = 49},{<unknown>, line = 75, col = 50}) "1"),Var (fromList []) ({<unknown>, line = 75, col = 51},{<unknown>, line = 75, col = 53}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 75, col = 54},{<unknown>, line = 75, col = 56}) [(VarName (fromList []) "k",[])]])]))))) (FSeq (fromList []) ({<unknown>, line = 76, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 76, col = 6},{<unknown>, line = 76, col = 59}) (Var (fromList []) ({<unknown>, line = 76, col = 6},{<unknown>, line = 76, col = 13}) [(VarName (fromList []) "visuz1",[])]) (Bin (fromList []) ({<unknown>, line = 76, col = 15},{<unknown>, line = 76, col = 59}) (Mul (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 76, col = 15},{<unknown>, line = 76, col = 22}) (Var (fromList []) ({<unknown>, line = 76, col = 16},{<unknown>, line = 76, col = 21}) [(VarName (fromList []) "evsz1",[])])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 76, col = 24},{<unknown>, line = 76, col = 59}) (Bin (fromList []) ({<unknown>, line = 76, col = 26},{<unknown>, line = 76, col = 58}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 76, col = 26},{<unknown>, line = 76, col = 40}) [(VarName (fromList [("msak",[])]) "diu3",[Var (fromList []) ({<unknown>, line = 76, col = 31},{<unknown>, line = 76, col = 33}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 76, col = 34},{<unknown>, line = 76, col = 36}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 76, col = 37},{<unknown>, line = 76, col = 39}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 76, col = 41},{<unknown>, line = 76, col = 58}) [(VarName (fromList [("msak",[])]) "diu7",[Bin (fromList []) ({<unknown>, line = 76, col = 46},{<unknown>, line = 76, col = 49}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 76, col = 46},{<unknown>, line = 76, col = 47}) [(VarName (fromList []) "i",[])]) (Con (fromList []) ({<unknown>, line = 76, col = 48},{<unknown>, line = 76, col = 49}) "1"),Var (fromList []) ({<unknown>, line = 76, col = 50},{<unknown>, line = 76, col = 52}) [(VarName (fromList []) "j",[])],Bin (fromList []) ({<unknown>, line = 76, col = 53},{<unknown>, line = 76, col = 56}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 76, col = 53},{<unknown>, line = 76, col = 54}) [(VarName (fromList []) "k",[])]) (Con (fromList []) ({<unknown>, line = 76, col = 55},{<unknown>, line = 76, col = 56}) "1")])]))))) (FSeq (fromList []) ({<unknown>, line = 77, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 77, col = 6},{<unknown>, line = 77, col = 82}) (Var (fromList []) ({<unknown>, line = 77, col = 6},{<unknown>, line = 77, col = 10}) [(VarName (fromList []) "vfu",[])]) (Bin (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 82}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 59}) (Plus (fromList [])) (Bin (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 35}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 77, col = 12},{<unknown>, line = 77, col = 27}) (Bin (fromList []) ({<unknown>, line = 77, col = 13},{<unknown>, line = 77, col = 26}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 77, col = 13},{<unknown>, line = 77, col = 19}) [(VarName (fromList []) "visux2",[])]) (Var (fromList []) ({<unknown>, line = 77, col = 20},{<unknown>, line = 77, col = 26}) [(VarName (fromList []) "visux1",[])]))) (Var (fromList []) ({<unknown>, line = 77, col = 28},{<unknown>, line = 77, col = 35}) [(VarName (fromList [("msak",[])]) "dxs",[Var (fromList []) ({<unknown>, line = 77, col = 32},{<unknown>, line = 77, col = 33}) [(VarName (fromList []) "i",[])]])])) (Bin (fromList []) ({<unknown>, line = 77, col = 36},{<unknown>, line = 77, col = 59}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 77, col = 36},{<unknown>, line = 77, col = 51}) (Bin (fromList []) ({<unknown>, line = 77, col = 37},{<unknown>, line = 77, col = 50}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 77, col = 37},{<unknown>, line = 77, col = 43}) [(VarName (fromList []) "visuy2",[])]) (Var (fromList []) ({<unknown>, line = 77, col = 44},{<unknown>, line = 77, col = 50}) [(VarName (fromList []) "visuy1",[])]))) (Var (fromList []) ({<unknown>, line = 77, col = 52},{<unknown>, line = 77, col = 59}) [(VarName (fromList [("msak",[])]) "dy1",[Var (fromList []) ({<unknown>, line = 77, col = 56},{<unknown>, line = 77, col = 57}) [(VarName (fromList []) "j",[])]])]))) (Bin (fromList []) ({<unknown>, line = 77, col = 60},{<unknown>, line = 77, col = 82}) (Div (fromList [])) (ParenthesizedExpr (fromList []) ({<unknown>, line = 77, col = 60},{<unknown>, line = 77, col = 75}) (Bin (fromList []) ({<unknown>, line = 77, col = 61},{<unknown>, line = 77, col = 74}) (Minus (fromList [])) (Var (fromList []) ({<unknown>, line = 77, col = 61},{<unknown>, line = 77, col = 67}) [(VarName (fromList []) "visuz2",[])]) (Var (fromList []) ({<unknown>, line = 77, col = 68},{<unknown>, line = 77, col = 74}) [(VarName (fromList []) "visuz1",[])]))) (Var (fromList []) ({<unknown>, line = 77, col = 76},{<unknown>, line = 77, col = 82}) [(VarName (fromList [("msak",[])]) "dzn",[Var (fromList []) ({<unknown>, line = 77, col = 80},{<unknown>, line = 77, col = 81}) [(VarName (fromList []) "k",[])]])])))) (FSeq (fromList []) ({<unknown>, line = 78, col = 6},{<unknown>, line = 79, col = 12}) (Assg (fromList []) ({<unknown>, line = 78, col = 6},{<unknown>, line = 78, col = 31}) (Var (fromList []) ({<unknown>, line = 78, col = 6},{<unknown>, line = 78, col = 31}) [(VarName (fromList [("msak",[])]) "f",[Var (fromList []) ({<unknown>, line = 78, col = 8},{<unknown>, line = 78, col = 9}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 78, col = 10},{<unknown>, line = 78, col = 11}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 78, col = 12},{<unknown>, line = 78, col = 13}) [(VarName (fromList []) "k",[])]])]) (ParenthesizedExpr (fromList []) ({<unknown>, line = 78, col = 17},{<unknown>, line = 78, col = 31}) (Bin (fromList []) ({<unknown>, line = 78, col = 18},{<unknown>, line = 78, col = 30}) (Plus (fromList [])) (Var (fromList []) ({<unknown>, line = 78, col = 18},{<unknown>, line = 78, col = 26}) [(VarName (fromList [("msak",[])]) "f",[Var (fromList []) ({<unknown>, line = 78, col = 20},{<unknown>, line = 78, col = 21}) [(VarName (fromList []) "i",[])],Var (fromList []) ({<unknown>, line = 78, col = 22},{<unknown>, line = 78, col = 23}) [(VarName (fromList []) "j",[])],Var (fromList []) ({<unknown>, line = 78, col = 24},{<unknown>, line = 78, col = 25}) [(VarName (fromList []) "k",[])]])]) (Var (fromList []) ({<unknown>, line = 78, col = 27},{<unknown>, line = 78, col = 30}) [(VarName (fromList []) "vfu",[])])))) (NullStmt (fromList []) ({<unknown>, line = 79, col = 12},{<unknown>, line = 79, col = 12})))))))))))))))))
CallStack (from HasCallStack):
  error, called at src/StencilDetection.hs:204:38 in F4-0.1.0.0-D7RDINYaNhyFjCMhEfJGtk:StencilDetection
