
================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	dyn
	vernieuw
	shapiro
File containing main subroutine: 
	main.f95
Source directory:
	./Shallow-Water-2D
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: 
CPP Excludes:

"Executing compiler main..."
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/main_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/vernieuw_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/sub_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/init_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/dyn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/shapiro_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./Shallow-Water-2D/main.f95
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/dyn_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/shapiro_tmp.f95 | grep -v -E '^\s*$' 
cpp -Wno-invalid-pp-token -P  ./Shallow-Water-2D/vernieuw_tmp.f95 | grep -v -E '^\s*$' 
Parsing ./Shallow-Water-2D/dyn.f95
Parsing ./Shallow-Water-2D/shapiro.f95
Parsing ./Shallow-Water-2D/vernieuw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")
end program wave2d

AST not shown.
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn
Filename: ./Shallow-Water-2D/dyn.f95
Source:
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
    do j = 1, ny, 1
        do k = 1, nx, 1
                du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
                dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                un(j,k) = 0.0
                uu = u(j,k)
                duu = du(j,k)
                if (wet(j,k)==1) then
                                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                else
                                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                end if
                vv = v(j,k)
                dvv = dv(j,k)
                vn(j,k) = 0.0
                if (wet(j,k)==1) then
                                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                else
                                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                end if
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
                hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
                hue = hep+hen
                hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
                hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
                huw = hwp+hwn
                hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
                hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
                hvn = hnp+hnn
                hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
                hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
                hvs = hsp+hsn
                etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
        end do
    end do
end subroutine dyn

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: shapiro
Filename: ./Shallow-Water-2D/shapiro.f95
Source:
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
    do j = 1, ny, 1
        do k = 1, nx, 1
                if (wet(j,k)==1) then
                                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                                eta(j,k) = term1+term2+term3
                else
                                eta(j,k) = etan(j,k)
                end if
        end do
    end do
end subroutine shapiro

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: vernieuw
Filename: ./Shallow-Water-2D/vernieuw.f95
Source:
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                h(j,k) = hzero(j,k)+eta(j,k)
                wet(j,k) = 1
                if (h(j,k)<hmin) then
                                wet(j,k) = 0
                end if
                u(j,k) = un(j,k)
                v(j,k) = vn(j,k)
        end do
    end do
end subroutine vernieuw

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real :: g
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! Original Subroutine Name: dyn {
    do j = 1, 500, 1
        do k = 1, 500, 1
                du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
                dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
        end do
    end do
    do j = 1, 500, 1
        do k = 1, 500, 1
                un(j,k) = 0.0
                uu = u(j,k)
                duu = du(j,k)
                if (wet(j,k)==1) then
                                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                else
                                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                end if
                vv = v(j,k)
                dvv = dv(j,k)
                vn(j,k) = 0.0
                if (wet(j,k)==1) then
                                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                else
                                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                end if
        end do
    end do
    do j = 1, 500, 1
        do k = 1, 500, 1
                hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
                hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
                hue = hep+hen
                hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
                hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
                huw = hwp+hwn
                hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
                hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
                hvn = hnp+hnn
                hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
                hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
                hvs = hsp+hsn
                etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
        end do
    end do
!}
! Original Subroutine Name: shapiro {
    do j = 1, 500, 1
        do k = 1, 500, 1
                if (wet(j,k)==1) then
                                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                                eta(j,k) = term1+term2+term3
                else
                                eta(j,k) = etan(j,k)
                end if
        end do
    end do
!}
! Original Subroutine Name: vernieuw {
    do j = 0, 501, 1
        do k = 0, 501, 1
                h(j,k) = hzero(j,k)+eta(j,k)
                wet(j,k) = 1
                if (h(j,k)<hmin) then
                                wet(j,k) = 0
                end if
                u(j,k) = un(j,k)
                v(j,k) = vn(j,k)
        end do
    end do
!}
end subroutine dyn_shapiro_vernieuw_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")
end program wave2d

AST not shown.
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map + Fold Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real :: g
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! Original Subroutine Name: dyn {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
!}
!}
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(k,1,500,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
!}
!}
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(k,1,500,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
!}
!}
!}
! Original Subroutine Name: shapiro {
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(k,1,500,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
!}
!}
!}
! Original Subroutine Name: vernieuw {
! OpenCLMap ( ["hzero","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
!}
!}
end subroutine dyn_shapiro_vernieuw_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Stencil Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real :: g
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! Original Subroutine Name: dyn {
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
!}
!}    
!}
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(k,1,500,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
!}
!}    
!}
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(k,1,500,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
!}
!}    
!}
!}
! Original Subroutine Name: shapiro {
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(k,1,500,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
!}
!}    
!}
!}
! Original Subroutine Name: vernieuw {
! OpenCLMap ( ["hzero","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
!}
!}
end subroutine dyn_shapiro_vernieuw_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")
end program wave2d

AST not shown.
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Combined 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real :: g
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! Original Subroutine Name: dyn {
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
!}    
!}
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
!}    
!}
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
!}    
!}
!}
! Original Subroutine Name: shapiro {
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
!}    
!}
!}
! Original Subroutine Name: vernieuw {
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
!}
end subroutine dyn_shapiro_vernieuw_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")
end program wave2d

AST not shown.
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 With Loop Guards 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real :: g
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! Original Subroutine Name: dyn {
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
!}
! Original Subroutine Name: shapiro {
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
!}
! Original Subroutine Name: vernieuw {
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
!}
end subroutine dyn_shapiro_vernieuw_merged

AST not shown.
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")
end program wave2d

AST not shown.
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Kernels 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


--------------------
subroutine dyn_0(dt,dx,dy,eta,g,j,k)
      real :: dt
      real, dimension(0:501,0:501) :: du
      real, dimension(0:501,0:501) :: dv
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
end subroutine dyn_0

======================


--------------------
subroutine dyn_1(j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1

======================


--------------------
subroutine dyn_2(dt,dx,dy,eta,etan,h,j,k,un,vn)
      real :: dt
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(InOut) :: vn
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2

======================


--------------------
subroutine shapiro(eps,eta,etan,j,k,wet)
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
end subroutine shapiro

======================


--------------------
subroutine vernieuw(eta,h,hmin,hzero,j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
end subroutine vernieuw

======================

no. of kernels: 5
 ! ==============================================
 ! Name: dyn_0 Order: 0
 ! Input streams:
 !	StencilStream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
 ! Output streams:
 !	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
 !	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_0(dt,dx,dy,eta,g,j,k)
      real :: dt
      real, dimension(0:501,0:501) :: du
      real, dimension(0:501,0:501) :: dv
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
end subroutine dyn_0
 ! ==============================================

 ! ==============================================
 ! Name: dyn_1 Order: 1
 ! Input streams:
 !	StencilStream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
 !	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
 !	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_1(j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1
 ! ==============================================

 ! ==============================================
 ! Name: dyn_2 Order: 2
 ! Input streams:
 !	StencilStream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
 !	StencilStream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]!	2 point stencil on 2D array un: [[0,0],[0,-1]]
 !	StencilStream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_2(dt,dx,dy,eta,etan,h,j,k,un,vn)
      real :: dt
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(InOut) :: vn
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2
 ! ==============================================

 ! ==============================================
 ! Name: shapiro Order: 3
 ! Input streams:
 !	StencilStream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
 !	StencilStream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
 ! Output streams:
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine shapiro(eps,eta,etan,j,k,wet)
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
end subroutine shapiro
 ! ==============================================

 ! ==============================================
 ! Name: vernieuw Order: 4
 ! Input streams:
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: hzero_j_k array name: hzero type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine vernieuw(eta,h,hmin,hzero,j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
end subroutine vernieuw
 ! ==============================================


wet_j_k is largest stream size = 252004
BEFORE
dyn_1 requires:
StencilStream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
dyn_1 requires:
Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
dyn_1 requires:
Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
dyn_2 requires:
StencilStream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
dyn_2 requires:
Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
shapiro requires:
StencilStream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
vernieuw requires:
Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
vernieuw requires:
Stream: hzero_j_k array name: hzero type: Float dimensions: [(0,501),(0,501)]
vernieuw requires:
Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
vernieuw requires:
Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]


--------------------------------------------------------------------------------

Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
Produced at: dyn_1
Consumed at: vernieuw
Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
Produced at: dyn_1
Consumed at: vernieuw

 ! ==============================================
 ! Name: dyn_0 Order: 0
 ! Input streams:
 !	StencilStream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
 ! Output streams:
 !	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
 !	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_0(dt,dx,dy,eta,g,j,k)
      real :: dt
      real, dimension(0:501,0:501) :: du
      real, dimension(0:501,0:501) :: dv
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
end subroutine dyn_0
 ! ==============================================


 ! ==============================================
 ! Name: dyn_1 Order: 1
 ! Input streams:
 !	StencilStream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
 !	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
 !	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_1(j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1
 ! ==============================================


 ! ==============================================
 ! Name: dyn_2 Order: 2
 ! Input streams:
 !	StencilStream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
 !	StencilStream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]!	2 point stencil on 2D array un: [[0,0],[0,-1]]
 !	StencilStream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_2(dt,dx,dy,eta,etan,h,j,k,un,vn)
      real :: dt
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(InOut) :: vn
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2
 ! ==============================================


 ! ==============================================
 ! Name: shapiro Order: 3
 ! Input streams:
 !	TransitStream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	TransitStream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	StencilStream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
 !	StencilStream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
 ! Output streams:
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine shapiro(eps,eta,etan,j,k,wet)
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
end subroutine shapiro
 ! ==============================================


 ! ==============================================
 ! Name: vernieuw Order: 4
 ! Input streams:
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: hzero_j_k array name: hzero type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine vernieuw(eta,h,hmin,hzero,j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
end subroutine vernieuw
 ! ==============================================



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 With Smart Caches 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

"------------------------------------------"
 ! ==============================================
 ! Name: dyn_0 Order: 0
 ! Input streams:
 !	Stream: eta_j_kp1 array name: eta type: Float dimensions: [(0,501),(0,501)]
 !	Stream: eta_jp1_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
 !	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_0(dt,dx,dy,eta,g,j,k)
      real :: dt
      real, dimension(0:501,0:501) :: du
      real, dimension(0:501,0:501) :: dv
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
end subroutine dyn_0
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: dyn_1 Order: 1
 ! Input streams:
 !	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
 !	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_kp1 array name: wet type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_jp1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_1(j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: dyn_2 Order: 2
 ! Input streams:
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_jm1_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_j_kp1 array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_jp1_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_j_km1 array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_km1 array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_jm1_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine dyn_2(dt,dx,dy,eta,etan,h,j,k,un,vn)
      real :: dt
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(InOut) :: vn
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: shapiro Order: 3
 ! Input streams:
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_jm1_k array name: etan type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_j_kp1 array name: etan type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_jp1_k array name: etan type: Float dimensions: [(0,501),(0,501)]
 !	Stream: etan_j_km1 array name: etan type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_jm1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_kp1 array name: wet type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_jp1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_km1 array name: wet type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine shapiro(eps,eta,etan,j,k,wet)
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
end subroutine shapiro
 ! ==============================================


"------------------------------------------"
"------------------------------------------"
 ! ==============================================
 ! Name: vernieuw Order: 4
 ! Input streams:
 !	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: hzero_j_k array name: hzero type: Float dimensions: [(0,501),(0,501)]
 !	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
 !	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
 ! Output streams:
 !	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
 !	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
 !	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
 !	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
 ! Output Reduction Variables:
 ! --------------------------------------------
subroutine vernieuw(eta,h,hmin,hzero,j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
end subroutine vernieuw
 ! ==============================================


"------------------------------------------"

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 With Memory Readers 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

--------------  PIPELINE STAGE  ---------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a map kernel.
Name:dyn_0
--------------------------------------------------------------------------------
Input Streams:
	Stream: eta_j_kp1 array name: eta type: Float dimensions: [(0,501),(0,501)]
	Stream: eta_jp1_k array name: eta type: Float dimensions: [(0,501),(0,501)]
	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
OutputStreams:
	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
readPipes:
writtenPipes:

--------------------------------------------------------------------------------
subroutine dyn_0(dt,dx,dy,eta,g,j,k)
      real :: dt
      real, dimension(0:501,0:501) :: du
      real, dimension(0:501,0:501) :: dv
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
end subroutine dyn_0

--------------------------------------------------------------------------------
NullPipeLineData
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Just 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a smart cache kernel.
Name: dyn_0_smart_cache
Size: 503
Cache Lines:
	-------------------------------
	Smart cache item
	Input stream: eta_j_k
	Buffer size: 503
	Max positive offset = 503
	Max negative offset = 0
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		eta_j_kp1 from buffer index = 503
		eta_jp1_k from buffer index = 2
		eta_j_k from buffer index = 1
	-------------------------------


Input Streams:
	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
Output Streams:
	Stream: eta_j_kp1 array name: eta type: Float dimensions: [(0,501),(0,501)]
	Stream: eta_jp1_k array name: eta type: Float dimensions: [(0,501),(0,501)]
	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: dyn_0_eta_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	eta_j_k --> Stream "eta_j_k" "eta" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------------------

--------------  PIPELINE STAGE  ---------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a map kernel.
Name:dyn_1
--------------------------------------------------------------------------------
Input Streams:
	Stream: du_j_k array name: du type: Float dimensions: [(0,501),(0,501)]
	Stream: dv_j_k array name: dv type: Float dimensions: [(0,501),(0,501)]
	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_kp1 array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_jp1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
OutputStreams:
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
readPipes:
writtenPipes:

--------------------------------------------------------------------------------
subroutine dyn_1(j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1

--------------------------------------------------------------------------------
NullPipeLineData
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Just 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a smart cache kernel.
Name: dyn_1_smart_cache
Size: 503
Cache Lines:
	-------------------------------
	Smart cache item
	Input stream: wet_j_k
	Buffer size: 503
	Max positive offset = 503
	Max negative offset = 0
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		wet_j_kp1 from buffer index = 503
		wet_jp1_k from buffer index = 2
		wet_j_k from buffer index = 1
	-------------------------------


Input Streams:
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
Output Streams:
	Stream: wet_j_kp1 array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_jp1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: dyn_1_wet_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	wet_j_k --> Stream "wet_j_k" "wet" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: dyn_1_u_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	u_j_k --> Stream "u_j_k" "u" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: dyn_1_v_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	v_j_k --> Stream "v_j_k" "v" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------------------

--------------  PIPELINE STAGE  ---------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a map kernel.
Name:dyn_2
--------------------------------------------------------------------------------
Input Streams:
	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
	Stream: h_jm1_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_kp1 array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_jp1_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_km1 array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_km1 array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_jm1_k array name: vn type: Float dimensions: [(0,501),(0,501)]
OutputStreams:
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
readPipes:
writtenPipes:

--------------------------------------------------------------------------------
subroutine dyn_2(dt,dx,dy,eta,etan,h,j,k,un,vn)
      real :: dt
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(InOut) :: vn
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2

--------------------------------------------------------------------------------
NullPipeLineData
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Just 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a smart cache kernel.
Name: dyn_2_smart_cache
Size: 1005
Cache Lines:
	-------------------------------
	Smart cache item
	Input stream: h_j_k
	Buffer size: 1005
	Max positive offset = 503
	Max negative offset = 503
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		h_jm1_k from buffer index = 502
		h_j_kp1 from buffer index = 1005
		h_j_k from buffer index = 503
		h_jp1_k from buffer index = 504
		h_j_km1 from buffer index = 1
	-------------------------------

	-------------------------------
	Smart cache item
	Input stream: un_j_k
	Buffer size: 1005
	Max positive offset = 0
	Max negative offset = 503
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		un_j_k from buffer index = 1005
		un_j_km1 from buffer index = 503
	-------------------------------

	-------------------------------
	Smart cache item
	Input stream: vn_j_k
	Buffer size: 1005
	Max positive offset = 0
	Max negative offset = 2
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		vn_j_k from buffer index = 1005
		vn_jm1_k from buffer index = 1004
	-------------------------------


Input Streams:
	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
Output Streams:
	Stream: h_jm1_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_kp1 array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_jp1_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_km1 array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_km1 array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_jm1_k array name: vn type: Float dimensions: [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: dyn_2_h_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	h_j_k --> Stream "h_j_k" "h" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: dyn_2_eta_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	eta_j_k --> Stream "eta_j_k" "eta" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------------------

--------------  PIPELINE STAGE  ---------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a map kernel.
Name:shapiro
--------------------------------------------------------------------------------
Input Streams:
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_jm1_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_kp1 array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_jp1_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_km1 array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_jm1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_kp1 array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_jp1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_km1 array name: wet type: Float dimensions: [(0,501),(0,501)]
OutputStreams:
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
readPipes:
writtenPipes:

--------------------------------------------------------------------------------
subroutine shapiro(eps,eta,etan,j,k,wet)
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
end subroutine shapiro

--------------------------------------------------------------------------------
NullPipeLineData
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Just 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a smart cache kernel.
Name: shapiro_smart_cache
Size: 1005
Cache Lines:
	-------------------------------
	Smart cache item
	Input stream: vn_j_k
	Buffer size: 1005
	Max positive offset = 0
	Max negative offset = 0
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		vn_j_k from buffer index = 1005
	-------------------------------

	-------------------------------
	Smart cache item
	Input stream: un_j_k
	Buffer size: 1005
	Max positive offset = 0
	Max negative offset = 0
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		un_j_k from buffer index = 1005
	-------------------------------

	-------------------------------
	Smart cache item
	Input stream: etan_j_k
	Buffer size: 1005
	Max positive offset = 503
	Max negative offset = 503
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		etan_jm1_k from buffer index = 502
		etan_j_kp1 from buffer index = 1005
		etan_j_k from buffer index = 503
		etan_jp1_k from buffer index = 504
		etan_j_km1 from buffer index = 1
	-------------------------------

	-------------------------------
	Smart cache item
	Input stream: wet_j_k
	Buffer size: 1005
	Max positive offset = 503
	Max negative offset = 503
	Stream Dimensions: [(0,501),(0,501)]
	Output Streams:
		wet_jm1_k from buffer index = 502
		wet_j_kp1 from buffer index = 1005
		wet_j_k from buffer index = 503
		wet_jp1_k from buffer index = 504
		wet_j_km1 from buffer index = 1
	-------------------------------


Input Streams:
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
Output Streams:
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_jm1_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_kp1 array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_jp1_k array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: etan_j_km1 array name: etan type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_jm1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_kp1 array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_jp1_k array name: wet type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_km1 array name: wet type: Float dimensions: [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: shapiro_wet_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	wet_j_k --> Stream "wet_j_k" "wet" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------------------

--------------  PIPELINE STAGE  ---------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a map kernel.
Name:vernieuw
--------------------------------------------------------------------------------
Input Streams:
	Stream: eta_j_k array name: eta type: Float dimensions: [(0,501),(0,501)]
	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: hzero_j_k array name: hzero type: Float dimensions: [(0,501),(0,501)]
	Stream: un_j_k array name: un type: Float dimensions: [(0,501),(0,501)]
	Stream: vn_j_k array name: vn type: Float dimensions: [(0,501),(0,501)]
OutputStreams:
	Stream: h_j_k array name: h type: Float dimensions: [(0,501),(0,501)]
	Stream: u_j_k array name: u type: Float dimensions: [(0,501),(0,501)]
	Stream: v_j_k array name: v type: Float dimensions: [(0,501),(0,501)]
	Stream: wet_j_k array name: wet type: Float dimensions: [(0,501),(0,501)]
readPipes:
writtenPipes:

--------------------------------------------------------------------------------
subroutine vernieuw(eta,h,hmin,hzero,j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
end subroutine vernieuw

--------------------------------------------------------------------------------
NullPipeLineData
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Nothing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory writer kernel.
Name: vernieuw_output_writer
--------------------------------------------------------------------------------
Streams to memory:
	Stream "h_j_k" "h" Float [(0,501),(0,501)] --> h_j_k
	Stream "u_j_k" "u" Float [(0,501),(0,501)] --> u_j_k
	Stream "v_j_k" "v" Float [(0,501),(0,501)] --> v_j_k
	Stream "wet_j_k" "wet" Float [(0,501),(0,501)] --> wet_j_k

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: vernieuw_h_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	h_j_k --> Stream "h_j_k" "h" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is a memory reader kernel.
Name: vernieuw_hzero_j_k_reader
--------------------------------------------------------------------------------
Memory to streams:
	hzero_j_k --> Stream "hzero_j_k" "hzero" Float [(0,501),(0,501)]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
----------------------------------------------


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Routing Pipes 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Pipe "dyn_0" "dyn_1" "dyn_0__dyn_1__du_j_k__pipe" Float (Stream "du_j_k" "du" Float [(0,501),(0,501)])

Pipe "dyn_0" "dyn_1" "dyn_0__dyn_1__dv_j_k__pipe" Float (Stream "dv_j_k" "dv" Float [(0,501),(0,501)])

Pipe "dyn_0_smart_cache" "dyn_0" "dyn_0_smart_cache__dyn_0__eta_j_kp1__pipe" Float (Stream "eta_j_kp1" "eta" Float [(0,501),(0,501)])

Pipe "dyn_0_smart_cache" "dyn_0" "dyn_0_smart_cache__dyn_0__eta_jp1_k__pipe" Float (Stream "eta_jp1_k" "eta" Float [(0,501),(0,501)])

Pipe "dyn_0_smart_cache" "dyn_0" "dyn_0_smart_cache__dyn_0__eta_j_k__pipe" Float (Stream "eta_j_k" "eta" Float [(0,501),(0,501)])

Pipe "dyn_0_eta_j_k_reader" "dyn_0_smart_cache" "dyn_0_eta_j_k_reader__dyn_0_smart_cache__eta_j_k__pipe" Float (Stream "eta_j_k" "eta" Float [(0,501),(0,501)])

Pipe "dyn_1" "dyn_2_smart_cache" "dyn_1__dyn_2_smart_cache__un_j_k__pipe" Float (Stream "un_j_k" "un" Float [(0,501),(0,501)])

Pipe "dyn_1" "dyn_2_smart_cache" "dyn_1__dyn_2_smart_cache__vn_j_k__pipe" Float (Stream "vn_j_k" "vn" Float [(0,501),(0,501)])

Pipe "dyn_1_smart_cache" "dyn_1" "dyn_1_smart_cache__dyn_1__wet_j_kp1__pipe" Float (Stream "wet_j_kp1" "wet" Float [(0,501),(0,501)])

Pipe "dyn_1_smart_cache" "dyn_1" "dyn_1_smart_cache__dyn_1__wet_jp1_k__pipe" Float (Stream "wet_jp1_k" "wet" Float [(0,501),(0,501)])

Pipe "dyn_1_smart_cache" "dyn_1" "dyn_1_smart_cache__dyn_1__wet_j_k__pipe" Float (Stream "wet_j_k" "wet" Float [(0,501),(0,501)])

Pipe "dyn_1_wet_j_k_reader" "dyn_1_smart_cache" "dyn_1_wet_j_k_reader__dyn_1_smart_cache__wet_j_k__pipe" Float (Stream "wet_j_k" "wet" Float [(0,501),(0,501)])

Pipe "dyn_1_u_j_k_reader" "dyn_1" "dyn_1_u_j_k_reader__dyn_1__u_j_k__pipe" Float (Stream "u_j_k" "u" Float [(0,501),(0,501)])

Pipe "dyn_1_v_j_k_reader" "dyn_1" "dyn_1_v_j_k_reader__dyn_1__v_j_k__pipe" Float (Stream "v_j_k" "v" Float [(0,501),(0,501)])

Pipe "dyn_2" "shapiro_smart_cache" "dyn_2__shapiro_smart_cache__vn_j_k__pipe" Float (Stream "vn_j_k" "vn" Float [(0,501),(0,501)])

Pipe "dyn_2" "shapiro_smart_cache" "dyn_2__shapiro_smart_cache__un_j_k__pipe" Float (Stream "un_j_k" "un" Float [(0,501),(0,501)])

Pipe "dyn_2" "shapiro_smart_cache" "dyn_2__shapiro_smart_cache__etan_j_k__pipe" Float (Stream "etan_j_k" "etan" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__h_jm1_k__pipe" Float (Stream "h_jm1_k" "h" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__h_j_kp1__pipe" Float (Stream "h_j_kp1" "h" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__h_j_k__pipe" Float (Stream "h_j_k" "h" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__h_jp1_k__pipe" Float (Stream "h_jp1_k" "h" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__h_j_km1__pipe" Float (Stream "h_j_km1" "h" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__un_j_k__pipe" Float (Stream "un_j_k" "un" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__un_j_km1__pipe" Float (Stream "un_j_km1" "un" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__vn_j_k__pipe" Float (Stream "vn_j_k" "vn" Float [(0,501),(0,501)])

Pipe "dyn_2_smart_cache" "dyn_2" "dyn_2_smart_cache__dyn_2__vn_jm1_k__pipe" Float (Stream "vn_jm1_k" "vn" Float [(0,501),(0,501)])

Pipe "dyn_2_h_j_k_reader" "dyn_2_smart_cache" "dyn_2_h_j_k_reader__dyn_2_smart_cache__h_j_k__pipe" Float (Stream "h_j_k" "h" Float [(0,501),(0,501)])

Pipe "dyn_2_eta_j_k_reader" "dyn_2" "dyn_2_eta_j_k_reader__dyn_2__eta_j_k__pipe" Float (Stream "eta_j_k" "eta" Float [(0,501),(0,501)])

Pipe "shapiro" "vernieuw" "shapiro__vernieuw__eta_j_k__pipe" Float (Stream "eta_j_k" "eta" Float [(0,501),(0,501)])

Pipe "shapiro" "vernieuw" "shapiro__vernieuw__un_j_k__pipe" Float (Stream "un_j_k" "un" Float [(0,501),(0,501)])

Pipe "shapiro" "vernieuw" "shapiro__vernieuw__vn_j_k__pipe" Float (Stream "vn_j_k" "vn" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__vn_j_k__pipe" Float (Stream "vn_j_k" "vn" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__un_j_k__pipe" Float (Stream "un_j_k" "un" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__etan_jm1_k__pipe" Float (Stream "etan_jm1_k" "etan" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__etan_j_kp1__pipe" Float (Stream "etan_j_kp1" "etan" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__etan_j_k__pipe" Float (Stream "etan_j_k" "etan" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__etan_jp1_k__pipe" Float (Stream "etan_jp1_k" "etan" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__etan_j_km1__pipe" Float (Stream "etan_j_km1" "etan" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__wet_jm1_k__pipe" Float (Stream "wet_jm1_k" "wet" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__wet_j_kp1__pipe" Float (Stream "wet_j_kp1" "wet" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__wet_j_k__pipe" Float (Stream "wet_j_k" "wet" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__wet_jp1_k__pipe" Float (Stream "wet_jp1_k" "wet" Float [(0,501),(0,501)])

Pipe "shapiro_smart_cache" "shapiro" "shapiro_smart_cache__shapiro__wet_j_km1__pipe" Float (Stream "wet_j_km1" "wet" Float [(0,501),(0,501)])

Pipe "shapiro_wet_j_k_reader" "shapiro_smart_cache" "shapiro_wet_j_k_reader__shapiro_smart_cache__wet_j_k__pipe" Float (Stream "wet_j_k" "wet" Float [(0,501),(0,501)])

Pipe "vernieuw" "vernieuw_output_writer" "vernieuw__vernieuw_output_writer__h_j_k__pipe" Float (Stream "h_j_k" "h" Float [(0,501),(0,501)])

Pipe "vernieuw" "vernieuw_output_writer" "vernieuw__vernieuw_output_writer__u_j_k__pipe" Float (Stream "u_j_k" "u" Float [(0,501),(0,501)])

Pipe "vernieuw" "vernieuw_output_writer" "vernieuw__vernieuw_output_writer__v_j_k__pipe" Float (Stream "v_j_k" "v" Float [(0,501),(0,501)])

Pipe "vernieuw" "vernieuw_output_writer" "vernieuw__vernieuw_output_writer__wet_j_k__pipe" Float (Stream "wet_j_k" "wet" Float [(0,501),(0,501)])

Pipe "vernieuw_h_j_k_reader" "vernieuw" "vernieuw_h_j_k_reader__vernieuw__h_j_k__pipe" Float (Stream "h_j_k" "h" Float [(0,501),(0,501)])

Pipe "vernieuw_hzero_j_k_reader" "vernieuw" "vernieuw_hzero_j_k_reader__vernieuw__hzero_j_k__pipe" Float (Stream "hzero_j_k" "hzero" Float [(0,501),(0,501)])

Graph Viz data:

digraph G {

	dyn_0 -> dyn_1 [ label="du_j_k" ]
	dyn_0 -> dyn_1 [ label="dv_j_k" ]
	dyn_0_smart_cache -> dyn_0 [ label="eta_j_kp1" ]
	dyn_0_smart_cache -> dyn_0 [ label="eta_jp1_k" ]
	dyn_0_smart_cache -> dyn_0 [ label="eta_j_k" ]
	dyn_0_eta_j_k_reader -> dyn_0_smart_cache [ label="eta_j_k" ]
	dyn_1 -> dyn_2_smart_cache [ label="un_j_k" ]
	dyn_1 -> dyn_2_smart_cache [ label="vn_j_k" ]
	dyn_1_smart_cache -> dyn_1 [ label="wet_j_kp1" ]
	dyn_1_smart_cache -> dyn_1 [ label="wet_jp1_k" ]
	dyn_1_smart_cache -> dyn_1 [ label="wet_j_k" ]
	dyn_1_wet_j_k_reader -> dyn_1_smart_cache [ label="wet_j_k" ]
	dyn_1_u_j_k_reader -> dyn_1 [ label="u_j_k" ]
	dyn_1_v_j_k_reader -> dyn_1 [ label="v_j_k" ]
	dyn_2 -> shapiro_smart_cache [ label="vn_j_k" ]
	dyn_2 -> shapiro_smart_cache [ label="un_j_k" ]
	dyn_2 -> shapiro_smart_cache [ label="etan_j_k" ]
	dyn_2_smart_cache -> dyn_2 [ label="h_jm1_k" ]
	dyn_2_smart_cache -> dyn_2 [ label="h_j_kp1" ]
	dyn_2_smart_cache -> dyn_2 [ label="h_j_k" ]
	dyn_2_smart_cache -> dyn_2 [ label="h_jp1_k" ]
	dyn_2_smart_cache -> dyn_2 [ label="h_j_km1" ]
	dyn_2_smart_cache -> dyn_2 [ label="un_j_k" ]
	dyn_2_smart_cache -> dyn_2 [ label="un_j_km1" ]
	dyn_2_smart_cache -> dyn_2 [ label="vn_j_k" ]
	dyn_2_smart_cache -> dyn_2 [ label="vn_jm1_k" ]
	dyn_2_h_j_k_reader -> dyn_2_smart_cache [ label="h_j_k" ]
	dyn_2_eta_j_k_reader -> dyn_2 [ label="eta_j_k" ]
	shapiro -> vernieuw [ label="eta_j_k" ]
	shapiro -> vernieuw [ label="un_j_k" ]
	shapiro -> vernieuw [ label="vn_j_k" ]
	shapiro_smart_cache -> shapiro [ label="vn_j_k" ]
	shapiro_smart_cache -> shapiro [ label="un_j_k" ]
	shapiro_smart_cache -> shapiro [ label="etan_jm1_k" ]
	shapiro_smart_cache -> shapiro [ label="etan_j_kp1" ]
	shapiro_smart_cache -> shapiro [ label="etan_j_k" ]
	shapiro_smart_cache -> shapiro [ label="etan_jp1_k" ]
	shapiro_smart_cache -> shapiro [ label="etan_j_km1" ]
	shapiro_smart_cache -> shapiro [ label="wet_jm1_k" ]
	shapiro_smart_cache -> shapiro [ label="wet_j_kp1" ]
	shapiro_smart_cache -> shapiro [ label="wet_j_k" ]
	shapiro_smart_cache -> shapiro [ label="wet_jp1_k" ]
	shapiro_smart_cache -> shapiro [ label="wet_j_km1" ]
	shapiro_wet_j_k_reader -> shapiro_smart_cache [ label="wet_j_k" ]
	vernieuw -> vernieuw_output_writer [ label="h_j_k" ]
	vernieuw -> vernieuw_output_writer [ label="u_j_k" ]
	vernieuw -> vernieuw_output_writer [ label="v_j_k" ]
	vernieuw -> vernieuw_output_writer [ label="wet_j_k" ]
	vernieuw_h_j_k_reader -> vernieuw [ label="h_j_k" ]
	vernieuw_hzero_j_k_reader -> vernieuw [ label="hzero_j_k" ]
}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Scalarizing Kernels 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Kernel = 
subroutine dyn_0(dt,dx,dy,eta,g,j,k)
      real :: dt
      real, dimension(0:501,0:501) :: du
      real, dimension(0:501,0:501) :: dv
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
        dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    end if
!}    
!}
end subroutine dyn_0

Streams = 
subroutine dyn_0(dt,dx,dy,g,j,k)
      real :: dt
      real :: du_j_k
      real :: dv_j_k
      real :: dx
      real :: dy
      real, intent(In) :: eta_j_kp1
      real, intent(In) :: eta_jp1_k
      real, intent(In) :: eta_j_k
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
! OpenCLStencil (
!	3 point stencil on 2D array eta: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        du_j_k = -dt*g*(eta_j_kp1-eta_j_k)/dx
        dv_j_k = -dt*g*(eta_jp1_k-eta_j_k)/dy
    end if
!}    
!}
end subroutine dyn_0

Kernel = 
subroutine dyn_1(j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501) :: du
      real :: duu
      real, dimension(0:501,0:501) :: dv
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real :: uu
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un(j,k) = 0.0
        uu = u(j,k)
        duu = du(j,k)
        if (wet(j,k)==1) then
                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                un(j,k) = uu+duu
                end if
        else
                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                un(j,k) = uu+duu
                end if
        end if
        vv = v(j,k)
        dvv = dv(j,k)
        vn(j,k) = 0.0
        if (wet(j,k)==1) then
                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                vn(j,k) = vv+dvv
                end if
        else
                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                vn(j,k) = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1

Streams = 
subroutine dyn_1(j,k)
      real :: du_j_k
      real :: duu
      real :: dv_j_k
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, intent(Out) :: u_j_k
      real, intent(InOut) :: un_j_k
      real :: uu
      real, intent(Out) :: v_j_k
      real, intent(InOut) :: vn_j_k
      real :: vv
      integer, intent(Out) :: wet_j_kp1
      integer, intent(Out) :: wet_jp1_k
      integer, intent(Out) :: wet_j_k
! OpenCLStencil (
!	3 point stencil on 2D array wet: [[1,0],[0,0],[0,1]]
!    ){
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        un_j_k = 0.0
        uu = u_j_k
        duu = du_j_k
        if (wet_j_k==1) then
                if ((wet_j_kp1==1) .or. (duu>0.0)) then
                                un_j_k = uu+duu
                end if
        else
                if ((wet_j_kp1==1) .and. (duu<0.0)) then
                                un_j_k = uu+duu
                end if
        end if
        vv = v_j_k
        dvv = dv_j_k
        vn_j_k = 0.0
        if (wet_j_k==1) then
                if ((wet_jp1_k==1) .or. (dvv>0.0)) then
                                vn_j_k = vv+dvv
                end if
        else
                if ((wet_jp1_k==1) .and. (dvv<0.0)) then
                                vn_j_k = vv+dvv
                end if
        end if
    end if
!}    
!}
end subroutine dyn_1

Kernel = 
subroutine dyn_2(dt,dx,dy,eta,etan,h,j,k,un,vn)
      real :: dt
      real :: dx
      real :: dy
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      real, dimension(0:501,0:501), intent(InOut) :: h
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(InOut) :: vn
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
        hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
        hue = hep+hen
        hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
        hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
        huw = hwp+hwn
        hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
        hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
        hvn = hnp+hnn
        hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
        hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
        hvs = hsp+hsn
        etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2

Streams = 
subroutine dyn_2(dt,dx,dy,j,k)
      real :: dt
      real :: dx
      real :: dy
      real, intent(In) :: eta_j_k
      real :: etan_j_k
      real, intent(InOut) :: h_jm1_k
      real, intent(InOut) :: h_j_kp1
      real, intent(InOut) :: h_j_k
      real, intent(InOut) :: h_jp1_k
      real, intent(InOut) :: h_j_km1
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, intent(InOut) :: un_j_k
      real, intent(InOut) :: vn_j_k
      real, intent(InOut) :: vn_jm1_k
      real, intent(InOut) :: vn_j_k
! OpenCLStencil (
!	5 point stencil on 2D array h: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	2 point stencil on 2D array un: [[0,0],[0,-1]]
!	2 point stencil on 2D array vn: [[0,0],[-1,0]]
!    ){
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        hep = 0.5*(un_j_k+abs(un_j_k))*h_j_k
        hen = 0.5*(un_j_k-abs(un_j_k))*h_j_kp1
        hue = hep+hen
        hwp = 0.5*(un_j_km1+abs(un_j_km1))*h_j_km1
        hwn = 0.5*(un_j_km1-abs(un_j_km1))*h_j_k
        huw = hwp+hwn
        hnp = 0.5*(vn_j_k+abs(vn_j_k))*h_j_k
        hnn = 0.5*(vn_j_k-abs(vn_j_k))*h_jp1_k
        hvn = hnp+hnn
        hsp = 0.5*(vn_jm1_k+abs(vn_jm1_k))*h_jm1_k
        hsn = 0.5*(vn_jm1_k-abs(vn_jm1_k))*h_j_k
        hvs = hsp+hsn
        etan_j_k = eta_j_k-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    end if
!}    
!}
end subroutine dyn_2

Kernel = 
subroutine shapiro(eps,eta,etan,j,k,wet)
      real :: eps
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501) :: etan
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet(j,k)==1) then
                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                eta(j,k) = term1+term2+term3
        else
                eta(j,k) = etan(j,k)
        end if
    end if
!}    
!}
end subroutine shapiro

Streams = 
subroutine shapiro(eps,j,k)
      real :: eps
      real, intent(In) :: eta_j_k
      real :: etan_jm1_k
      real :: etan_j_kp1
      real :: etan_j_k
      real :: etan_jp1_k
      real :: etan_j_km1
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, intent(Out) :: wet_jm1_k
      integer, intent(Out) :: wet_j_kp1
      integer, intent(Out) :: wet_j_k
      integer, intent(Out) :: wet_jp1_k
      integer, intent(Out) :: wet_j_km1
! OpenCLStencil (
!	5 point stencil on 2D array etan: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!	5 point stencil on 2D array wet: [[1,0],[0,0],[0,1],[0,-1],[-1,0]]
!    ){
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500,1)","(k,1,500,1)"],[]) {
    if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
        if (wet_j_k==1) then
                term1 = (1.0-0.25*eps*(wet_j_kp1+wet_j_km1+wet_jp1_k+wet_jm1_k))*etan_j_k
                term2 = 0.25*eps*(wet_j_kp1*etan_j_kp1+wet_j_km1*etan_j_km1)
                term3 = 0.25*eps*(wet_jp1_k*etan_jp1_k+wet_jm1_k*etan_jm1_k)
                eta_j_k = term1+term2+term3
        else
                eta_j_k = etan_j_k
        end if
    end if
!}    
!}
end subroutine shapiro

Kernel = 
subroutine vernieuw(eta,h,hmin,hzero,j,k,u,un,v,vn,wet)
      real, dimension(0:501,0:501), intent(In) :: eta
      real, dimension(0:501,0:501), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:501,0:501), intent(In) :: hzero
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:501,0:501), intent(Out) :: u
      real, dimension(0:501,0:501), intent(InOut) :: un
      real, dimension(0:501,0:501), intent(Out) :: v
      real, dimension(0:501,0:501), intent(InOut) :: vn
      integer, dimension(0:501,0:501), intent(Out) :: wet
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
!}
end subroutine vernieuw

Streams = 
subroutine vernieuw(hmin,j,k)
      real, intent(In) :: eta_j_k
      real, intent(InOut) :: h_j_k
      real, intent(In) :: hmin
      real, intent(In) :: hzero_j_k
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, intent(Out) :: u_j_k
      real, intent(InOut) :: un_j_k
      real, intent(Out) :: v_j_k
      real, intent(InOut) :: vn_j_k
      integer, intent(Out) :: wet_j_k
! OpenCLMap ( ["hzero","h","hmin","un","vn","eta"],["h","wet","u","v"],["(j,0,501,1)","(k,0,501,1)"],[]) {
    h_j_k = hzero_j_k+eta_j_k
    wet_j_k = 1
    if (h_j_k<hmin) then
        wet_j_k = 0
    end if
    u_j_k = un_j_k
    v_j_k = vn_j_k
!}
end subroutine vernieuw


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dyn_0_smart_cache 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine dyn_0_smart_cache
      real :: eta_read_in
      real, dimension(1:503) :: eta_buffer
      real :: eta_j_kp1
      real :: eta_jp1_k
      real :: eta_j_k
      integer :: i
      integer :: count
      integer :: compIndex
      integer, parameter :: nloop = 252507 
      integer, parameter :: smartCacheSize = 503 
      integer, parameter :: maxPositiveOffset = 503 
      integer, parameter :: maxNegativeOffset = 0 
    do count = 1, count<=nloop, 1
        compIndex = count-maxPositiveOffset
        !$PRAGMA unroll
        do i = 1, i<=smartCacheSize-1, 1
                eta_buffer(i) = eta_buffer(i+1)
        end do
        if (count<smartCacheSize) then
                ! F4 Comment: read pipe dyn_0_eta_j_k_reader__dyn_0_smart_cache__eta_j_k__pipe
                call readPipe(dyn_0_eta_j_k_reader__dyn_0_smart_cache__eta_j_k__pipe, eta_read_in)
                eta_buffer(503) = eta_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
        if (compIndex>=0) then
                ! F4 Comment: write pipe dyn_0_smart_cache__dyn_0__eta_j_k__pipe
                eta_j_k = eta_buffer(1)
                call writePipe(dyn_0_smart_cache__dyn_0__eta_j_k__pipe, eta_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_0_smart_cache__dyn_0__eta_j_kp1__pipe
                eta_j_kp1 = eta_buffer(503)
                call writePipe(dyn_0_smart_cache__dyn_0__eta_j_kp1__pipe, eta_j_kp1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_0_smart_cache__dyn_0__eta_jp1_k__pipe
                eta_jp1_k = eta_buffer(2)
                call writePipe(dyn_0_smart_cache__dyn_0__eta_jp1_k__pipe, eta_jp1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
    end do
end subroutine dyn_0_smart_cache


--------------------------------------------------------------------------------


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dyn_1_smart_cache 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine dyn_1_smart_cache
      real :: wet_read_in
      real, dimension(1:503) :: wet_buffer
      real :: wet_j_kp1
      real :: wet_jp1_k
      real :: wet_j_k
      integer :: i
      integer :: count
      integer :: compIndex
      integer, parameter :: nloop = 252507 
      integer, parameter :: smartCacheSize = 503 
      integer, parameter :: maxPositiveOffset = 503 
      integer, parameter :: maxNegativeOffset = 0 
    do count = 1, count<=nloop, 1
        compIndex = count-maxPositiveOffset
        !$PRAGMA unroll
        do i = 1, i<=smartCacheSize-1, 1
                wet_buffer(i) = wet_buffer(i+1)
        end do
        if (count<smartCacheSize) then
                ! F4 Comment: read pipe dyn_1_wet_j_k_reader__dyn_1_smart_cache__wet_j_k__pipe
                call readPipe(dyn_1_wet_j_k_reader__dyn_1_smart_cache__wet_j_k__pipe, wet_read_in)
                wet_buffer(503) = wet_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
        if (compIndex>=0) then
                ! F4 Comment: write pipe dyn_1_smart_cache__dyn_1__wet_j_k__pipe
                wet_j_k = wet_buffer(1)
                call writePipe(dyn_1_smart_cache__dyn_1__wet_j_k__pipe, wet_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_1_smart_cache__dyn_1__wet_j_kp1__pipe
                wet_j_kp1 = wet_buffer(503)
                call writePipe(dyn_1_smart_cache__dyn_1__wet_j_kp1__pipe, wet_j_kp1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_1_smart_cache__dyn_1__wet_jp1_k__pipe
                wet_jp1_k = wet_buffer(2)
                call writePipe(dyn_1_smart_cache__dyn_1__wet_jp1_k__pipe, wet_jp1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
    end do
end subroutine dyn_1_smart_cache


--------------------------------------------------------------------------------


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dyn_2_smart_cache 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine dyn_2_smart_cache
      real :: h_read_in
      real :: un_read_in
      real :: vn_read_in
      real, dimension(1:1005) :: h_buffer
      real, dimension(1:1005) :: un_buffer
      real, dimension(1:1005) :: vn_buffer
      real :: h_jm1_k
      real :: h_j_kp1
      real :: h_j_k
      real :: h_jp1_k
      real :: h_j_km1
      real :: un_j_k
      real :: un_j_km1
      real :: vn_j_k
      real :: vn_jm1_k
      integer :: i
      integer :: count
      integer :: compIndex
      integer, parameter :: nloop = 252507 
      integer, parameter :: smartCacheSize = 1005 
      integer, parameter :: maxPositiveOffset = 503 
      integer, parameter :: maxNegativeOffset = 503 
    do count = 1, count<=nloop, 1
        compIndex = count-maxPositiveOffset
        !$PRAGMA unroll
        do i = 1, i<=smartCacheSize-1, 1
                h_buffer(i) = h_buffer(i+1)
                un_buffer(i) = un_buffer(i+1)
                vn_buffer(i) = vn_buffer(i+1)
        end do
        if (count<smartCacheSize) then
                ! F4 Comment: read pipe dyn_2_h_j_k_reader__dyn_2_smart_cache__h_j_k__pipe
                call readPipe(dyn_2_h_j_k_reader__dyn_2_smart_cache__h_j_k__pipe, h_read_in)
                h_buffer(1005) = h_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: read pipe dyn_1__dyn_2_smart_cache__un_j_k__pipe
                call readPipe(dyn_1__dyn_2_smart_cache__un_j_k__pipe, un_read_in)
                un_buffer(1005) = un_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: read pipe dyn_1__dyn_2_smart_cache__vn_j_k__pipe
                call readPipe(dyn_1__dyn_2_smart_cache__vn_j_k__pipe, vn_read_in)
                vn_buffer(1005) = vn_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
        if (compIndex>=0) then
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__h_j_k__pipe
                h_j_k = h_buffer(503)
                call writePipe(dyn_2_smart_cache__dyn_2__h_j_k__pipe, h_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__h_j_km1__pipe
                h_j_km1 = h_buffer(1)
                call writePipe(dyn_2_smart_cache__dyn_2__h_j_km1__pipe, h_j_km1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__h_j_kp1__pipe
                h_j_kp1 = h_buffer(1005)
                call writePipe(dyn_2_smart_cache__dyn_2__h_j_kp1__pipe, h_j_kp1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__h_jm1_k__pipe
                h_jm1_k = h_buffer(502)
                call writePipe(dyn_2_smart_cache__dyn_2__h_jm1_k__pipe, h_jm1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__h_jp1_k__pipe
                h_jp1_k = h_buffer(504)
                call writePipe(dyn_2_smart_cache__dyn_2__h_jp1_k__pipe, h_jp1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__un_j_k__pipe
                un_j_k = un_buffer(1005)
                call writePipe(dyn_2_smart_cache__dyn_2__un_j_k__pipe, un_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__un_j_km1__pipe
                un_j_km1 = un_buffer(503)
                call writePipe(dyn_2_smart_cache__dyn_2__un_j_km1__pipe, un_j_km1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__vn_j_k__pipe
                vn_j_k = vn_buffer(1005)
                call writePipe(dyn_2_smart_cache__dyn_2__vn_j_k__pipe, vn_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe dyn_2_smart_cache__dyn_2__vn_jm1_k__pipe
                vn_jm1_k = vn_buffer(1004)
                call writePipe(dyn_2_smart_cache__dyn_2__vn_jm1_k__pipe, vn_jm1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
    end do
end subroutine dyn_2_smart_cache


--------------------------------------------------------------------------------


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shapiro_smart_cache 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

subroutine shapiro_smart_cache
      real :: vn_read_in
      real :: un_read_in
      real :: etan_read_in
      real :: wet_read_in
      real, dimension(1:1005) :: vn_buffer
      real, dimension(1:1005) :: un_buffer
      real, dimension(1:1005) :: etan_buffer
      real, dimension(1:1005) :: wet_buffer
      real :: vn_j_k
      real :: un_j_k
      real :: etan_jm1_k
      real :: etan_j_kp1
      real :: etan_j_k
      real :: etan_jp1_k
      real :: etan_j_km1
      real :: wet_jm1_k
      real :: wet_j_kp1
      real :: wet_j_k
      real :: wet_jp1_k
      real :: wet_j_km1
      integer :: i
      integer :: count
      integer :: compIndex
      integer, parameter :: nloop = 252507 
      integer, parameter :: smartCacheSize = 1005 
      integer, parameter :: maxPositiveOffset = 503 
      integer, parameter :: maxNegativeOffset = 503 
    do count = 1, count<=nloop, 1
        compIndex = count-maxPositiveOffset
        !$PRAGMA unroll
        do i = 1, i<=smartCacheSize-1, 1
                vn_buffer(i) = vn_buffer(i+1)
                un_buffer(i) = un_buffer(i+1)
                etan_buffer(i) = etan_buffer(i+1)
                wet_buffer(i) = wet_buffer(i+1)
        end do
        if (count<smartCacheSize) then
                ! F4 Comment: read pipe dyn_2__shapiro_smart_cache__etan_j_k__pipe
                call readPipe(dyn_2__shapiro_smart_cache__etan_j_k__pipe, etan_read_in)
                etan_buffer(1005) = etan_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: read pipe dyn_2__shapiro_smart_cache__un_j_k__pipe
                call readPipe(dyn_2__shapiro_smart_cache__un_j_k__pipe, un_read_in)
                un_buffer(1005) = un_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: read pipe dyn_2__shapiro_smart_cache__vn_j_k__pipe
                call readPipe(dyn_2__shapiro_smart_cache__vn_j_k__pipe, vn_read_in)
                vn_buffer(1005) = vn_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: read pipe shapiro_wet_j_k_reader__shapiro_smart_cache__wet_j_k__pipe
                call readPipe(shapiro_wet_j_k_reader__shapiro_smart_cache__wet_j_k__pipe, wet_read_in)
                wet_buffer(1005) = wet_read_in
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
        if (compIndex>=0) then
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__etan_j_k__pipe
                etan_j_k = etan_buffer(503)
                call writePipe(shapiro_smart_cache__shapiro__etan_j_k__pipe, etan_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__etan_j_km1__pipe
                etan_j_km1 = etan_buffer(1)
                call writePipe(shapiro_smart_cache__shapiro__etan_j_km1__pipe, etan_j_km1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__etan_j_kp1__pipe
                etan_j_kp1 = etan_buffer(1005)
                call writePipe(shapiro_smart_cache__shapiro__etan_j_kp1__pipe, etan_j_kp1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__etan_jm1_k__pipe
                etan_jm1_k = etan_buffer(502)
                call writePipe(shapiro_smart_cache__shapiro__etan_jm1_k__pipe, etan_jm1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__etan_jp1_k__pipe
                etan_jp1_k = etan_buffer(504)
                call writePipe(shapiro_smart_cache__shapiro__etan_jp1_k__pipe, etan_jp1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__un_j_k__pipe
                un_j_k = un_buffer(1005)
                call writePipe(shapiro_smart_cache__shapiro__un_j_k__pipe, un_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__vn_j_k__pipe
                vn_j_k = vn_buffer(1005)
                call writePipe(shapiro_smart_cache__shapiro__vn_j_k__pipe, vn_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__wet_j_k__pipe
                wet_j_k = wet_buffer(503)
                call writePipe(shapiro_smart_cache__shapiro__wet_j_k__pipe, wet_j_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__wet_j_km1__pipe
                wet_j_km1 = wet_buffer(1)
                call writePipe(shapiro_smart_cache__shapiro__wet_j_km1__pipe, wet_j_km1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__wet_j_kp1__pipe
                wet_j_kp1 = wet_buffer(1005)
                call writePipe(shapiro_smart_cache__shapiro__wet_j_kp1__pipe, wet_j_kp1)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__wet_jm1_k__pipe
                wet_jm1_k = wet_buffer(502)
                call writePipe(shapiro_smart_cache__shapiro__wet_jm1_k__pipe, wet_jm1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
                ! F4 Comment: write pipe shapiro_smart_cache__shapiro__wet_jp1_k__pipe
                wet_jp1_k = wet_buffer(504)
                call writePipe(shapiro_smart_cache__shapiro__wet_jp1_k__pipe, wet_jp1_k)
                call memFence(CLK_CHANNEL_MEM_FENCE)
        end if
    end do
end subroutine shapiro_smart_cache


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

subroutine dyn_0_eta_j_k_reader(eta)
      real, dimension(1:252004) :: eta
      real :: eta_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe dyn_0_eta_j_k_reader__dyn_0_smart_cache__eta_j_k__pipe
        eta_j_k = eta(index)
        call writePipe(dyn_0_eta_j_k_reader__dyn_0_smart_cache__eta_j_k__pipe, eta_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_0_eta_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"eta")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_1_wet_j_k_reader(wet)
      real, dimension(1:252004) :: wet
      real :: wet_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe dyn_1_wet_j_k_reader__dyn_1_smart_cache__wet_j_k__pipe
        wet_j_k = wet(index)
        call writePipe(dyn_1_wet_j_k_reader__dyn_1_smart_cache__wet_j_k__pipe, wet_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_1_wet_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"wet")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_1_u_j_k_reader(u)
      real, dimension(1:252004) :: u
      real :: u_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe dyn_1_u_j_k_reader__dyn_1__u_j_k__pipe
        u_j_k = u(index)
        call writePipe(dyn_1_u_j_k_reader__dyn_1__u_j_k__pipe, u_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_1_u_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"u")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_1_v_j_k_reader(v)
      real, dimension(1:252004) :: v
      real :: v_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe dyn_1_v_j_k_reader__dyn_1__v_j_k__pipe
        v_j_k = v(index)
        call writePipe(dyn_1_v_j_k_reader__dyn_1__v_j_k__pipe, v_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_1_v_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"v")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_2_h_j_k_reader(h)
      real, dimension(1:252004) :: h
      real :: h_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe dyn_2_h_j_k_reader__dyn_2_smart_cache__h_j_k__pipe
        h_j_k = h(index)
        call writePipe(dyn_2_h_j_k_reader__dyn_2_smart_cache__h_j_k__pipe, h_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_2_h_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"h")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_2_eta_j_k_reader(eta)
      real, dimension(1:252004) :: eta
      real :: eta_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe dyn_2_eta_j_k_reader__dyn_2__eta_j_k__pipe
        eta_j_k = eta(index)
        call writePipe(dyn_2_eta_j_k_reader__dyn_2__eta_j_k__pipe, eta_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_2_eta_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"eta")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine shapiro_wet_j_k_reader(wet)
      real, dimension(1:252004) :: wet
      real :: wet_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe shapiro_wet_j_k_reader__shapiro_smart_cache__wet_j_k__pipe
        wet_j_k = wet(index)
        call writePipe(shapiro_wet_j_k_reader__shapiro_smart_cache__wet_j_k__pipe, wet_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine shapiro_wet_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"wet")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine vernieuw_h_j_k_reader(h)
      real, dimension(1:252004) :: h
      real :: h_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe vernieuw_h_j_k_reader__vernieuw__h_j_k__pipe
        h_j_k = h(index)
        call writePipe(vernieuw_h_j_k_reader__vernieuw__h_j_k__pipe, h_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine vernieuw_h_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"h")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine vernieuw_hzero_j_k_reader(hzero)
      real, dimension(1:252004) :: hzero
      real :: hzero_j_k
      integer, parameter :: nLoop = 252004 
      integer :: index
    do index = 1, index<=nLoop, 1
        ! F4 Comment: write pipe vernieuw_hzero_j_k_reader__vernieuw__hzero_j_k__pipe
        hzero_j_k = hzero(index)
        call writePipe(vernieuw_hzero_j_k_reader__vernieuw__hzero_j_k__pipe, hzero_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine vernieuw_hzero_j_k_reader


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"hzero")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine vernieuw_output_writer(h,u,v,wet)
      integer, parameter :: nLoop = 252004 
      integer :: index
      real :: h_j_k_read_in
      real, dimension(1:252004) :: h
      real :: u_j_k_read_in
      real, dimension(1:252004) :: u
      real :: v_j_k_read_in
      real, dimension(1:252004) :: v
      real :: wet_j_k_read_in
      real, dimension(1:252004) :: wet
    do index = 1, index<=nLoop, 1
        ! F4 Comment: read pipe vernieuw__vernieuw_output_writer__h_j_k__pipe
        call readPipe(vernieuw__vernieuw_output_writer__h_j_k__pipe, h_j_k_read_in)
        h(index) = h_j_k_read_in
        call memFence(CLK_CHANNEL_MEM_FENCE)
        ! F4 Comment: read pipe vernieuw__vernieuw_output_writer__u_j_k__pipe
        call readPipe(vernieuw__vernieuw_output_writer__u_j_k__pipe, u_j_k_read_in)
        u(index) = u_j_k_read_in
        call memFence(CLK_CHANNEL_MEM_FENCE)
        ! F4 Comment: read pipe vernieuw__vernieuw_output_writer__v_j_k__pipe
        call readPipe(vernieuw__vernieuw_output_writer__v_j_k__pipe, v_j_k_read_in)
        v(index) = v_j_k_read_in
        call memFence(CLK_CHANNEL_MEM_FENCE)
        ! F4 Comment: read pipe vernieuw__vernieuw_output_writer__wet_j_k__pipe
        call readPipe(vernieuw__vernieuw_output_writer__wet_j_k__pipe, wet_j_k_read_in)
        wet(index) = wet_j_k_read_in
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine vernieuw_output_writer


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"h"),(1,"u"),(2,"v"),(3,"wet")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_0(dt,dx,dy,g)
      integer, parameter :: nloop = 252004 
      real :: dt
      real :: du_j_k
      real :: dv_j_k
      real :: dx
      real :: dy
      real, intent(In) :: eta_j_kp1
      real, intent(In) :: eta_jp1_k
      real, intent(In) :: eta_j_k
      real :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
    do index = 1, index<=nloop, 1
        call readPipe(dyn_0_smart_cache__dyn_0__eta_j_k__pipe, eta_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_0_smart_cache__dyn_0__eta_j_kp1__pipe, eta_j_kp1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_0_smart_cache__dyn_0__eta_jp1_k__pipe, eta_jp1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
                du_j_k = -dt*g*(eta_j_kp1-eta_j_k)/dx
                dv_j_k = -dt*g*(eta_jp1_k-eta_j_k)/dy
        end if
        call writePipe(dyn_0__dyn_1__du_j_k__pipe, du_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(dyn_0__dyn_1__dv_j_k__pipe, dv_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_0


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"dt"),(1,"dx"),(2,"dy"),(3,"g")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_1
      integer, parameter :: nloop = 252004 
      real :: du_j_k
      real :: duu
      real :: dv_j_k
      real :: dvv
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, intent(Out) :: u_j_k
      real, intent(InOut) :: un_j_k
      real :: uu
      real, intent(Out) :: v_j_k
      real, intent(InOut) :: vn_j_k
      real :: vv
      integer, intent(Out) :: wet_j_kp1
      integer, intent(Out) :: wet_jp1_k
      integer, intent(Out) :: wet_j_k
    do index = 1, index<=nloop, 1
        call readPipe(dyn_0__dyn_1__du_j_k__pipe, du_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_0__dyn_1__dv_j_k__pipe, dv_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_1_u_j_k_reader__dyn_1__u_j_k__pipe, u_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_1_v_j_k_reader__dyn_1__v_j_k__pipe, v_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_1_smart_cache__dyn_1__wet_j_k__pipe, wet_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_1_smart_cache__dyn_1__wet_j_kp1__pipe, wet_j_kp1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_1_smart_cache__dyn_1__wet_jp1_k__pipe, wet_jp1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
                un_j_k = 0.0
                uu = u_j_k
                duu = du_j_k
                if (wet_j_k==1) then
                                if ((wet_j_kp1==1) .or. (duu>0.0)) then
                                                                un_j_k = uu+duu
                                end if
                else
                                if ((wet_j_kp1==1) .and. (duu<0.0)) then
                                                                un_j_k = uu+duu
                                end if
                end if
                vv = v_j_k
                dvv = dv_j_k
                vn_j_k = 0.0
                if (wet_j_k==1) then
                                if ((wet_jp1_k==1) .or. (dvv>0.0)) then
                                                                vn_j_k = vv+dvv
                                end if
                else
                                if ((wet_jp1_k==1) .and. (dvv<0.0)) then
                                                                vn_j_k = vv+dvv
                                end if
                end if
        end if
        call writePipe(dyn_1__dyn_2_smart_cache__un_j_k__pipe, un_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(dyn_1__dyn_2_smart_cache__vn_j_k__pipe, vn_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_1


--------------------------------------------------------------------------------

KCD {argPositions = []}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine dyn_2(dt,dx,dy)
      integer, parameter :: nloop = 252004 
      real :: dt
      real :: dx
      real :: dy
      real, intent(In) :: eta_j_k
      real :: etan_j_k
      real, intent(InOut) :: h_jm1_k
      real, intent(InOut) :: h_j_kp1
      real, intent(InOut) :: h_j_k
      real, intent(InOut) :: h_jp1_k
      real, intent(InOut) :: h_j_km1
      real :: hen
      real :: hep
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, intent(InOut) :: un_j_k
      real, intent(InOut) :: vn_j_k
      real, intent(InOut) :: vn_jm1_k
      real, intent(InOut) :: vn_j_k
    do index = 1, index<=nloop, 1
        call readPipe(dyn_2_eta_j_k_reader__dyn_2__eta_j_k__pipe, eta_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__h_j_k__pipe, h_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__h_j_km1__pipe, h_j_km1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__h_j_kp1__pipe, h_j_kp1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__h_jm1_k__pipe, h_jm1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__h_jp1_k__pipe, h_jp1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__un_j_k__pipe, un_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__un_j_km1__pipe, un_j_km1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__vn_j_k__pipe, vn_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(dyn_2_smart_cache__dyn_2__vn_jm1_k__pipe, vn_jm1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
                hep = 0.5*(un_j_k+abs(un_j_k))*h_j_k
                hen = 0.5*(un_j_k-abs(un_j_k))*h_j_kp1
                hue = hep+hen
                hwp = 0.5*(un_j_km1+abs(un_j_km1))*h_j_km1
                hwn = 0.5*(un_j_km1-abs(un_j_km1))*h_j_k
                huw = hwp+hwn
                hnp = 0.5*(vn_j_k+abs(vn_j_k))*h_j_k
                hnn = 0.5*(vn_j_k-abs(vn_j_k))*h_jp1_k
                hvn = hnp+hnn
                hsp = 0.5*(vn_jm1_k+abs(vn_jm1_k))*h_jm1_k
                hsn = 0.5*(vn_jm1_k-abs(vn_jm1_k))*h_j_k
                hvs = hsp+hsn
                etan_j_k = eta_j_k-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
        end if
        call writePipe(dyn_2__shapiro_smart_cache__etan_j_k__pipe, etan_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(dyn_2__shapiro_smart_cache__un_j_k__pipe, un_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(dyn_2__shapiro_smart_cache__vn_j_k__pipe, vn_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine dyn_2


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"dt"),(1,"dx"),(2,"dy")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine shapiro(eps)
      integer, parameter :: nloop = 252004 
      real :: eps
      real, intent(In) :: eta_j_k
      real :: etan_jm1_k
      real :: etan_j_kp1
      real :: etan_j_k
      real :: etan_jp1_k
      real :: etan_j_km1
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real :: term1
      real :: term2
      real :: term3
      integer, intent(Out) :: wet_jm1_k
      integer, intent(Out) :: wet_j_kp1
      integer, intent(Out) :: wet_j_k
      integer, intent(Out) :: wet_jp1_k
      integer, intent(Out) :: wet_j_km1
    do index = 1, index<=nloop, 1
        call readPipe(shapiro_smart_cache__shapiro__etan_j_k__pipe, etan_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__etan_j_km1__pipe, etan_j_km1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__etan_j_kp1__pipe, etan_j_kp1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__etan_jm1_k__pipe, etan_jm1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__etan_jp1_k__pipe, etan_jp1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__un_j_k__pipe, un_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__vn_j_k__pipe, vn_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__wet_j_k__pipe, wet_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__wet_j_km1__pipe, wet_j_km1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__wet_j_kp1__pipe, wet_j_kp1)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__wet_jm1_k__pipe, wet_jm1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro_smart_cache__shapiro__wet_jp1_k__pipe, wet_jp1_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        if ((j>=1) .and. (j<=500) .and. (k>=1) .and. (k<=500)) then
                if (wet_j_k==1) then
                                term1 = (1.0-0.25*eps*(wet_j_kp1+wet_j_km1+wet_jp1_k+wet_jm1_k))*etan_j_k
                                term2 = 0.25*eps*(wet_j_kp1*etan_j_kp1+wet_j_km1*etan_j_km1)
                                term3 = 0.25*eps*(wet_jp1_k*etan_jp1_k+wet_jm1_k*etan_jm1_k)
                                eta_j_k = term1+term2+term3
                else
                                eta_j_k = etan_j_k
                end if
        end if
        call writePipe(shapiro__vernieuw__eta_j_k__pipe, eta_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(shapiro__vernieuw__un_j_k__pipe, un_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(shapiro__vernieuw__vn_j_k__pipe, vn_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine shapiro


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"eps")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------------------------------------------------------------

subroutine vernieuw(hmin)
      integer, parameter :: nloop = 252004 
      real, intent(In) :: eta_j_k
      real, intent(InOut) :: h_j_k
      real, intent(In) :: hmin
      real, intent(In) :: hzero_j_k
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, intent(Out) :: u_j_k
      real, intent(InOut) :: un_j_k
      real, intent(Out) :: v_j_k
      real, intent(InOut) :: vn_j_k
      integer, intent(Out) :: wet_j_k
    do index = 1, index<=nloop, 1
        call readPipe(shapiro__vernieuw__eta_j_k__pipe, eta_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(vernieuw_h_j_k_reader__vernieuw__h_j_k__pipe, h_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(vernieuw_hzero_j_k_reader__vernieuw__hzero_j_k__pipe, hzero_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro__vernieuw__un_j_k__pipe, un_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call readPipe(shapiro__vernieuw__vn_j_k__pipe, vn_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        h_j_k = hzero_j_k+eta_j_k
        wet_j_k = 1
        if (h_j_k<hmin) then
                wet_j_k = 0
        end if
        u_j_k = un_j_k
        v_j_k = vn_j_k
        call writePipe(vernieuw__vernieuw_output_writer__h_j_k__pipe, h_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(vernieuw__vernieuw_output_writer__u_j_k__pipe, u_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(vernieuw__vernieuw_output_writer__v_j_k__pipe, v_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
        call writePipe(vernieuw__vernieuw_output_writer__wet_j_k__pipe, wet_j_k)
        call memFence(CLK_CHANNEL_MEM_FENCE)
    end do
end subroutine vernieuw


--------------------------------------------------------------------------------

KCD {argPositions = [(0,"hmin")]}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

