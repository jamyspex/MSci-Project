
================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	dyn
	vernieuw
	shapiro
File containing main subroutine: 
	main.f95
Source directory:
	./Shallow-Water-2D
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: 
CPP Excludes:

Parsing ./Shallow-Water-2D/main.f95
Parsing ./Shallow-Water-2D/dyn.f95
Parsing ./Shallow-Water-2D/init.f95
Parsing ./Shallow-Water-2D/shapiro.f95
Parsing ./Shallow-Water-2D/vernieuw.f95

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines not for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: init
Filename: ./Shallow-Water-2D/init.f95
Source:
subroutine init(hmin,dx,dy,dt,g,j,k,hzero,eta,etan,h,wet,u,un,v,vn)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real, intent(InOut) :: hmin
      real, intent(Out) :: dx
      real, intent(Out) :: dy
      real, intent(Out) :: dt
      real, intent(Out) :: g
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: eta
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: etan
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: vn
    hmin = 0.05
    dx = 10.0
    dy = 10.0
    dt = 0.1
    g = 9.81
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                hzero(j,k) = 10.0
        end do
    end do
    do k = 0, nx+1, 1
        hzero(0,k) = -10.0
        hzero(ny+1,k) = -10.0
    end do
    do j = 0, ny+1, 1
        hzero(j,0) = -10.0
        hzero(j,nx+1) = -10.0
    end do
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                eta(j,k) = -min(0.0,hzero(j,k))
                etan(j,k) = eta(j,k)
        end do
    end do
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                h(j,k) = hzero(j,k)+eta(j,k)
                wet(j,k) = 1
                if (h(j,k)<hmin) then
                                wet(j,k) = 0
                end if
                u(j,k) = 0.
                un(j,k) = 0.
                v(j,k) = 0.
                vn(j,k) = 0.
        end do
    end do
end subroutine init

Argument translations:

This subroutine will not be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")

end program wave2d
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	init->
	    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn
Filename: ./Shallow-Water-2D/dyn.f95
Source:
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
    do j = 1, ny, 1
        do k = 1, nx, 1
                du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
                dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                un(j,k) = 0.0
                uu = u(j,k)
                duu = du(j,k)
                if (wet(j,k)==1) then
                                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                else
                                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                end if
                vv = v(j,k)
                dvv = dv(j,k)
                vn(j,k) = 0.0
                if (wet(j,k)==1) then
                                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                else
                                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                end if
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
                hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
                hue = hep+hen
                hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
                hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
                huw = hwp+hwn
                hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
                hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
                hvn = hnp+hnn
                hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
                hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
                hvs = hsp+hsn
                etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
        end do
    end do
end subroutine dyn

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: shapiro
Filename: ./Shallow-Water-2D/shapiro.f95
Source:
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
    do j = 1, ny, 1
        do k = 1, nx, 1
                if (wet(j,k)==1) then
                                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                                eta(j,k) = term1+term2+term3
                else
                                eta(j,k) = etan(j,k)
                end if
        end do
    end do
end subroutine shapiro

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: vernieuw
Filename: ./Shallow-Water-2D/vernieuw.f95
Source:
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                h(j,k) = hzero(j,k)+eta(j,k)
                wet(j,k) = 1
                if (h(j,k)<hmin) then
                                wet(j,k) = 0
                end if
                u(j,k) = un(j,k)
                v(j,k) = vn(j,k)
        end do
    end do
end subroutine vernieuw

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Subroutines for offload merged 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
module module_dyn_shapiro_vernieuw_merged
contains
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:ny+1,0:nx+1) :: du
      real :: duu
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      integer :: j
      integer :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real :: uu
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
    do j = 1, ny, 1
        do k = 1, nx, 1
                du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
                dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                un(j,k) = 0.0
                uu = u(j,k)
                duu = du(j,k)
                if (wet(j,k)==1) then
                                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                else
                                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                end if
                vv = v(j,k)
                dvv = dv(j,k)
                vn(j,k) = 0.0
                if (wet(j,k)==1) then
                                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                else
                                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                end if
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
                hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
                hue = hep+hen
                hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
                hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
                huw = hwp+hwn
                hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
                hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
                hvn = hnp+hnn
                hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
                hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
                hvs = hsp+hsn
                etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                if (wet(j,k)==1) then
                                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                                eta(j,k) = term1+term2+term3
                else
                                eta(j,k) = etan(j,k)
                end if
        end do
    end do
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                h(j,k) = hzero(j,k)+eta(j,k)
                wet(j,k) = 1
                if (h(j,k)<hmin) then
                                wet(j,k) = 0
                end if
                u(j,k) = un(j,k)
                v(j,k) = vn(j,k)
        end do
    end do
end subroutine dyn_shapiro_vernieuw_merged

end module module_dyn_shapiro_vernieuw_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: wave2d
Filename: ./Shallow-Water-2D/main.f95
Source:
program wave2d
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1) :: h
      real :: hmin
      real, dimension(0:ny+1,0:nx+1) :: hzero
      integer :: j
      integer :: k
      real, dimension(0:ny+1,0:nx+1) :: u
      real, dimension(0:ny+1,0:nx+1) :: un
      real, dimension(0:ny+1,0:nx+1) :: v
      real, dimension(0:ny+1,0:nx+1) :: vn
      integer, dimension(0:ny+1,0:nx+1) :: wet
      real :: hmax
      real :: time
      real :: dtmax
      real :: c
      real :: lambda
      integer :: n
      integer :: ntot
      integer :: nout
      integer :: dummy
    ntot = 10000
    eps = 0.05
    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
    open(90, file='debug.dat', form='formatted')
    open(10, file='eta0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
    end do
    close(10)
    open(10, file='h0.dat', form='formatted')
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(hzero(j,k), k = 0, nx+1)
    end do
    close(10)
    hmax = 0.
    do j = 1, ny, 1
        do k = 1, nx, 1
                hmax = max(hmax,h(j,k))
        end do
    end do
    dummy = 0
    c = sqrt(2*g*hmax)
    write(6, *)("c = ", c)
    lambda = dt*sqrt(g*hmax)/min(dx,dy)
    write(6, *)("lambda = ", lambda)
    if (lambda>1) then
        write(6, *)("This will not work. Do you know why?")
        stop 
    end if
    open(10, file='eta.dat', form='formatted')
    open(20, file='h.dat', form='formatted')
    open(30, file='u.dat', form='formatted')
    open(40, file='v.dat', form='formatted')
    do j = 26, 26, 1
        do k = 26, 26, 1
                eta(j,k) = 1.0
        end do
    end do
    do n = 1, ntot, 1
        time = REAL(n)*dt
        call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
        call shapiro(j, k, wet, etan, eps, eta)
        call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
    end do
    do j = 0, ny+1, 1
        write(10, '(101F12.6)')(eta(j,k), k = 0, nx+1)
        write(20, '(101F12.6)')(h(j,k), k = 0, nx+1)
        write(30, '(101F12.6)')(u(j,k), k = 0, nx+1)
        write(40, '(101F12.6)')(v(j,k), k = 0, nx+1)
    end do
    write(6, *)("Data output at time = ", time/60.0, " min")

end program wave2d
Argument translations:
	dyn->
	    call dyn(j, k, dx, g, eta, dt, dy, un, u, wet, v, vn, h, etan)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	init->
	    call init(hmin, dx, dy, dt, g, j, k, hzero, eta, etan, h, wet, u, un, v, vn)
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	shapiro->
	    call shapiro(j, k, wet, etan, eps, eta)
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	vernieuw->
	    call vernieuw(dt, dx, dy, eps, eta, etan, g, h, hmin, hzero, j, k, u, un, v, vn, wet)
	ArgTrans {parameter = ArgName (fromList []) "dt", argument = VarName (fromList []) "dt"}
	ArgTrans {parameter = ArgName (fromList []) "dx", argument = VarName (fromList []) "dx"}
	ArgTrans {parameter = ArgName (fromList []) "dy", argument = VarName (fromList []) "dy"}
	ArgTrans {parameter = ArgName (fromList []) "eps", argument = VarName (fromList []) "eps"}
	ArgTrans {parameter = ArgName (fromList []) "eta", argument = VarName (fromList []) "eta"}
	ArgTrans {parameter = ArgName (fromList []) "etan", argument = VarName (fromList []) "etan"}
	ArgTrans {parameter = ArgName (fromList []) "g", argument = VarName (fromList []) "g"}
	ArgTrans {parameter = ArgName (fromList []) "h", argument = VarName (fromList []) "h"}
	ArgTrans {parameter = ArgName (fromList []) "hmin", argument = VarName (fromList []) "hmin"}
	ArgTrans {parameter = ArgName (fromList []) "hzero", argument = VarName (fromList []) "hzero"}
	ArgTrans {parameter = ArgName (fromList []) "j", argument = VarName (fromList []) "j"}
	ArgTrans {parameter = ArgName (fromList []) "k", argument = VarName (fromList []) "k"}
	ArgTrans {parameter = ArgName (fromList []) "u", argument = VarName (fromList []) "u"}
	ArgTrans {parameter = ArgName (fromList []) "un", argument = VarName (fromList []) "un"}
	ArgTrans {parameter = ArgName (fromList []) "v", argument = VarName (fromList []) "v"}
	ArgTrans {parameter = ArgName (fromList []) "vn", argument = VarName (fromList []) "vn"}
	ArgTrans {parameter = ArgName (fromList []) "wet", argument = VarName (fromList []) "wet"}

This subroutine will not be offloaded to the FPGA
================================================================================


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Map Detection 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

================================================================================
Subroutine name: dyn_shapiro_vernieuw_merged
Filename: 
Source:
module module_dyn_shapiro_vernieuw_merged
contains
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:ny+1,0:nx+1) :: du
      real :: duu
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      integer :: j
      integer :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real :: uu
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    }
    }
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(k,1,500.0,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    }
    }
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(k,1,500.0,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
    }
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
    }
! OpenCLMap ( ["hzero","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
    }
end subroutine dyn_shapiro_vernieuw_merged

end module module_dyn_shapiro_vernieuw_merged
Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================



--------------------------------------------------------------------------------
dyn_shapiro_vernieuw_merged
--------------------------------------------------------------------------------
module module_dyn_shapiro_vernieuw_merged
contains
subroutine dyn_shapiro_vernieuw_merged(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real, dimension(0:ny+1,0:nx+1) :: du
      real :: duu
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: dvv
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real :: hen
      real :: hep
      real, intent(In) :: hmin
      real :: hnn
      real :: hnp
      real :: hsn
      real :: hsp
      real :: hue
      real :: huw
      real :: hvn
      real :: hvs
      real :: hwn
      real :: hwp
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      integer :: j
      integer :: k
      real :: term1
      real :: term2
      real :: term3
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real :: uu
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real :: vv
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    }
    }
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(k,1,500.0,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    }
    }
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(k,1,500.0,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
    }
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
    }
! OpenCLMap ( ["hzero","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
    }
end subroutine dyn_shapiro_vernieuw_merged

end module module_dyn_shapiro_vernieuw_merged
--------------------------------------------------------------------------------

Array {varName = VarName (fromList []) "du", arrDimensions = 2}
Array {varName = VarName (fromList []) "dv", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "eta", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "etan", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "h", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "hzero", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "u", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "un", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "v", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "vn", arrDimensions = 2}
Array {varName = VarName (fromList [("msak",[])]) "wet", arrDimensions = 2}


----------------------------------
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    }
    }
Stencil (fromList []) 2 3 [[1,0],[0,0],[0,1]] (VarName (fromList [("msak",[])]) "eta")

----------------------------------
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    }

----------------------------------
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(k,1,500.0,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    }
    }
Stencil (fromList []) 2 3 [[1,0],[0,0],[0,1]] (VarName (fromList [("msak",[])]) "wet")

----------------------------------
! OpenCLMap ( ["u","du","wet","v","dv"],[],["(k,1,500.0,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    }

----------------------------------
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(k,1,500.0,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
    }
Stencil (fromList []) 2 5 [[1,0],[0,0],[0,1],[0,-1],[-1,0]] (VarName (fromList [("msak",[])]) "h")
Stencil (fromList []) 2 2 [[0,0],[0,-1]] (VarName (fromList [("msak",[])]) "un")
Stencil (fromList []) 2 2 [[0,0],[-1,0]] (VarName (fromList [("msak",[])]) "vn")

----------------------------------
! OpenCLMap ( ["h","eta","dt","dx","dy"],[],["(k,1,500.0,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }

----------------------------------
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
    }
Stencil (fromList []) 2 5 [[1,0],[0,0],[0,1],[0,-1],[-1,0]] (VarName (fromList [("msak",[])]) "etan")
Stencil (fromList []) 2 5 [[1,0],[0,0],[0,1],[0,-1],[-1,0]] (VarName (fromList [("msak",[])]) "wet")

----------------------------------
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }

----------------------------------
! OpenCLMap ( ["hzero","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
    }

----------------------------------
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }

