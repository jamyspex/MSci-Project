
================================================================================
F4: Finite-element Fortran for FPGAs
This compiler allows Fortran finite element codes to be compiled
for execution on FPGA devices via OpenCL
================================================================================

The following command line values were parsed:

Files with subroutines to be parallelised:
	vernieuw
	dyn
	shapiro
File containing main subroutine: 
	main.f95
Source directory:
	./Shallow-Water-2D/
Fixed form: False
Loop fusion bound: Nothing
CPP Defines: asdf, asdf, adfa=asfdasf, 
CPP Excludes:

Parsing ./Shallow-Water-2D/main.f95
Parsing ./Shallow-Water-2D/dyn.f95
Parsing ./Shallow-Water-2D/init.f95
Parsing ./Shallow-Water-2D/shapiro.f95
Parsing ./Shallow-Water-2D/vernieuw.f95
================================================================================
Subroutine name: dyn
Filename: ./Shallow-Water-2D/dyn.f95
AST:
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
    do j = 1, ny, 1
        do k = 1, nx, 1
                du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
                dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                un(j,k) = 0.0
                uu = u(j,k)
                duu = du(j,k)
                if (wet(j,k)==1) then
                                if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                else
                                if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                                                                un(j,k) = uu+duu
                                end if
                end if
                vv = v(j,k)
                dvv = dv(j,k)
                vn(j,k) = 0.0
                if (wet(j,k)==1) then
                                if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                else
                                if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                                                                vn(j,k) = vv+dvv
                                end if
                end if
        end do
    end do
    do j = 1, ny, 1
        do k = 1, nx, 1
                hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
                hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
                hue = hep+hen
                hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
                hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
                huw = hwp+hwn
                hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
                hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
                hvn = hnp+hnn
                hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
                hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
                hvs = hsp+hsn
                etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
        end do
    end do
end subroutine dyn

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: shapiro
Filename: ./Shallow-Water-2D/shapiro.f95
AST:
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
    do j = 1, ny, 1
        do k = 1, nx, 1
                if (wet(j,k)==1) then
                                term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
                                term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
                                term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
                                eta(j,k) = term1+term2+term3
                else
                                eta(j,k) = etan(j,k)
                end if
        end do
    end do
end subroutine shapiro

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================

================================================================================
Subroutine name: vernieuw
Filename: ./Shallow-Water-2D/vernieuw.f95
AST:
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
    do j = 0, ny+1, 1
        do k = 0, nx+1, 1
                h(j,k) = hzero(j,k)+eta(j,k)
                wet(j,k) = 1
                if (h(j,k)<hmin) then
                                wet(j,k) = 0
                end if
                u(j,k) = un(j,k)
                v(j,k) = vn(j,k)
        end do
    end do
end subroutine vernieuw

Argument translations:

This subroutine will be offloaded to the FPGA
================================================================================



--------------------------------------------------------------------------------
dyn
--------------------------------------------------------------------------------
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    }
    }
! OpenCLMap ( ["u","du","wet","v","dv"],["un","vn"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["j","u","du","wet","v","dv"],["un","vn"],["(k,1,500.0,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    }
    }
! OpenCLMap ( ["h","eta","dt","dx","dy"],["etan"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["j","h","eta","dt","dx","dy"],["etan"],["(k,1,500.0,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
    }
end subroutine dyn

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
shapiro
--------------------------------------------------------------------------------
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["wet","j","etan","eps"],["eta"],["(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
    }
end subroutine shapiro

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
vernieuw
--------------------------------------------------------------------------------
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
! OpenCLMap ( ["j","hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
    }
end subroutine vernieuw

--------------------------------------------------------------------------------


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Combined 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



--------------------------------------------------------------------------------
dyn
--------------------------------------------------------------------------------
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
! OpenCLMap ( ["dt","g","dx","dy","u","du","wet","v","dv","j","h","eta"],["du","dv","un","vn","etan"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
end subroutine dyn

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
shapiro
--------------------------------------------------------------------------------
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
! OpenCLMap ( ["wet","etan","eps","j"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
end subroutine shapiro

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
vernieuw
--------------------------------------------------------------------------------
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn","j"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
end subroutine vernieuw

--------------------------------------------------------------------------------

