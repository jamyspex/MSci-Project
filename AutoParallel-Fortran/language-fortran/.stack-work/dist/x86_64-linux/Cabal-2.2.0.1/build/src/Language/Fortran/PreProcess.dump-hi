
==================== FINAL INTERFACE ====================
2018-10-16 11:47:22.276375382 UTC

interface language-fortran-0.3-DnTmLOXLSgMntUzwJ6Kf9:Language.Fortran.PreProcess 8043
  interface hash: 7389e6d3e5d53960ce8a71c9a29a9570
  ABI hash: b76c8713a953cb7f78c5e60c26b27dd0
  export-list hash: 43e7e9abb13dc03506eec68a49699a4b
  orphan hash: 8717997d9b07c7ec85ae80a86a9ce187
  flag hash: 64c1b7834bba40ce99ae7f275201cdad
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.Fortran.PreProcess.parseExpr
  Language.Fortran.PreProcess.pre_process
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0* binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 mtl-2.2.2 parsec-3.1.13.0
                      text-1.2.3.1 transformers-0.5.5.0
orphans: text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.Environment 7fdede11f96719870569cb0da1adac2f
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  parsec-3.1.13.0:Text.Parsec.Char 18e237b7b07beae07475d25f068850cc
import  -/  parsec-3.1.13.0:Text.Parsec.Combinator a9dbf5e1d9693551a5b146ee71dced08
import  -/  parsec-3.1.13.0:Text.Parsec.Pos e50c2afab99d3b473a1dba0ba039aace
import  -/  parsec-3.1.13.0:Text.Parsec.Prim 87b017e30237d731dcc4071aa883ba1c
import  -/  parsec-3.1.13.0:Text.ParserCombinators.Parsec c715a7d4123ce693b60b6632ae019dc5
import  -/  parsec-3.1.13.0:Text.ParserCombinators.Parsec.Prim 53f5e1ef82ea1a66eecf3ad5989b29b2
10dd46a679a0974f0efe38192769a5f7
  $s$fEqMaybe :: GHC.Classes.Eq (GHC.Base.Maybe [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [GHC.Types.Char])
                  (\ (ds :: GHC.Base.Maybe [GHC.Types.Char])
                     (ds1 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1 -> GHC.Base.eqString a1 b1 } })
                  Language.Fortran.PreProcess.$s$fEqMaybe_$s$fEqMaybe_$c/= -}
90f62fc7f8cba52537a2196c70c28855
  $s$fEqMaybe_$c== ::
    GHC.Base.Maybe [GHC.Types.Char]
    -> GHC.Base.Maybe [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe [GHC.Types.Char])
                   (ds1 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Base.eqString a1 b1 } }) -}
561fb7400f0ebdc5d6911dea84d30481
  $s$fEqMaybe_$s$fEqMaybe_$c/= ::
    GHC.Base.Maybe [GHC.Types.Char]
    -> GHC.Base.Maybe [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: GHC.Base.Maybe [GHC.Types.Char])
                   (y :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x2 of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
cee14b7513836852a6ff508d74c13a8d
  $s$fStream[]mtok ::
    Text.Parsec.Prim.Stream [tok] Data.Functor.Identity.Identity tok
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ tok.
                  @ [tok]
                  @ Data.Functor.Identity.Identity
                  @ tok
                  Data.Functor.Identity.$fMonadIdentity
                  (Language.Fortran.PreProcess.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
                     @ tok) -}
1fad0dddeba4552b2f99926c805d475c
  $s$fStream[]mtok_$s$fStream[]mtok_$cuncons ::
    [tok]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok]))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ tok (ds :: [tok]) ->
                 case ds of wild {
                   []
                   -> (GHC.Base.Nothing @ (tok, [tok]))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe (tok, [tok])>_R))
                   : t ts
                   -> (GHC.Base.Just @ (tok, [tok]) (t, ts))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe (tok, [tok])>_R)) }) -}
24961c918fb19ab8ce98ddce8f6355b5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.Fortran.PreProcess.$trModule3
                   Language.Fortran.PreProcess.$trModule1) -}
404cf33c3e765ddd24dc389061c7abd9
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.PreProcess.$trModule2) -}
e648e7e516c321d36f3a73eaa337293e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.Fortran.PreProcess"#) -}
70fdf70bf4566b17b37b4cb541e40d65
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.PreProcess.$trModule4) -}
d67e61e3876adf583eac54d906c0f5b7
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("language-fortran-0.3-DnTmLOXLSgMntUzwJ6Kf9"#) -}
37734e426e90be1115cc6135a987d3ec
  parseExpr :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (file :: GHC.Base.String)
                   (input :: GHC.Base.String) ->
                 case (Text.Parsec.Prim.runPT
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ GHC.Types.Int
                         @ [GHC.Types.Char]
                         (Text.ParserCombinators.Parsec.Prim.$s$fStream[]mtok
                            @ GHC.Types.Char)
                         (\ @ b1
                            (s1 :: Text.Parsec.Prim.State
                                     [GHC.Types.Char] GHC.Types.Int)[OneShot]
                            (cok :: [GHC.Types.Char]
                                    -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                    -> Text.Parsec.Error.ParseError
                                    -> Data.Functor.Identity.Identity b1)[OneShot]
                            (cerr :: Text.Parsec.Error.ParseError
                                     -> Data.Functor.Identity.Identity b1)[OneShot]
                            (eok :: [GHC.Types.Char]
                                    -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                    -> Text.Parsec.Error.ParseError
                                    -> Data.Functor.Identity.Identity b1)[OneShot]
                            (eerr :: Text.Parsec.Error.ParseError
                                     -> Data.Functor.Identity.Identity b1)[OneShot] ->
                          let {
                            err :: Text.Parsec.Error.ParseError
                            = case s1 of wild { Text.Parsec.Prim.State ds ds1 ds2 ->
                              case ds1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                              case GHC.Classes.$fOrd[]_$s$ccompare1 ww4 ww4 of wild1 {
                                DEFAULT
                                -> Text.Parsec.Error.ParseError
                                     ww3
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)
                                GHC.Types.EQ
                                -> Text.Parsec.Error.ParseError
                                     ww3
                                     Text.Parsec.Prim.$fMonadReaderrParsecT2 } } }
                          } in
                          Text.Parsec.Prim.$fApplicativeParsecT2
                            @ [GHC.Types.Char]
                            @ GHC.Types.Int
                            @ Data.Functor.Identity.Identity
                            @ ()
                            @ [GHC.Types.Char]
                            (\ @ b
                               (w2 :: Text.Parsec.Prim.State
                                        [GHC.Types.Char] GHC.Types.Int)[OneShot]
                               (w3 :: ()
                                      -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                      -> Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot]
                               (w4 :: Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot]
                               (w5 :: ()
                                      -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                      -> Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot]
                               (w6 :: Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot] ->
                             Text.Parsec.Prim.$wsetPosition
                               @ Data.Functor.Identity.Identity
                               @ [GHC.Types.Char]
                               @ GHC.Types.Int
                               (case s1 of wild { Text.Parsec.Prim.State ds ds1 ds2 ->
                                Text.Parsec.Pos.SourcePos file 1# 1# })
                               @ b
                               w2
                               w5)
                              `cast`
                            (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                      <[GHC.Types.Char]>_R
                                      <GHC.Types.Int>_R
                                      <Data.Functor.Identity.Identity>_R
                                      <()>_R))
                            Language.Fortran.PreProcess.parseExpr2
                              `cast`
                            (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                      <[GHC.Types.Char]>_R
                                      <GHC.Types.Int>_R
                                      <Data.Functor.Identity.Identity>_R
                                      <[GHC.Types.Char]>_R))
                            @ b1
                            s1
                            cok
                            cerr
                            (\ (x2 :: [GHC.Types.Char])
                               (s3 :: Text.Parsec.Prim.State
                                        [GHC.Types.Char] GHC.Types.Int)[OneShot]
                               (err' :: Text.Parsec.Error.ParseError)[OneShot] ->
                             eok x2 s3 (Text.Parsec.Error.mergeError err err'))
                            (\ (err' :: Text.Parsec.Error.ParseError) ->
                             eerr (Text.Parsec.Error.mergeError err err')))
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <GHC.Types.Int>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Char]>_R))
                         Language.Fortran.PreProcess.parseExpr1
                         (GHC.Types.[] @ GHC.Types.Char)
                         input)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError [GHC.Types.Char]>_R) of wild {
                   Data.Either.Left err -> GHC.Types.[] @ GHC.Types.Char
                   Data.Either.Right x2 -> x2 }) -}
0f5cbe035b8dc59da02d364c34ae5ea1
  parseExpr1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
ab118ee041644927b9465e4802ee089d
  parseExpr2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Unfolding: (Language.Fortran.PreProcess.parseExpr3
                   (GHC.Types.[] @ (GHC.Base.Maybe [GHC.Types.Char]))) -}
7f97b82272b86c8e24007011c7e66af6
  parseExpr3 ::
    [GHC.Base.Maybe [GHC.Types.Char]]
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
       -> ([GHC.Types.Char]
           -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([GHC.Types.Char]
           -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (labels :: [GHC.Base.Maybe [GHC.Types.Char]]) ->
                 Language.Fortran.PreProcess.parseExpr6
                   @ GHC.Types.Char
                   @ GHC.Types.Int
                   @ GHC.Types.Char
                   Language.Fortran.PreProcess.parseExpr5
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <GHC.Types.Int>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (let {
                      p1 :: Text.Parsec.Prim.ParsecT
                              [GHC.Types.Char]
                              GHC.Types.Int
                              Data.Functor.Identity.Identity
                              [GHC.Types.Char]
                      = case labels of wild {
                          []
                          -> Language.Fortran.PreProcess.parseExpr4
                               `cast`
                             (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                       <[GHC.Types.Char]>_R
                                       <GHC.Types.Int>_R
                                       <Data.Functor.Identity.Identity>_R
                                       <[GHC.Types.Char]>_R))
                          : ds1 ds2
                          -> Language.Fortran.PreProcess.parseExpr_end_or_start_do wild }
                    } in
                    (\ @ b
                       (s1 :: Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int)
                       (cok :: [GHC.Types.Char]
                               -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b)
                       (ds :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b)
                       (eok :: [GHC.Types.Char]
                               -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b)
                       (eerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b) ->
                     p1
                       `cast`
                     (Text.Parsec.Prim.N:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <GHC.Types.Int>_R
                          <Data.Functor.Identity.Identity>_R
                          <[GHC.Types.Char]>_R)
                       @ b
                       s1
                       cok
                       eerr
                       eok
                       eerr)
                      `cast`
                    (Sym (Text.Parsec.Prim.N:ParsecT[0]
                              <[GHC.Types.Char]>_R
                              <GHC.Types.Int>_R
                              <Data.Functor.Identity.Identity>_R
                              <[GHC.Types.Char]>_R)))) -}
dd202150064f94cc2ad899b3b00be55a
  parseExpr4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)> -}
5ee703bbf0e918706d8b79aaef7003e0
  parseExpr5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LS(LSS)S),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta :: Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int)
                   (eta1 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta2 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 case eta of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wsatisfy
                   @ [GHC.Types.Char]
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Int
                   (Language.Fortran.PreProcess.$s$fStream[]mtok @ GHC.Types.Char)
                   Text.Parsec.Char.anyChar2
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   eta1
                   eta4 } }) -}
b37f9a2c02ca7e206432479a8a9a5dfb
  parseExpr6 ::
    Text.Parsec.Prim.ParsecT [tok] u Data.Functor.Identity.Identity a
    -> Text.Parsec.String.GenParser tok u [a]
    -> forall b.
       Text.Parsec.Prim.State [tok] u
       -> ([a]
           -> Text.Parsec.Prim.State [tok] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State [tok] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(U)> -}
832f993d9c6140498332d0e262b4d7bd
  parseExpr_end_or_start_do ::
    [GHC.Base.Maybe [GHC.Types.Char]]
    -> Text.Parsec.String.GenParser
         GHC.Types.Char GHC.Types.Int [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,U> -}
2088dfb062c4d68174fd47de79761b5c
  pre_process :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (Language.Fortran.PreProcess.parseExpr
                   (GHC.Types.[] @ GHC.Types.Char)) -}
"SPEC/Language.Fortran.PreProcess $fEqMaybe @ [Char]" [orphan] forall (v :: GHC.Classes.Eq
                                                                              [GHC.Types.Char])
  GHC.Base.$fEqMaybe @ [GHC.Types.Char] v
  = Language.Fortran.PreProcess.$s$fEqMaybe
"SPEC/Language.Fortran.PreProcess $fEqMaybe_$c/= @ [Char]" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                      [GHC.Types.Char])
  GHC.Base.$fEqMaybe_$c/= @ [GHC.Types.Char] $dEq
  = Language.Fortran.PreProcess.$s$fEqMaybe_$s$fEqMaybe_$c/=
"SPEC/Language.Fortran.PreProcess $fEqMaybe_$c== @ [Char]" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                      [GHC.Types.Char])
  GHC.Base.$fEqMaybe_$c== @ [GHC.Types.Char] $dEq
  = Language.Fortran.PreProcess.$s$fEqMaybe_$c==
"SPEC/Language.Fortran.PreProcess $fStream[]mtok @ Identity _" [orphan] forall @ tok
                                                                               (v :: GHC.Base.Monad
                                                                                       Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok @ Data.Functor.Identity.Identity
                                  @ tok
                                  v
  = Language.Fortran.PreProcess.$s$fStream[]mtok @ tok
"SPEC/Language.Fortran.PreProcess $fStream[]mtok_$cuncons @ Identity _" [orphan] forall @ tok
                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                      Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cuncons @ Data.Functor.Identity.Identity
                                           @ tok
                                           $dMonad
  = Language.Fortran.PreProcess.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
      @ tok
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

