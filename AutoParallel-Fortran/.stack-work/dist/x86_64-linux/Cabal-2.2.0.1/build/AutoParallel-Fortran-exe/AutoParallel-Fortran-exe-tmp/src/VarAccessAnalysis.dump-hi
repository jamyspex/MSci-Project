
==================== FINAL INTERFACE ====================
2018-11-16 12:45:15.664845567 UTC

interface main:VarAccessAnalysis 8043
  interface hash: f27c896c363a6c1a7f054dcc8e6e71ba
  ABI hash: 53752df4324502d602d68f0512d6b3c9
  export-list hash: 7d36a7dfcc704fd9b4303a1ab3c7be89
  orphan hash: 8077d2f6b6b201193c8b3274c44e2e2c
  flag hash: 7853c119b27f3f568e863cba4679c19c
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  F95IntrinsicFunctions.f95IntrinsicFunctions
  VarAccessAnalysis.analyseAllVarAccess
  VarAccessAnalysis.analyseAllVarAccess_progUnit
  VarAccessAnalysis.collectVarNames
  VarAccessAnalysis.getAccessLocationsAfterSrcSpan
  VarAccessAnalysis.getAccessLocationsBeforeSrcSpan
  VarAccessAnalysis.getAccessLocationsInsideSrcSpan
  VarAccessAnalysis.getAccessesBetweenSrcSpans
  VarAccessAnalysis.getAccessesBetweenSrcSpansIgnore
  VarAccessAnalysis.getArguments
  VarAccessAnalysis.getDeclaredVarNames
  VarAccessAnalysis.getNonTempVars
  VarAccessAnalysis.getPrexistingVars
  VarAccessAnalysis.getValueAtSrcSpan
  VarAccessAnalysis.isFunctionCall
  VarAccessAnalysis.VarAccessAnalysis
module dependencies: F95IntrinsicFunctions Language.Fortran
                     Language.Fortran.Lexer Language.Fortran.Parser
                     Language.Fortran.PreProcess LanguageFortranTools PreProcessor
                     Warning
package dependencies: array-0.5.2.0 base-4.11.1.0 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      directory-1.3.1.5 filepath-1.4.2 ghc-prim-0.5.2.0
                      haskell-src-1.0.3.0 integer-gmp-1.0.2.0 mtl-2.2.2 parsec-3.1.13.0
                      process-1.6.3.0 syb-0.7 text-1.2.3.1 time-1.8.0.2
                      transformers-0.5.5.0 unix-2.7.2.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         syb-0.7:Data.Generics.Instances base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
import  -/  base-4.11.1.0:Data.Char 3e89818e2b8ef1a2cc5393163484da72
import  -/  base-4.11.1.0:Data.Data b150502d549600eff3202c16ff6cf22d
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  containers-0.5.11.0:Data.Map f51b9cf04edd738eb6d014be576b3403
import  -/  containers-0.5.11.0:Data.Map.Internal e02d23495520de11b8e9f3c9c93a4d11
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  F95IntrinsicFunctions 2a2dc1d4915ed7b9c5e736fba48a3676
  exports: a9e028fabd4d7137fc009fef93c07a09
  f95IntrinsicFunctions 79f039953e6ee977de902fe8df3b89c4
import  -/  Language.Fortran e2add56600673959dbdfe1ac093795c9
  exports: 6ca1e7b188145fc0c602707ea4a1c428
  Arg 2ecf4bb24a966e219012eee596c45ea8
  ArgName 9acaf710a8bc920f63e26e943ae5d9fe
  ArgName 7dbcccb83ec422e5f4dcc4667e1f64fb
  Assg c3a5a5c7c0380c697e6a5cda4cc060bd
  Block d58adfcbfbefac7829b419bc0d801569
  Block c8f6dc9d55c3b3cbc94e3fb30057f310
  Call ecfba85593faf88229821091dac9ee3b
  Decl bf5604fd57dfb9f698111c9b30ee5605
  Decl e30f41d3f2effdd4b4a22fa8cf8c0055
  Expr 6304956f2901eead56a8fac1e90d4904
  Fortran cab0cd6287333175c6b9d87427982518
  If 70f325448a0ac0d3e601c0f9e1e99ec6
  Null 1580fcfff05ff5fc8ac22a76d8ac4e12
  NullExpr adfc15f00ad4bfbe033d167983c94995
  ProgUnit 573fa2fe80c5713ab0c018712ac118d8
  Program 607f4435fb994a8c5b83bd9f7709b3c3
  SrcLoc af6592465c21031ac12547ec948ff586
  SrcLoc 46c6d78d8d8ad90615ee6b6136237ffd
  SrcSpan 667dadf32292a4602702274000a648d8
  VarName a39ab087efdb6eba24247b07097f591c
  VarName 361ec85699986b0b7f4d68a05374d64d
  srcSpan c13b4efea655d094fcf2aa6fb6fdfaaf
import  -/  Language.Fortran.Parser 94f87e312918e2e0d84323268977b8af
  exports: 811e5416839040be903a08c9e7bce6b9
import  -/  LanguageFortranTools 737e8abc5de089abcd0ce62660f9d159
  exports: a5a994dcb8ba92c93a8a354a063275b0
  Anno 1420203ed9c39fcf982d2ff37c01ae68
  appendToMap 77a73b9bc695373ab2fcd5b66619a1a4
  checkSrcLocBefore e60527f39c486756f2c7f90a90e6c660
  checkSrcSpanAfter fa8dc93cd7f3d507f6e84c6e36c68aed
  checkSrcSpanBefore 5147f615e784e745818778fbeb5abdf7
  checkSrcSpanBefore_line f92e64a1107f1ea3da20018cf98eb008
  combineMaps 7a416190dd312c66ab0c5e1e6c977d9b
  extractContainedVars 767cae289da3c9031018929f0cd15574
  extractExpr a8c78e7bfc32415d9f59def6fd3159c8
  extractExpr_list 6dab979ee8b8d4ff63fc85e5d8625380
  extractOperands 8fb945abeb65fded10e8824b0c525de5
  extractVarNames 920113507cf2d36f1a1834c3a88c2c59
  getEarliestSrcSpan 7f2f1226a255a2e3e291f9b34ce0c8e9
  listConcatUnique 28a5be85845b4739b6b5219484213c70
  listRemoveDuplications cc90c431c334b3429c5de18c32c0abd0
  nullAnno b5ec3f8914fec256ad2e53b761b9bd52
  nullSrcSpan d9f6701836bf1a31425d57566b44db7b
  srcSpanInSrcSpan c04e1c706b70ba96c1b0cba68a25e122
  varNameStr 4f55193896441ff99d96346c5aacd560
import  -/  Warning b5ec059e95d91647264308e84d2ed3ea
  exports: d9b5419f40dd7650497f479a7fe0214a
import  -/  syb-0.7:Data.Generics 2ddc257f9ac35414fc37ff4d19b4d388
import  -/  syb-0.7:Data.Generics.Aliases a5097c06261967df51d59247bf1d4958
import  -/  syb-0.7:Data.Generics.Schemes 58bc96c8ed0bed4ad53424f237efe8b8
b19264d15d06cc5aeea3c55ae140e048
  $s$fDataArgList ::
    Data.Data.Data
      (Language.Fortran.ArgList
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.ArgList
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ Language.Fortran.ArgList
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     Language.Fortran.$fDataArgList9
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ (Data.Map.Internal.Map [GHC.Types.Char])
                        @ [GHC.Base.String]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ Data.Map.Internal.Map
                           @ [GHC.Types.Char]
                           Data.Map.Internal.$fDataMap17
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ [GHC.Types.Char]
                           Data.Data.$fData[]3
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ArgList
                                                                       (Data.Map.Internal.Map
                                                                          GHC.Base.String
                                                                          [GHC.Base.String])>_N)
                  (Language.Fortran.$fDataArgList_$cgfoldl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgunfold
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (\ (ds :: Language.Fortran.ArgList
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   case ds of wild { Language.Fortran.ArgList ds1 ds2 ->
                   Language.Fortran.$cArgList })
                  (\ (ds :: Language.Fortran.ArgList
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   Language.Fortran.$tArgList)
                  (Language.Fortran.$fDataArgList_$cdataCast1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable1 :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.ArgList
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))))
                  (\ (ds :: forall b. Data.Data.Data b => b -> b)
                     (x0 :: Language.Fortran.ArgList
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   case x0 of wild { Language.Fortran.ArgList a1 a2 ->
                   (Language.Fortran.ArgList
                      @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                      (ds
                         @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                         VarAccessAnalysis.$s$fDataArgList_$s$fDataMap
                         a1)
                      (ds
                         @ (Language.Fortran.Expr
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                         (Language.Fortran.$fDataExpr
                            @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                            VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                         a2))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <Language.Fortran.ArgList
                                (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)) })
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ArgList
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ArgList
                               (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                  (Language.Fortran.$fDataArgList_$cgmapQl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgmapQr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgmapQ
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgmapQi
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgmapM
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgmapMp
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataArgList_$cgmapMo
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap) -}
185a5edac5783223ccf2db61dcee33d8
  $s$fDataArgList_$s$fDataMap ::
    Data.Data.Data
      (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ (Data.Map.Internal.Map [GHC.Types.Char])
                     @ [GHC.Base.String]
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ (* -> *)
                        @ Data.Map.Internal.Map
                        @ [GHC.Types.Char]
                        Data.Map.Internal.$fDataMap17
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7))
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ [GHC.Types.Char]
                        Data.Data.$fData[]3
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7)))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Data.Map.Internal.Map
                                                                       [GHC.Types.Char]
                                                                       [GHC.Base.String]>_N)
                  (Data.Map.Internal.$fDataMap_$cgfoldl
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgunfold
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (\ (ds :: Data.Map.Internal.Map
                              [GHC.Types.Char] [GHC.Base.String]) ->
                   Data.Map.Internal.fromListConstr)
                  (\ (ds :: Data.Map.Internal.Map
                              [GHC.Types.Char] [GHC.Base.String]) ->
                   Data.Map.Internal.mapDataType)
                  (\ @ t :: * -> *
                     @ c :: * -> *
                     ($dTypeable1 :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d. Data.Data.Data d => c (t d)) ->
                   GHC.Base.Nothing
                     @ (c (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])))
                  (Data.Map.Internal.$fDataMap_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap6
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]>_R)
                  (Data.Map.Internal.$fDataMap_$cgmapQl
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapQr
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapQ
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapQi
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapM
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
9c74bee84bff0902934df9dd56c2f050
  $s$fDataArgList_$s$fData[] :: Data.Data.Data [[GHC.Types.Char]]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [[GHC.Types.Char]]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[[GHC.Types.Char]]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: [[GHC.Types.Char]]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [[GHC.Types.Char]]) -> Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable1 :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c [[GHC.Types.Char]]))
                  (Data.Data.$fData[]_$cgmapT
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQr
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQ
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQi
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
d0acaf9684d7e8d2bae35a7dc09393b6
  $s$fDataMap_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe
         (c (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]))
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t :: * -> * -> *
                   @ c :: * -> *
                   (w3 :: Data.Typeable.Internal.Typeable t) ->
                 Data.Map.Internal.$w$cdataCast2
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   Data.Data.$fData[]_$s$fData[]
                   VarAccessAnalysis.$s$fDataArgList_$s$fData[]
                   @ t
                   @ c
                   w3) -}
1dafc04084429ecd76a78da2d85c9ee7
  $s$fDataProgUnit ::
    Data.Data.Data
      (Language.Fortran.ProgUnit
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.ProgUnit
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ Language.Fortran.ProgUnit
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     Language.Fortran.$fDataProgUnit6
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ (Data.Map.Internal.Map [GHC.Types.Char])
                        @ [GHC.Base.String]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ Data.Map.Internal.Map
                           @ [GHC.Types.Char]
                           Data.Map.Internal.$fDataMap17
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ [GHC.Types.Char]
                           Data.Data.$fData[]3
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ProgUnit
                                                                       (Data.Map.Internal.Map
                                                                          GHC.Base.String
                                                                          [GHC.Base.String])>_N)
                  (Language.Fortran.$fDataProgUnit_$cgfoldl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgunfold
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (\ (ds :: Language.Fortran.ProgUnit
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   case ds of wild {
                     Language.Fortran.Main ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cMain
                     Language.Fortran.Sub ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cSub
                     Language.Fortran.Function ds1 ds2 ds3 ds4 ds5 ds6 ds7
                     -> Language.Fortran.$cFunction
                     Language.Fortran.Module ds1 ds2 ds3 ds4 ds5 ds6 ds7
                     -> Language.Fortran.$cModule
                     Language.Fortran.BlockData ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cBlockData
                     Language.Fortran.PSeq ds1 ds2 ds3 ds4 -> Language.Fortran.$cPSeq
                     Language.Fortran.Prog ds1 ds2 ds3 -> Language.Fortran.$cProg
                     Language.Fortran.NullProg ds1 ds2 -> Language.Fortran.$cNullProg
                     Language.Fortran.IncludeProg ds1 ds2 ds3 ds4
                     -> Language.Fortran.$cIncludeProg })
                  (\ (ds :: Language.Fortran.ProgUnit
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   Language.Fortran.$tProgUnit)
                  (Language.Fortran.$fDataProgUnit_$cdataCast1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable1 :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.ProgUnit
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))))
                  (Language.Fortran.$fDataProgUnit1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ProgUnit
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ProgUnit
                               (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                  (Language.Fortran.$fDataProgUnit_$cgmapQl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapQr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapQ
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapQi
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapM
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapMp
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapMo
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fDataArgList_$s$fDataMap) -}
8dfe0be4d7ed795087dc7dc2f69c12e5
  $s$fData[] ::
    Data.Data.Data
      [Language.Fortran.ProgUnit LanguageFortranTools.Anno]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [Language.Fortran.ProgUnit LanguageFortranTools.Anno]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ Language.Fortran.ProgUnit
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        Language.Fortran.$fDataProgUnit6
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ (Data.Map.Internal.Map [GHC.Types.Char])
                           @ [GHC.Base.String]
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ (* -> *)
                              @ Data.Map.Internal.Map
                              @ [GHC.Types.Char]
                              Data.Map.Internal.$fDataMap17
                              (Data.Typeable.Internal.mkTrApp
                                 @ *
                                 @ *
                                 @ []
                                 @ GHC.Types.Char
                                 Data.Data.$fData[]3
                                 Data.Data.$fDataChar7))
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ [GHC.Types.Char]
                              Data.Data.$fData[]3
                              (Data.Typeable.Internal.mkTrApp
                                 @ *
                                 @ *
                                 @ []
                                 @ GHC.Types.Char
                                 Data.Data.$fData[]3
                                 Data.Data.$fDataChar7)))))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[Language.Fortran.ProgUnit
                                                                        LanguageFortranTools.Anno]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgunfold
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (\ (ds :: [Language.Fortran.ProgUnit LanguageFortranTools.Anno]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [Language.Fortran.ProgUnit LanguageFortranTools.Anno]) ->
                   Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable1 :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c [Language.Fortran.ProgUnit LanguageFortranTools.Anno]))
                  (Data.Data.$fData[]_$cgmapT
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapQl
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapQr
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapQ
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapQi
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapM
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapMp
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit)
                  (Data.Data.$fData[]_$cgmapMo
                     @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                     VarAccessAnalysis.$s$fDataProgUnit) -}
7b6661caaa68aae0ea6f4f8d293c458e
  $s$fData[]1 ::
    Data.Typeable.Internal.TypeRep
      [Language.Fortran.ProgUnit LanguageFortranTools.Anno]
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                   Data.Data.$fData[]3
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.ProgUnit
                      @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                      Language.Fortran.$fDataProgUnit6
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ *
                         @ (Data.Map.Internal.Map [GHC.Types.Char])
                         @ [GHC.Base.String]
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ (* -> *)
                            @ Data.Map.Internal.Map
                            @ [GHC.Types.Char]
                            Data.Map.Internal.$fDataMap17
                            (Data.Typeable.Internal.mkTrApp
                               @ *
                               @ *
                               @ []
                               @ GHC.Types.Char
                               Data.Data.$fData[]3
                               Data.Data.$fDataChar7))
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ [GHC.Types.Char]
                            Data.Data.$fData[]3
                            (Data.Typeable.Internal.mkTrApp
                               @ *
                               @ *
                               @ []
                               @ GHC.Types.Char
                               Data.Data.$fData[]3
                               Data.Data.$fDataChar7))))) -}
059aa3feaed200d14ba1d2b793d2878a
  $s$fData[]7 :: Data.Typeable.Internal.TypeRep [[GHC.Types.Char]]
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]3
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Types.Char
                      Data.Data.$fData[]3
                      Data.Data.$fDataChar7)) -}
d7023615550d73c4f26cf97d1264ef27
  $s$fEqExpr ::
    GHC.Classes.Eq
      (Language.Fortran.Expr
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Expr
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fEqArgList_$c==
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fEqExpr_$s$fEqMap)
                  VarAccessAnalysis.$s$fEqExpr_$s$fEqExpr_$c/= -}
e3683638a0a73985d2dca6c7cdb12bba
  $s$fEqExpr_$s$fEqExpr_$c/= ::
    Language.Fortran.Expr
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.Expr
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.Fortran.Expr
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                   (y :: Language.Fortran.Expr
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                 case Language.Fortran.$fEqArgList_$c==
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        VarAccessAnalysis.$s$fEqExpr_$s$fEqMap
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
245b4733efdabc949296c033eaef5e42
  $s$fEqExpr_$s$fEqMap ::
    GHC.Classes.Eq
      (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Map.Internal.$fEqMap_$c==
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]2)
                  VarAccessAnalysis.$s$fEqExpr_$s$fEqMap_$c/= -}
c1db7c8f504e9a042e3e858606139f92
  $s$fEqExpr_$s$fEqMap_$c/= ::
    Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                   (y :: Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]) ->
                 case Data.Map.Internal.$fEqMap_$c==
                        @ [GHC.Types.Char]
                        @ [GHC.Base.String]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        GHC.Classes.$fEq[]_$s$fEq[]2
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d26b4c3d25eda1a2c36453aff964b604
  $s$fEqVarName ::
    GHC.Classes.Eq
      (Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.VarName
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fEqVarName_$c==
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fEqExpr_$s$fEqMap)
                  VarAccessAnalysis.$s$fEqVarName_$s$fEqVarName_$c/= -}
e153619d39d00990497d156afb87866b
  $s$fEqVarName_$s$fEqVarName_$c/= ::
    Language.Fortran.VarName
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.Fortran.VarName
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                   (y :: Language.Fortran.VarName
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                 case x of wild { Language.Fortran.VarName a1 a2 ->
                 case y of wild1 { Language.Fortran.VarName b1 b2 ->
                 case Data.Map.Internal.$fEqMap_$c==
                        @ [GHC.Types.Char]
                        @ [GHC.Base.String]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        GHC.Classes.$fEq[]_$s$fEq[]2
                        a1
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
fada9ddd0ed733ee8e232bf1b78429ee
  $s$fOrdMap ::
    GHC.Classes.Ord
      (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                  VarAccessAnalysis.$s$fEqExpr_$s$fEqMap
                  (Data.Map.Internal.$fOrdMap_$ccompare
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2)
                  (Data.Map.Internal.$fOrdMap_$c<
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2)
                  (Data.Map.Internal.$fOrdMap_$c<=
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2)
                  (Data.Map.Internal.$fOrdMap_$c>
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2)
                  (Data.Map.Internal.$fOrdMap_$c>=
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2)
                  (Data.Map.Internal.$fOrdMap_$cmax
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2)
                  (Data.Map.Internal.$fOrdMap_$cmin
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     GHC.Classes.$fOrd[]_$s$fOrd[]2) -}
99ca7d70c87057fbea06100eac2cd2a8
  $s$fOrdVarName ::
    GHC.Classes.Ord
      (Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.VarName
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  VarAccessAnalysis.$s$fEqVarName
                  (Language.Fortran.$fOrdVarName_$ccompare
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap)
                  (Language.Fortran.$fOrdVarName_$c<
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap)
                  (Language.Fortran.$fOrdVarName_$c<=
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap)
                  (\ (a :: Language.Fortran.VarName
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                     (b :: Language.Fortran.VarName
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   Language.Fortran.$fOrdVarName_$c<
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap
                     b
                     a)
                  (Language.Fortran.$fOrdVarName_$c>=
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap)
                  (Language.Fortran.$fOrdVarName_$cmax
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap)
                  (Language.Fortran.$fOrdVarName_$cmin
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     VarAccessAnalysis.$s$fOrdMap) -}
34fc577e2481da7d2d029467580ed320
  $s$fOrdVarName_$cmax ::
    Language.Fortran.VarName
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
  {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S(SL),1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w362 :: Language.Fortran.VarName
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                   (w363 :: Language.Fortran.VarName
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ ([GHC.Types.Char], [GHC.Base.String])
                        (GHC.Classes.$fOrd(,)
                           @ [GHC.Types.Char]
                           @ [GHC.Base.String]
                           GHC.Classes.$fOrd[]_$s$fOrd[]1
                           GHC.Classes.$fOrd[]_$s$fOrd[]2)
                        (Data.Map.Internal.$fDataMap_go
                           @ [GHC.Types.Char]
                           @ [GHC.Base.String]
                           (GHC.Types.[] @ ([GHC.Types.Char], [GHC.Base.String]))
                           ww4)
                        (Data.Map.Internal.$fDataMap_go
                           @ [GHC.Types.Char]
                           @ [GHC.Base.String]
                           (GHC.Types.[] @ ([GHC.Types.Char], [GHC.Base.String]))
                           ww1) of wild {
                   GHC.Types.LT
                   -> Language.Fortran.VarName
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        ww1
                        ww2
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww5 ww2 of wild1 {
                        DEFAULT
                        -> Language.Fortran.VarName
                             @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                             ww4
                             ww5
                        GHC.Types.LT
                        -> Language.Fortran.VarName
                             @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                             ww1
                             ww2 }
                   GHC.Types.GT
                   -> Language.Fortran.VarName
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        ww4
                        ww5 } } }) -}
de07d231aa682c25ec4f60083c0cbf09
  $s$fOrdVarName_$cmin ::
    Language.Fortran.VarName
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
  {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S(SL),1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w362 :: Language.Fortran.VarName
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                   (w363 :: Language.Fortran.VarName
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ ([GHC.Types.Char], [GHC.Base.String])
                        (GHC.Classes.$fOrd(,)
                           @ [GHC.Types.Char]
                           @ [GHC.Base.String]
                           GHC.Classes.$fOrd[]_$s$fOrd[]1
                           GHC.Classes.$fOrd[]_$s$fOrd[]2)
                        (Data.Map.Internal.$fDataMap_go
                           @ [GHC.Types.Char]
                           @ [GHC.Base.String]
                           (GHC.Types.[] @ ([GHC.Types.Char], [GHC.Base.String]))
                           ww4)
                        (Data.Map.Internal.$fDataMap_go
                           @ [GHC.Types.Char]
                           @ [GHC.Base.String]
                           (GHC.Types.[] @ ([GHC.Types.Char], [GHC.Base.String]))
                           ww1) of wild {
                   GHC.Types.LT
                   -> Language.Fortran.VarName
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        ww4
                        ww5
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww5 ww2 of wild1 {
                        DEFAULT
                        -> Language.Fortran.VarName
                             @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                             ww1
                             ww2
                        GHC.Types.LT
                        -> Language.Fortran.VarName
                             @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                             ww4
                             ww5 }
                   GHC.Types.GT
                   -> Language.Fortran.VarName
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        ww1
                        ww2 } } }) -}
07801f1dff51c04e0c54c9f3781fbb5b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   VarAccessAnalysis.$trModule3
                   VarAccessAnalysis.$trModule1) -}
86cb67b727e95539f93de1453221f755
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS VarAccessAnalysis.$trModule2) -}
d80a93fc4537e026be7e9595f9eba51f
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VarAccessAnalysis"#) -}
513f50ae0a6c8d1f3897d727d4ac10d7
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS VarAccessAnalysis.$trModule4) -}
64ec1e5ce72f0a420fd13d33d0cd420f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
c736e7ccc00333922decda9003980b36
  $w$sgo13 ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> a1
    -> Data.Map.Internal.Map
         (Language.Fortran.VarName LanguageFortranTools.Anno) a1
    -> Data.Map.Internal.Map
         (Language.Fortran.VarName LanguageFortranTools.Anno) a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
2a1f7a35d9267b22319171d96c383210
  $wanalyseAllVarAccess ::
    [GHC.Base.String]
    -> Language.Fortran.Program LanguageFortranTools.Anno
    -> (# [VarAccessAnalysis.LocalVarAccessAnalysis],
          VarAccessAnalysis.LocalVarValueAnalysis,
          [Language.Fortran.VarName LanguageFortranTools.Anno],
          [Language.Fortran.VarName LanguageFortranTools.Anno] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
7603430adbd228ac7ec24fa21bcf4e3c
  $wgetAccessLocationsAfterSrcSpan ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> (# [Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan] #)
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,1*U(U,U)><L,U(A,U(A,U(U),U(U)))>,
     Inline: [0],
     Unfolding: (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.SrcSpan) ->
                 let {
                   ds :: ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                   = case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                     case w of wild { (,,,) ds1 ds2 ds3 ds4 ->
                     case ds1 of wild1 {
                       []
                       -> case VarAccessAnalysis.getAccessLocationsAfterSrcSpan2
                          ret_ty ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                          of {}
                       : x xs
                       -> VarAccessAnalysis.$wpoly_go13
                            @ ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                            VarAccessAnalysis.getAccessLocationsAfterSrcSpan1
                            ww1
                            ww2
                            x } } }
                 } in
                 (# case ds of wild { (,) reads writes ->
                    GHC.List.filter
                      @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                      (\ (x :: Language.Fortran.SrcSpan) ->
                       LanguageFortranTools.checkSrcSpanAfter x w2)
                      reads },
                    case ds of wild { (,) reads writes ->
                    GHC.List.filter
                      @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                      (\ (x :: Language.Fortran.SrcSpan) ->
                       LanguageFortranTools.checkSrcSpanAfter x w2)
                      writes } #)) -}
905a61ddd1a2b95c299d35afbe258347
  $wgetAccessLocationsBeforeSrcSpan ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> (# [Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan] #)
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,1*U(U,U)><L,U(U(A,U(U),U(U)),A)>,
     Inline: [0],
     Unfolding: (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.SrcSpan) ->
                 let {
                   ds :: ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                   = case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                     case w of wild { (,,,) ds1 ds2 ds3 ds4 ->
                     case ds1 of wild1 {
                       []
                       -> case VarAccessAnalysis.getAccessLocationsBeforeSrcSpan1
                          ret_ty ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                          of {}
                       : x xs
                       -> VarAccessAnalysis.$wpoly_go13
                            @ ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                            VarAccessAnalysis.getAccessLocationsAfterSrcSpan1
                            ww1
                            ww2
                            x } } }
                 } in
                 (# case ds of wild { (,) reads writes ->
                    GHC.List.filter
                      @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                      (\ (x :: Language.Fortran.SrcSpan) ->
                       LanguageFortranTools.checkSrcSpanBefore x w2)
                      reads },
                    case ds of wild { (,) reads writes ->
                    GHC.List.filter
                      @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                      (\ (x :: Language.Fortran.SrcSpan) ->
                       LanguageFortranTools.checkSrcSpanBefore x w2)
                      writes } #)) -}
72b9b2340c0ba76c1278b768078125f5
  $wgetAccessLocationsInsideSrcSpan ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> (# [Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan] #)
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,1*U(U,U)><L,U(U(A,U(U),U(U)),U(A,U(U),U(U)))>,
     Inline: [0],
     Unfolding: (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.SrcSpan) ->
                 let {
                   ds :: ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                   = case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                     case w of wild { (,,,) ds1 ds2 ds3 ds4 ->
                     case ds1 of wild1 {
                       []
                       -> case VarAccessAnalysis.getAccessLocationsInsideSrcSpan1
                          ret_ty ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                          of {}
                       : x xs
                       -> VarAccessAnalysis.$wpoly_go13
                            @ ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                            VarAccessAnalysis.getAccessLocationsAfterSrcSpan1
                            ww1
                            ww2
                            (VarAccessAnalysis.getAccessesInsideSrcSpan x w2) } } }
                 } in
                 (# case ds of wild { (,) readsInside writesInside -> readsInside },
                    case ds of wild { (,) readsInside writesInside ->
                    writesInside } #)) -}
efb399ec263d852c708b1384b8986b56
  $wgetAccessesBetweenManySrcSpans ::
    VarAccessAnalysis.VarAccessAnalysis
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> (# [Language.Fortran.VarName LanguageFortranTools.Anno],
          [Language.Fortran.VarName LanguageFortranTools.Anno] #)
  {- Arity: 2, Strictness: <L,U(U,A,A,A)><S,1*U>, Inline: [0] -}
19b6f55d2584e27cba4afd51696341ca
  $wgetAccessesBetweenSrcSpans ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> (# [Language.Fortran.VarName LanguageFortranTools.Anno],
          [Language.Fortran.VarName LanguageFortranTools.Anno] #)
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,U(A,U(U),U(U))><L,U(A,U(U),U(U))>,
     Inline: [0] -}
dec22d0f9b959800cea7af24d874a6e7
  $wgetAccessesBetweenSrcSpansIgnoreBuildSrcSpans ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> [Language.Fortran.SrcSpan]
    -> (# (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc),
          [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Inline: [0] -}
82c6239666f08427ae7f0fdb1e4a8bc6
  $wgetNonTempVars ::
    Language.Fortran.SrcSpan
    -> [VarAccessAnalysis.LocalVarAccessAnalysis]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 3, Strictness: <L,U(A,U(A,U(U),A))><S,1*U><L,1*U>,
     Inline: [0] -}
312a1bd09f2d6262f9747cb6e4bb5e12
  $wgetPrexistingVars ::
    Language.Fortran.SrcSpan
    -> [VarAccessAnalysis.LocalVarAccessAnalysis]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 3,
     Strictness: <L,U(U(A,U(U),U(U)),U(A,U(U),U(U)))><S,1*U><L,1*U>,
     Inline: [0] -}
7fdeab22b1279d220ce11c2b117a1607
  $wgetValueAtSrcSpan ::
    LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> Language.Fortran.SrcSpan
    -> VarAccessAnalysis.LocalVarValueAnalysis
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 4, Strictness: <L,U><L,U><L,U(U(A,U(U),U(U)),A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: LanguageFortranTools.Anno)
                   (ww1 :: Language.Fortran.Variable)
                   (w :: Language.Fortran.SrcSpan)
                   (ww2 :: VarAccessAnalysis.LocalVarValueAnalysis) ->
                 letrec {
                   go6 :: [(Language.Fortran.SrcSpan,
                            Language.Fortran.Expr LanguageFortranTools.Anno)]
                          -> Language.Fortran.Expr LanguageFortranTools.Anno
                          -> Language.Fortran.Expr LanguageFortranTools.Anno
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [(Language.Fortran.SrcSpan,
                                Language.Fortran.Expr LanguageFortranTools.Anno)])
                       (eta :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go6
                            ys
                            (case y of wild1 { (,) item_src expr ->
                             case item_src of ww3 { (,) ww4 ww5 ->
                             case ww5 of ww6 { Language.Fortran.SrcLoc ww7 ww8 ww9 ->
                             case ww8 of ww10 { GHC.Types.I# ww11 ->
                             case w of ww12 { (,) ww13 ww14 ->
                             case ww13 of ww15 { Language.Fortran.SrcLoc ww16 ww17 ww18 ->
                             case ww17 of ww19 { GHC.Types.I# ww20 ->
                             case GHC.Prim.<# ww11 ww20 of lwild {
                               DEFAULT
                               -> case GHC.Prim.==# ww11 ww20 of lwild1 {
                                    DEFAULT -> eta
                                    1#
                                    -> case ww9 of wild2 { GHC.Types.I# x ->
                                       case ww18 of wild3 { GHC.Types.I# y1 ->
                                       case GHC.Prim.<# x y1 of lwild2 {
                                         DEFAULT -> eta 1# -> expr } } } }
                               1# -> expr } } } } } } } }) }
                 } in
                 go6
                   (VarAccessAnalysis.$wpoly_go13
                      @ [(Language.Fortran.SrcSpan,
                          Language.Fortran.Expr LanguageFortranTools.Anno)]
                      (GHC.Types.[]
                         @ (Language.Fortran.SrcSpan,
                            Language.Fortran.Expr LanguageFortranTools.Anno))
                      ww
                      ww1
                      ww2)
                   VarAccessAnalysis.getValueAtSrcSpan1) -}
a392b583e68bbc61c695770e69db1dbb
  $wpoly_go13 ::
    a
    -> LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> Data.Map.Internal.Map
         (Language.Fortran.VarName LanguageFortranTools.Anno) a
    -> a
  {- Arity: 4, Strictness: <L,1*U><L,U><L,U><S,1*U>, Inline: [0] -}
9d142f2355a22a01b1c9f99cdc5e4a3c
  type LocalVarAccessAnalysis =
    Data.Map.Internal.Map
      (Language.Fortran.VarName LanguageFortranTools.Anno)
      VarAccessAnalysis.VarAccessRecord
ee199415278e2f4fe956fdaa386bb954
  type LocalVarValueAnalysis =
    Data.Map.Internal.Map
      (Language.Fortran.VarName LanguageFortranTools.Anno)
      [(Language.Fortran.SrcSpan,
        Language.Fortran.Expr LanguageFortranTools.Anno)]
6eba2d91974ef76d532f7c235d4d961a
  type VarAccessAnalysis =
    ([VarAccessAnalysis.LocalVarAccessAnalysis],
     VarAccessAnalysis.LocalVarValueAnalysis,
     [Language.Fortran.VarName LanguageFortranTools.Anno],
     [Language.Fortran.VarName LanguageFortranTools.Anno])
e0b705e80f96d523a29ae747bd00ff2c
  type VarAccessRecord =
    ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
ff320c276aed332471cd3abbf659bd24
  type VarAccessRecordWV =
    ([(Language.Fortran.SrcSpan,
       Language.Fortran.Expr LanguageFortranTools.Anno)],
     [(Language.Fortran.SrcSpan,
       Language.Fortran.Expr LanguageFortranTools.Anno)])
b6bab9144299c3ee32e195965821c2fb
  analyseAllVarAccess ::
    [GHC.Base.String]
    -> Language.Fortran.Program LanguageFortranTools.Anno
    -> VarAccessAnalysis.VarAccessAnalysis
  {- Arity: 2, Strictness: <L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Base.String])
                   (w1 :: Language.Fortran.Program LanguageFortranTools.Anno) ->
                 case VarAccessAnalysis.$wanalyseAllVarAccess
                        w
                        w1 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
e7cc16dc934986186ae9d6da7df6ad4a
  analyseAllVarAccess_progUnit ::
    [GHC.Base.String]
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> VarAccessAnalysis.VarAccessAnalysis
  {- Arity: 2, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ioWriteSubroutineNames :: [GHC.Base.String])
                   (progUnit :: Language.Fortran.ProgUnit
                                  LanguageFortranTools.Anno) ->
                 VarAccessAnalysis.analyseAllVarAccess
                   ioWriteSubroutineNames
                   (GHC.Types.:
                      @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                      progUnit
                      (GHC.Types.[]
                         @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)))) -}
5ac0a4f3c0ddf2c6cee7afd301dd28a3
  collectVarNames ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (declarations :: [Language.Fortran.VarName
                                       LanguageFortranTools.Anno])
                   (item :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 let {
                   exprVarNames :: [Language.Fortran.VarName
                                      LanguageFortranTools.Anno]
                   = case item of wild {
                       DEFAULT
                       -> GHC.Types.[]
                            @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                       Language.Fortran.Var ds1 ds2 lst
                       -> LanguageFortranTools.extractVarNames_go lst }
                 } in
                 let {
                   $j :: [Language.Fortran.VarName LanguageFortranTools.Anno] <join 0>
                   = case item of wild {
                       DEFAULT
                       -> GHC.Types.[]
                            @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                       Language.Fortran.Var ds1 ds2 lst
                       -> VarAccessAnalysis.collectVarNames_go
                            (VarAccessAnalysis.collectVarNames_go9
                               lst
                               (GHC.Types.[] @ (Language.Fortran.Expr LanguageFortranTools.Anno)))
                            (GHC.Types.[]
                               @ (Language.Fortran.VarName LanguageFortranTools.Anno)) }
                 } in
                 case GHC.List.elem
                        @ Language.Fortran.Variable
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        (case GHC.List.$wlenAcc
                                @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                exprVarNames
                                0# of ww2 { DEFAULT ->
                         case GHC.Prim.># ww2 0# of lwild {
                           DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                           1#
                           -> case exprVarNames of wild {
                                [] -> case GHC.List.badHead ret_ty Language.Fortran.Variable of {}
                                : x ds1
                                -> case x of wild1 { Language.Fortran.VarName ds exprVarNameStr ->
                                   exprVarNameStr } } } })
                        F95IntrinsicFunctions.f95IntrinsicFunctions of wild {
                   GHC.Types.False
                   -> let {
                        exit :: [Language.Fortran.VarName LanguageFortranTools.Anno]
                          <join 0>
                        = LanguageFortranTools.extractVarNames item
                      } in
                      let {
                        $j1 :: [Language.Fortran.VarName LanguageFortranTools.Anno]
                          <join 0>
                        = case item of wild1 {
                            DEFAULT
                            -> case VarAccessAnalysis.collectVarNames1 of wild2 {
                                 GHC.Types.False -> $j
                                 GHC.Types.True
                                 -> GHC.Types.[]
                                      @ (Language.Fortran.VarName LanguageFortranTools.Anno) }
                            Language.Fortran.Var ds1 ds2 lst
                            -> case GHC.Classes.$fEq[]_$c==
                                      @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                      VarAccessAnalysis.$s$fEqExpr
                                      (VarAccessAnalysis.collectVarNames_go9
                                         lst
                                         (GHC.Types.[]
                                            @ (Language.Fortran.Expr LanguageFortranTools.Anno)))
                                      (GHC.Types.[]
                                         @ (Language.Fortran.Expr
                                              LanguageFortranTools.Anno)) of wild2 {
                                 GHC.Types.False -> $j
                                 GHC.Types.True -> LanguageFortranTools.extractVarNames_go lst } }
                      } in
                      letrec {
                        go6 :: [Language.Fortran.VarName LanguageFortranTools.Anno]
                               -> [Language.Fortran.VarName LanguageFortranTools.Anno]
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [Language.Fortran.VarName LanguageFortranTools.Anno]) ->
                          case ds of wild1 {
                            [] -> $j1
                            : y ys
                            -> case GHC.List.elem
                                      @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                      VarAccessAnalysis.$s$fEqVarName
                                      y
                                      declarations of wild2 {
                                 GHC.Types.False -> go6 ys GHC.Types.True -> exit } }
                      } in
                      go6 exprVarNames
                   GHC.Types.True -> $j }) -}
1653741c1c8ead557b4595b8be2d47d8
  collectVarNames1 :: GHC.Types.Bool
  {- Unfolding: (GHC.Classes.$fEq[]_$c==
                   @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                   VarAccessAnalysis.$s$fEqExpr
                   (GHC.Types.[] @ (Language.Fortran.Expr LanguageFortranTools.Anno))
                   (GHC.Types.[]
                      @ (Language.Fortran.Expr LanguageFortranTools.Anno))) -}
1a59dee90847a0eb8c1a4b6117eeb846
  collectVarNames_go ::
    [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
bacfa0357e2e6a30651c6d5517e94b09
  collectVarNames_go9 ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      [Language.Fortran.Expr LanguageFortranTools.Anno])]
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
09e175097c99b3e6613bac36721ea966
  getAccessLocationsAfterSrcSpan ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,1*U(U,U)><L,U(A,U(A,U(U),U(U)))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.SrcSpan) ->
                 case VarAccessAnalysis.$wgetAccessLocationsAfterSrcSpan
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
e94b37e28aed43470872e9d837e9e742
  getAccessLocationsAfterSrcSpan1 ::
    ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Types.[] @ Language.Fortran.SrcSpan,
                  GHC.Types.[] @ Language.Fortran.SrcSpan)) -}
b5516b011245c2da6f199f86a80ebbea
  getAccessLocationsAfterSrcSpan2 ::
    VarAccessAnalysis.LocalVarAccessAnalysis
  {- Strictness: x -}
48ee41792acebbf4ebcdce94c39b9501
  getAccessLocationsBeforeSrcSpan ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,1*U(U,U)><L,U(U(A,U(U),U(U)),A)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.SrcSpan) ->
                 case VarAccessAnalysis.$wgetAccessLocationsBeforeSrcSpan
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
8a6b2966c1c9085378fdd845fa139ea0
  getAccessLocationsBeforeSrcSpan1 ::
    VarAccessAnalysis.LocalVarAccessAnalysis
  {- Strictness: x -}
7b5873e0a53465d1ef2979902736a3a5
  getAccessLocationsInsideSrcSpan ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,1*U(U,U)><L,U(U(A,U(U),U(U)),U(A,U(U),U(U)))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.SrcSpan) ->
                 case VarAccessAnalysis.$wgetAccessLocationsInsideSrcSpan
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
4fc502d3dee80436190453b3b2bdcf6e
  getAccessLocationsInsideSrcSpan1 ::
    VarAccessAnalysis.LocalVarAccessAnalysis
  {- Strictness: x -}
bfa9023396c3475f1d6e0c51c2c75ed0
  getAccessesBetweenManySrcSpans ::
    VarAccessAnalysis.VarAccessAnalysis
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> ([Language.Fortran.VarName LanguageFortranTools.Anno],
        [Language.Fortran.VarName LanguageFortranTools.Anno])
  {- Arity: 2, Strictness: <L,U(U,A,A,A)><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]) ->
                 case VarAccessAnalysis.$wgetAccessesBetweenManySrcSpans
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
e4145c58de7901d192803d643306f238
  getAccessesBetweenSrcSpans ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> ([Language.Fortran.VarName LanguageFortranTools.Anno],
        [Language.Fortran.VarName LanguageFortranTools.Anno])
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A)><L,U(A,U(U),U(U))><L,U(A,U(U),U(U))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: VarAccessAnalysis.VarAccessAnalysis)
                   (w1 :: Language.Fortran.SrcLoc)
                   (w2 :: Language.Fortran.SrcLoc) ->
                 case VarAccessAnalysis.$wgetAccessesBetweenSrcSpans
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
6bb61dc36b3fa623123f285869d73f3a
  getAccessesBetweenSrcSpansIgnore ::
    VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> [Language.Fortran.SrcSpan]
    -> ([Language.Fortran.VarName LanguageFortranTools.Anno],
        [Language.Fortran.VarName LanguageFortranTools.Anno])
  {- Arity: 4,
     Strictness: <L,U(U,A,A,A)><S,1*U(A,U)><S,1*U(U,A)><S,1*U>m,
     Unfolding: InlineRule (4, True, False)
                (\ (accessAnalysis :: VarAccessAnalysis.VarAccessAnalysis)
                   (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                   (ds1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                   (skipSrcs :: [Language.Fortran.SrcSpan]) ->
                 case ds of wild { (,) ds2 startLoc ->
                 case ds1 of wild1 { (,) endLoc ds3 ->
                 VarAccessAnalysis.getAccessesBetweenManySrcSpans
                   accessAnalysis
                   (VarAccessAnalysis.getAccessesBetweenSrcSpansIgnoreBuildSrcSpans
                      startLoc
                      endLoc
                      skipSrcs) } }) -}
b485e0a8d3f37833300e66890671a69e
  getAccessesBetweenSrcSpansIgnoreBuildSrcSpans ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> [Language.Fortran.SrcSpan]
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>m2,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Language.Fortran.SrcLoc)
                   (w1 :: Language.Fortran.SrcLoc)
                   (w2 :: [Language.Fortran.SrcSpan]) ->
                 case VarAccessAnalysis.$wgetAccessesBetweenSrcSpansIgnoreBuildSrcSpans
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.:
                   @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                   ww1
                   ww2 }) -}
19c45ecbf63a3cf562c7537ac261cf29
  getAccessesBetweenSrcSpansIgnore_$s$wgetAccessesBetweenManySrcSpans ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> ([Data.Map.Internal.Map
           (Language.Fortran.VarName
              (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]]))
           ([(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)],
            [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)])],
        Data.Map.Internal.Map
          (Language.Fortran.VarName
             (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]]))
          [((Language.Fortran.SrcLoc, Language.Fortran.SrcLoc),
            Language.Fortran.Expr
              (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]]))],
        [Language.Fortran.VarName
           (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])],
        [Language.Fortran.VarName
           (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])])
    -> (# [Language.Fortran.VarName LanguageFortranTools.Anno],
          [Language.Fortran.VarName LanguageFortranTools.Anno] #)
  {- Arity: 3,
     Strictness: <S,1*U(U(A,U(U),U(U)),U(A,U(U),U(U)))><L,1*U><L,U(U,A,A,A)> -}
d2f8ab7b56c3528ac64f43d9ecca04cb
  getAccessesInsideSrcSpan ::
    VarAccessAnalysis.LocalVarAccessAnalysis
    -> Language.Fortran.SrcSpan
    -> VarAccessAnalysis.LocalVarAccessAnalysis
  {- Arity: 2, Strictness: <S,U><L,U(U(A,U(U),U(U)),U(A,U(U),U(U)))>,
     Unfolding: (\ (localVarAccesses :: VarAccessAnalysis.LocalVarAccessAnalysis)
                   (src :: Language.Fortran.SrcSpan) ->
                 let {
                   lvl128 :: Language.Fortran.SrcSpan -> GHC.Types.Bool {- Arity: 1 -}
                   = LanguageFortranTools.srcSpanInSrcSpan src
                 } in
                 letrec {
                   go6 :: (VarAccessAnalysis.LocalVarAccessAnalysis
                           -> VarAccessAnalysis.LocalVarAccessAnalysis)
                          -> Data.Map.Internal.Map
                               (Language.Fortran.VarName LanguageFortranTools.Anno)
                               ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                          -> VarAccessAnalysis.LocalVarAccessAnalysis
                          -> VarAccessAnalysis.LocalVarAccessAnalysis
                     {- Arity: 3, Strictness: <C(S),1*C1(U)><S,1*U><L,U> -}
                   = \ (z' :: VarAccessAnalysis.LocalVarAccessAnalysis
                              -> VarAccessAnalysis.LocalVarAccessAnalysis)
                       (ds :: Data.Map.Internal.Map
                                (Language.Fortran.VarName LanguageFortranTools.Anno)
                                ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan]))
                       (eta :: VarAccessAnalysis.LocalVarAccessAnalysis) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> case kx of ww { Language.Fortran.VarName ww1 ww2 ->
                          go6
                            (\ (v :: VarAccessAnalysis.LocalVarAccessAnalysis)[OneShot] ->
                             go6
                               z'
                               r
                               (let {
                                  ds1 :: ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                                  = VarAccessAnalysis.$wpoly_go13
                                      @ ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                                      VarAccessAnalysis.getAccessLocationsAfterSrcSpan1
                                      ww1
                                      ww2
                                      v
                                } in
                                VarAccessAnalysis.$w$sgo13
                                  @ ([Language.Fortran.SrcSpan], [Language.Fortran.SrcSpan])
                                  ww
                                  ww1
                                  ww2
                                  (case ds1 of wild1 { (,) reads writes ->
                                   GHC.List.filter
                                     @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                                     lvl128
                                     reads },
                                   case ds1 of wild1 { (,) reads writes ->
                                   GHC.List.filter
                                     @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                                     lvl128
                                     writes })
                                  v))
                            l
                            eta }
                       Data.Map.Internal.Tip -> z' eta }
                 } in
                 go6
                   (GHC.Base.id @ VarAccessAnalysis.LocalVarAccessAnalysis)
                   localVarAccesses
                   localVarAccesses) -}
a90d5f5f34429817dbc2a090c06611ff
  getArguments ::
    Language.Fortran.Program LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (prog :: Language.Fortran.Program LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno))
                   VarAccessAnalysis.getArguments1
                   @ (Language.Fortran.Program LanguageFortranTools.Anno)
                   VarAccessAnalysis.$s$fData[]
                   prog) -}
c963a449b2d9953ce404953f266ea14d
  getArguments1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case VarAccessAnalysis.getArguments2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        1#
                        -> case eta
                                  `cast`
                                (UnsafeCo representational a (Language.Fortran.ArgName
                                                                LanguageFortranTools.Anno)) of wild2 {
                             DEFAULT
                             -> GHC.Types.[]
                                  @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                             Language.Fortran.ArgName ds str
                             -> GHC.Types.:
                                  @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                  (Language.Fortran.VarName
                                     @ LanguageFortranTools.Anno
                                     (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                                     str)
                                  (GHC.Types.[]
                                     @ (Language.Fortran.VarName
                                          LanguageFortranTools.Anno)) } } } } }) -}
2839714a045e3358feb0cdae67ca9b1f
  getArguments2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgName
                        4187460949675603402##
                        17695948308021011151##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgName3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> * -> *)
                        @ Data.Map.Internal.Map
                        11323335571407833487##
                        2177232330301466659##
                        Data.Map.Internal.$trModule
                        Data.Map.Internal.$fDataMap9
                        0#
                        GHC.Types.krep$*->*->*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww1 { (#,,,,#) ww2 ww3 ww4 ww5 ww6 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.ArgName LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.ArgName
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.ArgName
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ *
                         @ (Data.Map.Internal.Map GHC.Base.String)
                         @ [GHC.Base.String]
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ (* -> *)
                            @ Data.Map.Internal.Map
                            @ GHC.Base.String
                            (Data.Typeable.Internal.TrTyCon
                               @ (* -> * -> *)
                               @ Data.Map.Internal.Map
                               ww2
                               ww3
                               ww4
                               ww5
                               ww6)
                            VarAccessAnalysis.getArguments4)
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Base.String
                            VarAccessAnalysis.getArguments3
                            VarAccessAnalysis.getArguments4))) } }) -}
56871859c9a3875af9f4560ca5862563
  getArguments3 :: Data.Typeable.Internal.TypeRep []
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ []
                        15300440589168157478##
                        15016221815972113379##
                        GHC.Types.$trModule
                        GHC.Types.$tc[]1
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ []
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
9fef02b1926de659501e88d3bdadc15c
  getArguments4 :: Data.Typeable.Internal.TypeRep [GHC.Types.Char]
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ *
                        @ GHC.Types.Char
                        8424092006618324671##
                        2724268014499746065##
                        GHC.Types.$trModule
                        GHC.Types.$tcChar1
                        0#
                        GHC.Types.krep$*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ GHC.Types.Char
                   VarAccessAnalysis.getArguments3
                   (Data.Typeable.Internal.TrTyCon
                      @ *
                      @ GHC.Types.Char
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
3631ecdfa4430abc82d37e721099d494
  getDeclaredVarNames ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Decl
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.Decl ds1 ds2 lst ds3
                   -> VarAccessAnalysis.getDeclaredVarNames_go
                        lst
                        (GHC.Types.[]
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno)) }) -}
fd14bafe846b710ca93e897b5969add1
  getDeclaredVarNames_go ::
    [(Language.Fortran.Expr LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno,
      GHC.Base.Maybe GHC.Types.Int)]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
902b39df5c90ea9341608aa427d00dde
  getNonTempVars ::
    Language.Fortran.SrcSpan
    -> VarAccessAnalysis.VarAccessAnalysis
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <L,U(A,U(A,U(U),A))><S(SLLL),1*U(1*U,A,1*U,A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: VarAccessAnalysis.VarAccessAnalysis) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 VarAccessAnalysis.$wgetNonTempVars w ww1 ww3 }) -}
e0d2cbd38ee60be110b1aeee86e420a5
  getPrexistingVars ::
    Language.Fortran.SrcSpan
    -> VarAccessAnalysis.VarAccessAnalysis
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <L,U(U(A,U(U),U(U)),U(A,U(U),U(U)))><S(SLLL),1*U(1*U,A,1*U,A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: VarAccessAnalysis.VarAccessAnalysis) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 VarAccessAnalysis.$wgetPrexistingVars w ww1 ww3 }) -}
c331f40e666b6ff9fd3404effa137ea6
  getValueAtSrcSpan ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.SrcSpan
    -> VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <S,1*U(U,U)><L,U(U(A,U(U),U(U)),A)><S(LSLL),1*U(A,1*U,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w1 :: Language.Fortran.SrcSpan)
                   (w2 :: VarAccessAnalysis.VarAccessAnalysis) ->
                 case w of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { (,,,) ww4 ww5 ww6 ww7 ->
                 VarAccessAnalysis.$wgetValueAtSrcSpan ww1 ww2 w1 ww5 } }) -}
74ba92928424bc5be9e4b89c6fcdcf6f
  getValueAtSrcSpan1 ::
    Language.Fortran.Expr LanguageFortranTools.Anno
  {- Strictness: m8,
     Unfolding: (Language.Fortran.NullExpr
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan) -}
3044e5e5d7ee49158fef87ee8f392329
  isFunctionCall ::
    [GHC.Base.String]
    -> VarAccessAnalysis.VarAccessAnalysis
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,1*U(A,A,A,1*U)><L,U>,
     Unfolding: (\ (intrinsics :: [GHC.Base.String])
                   (accessAnalysis :: VarAccessAnalysis.VarAccessAnalysis)
                   (expr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 let {
                   exprVarNames :: [Language.Fortran.VarName
                                      LanguageFortranTools.Anno]
                   = case expr of wild {
                       DEFAULT
                       -> GHC.Types.[]
                            @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                       Language.Fortran.Var ds1 ds2 lst
                       -> LanguageFortranTools.extractVarNames_go lst }
                 } in
                 case GHC.List.elem
                        @ Language.Fortran.Variable
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        (case GHC.List.$wlenAcc
                                @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                exprVarNames
                                0# of ww2 { DEFAULT ->
                         case GHC.Prim.># ww2 0# of lwild {
                           DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                           1#
                           -> case exprVarNames of wild {
                                [] -> case GHC.List.badHead ret_ty Language.Fortran.Variable of {}
                                : x ds1
                                -> case x of wild1 { Language.Fortran.VarName ds exprVarNameStr ->
                                   exprVarNameStr } } } })
                        intrinsics of wild {
                   GHC.Types.False
                   -> let {
                        declaredVarNames :: [Language.Fortran.VarName
                                               LanguageFortranTools.Anno]
                        = case accessAnalysis of wild1 { (,,,) ds ds1 ds2 x -> x }
                      } in
                      let {
                        $j :: GHC.Types.Bool <join 0>
                        = case expr of wild1 {
                            DEFAULT
                            -> case VarAccessAnalysis.collectVarNames1 of wild2 {
                                 GHC.Types.False -> GHC.Types.True
                                 GHC.Types.True -> GHC.Types.False }
                            Language.Fortran.Var ds1 ds2 lst
                            -> case GHC.Classes.$fEq[]_$c==
                                      @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                      VarAccessAnalysis.$s$fEqExpr
                                      (VarAccessAnalysis.collectVarNames_go9
                                         lst
                                         (GHC.Types.[]
                                            @ (Language.Fortran.Expr LanguageFortranTools.Anno)))
                                      (GHC.Types.[]
                                         @ (Language.Fortran.Expr
                                              LanguageFortranTools.Anno)) of wild2 {
                                 GHC.Types.False -> GHC.Types.True
                                 GHC.Types.True -> GHC.Types.False } }
                      } in
                      letrec {
                        go6 :: [Language.Fortran.VarName LanguageFortranTools.Anno]
                               -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [Language.Fortran.VarName LanguageFortranTools.Anno]) ->
                          case ds of wild1 {
                            [] -> $j
                            : y ys
                            -> case GHC.List.elem
                                      @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                      VarAccessAnalysis.$s$fEqVarName
                                      y
                                      declaredVarNames of wild2 {
                                 GHC.Types.False -> go6 ys GHC.Types.True -> GHC.Types.False } }
                      } in
                      go6 exprVarNames
                   GHC.Types.True -> GHC.Types.True }) -}
"SC:$wgetAccessesBetweenManySrcSpans0" [0] forall (sc :: (Language.Fortran.SrcLoc,
                                                          Language.Fortran.SrcLoc))
                                                  (sc1 :: [(Language.Fortran.SrcLoc,
                                                            Language.Fortran.SrcLoc)])
                                                  (sc2 :: ([Data.Map.Internal.Map
                                                              (Language.Fortran.VarName
                                                                 (Data.Map.Internal.Map
                                                                    [GHC.Types.Char]
                                                                    [[GHC.Types.Char]]))
                                                              ([(Language.Fortran.SrcLoc,
                                                                 Language.Fortran.SrcLoc)],
                                                               [(Language.Fortran.SrcLoc,
                                                                 Language.Fortran.SrcLoc)])],
                                                           Data.Map.Internal.Map
                                                             (Language.Fortran.VarName
                                                                (Data.Map.Internal.Map
                                                                   [GHC.Types.Char]
                                                                   [[GHC.Types.Char]]))
                                                             [((Language.Fortran.SrcLoc,
                                                                Language.Fortran.SrcLoc),
                                                               Language.Fortran.Expr
                                                                 (Data.Map.Internal.Map
                                                                    [GHC.Types.Char]
                                                                    [[GHC.Types.Char]]))],
                                                           [Language.Fortran.VarName
                                                              (Data.Map.Internal.Map
                                                                 [GHC.Types.Char]
                                                                 [[GHC.Types.Char]])],
                                                           [Language.Fortran.VarName
                                                              (Data.Map.Internal.Map
                                                                 [GHC.Types.Char]
                                                                 [[GHC.Types.Char]])]))
  VarAccessAnalysis.$wgetAccessesBetweenManySrcSpans sc2
                                                     (GHC.Types.:
                                                        @ (Language.Fortran.SrcLoc,
                                                           Language.Fortran.SrcLoc)
                                                        sc
                                                        sc1)
  = VarAccessAnalysis.getAccessesBetweenSrcSpansIgnore_$s$wgetAccessesBetweenManySrcSpans
      sc
      sc1
      sc2
"SPEC/VarAccessAnalysis $fDataArgList @ (Map String [String])" [orphan] forall (v :: Data.Data.Data
                                                                                       (Data.Map.Internal.Map
                                                                                          GHC.Base.String
                                                                                          [GHC.Base.String]))
  Language.Fortran.$fDataArgList @ (Data.Map.Internal.Map
                                      GHC.Base.String [GHC.Base.String])
                                 v
  = VarAccessAnalysis.$s$fDataArgList
"SPEC/VarAccessAnalysis $fDataMap @ [Char] @ [String]" [orphan] forall (v2 :: GHC.Classes.Ord
                                                                                [GHC.Types.Char])
                                                                       (v1 :: Data.Data.Data
                                                                                [GHC.Base.String])
                                                                       (v :: Data.Data.Data
                                                                               [GHC.Types.Char])
  Data.Map.Internal.$fDataMap @ [GHC.Types.Char]
                              @ [GHC.Base.String]
                              v
                              v1
                              v2
  = VarAccessAnalysis.$s$fDataArgList_$s$fDataMap
"SPEC/VarAccessAnalysis $fDataMap_$cdataCast2 @ [Char] @ [String]" [orphan] [0] forall (w2 :: GHC.Classes.Ord
                                                                                                [GHC.Types.Char])
                                                                                       (w1 :: Data.Data.Data
                                                                                                [GHC.Base.String])
                                                                                       (w :: Data.Data.Data
                                                                                               [GHC.Types.Char])
  Data.Map.Internal.$fDataMap_$cdataCast2 @ [GHC.Types.Char]
                                          @ [GHC.Base.String]
                                          w
                                          w1
                                          w2
  = VarAccessAnalysis.$s$fDataMap_$cdataCast2
"SPEC/VarAccessAnalysis $fDataProgUnit @ (Map String [String])" [orphan] forall (v :: Data.Data.Data
                                                                                        (Data.Map.Internal.Map
                                                                                           GHC.Base.String
                                                                                           [GHC.Base.String]))
  Language.Fortran.$fDataProgUnit @ (Data.Map.Internal.Map
                                       GHC.Base.String [GHC.Base.String])
                                  v
  = VarAccessAnalysis.$s$fDataProgUnit
"SPEC/VarAccessAnalysis $fData[] @ (ProgUnit Anno)" [orphan] forall (v :: Data.Data.Data
                                                                            (Language.Fortran.ProgUnit
                                                                               LanguageFortranTools.Anno))
  Data.Data.$fData[] @ (Language.Fortran.ProgUnit
                          LanguageFortranTools.Anno)
                     v
  = VarAccessAnalysis.$s$fData[]
"SPEC/VarAccessAnalysis $fData[] @ [Char]" [orphan] forall (v :: Data.Data.Data
                                                                   [GHC.Types.Char])
  Data.Data.$fData[] @ [GHC.Types.Char] v
  = VarAccessAnalysis.$s$fDataArgList_$s$fData[]
"SPEC/VarAccessAnalysis $fData[]7 @ (ProgUnit Anno)" [orphan] forall ($dData :: Data.Data.Data
                                                                                  (Language.Fortran.ProgUnit
                                                                                     LanguageFortranTools.Anno))
  Data.Data.$fData[]7 @ (Language.Fortran.ProgUnit
                           LanguageFortranTools.Anno)
                      $dData
  = VarAccessAnalysis.$s$fData[]1
"SPEC/VarAccessAnalysis $fData[]7 @ [Char]" [orphan] forall ($dData :: Data.Data.Data
                                                                         [GHC.Types.Char])
  Data.Data.$fData[]7 @ [GHC.Types.Char] $dData
  = VarAccessAnalysis.$s$fData[]7
"SPEC/VarAccessAnalysis $fEqExpr @ (Map String [String])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                  (Data.Map.Internal.Map
                                                                                     GHC.Base.String
                                                                                     [GHC.Base.String]))
  Language.Fortran.$fEqExpr @ (Data.Map.Internal.Map
                                 GHC.Base.String [GHC.Base.String])
                            v
  = VarAccessAnalysis.$s$fEqExpr
"SPEC/VarAccessAnalysis $fEqExpr_$c/= @ (Map String [String])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                          (Data.Map.Internal.Map
                                                                                             GHC.Base.String
                                                                                             [GHC.Base.String]))
  Language.Fortran.$fEqExpr_$c/= @ (Data.Map.Internal.Map
                                      GHC.Base.String [GHC.Base.String])
                                 $dEq
  = VarAccessAnalysis.$s$fEqExpr_$s$fEqExpr_$c/=
"SPEC/VarAccessAnalysis $fEqMap @ [Char] @ [String]" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                              [GHC.Base.String])
                                                                     (v :: GHC.Classes.Eq
                                                                             [GHC.Types.Char])
  Data.Map.Internal.$fEqMap @ [GHC.Types.Char]
                            @ [GHC.Base.String]
                            v
                            v1
  = VarAccessAnalysis.$s$fEqExpr_$s$fEqMap
"SPEC/VarAccessAnalysis $fEqMap_$c/= @ [Char] @ [String]" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                                      [GHC.Base.String])
                                                                          ($dEq :: GHC.Classes.Eq
                                                                                     [GHC.Types.Char])
  Data.Map.Internal.$fEqMap_$c/= @ [GHC.Types.Char]
                                 @ [GHC.Base.String]
                                 $dEq
                                 $dEq1
  = VarAccessAnalysis.$s$fEqExpr_$s$fEqMap_$c/=
"SPEC/VarAccessAnalysis $fEqVarName @ (Map String [String])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                     (Data.Map.Internal.Map
                                                                                        GHC.Base.String
                                                                                        [GHC.Base.String]))
  Language.Fortran.$fEqVarName @ (Data.Map.Internal.Map
                                    GHC.Base.String [GHC.Base.String])
                               v
  = VarAccessAnalysis.$s$fEqVarName
"SPEC/VarAccessAnalysis $fEqVarName_$c/= @ (Map String [String])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                             (Data.Map.Internal.Map
                                                                                                GHC.Base.String
                                                                                                [GHC.Base.String]))
  Language.Fortran.$fEqVarName_$c/= @ (Data.Map.Internal.Map
                                         GHC.Base.String [GHC.Base.String])
                                    $dEq
  = VarAccessAnalysis.$s$fEqVarName_$s$fEqVarName_$c/=
"SPEC/VarAccessAnalysis $fOrdMap @ [Char] @ [String]" [orphan] forall (v2 :: GHC.Classes.Ord
                                                                               [GHC.Base.String])
                                                                      (v1 :: GHC.Classes.Ord
                                                                               [GHC.Types.Char])
  Data.Map.Internal.$fOrdMap @ [GHC.Types.Char]
                             @ [GHC.Base.String]
                             v1
                             v2
  = VarAccessAnalysis.$s$fOrdMap
"SPEC/VarAccessAnalysis $fOrdVarName @ (Map String [String])" [orphan] forall (v :: GHC.Classes.Ord
                                                                                      (Data.Map.Internal.Map
                                                                                         GHC.Base.String
                                                                                         [GHC.Base.String]))
  Language.Fortran.$fOrdVarName @ (Data.Map.Internal.Map
                                     GHC.Base.String [GHC.Base.String])
                                v
  = VarAccessAnalysis.$s$fOrdVarName
"SPEC/VarAccessAnalysis $fOrdVarName_$cmax @ (Map String [String])" [orphan] [0] forall (w :: GHC.Classes.Ord
                                                                                                (Data.Map.Internal.Map
                                                                                                   GHC.Base.String
                                                                                                   [GHC.Base.String]))
  Language.Fortran.$fOrdVarName_$cmax @ (Data.Map.Internal.Map
                                           GHC.Base.String [GHC.Base.String])
                                      w
  = VarAccessAnalysis.$s$fOrdVarName_$cmax
"SPEC/VarAccessAnalysis $fOrdVarName_$cmin @ (Map String [String])" [orphan] [0] forall (w :: GHC.Classes.Ord
                                                                                                (Data.Map.Internal.Map
                                                                                                   GHC.Base.String
                                                                                                   [GHC.Base.String]))
  Language.Fortran.$fOrdVarName_$cmin @ (Data.Map.Internal.Map
                                           GHC.Base.String [GHC.Base.String])
                                      w
  = VarAccessAnalysis.$s$fOrdVarName_$cmin
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

