
==================== FINAL INTERFACE ====================
2018-11-16 12:45:01.157103313 UTC

interface main:Language.Fortran 8043
  interface hash: 26942ed2c02ba5a0e69903a8482b4eef
  ABI hash: e2add56600673959dbdfe1ac093795c9
  export-list hash: 6ca1e7b188145fc0c602707ea4a1c428
  orphan hash: 28578b5132fe2e1c4e13aa73fc34e5f4
  flag hash: bd870d91eeef610e4b5bae7431f1cd40
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.Fortran.Arg{Language.Fortran.Arg}
  Language.Fortran.ArgList{Language.Fortran.ArgList}
  Language.Fortran.ArgName{Language.Fortran.ASeq Language.Fortran.ArgName Language.Fortran.NullArg}
  Language.Fortran.Attr{Language.Fortran.Allocatable Language.Fortran.Dimension Language.Fortran.External Language.Fortran.Intent Language.Fortran.Intrinsic Language.Fortran.MeasureUnit Language.Fortran.Optional Language.Fortran.Parameter Language.Fortran.Pointer Language.Fortran.Private Language.Fortran.Public Language.Fortran.Save Language.Fortran.Sequence Language.Fortran.Target Language.Fortran.Volatile}
  Language.Fortran.BaseType{Language.Fortran.Character Language.Fortran.Complex Language.Fortran.DerivedType Language.Fortran.Elemental Language.Fortran.Integer Language.Fortran.Logical Language.Fortran.Pure Language.Fortran.Real Language.Fortran.Recursive Language.Fortran.SomeType}
  Language.Fortran.BinOp{Language.Fortran.And Language.Fortran.Concat Language.Fortran.Div Language.Fortran.Minus Language.Fortran.Mul Language.Fortran.Or Language.Fortran.Plus Language.Fortran.Power Language.Fortran.RelEQ Language.Fortran.RelGE Language.Fortran.RelGT Language.Fortran.RelLE Language.Fortran.RelLT Language.Fortran.RelNE}
  Language.Fortran.Block{Language.Fortran.Block}
  Language.Fortran.DataForm{Language.Fortran.Data}
  Language.Fortran.Decl{Language.Fortran.AccessStmt Language.Fortran.AttrStmt Language.Fortran.Common Language.Fortran.DSeq Language.Fortran.DataDecl Language.Fortran.Decl Language.Fortran.DerivedTypeDef Language.Fortran.Equivalence Language.Fortran.ExternalStmt Language.Fortran.Include Language.Fortran.Interface Language.Fortran.MeasureUnitDef Language.Fortran.Namelist Language.Fortran.NullDecl Language.Fortran.TextDecl}
  Language.Fortran.Expr{Language.Fortran.ArrayCon Language.Fortran.AssgExpr Language.Fortran.Bin Language.Fortran.Bound Language.Fortran.CallExpr Language.Fortran.Con Language.Fortran.ConL Language.Fortran.ConS Language.Fortran.ESeq Language.Fortran.Null Language.Fortran.NullExpr Language.Fortran.Sqrt Language.Fortran.Unary Language.Fortran.Var}
  Language.Fortran.Fortran{Language.Fortran.Allocate Language.Fortran.Assg Language.Fortran.Backspace Language.Fortran.Call Language.Fortran.Close Language.Fortran.Continue Language.Fortran.Cycle Language.Fortran.DataStmt Language.Fortran.Deallocate Language.Fortran.DoWhile Language.Fortran.Endfile Language.Fortran.Exit Language.Fortran.FSeq Language.Fortran.For Language.Fortran.Forall Language.Fortran.Format Language.Fortran.Goto Language.Fortran.If Language.Fortran.Inquire Language.Fortran.Label Language.Fortran.NullStmt Language.Fortran.Nullify Language.Fortran.Open Language.Fortran.OpenCLBufferRead Language.Fortran.OpenCLBufferWrite Language.Fortran.OpenCLMap Language.Fortran.OpenCLReduce Language.Fortran.OpenCLSeq Language.Fortran.Pause Language.Fortran.PointerAssg Language.Fortran.Print Language.Fortran.ReadS Language.Fortran.Return Language.Fortran.Rewind Language.Fortran.SelectStmt Language.Fortran.Stop Language.Fortran.TextStmt Language.Fortran.Where Language.Fortran.Write}
  Language.Fortran.Fraction{Language.Fortran.FractionConst Language.Fortran.IntegerConst Language.Fortran.NullFraction}
  Language.Fortran.GSpec{Language.Fortran.GAssg Language.Fortran.GName Language.Fortran.GOper}
  Language.Fortran.Implicit{Language.Fortran.ImplicitNone Language.Fortran.ImplicitNull}
  Language.Fortran.IntentAttr{Language.Fortran.In Language.Fortran.InOut Language.Fortran.Out}
  Language.Fortran.InterfaceSpec{Language.Fortran.FunctionInterface Language.Fortran.ModuleProcedure Language.Fortran.SubroutineInterface}
  Language.Fortran.MeasureUnit
  Language.Fortran.MeasureUnitSpec{Language.Fortran.UnitNone Language.Fortran.UnitProduct Language.Fortran.UnitQuotient}
  Language.Fortran.ProgName
  Language.Fortran.ProgUnit{Language.Fortran.BlockData Language.Fortran.Function Language.Fortran.IncludeProg Language.Fortran.Main Language.Fortran.Module Language.Fortran.NullProg Language.Fortran.PSeq Language.Fortran.Prog Language.Fortran.Sub}
  Language.Fortran.Program
  Language.Fortran.Renames
  Language.Fortran.Span{Language.Fortran.srcSpan}
  Language.Fortran.Spec{Language.Fortran.Access Language.Fortran.Action Language.Fortran.Advance Language.Fortran.Blank Language.Fortran.Delim Language.Fortran.Delimiter Language.Fortran.Direct Language.Fortran.End Language.Fortran.Eor Language.Fortran.Err Language.Fortran.ExFile Language.Fortran.Exist Language.Fortran.FMT Language.Fortran.File Language.Fortran.Floating Language.Fortran.Form Language.Fortran.Formatted Language.Fortran.IOLength Language.Fortran.IOStat Language.Fortran.NML Language.Fortran.Name Language.Fortran.Named Language.Fortran.NextRec Language.Fortran.NoSpec Language.Fortran.Number Language.Fortran.Opened Language.Fortran.Pad Language.Fortran.Position Language.Fortran.Read Language.Fortran.ReadWrite Language.Fortran.Rec Language.Fortran.Recl Language.Fortran.Sequential Language.Fortran.Size Language.Fortran.Status Language.Fortran.StringLit Language.Fortran.Unformatted Language.Fortran.Unit Language.Fortran.WriteSp}
  Language.Fortran.SrcLoc{Language.Fortran.SrcLoc srcColumn srcFilename srcLine}
  Language.Fortran.SrcSpan
  Language.Fortran.SubName{Language.Fortran.NullSubName Language.Fortran.SubName}
  Language.Fortran.Tagged{Language.Fortran.tag}
  Language.Fortran.Type{Language.Fortran.ArrayT Language.Fortran.BaseType}
  Language.Fortran.UnaryOp{Language.Fortran.Not Language.Fortran.UMinus}
  Language.Fortran.UseBlock{Language.Fortran.UseBlock}
  Language.Fortran.Uses{Language.Fortran.Use Language.Fortran.UseNil}
  Language.Fortran.VarName{Language.Fortran.VarName}
  Language.Fortran.Variable
module dependencies:
package dependencies: base-4.11.1.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0 syb-0.7
orphans: syb-0.7:Data.Generics.Instances base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Data b150502d549600eff3202c16ff6cf22d
import  -/  base-4.11.1.0:Data.Typeable 9548bf378a98cc2492ab02d9a516a250
import  -/  base-4.11.1.0:Data.Typeable.Internal 0b0201144a992d956fd13a21fc2d4b48
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.Read b9e6d20d40da8c8a12b566d22e1160e0
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:Text.ParserCombinators.ReadPrec d0ebf984ed486435a97481288b73febb
import  -/  base-4.11.1.0:Text.Read.Lex f8ad6f9ae74ae325ba69a4fa5c82aaca
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  syb-0.7:Data.Generics 2ddc257f9ac35414fc37ff4d19b4d388
82887652fad9210869d54e69e10af507
  $cASeq :: Data.Data.Constr
  {- Strictness: m -}
6bda0a3b00fc5c387d7521d74c5b0d2a
  $cAccess :: Data.Data.Constr
  {- Strictness: m -}
9b153b40806d6f8697fa13c4fd1d8045
  $cAccessStmt :: Data.Data.Constr
  {- Strictness: m -}
513dd2ca5099f0ab7c60ac7be131682e
  $cAction :: Data.Data.Constr
  {- Strictness: m -}
0f90f3687965dfccd53f7264fc0c9d7d
  $cAdvance :: Data.Data.Constr
  {- Strictness: m -}
c63208c4170142bb475bda152509d615
  $cAllocatable :: Data.Data.Constr
  {- Strictness: m -}
45b5b641ead4b71959d9d376ba96a53a
  $cAllocate :: Data.Data.Constr
  {- Strictness: m -}
7394cbeda582e867a53273846ac5b584
  $cAnd :: Data.Data.Constr
  {- Strictness: m -}
a23e0fa34ee0c8716b829714446f6c70
  $cArg :: Data.Data.Constr
  {- Strictness: m -}
1140d10036eb54e9ba1d19c6220ea98e
  $cArgList :: Data.Data.Constr
  {- Strictness: m -}
68fab1716e6fc65c6df5aa1c34712bf9
  $cArgName :: Data.Data.Constr
  {- Strictness: m -}
11b60fc097b69bdd8fb7540776476230
  $cArrayCon :: Data.Data.Constr
  {- Strictness: m -}
a32ed9399df4d9fd3c3029afc1a54b21
  $cArrayT :: Data.Data.Constr
  {- Strictness: m -}
696f9f7de7559c828ad2194490e15921
  $cAssg :: Data.Data.Constr
  {- Strictness: m -}
c19c19c76e753dd44a14cfd1bb2720ab
  $cAssgExpr :: Data.Data.Constr
  {- Strictness: m -}
4e95814c92703a5dfdc8b27802350a59
  $cAttrStmt :: Data.Data.Constr
  {- Strictness: m -}
5ae9abff899d6605f8baffad3866bf90
  $cBackspace :: Data.Data.Constr
  {- Strictness: m -}
17c49800317374168f28362ced48149c
  $cBaseType :: Data.Data.Constr
  {- Strictness: m -}
cf950c108c3773e069f3ebed6a036617
  $cBin :: Data.Data.Constr
  {- Strictness: m -}
851da9bb809d6693f566032d37e375b2
  $cBlank :: Data.Data.Constr
  {- Strictness: m -}
72209d7aeb5545b443edf6337afdd2b9
  $cBlock :: Data.Data.Constr
  {- Strictness: m -}
ffc1ceb6f1272f0c72374c05d311bec2
  $cBlockData :: Data.Data.Constr
  {- Strictness: m -}
669f75ac39194bb02a7a1701aa26f6fb
  $cBound :: Data.Data.Constr
  {- Strictness: m -}
cb2b7e9456407d5eb7231b87d937048c
  $cCall :: Data.Data.Constr
  {- Strictness: m -}
0796c8d1a3384969db67ce69dd7460c9
  $cCallExpr :: Data.Data.Constr
  {- Strictness: m -}
36066363fabff50f69f3fb5b946d1fa8
  $cCharacter :: Data.Data.Constr
  {- Strictness: m -}
86e41fa99ff22f813b277d9be051aa1a
  $cClose :: Data.Data.Constr
  {- Strictness: m -}
64243bed0eec96b931885cf28109e02f
  $cCommon :: Data.Data.Constr
  {- Strictness: m -}
6dcb8e7e2fdfce13ca7574bf2d795854
  $cComplex :: Data.Data.Constr
  {- Strictness: m -}
2d054bd26b9ca9757ccbad347e413498
  $cCon :: Data.Data.Constr
  {- Strictness: m -}
7cbdc680db062ce99ccd0d007b7a202b
  $cConL :: Data.Data.Constr
  {- Strictness: m -}
6f1d82e4be8d9c80a7eb3acd24f2a720
  $cConS :: Data.Data.Constr
  {- Strictness: m -}
16aee8959734f97d6d723297134f0f0c
  $cConcat :: Data.Data.Constr
  {- Strictness: m -}
445adadffdac85fb7e50e9dd3aa377cb
  $cContinue :: Data.Data.Constr
  {- Strictness: m -}
b68020b9ac623e2406caa9c1cc878b13
  $cCycle :: Data.Data.Constr
  {- Strictness: m -}
9c389311b0ddf8555b1ac1281fe231c6
  $cDSeq :: Data.Data.Constr
  {- Strictness: m -}
e39c7d0761e286162913402707083e11
  $cData :: Data.Data.Constr
  {- Strictness: m -}
25f4f770af18a44aca428b4532b60ad4
  $cDataDecl :: Data.Data.Constr
  {- Strictness: m -}
1e8b0e0d88766e6566e61876df6ad303
  $cDataStmt :: Data.Data.Constr
  {- Strictness: m -}
344a5adebbff0a9da7b23f8459e2ad32
  $cDeallocate :: Data.Data.Constr
  {- Strictness: m -}
d9fe94525bc3c5d722053796bacdb132
  $cDecl :: Data.Data.Constr
  {- Strictness: m -}
c8b7c6427bf90bda6f36acd9622626b4
  $cDelim :: Data.Data.Constr
  {- Strictness: m -}
e9d579f9946f66d0619e9988f160afce
  $cDelimiter :: Data.Data.Constr
  {- Strictness: m -}
6f2f2884ac18ea586c20935c0a39486a
  $cDerivedType :: Data.Data.Constr
  {- Strictness: m -}
b1cfdf8a186ef5e7fd8905b8ac8c04f5
  $cDerivedTypeDef :: Data.Data.Constr
  {- Strictness: m -}
c6b4fe1a8d741fd2bf30f3c4c89478c4
  $cDimension :: Data.Data.Constr
  {- Strictness: m -}
019e385a51a7eb9a5ff31a04001027a0
  $cDirect :: Data.Data.Constr
  {- Strictness: m -}
b381ff808bd743e6f216b9b07c81aa0e
  $cDiv :: Data.Data.Constr
  {- Strictness: m -}
a901a4a85e1f615a0bdf73d67f8eb65b
  $cDoWhile :: Data.Data.Constr
  {- Strictness: m -}
3849daea4f786211b6013c714fd383cb
  $cESeq :: Data.Data.Constr
  {- Strictness: m -}
8f937ba1bb448ee910062d4ff893ac0d
  $cElemental :: Data.Data.Constr
  {- Strictness: m -}
6cfc9e3e37a1b6c96e360238619614b1
  $cEnd :: Data.Data.Constr
  {- Strictness: m -}
86f79b8d3732cc3783967c15de4f5aac
  $cEndfile :: Data.Data.Constr
  {- Strictness: m -}
58fff7e2a01cc497b3956d7655b3161a
  $cEor :: Data.Data.Constr
  {- Strictness: m -}
6225f59fc5d1c989f54aeb8ec1642f6a
  $cEquivalence :: Data.Data.Constr
  {- Strictness: m -}
ad9a6f77e7defc2d99752f50eb00b129
  $cErr :: Data.Data.Constr
  {- Strictness: m -}
c61d534dda40f95e4d0267cba561048c
  $cExFile :: Data.Data.Constr
  {- Strictness: m -}
b7661984c91738397da8f67cbc5738ac
  $cExist :: Data.Data.Constr
  {- Strictness: m -}
2bdfcb3c0cd08ba901e4915bb7580094
  $cExit :: Data.Data.Constr
  {- Strictness: m -}
4bf5969e00bb43331016ad6c863da685
  $cExternal :: Data.Data.Constr
  {- Strictness: m -}
1b9e9f1396c81ce0c41f0fec03e9939c
  $cExternalStmt :: Data.Data.Constr
  {- Strictness: m -}
0129eec28c4c287c0375048f52d94b46
  $cFMT :: Data.Data.Constr
  {- Strictness: m -}
8844be69f52b05cd9b3ab7991d650c35
  $cFSeq :: Data.Data.Constr
  {- Strictness: m -}
0a6238f3c8e29f44a5ede6a219c58d81
  $cFile :: Data.Data.Constr
  {- Strictness: m -}
9d18cd3fb678cd10ca48cefe551ee341
  $cFloating :: Data.Data.Constr
  {- Strictness: m -}
f8560658e6176d7e202b9e47c185e6bd
  $cFor :: Data.Data.Constr
  {- Strictness: m -}
0a47539c30d56fa3281a55fab52240ef
  $cForall :: Data.Data.Constr
  {- Strictness: m -}
575e63aeaa27fe29c0f197d59d625eaf
  $cForm :: Data.Data.Constr
  {- Strictness: m -}
0ed6da74a93f6fe8dd92ca0a13fcbef9
  $cFormat :: Data.Data.Constr
  {- Strictness: m -}
8bf2bb48a8552f4558e1790540b6bfa3
  $cFormatted :: Data.Data.Constr
  {- Strictness: m -}
85f26ab9a984f7484f454500fc3e212a
  $cFractionConst :: Data.Data.Constr
  {- Strictness: m -}
38c8aa21dd29b9100759915f5dff0d45
  $cFunction :: Data.Data.Constr
  {- Strictness: m -}
b6f1b11e83e7fd317fd0622f72212f1e
  $cFunctionInterface :: Data.Data.Constr
  {- Strictness: m -}
4866da9751ea9d212f66f95d78b80150
  $cGAssg :: Data.Data.Constr
  {- Strictness: m -}
c1f8a1e162fb0ce5dd45dceb32a9022f
  $cGName :: Data.Data.Constr
  {- Strictness: m -}
907b7fd9e6d1bdec0d0f151941ba007b
  $cGOper :: Data.Data.Constr
  {- Strictness: m -}
a5e27ebd6c9c531c6367425f070a0b1d
  $cGoto :: Data.Data.Constr
  {- Strictness: m -}
6d25203a644a61894ecdd70a7d02fc68
  $cIOLength :: Data.Data.Constr
  {- Strictness: m -}
4d7b96c45ac00534e5b948cdcf81b79e
  $cIOStat :: Data.Data.Constr
  {- Strictness: m -}
ac4f19edf99d50f84e510f6b965bea3d
  $cIf :: Data.Data.Constr
  {- Strictness: m -}
ad83e548969e5c7ce4cfe44670804a56
  $cImplicitNone :: Data.Data.Constr
  {- Strictness: m -}
539c347bcbed594b226a3baaad3853a9
  $cImplicitNull :: Data.Data.Constr
  {- Strictness: m -}
4a684e83f56e3eee51be760f742d78d3
  $cIn :: Data.Data.Constr
  {- Strictness: m -}
8baf9a1efcf0eccfb1571a9a3654d39e
  $cInOut :: Data.Data.Constr
  {- Strictness: m -}
e04d43aebf262531418306f0325972c1
  $cInclude :: Data.Data.Constr
  {- Strictness: m -}
f4858867771d2017da6bda6298b4f4f8
  $cIncludeProg :: Data.Data.Constr
  {- Strictness: m -}
85c4356a628ea6d3d2cc3333def76dc2
  $cInquire :: Data.Data.Constr
  {- Strictness: m -}
0f1d8d5f24516ed1d10e53f052321bb0
  $cInteger :: Data.Data.Constr
  {- Strictness: m -}
1d8f4d0aed530473048a6366fb85b80a
  $cIntegerConst :: Data.Data.Constr
  {- Strictness: m -}
598fa6090a166c6996d560ca0e9d6896
  $cIntent :: Data.Data.Constr
  {- Strictness: m -}
691e35ade35109aaf23bcf1129eb240a
  $cInterface :: Data.Data.Constr
  {- Strictness: m -}
e97269db1b6a994bf53191e8d9b648db
  $cIntrinsic :: Data.Data.Constr
  {- Strictness: m -}
2bad6bb5bd5566250450c38b226aa616
  $cLabel :: Data.Data.Constr
  {- Strictness: m -}
1242fa9bf92fea68e807ad870bb8cba6
  $cLogical :: Data.Data.Constr
  {- Strictness: m -}
4fd3b7cf79956c1e30ca45be2cf1750c
  $cMain :: Data.Data.Constr
  {- Strictness: m -}
d8d1b43c56e0867f5d967a85c3ef8212
  $cMeasureUnit :: Data.Data.Constr
  {- Strictness: m -}
3c8aafb03e81afaae388863afce01ade
  $cMeasureUnitDef :: Data.Data.Constr
  {- Strictness: m -}
6066eae2e15645549a2f558b0cb67ec1
  $cMinus :: Data.Data.Constr
  {- Strictness: m -}
34cf35457405c4a6542abd401b496af8
  $cModule :: Data.Data.Constr
  {- Strictness: m -}
c71d58eba2e50b6c876daf5058d0fe5e
  $cModuleProcedure :: Data.Data.Constr
  {- Strictness: m -}
b3edd9fa2a8572aa17fe994a98f12a3d
  $cMul :: Data.Data.Constr
  {- Strictness: m -}
15fefb6687120bebf95c3a2af4fd85e7
  $cNML :: Data.Data.Constr
  {- Strictness: m -}
32d2d8fc880c7ecca6d858aaa54d731b
  $cName :: Data.Data.Constr
  {- Strictness: m -}
93b36ef5143613e059bfbfebb2c7f9fd
  $cNamed :: Data.Data.Constr
  {- Strictness: m -}
1b08159c921a1917521ad7eeeec0a7d4
  $cNamelist :: Data.Data.Constr
  {- Strictness: m -}
e76ae1f54e0c150b83e1b720a1145284
  $cNextRec :: Data.Data.Constr
  {- Strictness: m -}
3b2e04346a425223062d6d8193b16115
  $cNoSpec :: Data.Data.Constr
  {- Strictness: m -}
a6bcb94ff4ac49c0b2b42f0ebdfcc7f8
  $cNot :: Data.Data.Constr
  {- Strictness: m -}
ee4f586bc84113b15ba3e71070264877
  $cNull :: Data.Data.Constr
  {- Strictness: m -}
6e471a198af8a605fc75893b3d7557ab
  $cNullArg :: Data.Data.Constr
  {- Strictness: m -}
2c7864d2ef393466b4e2b554f0a0d55a
  $cNullDecl :: Data.Data.Constr
  {- Strictness: m -}
864a258582c9cd6ce8d6147a53786a20
  $cNullExpr :: Data.Data.Constr
  {- Strictness: m -}
54fd9d0333c2cbb268e5d25c4c612fa4
  $cNullFraction :: Data.Data.Constr
  {- Strictness: m -}
f84049fb712bbb92c42c6d183382230e
  $cNullProg :: Data.Data.Constr
  {- Strictness: m -}
6fa1d485adbe09e7e6627bbcd9bddfc9
  $cNullStmt :: Data.Data.Constr
  {- Strictness: m -}
1d3e8ef6772df741f71e093309bd2467
  $cNullSubName :: Data.Data.Constr
  {- Strictness: m -}
251bb0f6d1d8f1fa34873f642729eae0
  $cNullify :: Data.Data.Constr
  {- Strictness: m -}
e676a967df66fe53792359fed6833f3a
  $cNumber :: Data.Data.Constr
  {- Strictness: m -}
834f6fff11196a1346e895bfcba43cd7
  $cOpen :: Data.Data.Constr
  {- Strictness: m -}
b35afdcdc8d2829acec767d3146d6042
  $cOpenCLBufferRead :: Data.Data.Constr
  {- Strictness: m -}
e4c046f13edbad5bb72628af478cb77e
  $cOpenCLBufferWrite :: Data.Data.Constr
  {- Strictness: m -}
f6fb6186612c1ca61220d1474a97967b
  $cOpenCLMap :: Data.Data.Constr
  {- Strictness: m -}
4821800794118a09b08e50397b82e66c
  $cOpenCLReduce :: Data.Data.Constr
  {- Strictness: m -}
417881348eba415cbe257166902dff26
  $cOpenCLSeq :: Data.Data.Constr
  {- Strictness: m -}
3929da5f67bb8ea24131e476d5a1b4fc
  $cOpened :: Data.Data.Constr
  {- Strictness: m -}
d6f119bd9deb0f8ae0394855b84a4beb
  $cOptional :: Data.Data.Constr
  {- Strictness: m -}
c4dc668c308843cec14a74b22158b6a6
  $cOr :: Data.Data.Constr
  {- Strictness: m -}
105baf831642016db1ec0718e1fb2517
  $cOut :: Data.Data.Constr
  {- Strictness: m -}
6dda3de80f8519f1053985859537c8e3
  $cPSeq :: Data.Data.Constr
  {- Strictness: m -}
152389e7ff24fa3c9f162b6213b9a056
  $cPad :: Data.Data.Constr
  {- Strictness: m -}
8e4f2c3539d51a2bc217e4d641274992
  $cParameter :: Data.Data.Constr
  {- Strictness: m -}
2dd9c3313bc3c354cf026ebfe9ea7d3b
  $cPause :: Data.Data.Constr
  {- Strictness: m -}
2399097bee5697546ae6c7e78e9a52be
  $cPlus :: Data.Data.Constr
  {- Strictness: m -}
1ee844ce74262cdefb801a10fea61be3
  $cPointer :: Data.Data.Constr
  {- Strictness: m -}
d926fa02033296510cfa512b11c47644
  $cPointerAssg :: Data.Data.Constr
  {- Strictness: m -}
2cd02f79271e68858ccf2e95f8e8dc6e
  $cPosition :: Data.Data.Constr
  {- Strictness: m -}
fb9b611f7d02e48f3e54eae457dc4c9e
  $cPower :: Data.Data.Constr
  {- Strictness: m -}
6ec1b6dd5509b2e2c989e175320df2b0
  $cPrint :: Data.Data.Constr
  {- Strictness: m -}
3a73ac5813c4cfb48096d54abd7b7ed1
  $cPrivate :: Data.Data.Constr
  {- Strictness: m -}
fd42a2ca083e39ad4dbfd5c80e0f209a
  $cProg :: Data.Data.Constr
  {- Strictness: m -}
442e85e659c8a26c72824bb3d5e9d6a6
  $cPublic :: Data.Data.Constr
  {- Strictness: m -}
8a7547cf3292bff21da0043413966010
  $cPure :: Data.Data.Constr
  {- Strictness: m -}
1014c97f6a13f9595e4d15bea00c0a4f
  $cRead :: Data.Data.Constr
  {- Strictness: m -}
08c7274dc5d93ae4496937ca4e562e2e
  $cReadS :: Data.Data.Constr
  {- Strictness: m -}
d6d51417d3d7e11955410165b44f7006
  $cReadWrite :: Data.Data.Constr
  {- Strictness: m -}
6a0a0ac76a6426167c73b47134abf6bc
  $cReal :: Data.Data.Constr
  {- Strictness: m -}
e407eedb46bf10314b51deda6fd802af
  $cRec :: Data.Data.Constr
  {- Strictness: m -}
c2932b94ad1698e78a11b104a9bf13e5
  $cRecl :: Data.Data.Constr
  {- Strictness: m -}
c2384c37bc3517c4860a7eba5576c786
  $cRecursive :: Data.Data.Constr
  {- Strictness: m -}
1df24913bf532fa4a3d5a4cc570d8fe3
  $cRelEQ :: Data.Data.Constr
  {- Strictness: m -}
48f0be59004dc100eb3d57f1a62bfd88
  $cRelGE :: Data.Data.Constr
  {- Strictness: m -}
426d1eed92c7deb62d4fd4dabce96b87
  $cRelGT :: Data.Data.Constr
  {- Strictness: m -}
180f8449e4b4157667a04c394434c5e7
  $cRelLE :: Data.Data.Constr
  {- Strictness: m -}
fc67ed6c14596592e36b14885dba319c
  $cRelLT :: Data.Data.Constr
  {- Strictness: m -}
1992486cba31cacf20c1033b0da694cf
  $cRelNE :: Data.Data.Constr
  {- Strictness: m -}
725f6a866d5c1d254d3cd0afed48b3c7
  $cReturn :: Data.Data.Constr
  {- Strictness: m -}
02d17ec709ae73c028687269828d87be
  $cRewind :: Data.Data.Constr
  {- Strictness: m -}
c6650598229ffd4f423c8c3221acbb30
  $cSave :: Data.Data.Constr
  {- Strictness: m -}
75e9aedbce283c9e9a2ed3653f36423d
  $cSelectStmt :: Data.Data.Constr
  {- Strictness: m -}
a0464e0823e7e748287db6fa3f07d0e6
  $cSequence :: Data.Data.Constr
  {- Strictness: m -}
4df28f8ff82a4ce94f0a5fdd35e40425
  $cSequential :: Data.Data.Constr
  {- Strictness: m -}
b95f99f0b1db3f6b98e08aff55e162db
  $cSize :: Data.Data.Constr
  {- Strictness: m -}
b2b599d927b20c33dfb41c3dbca7544c
  $cSomeType :: Data.Data.Constr
  {- Strictness: m -}
5ed0d752b7a4e800934b2d6b64c6536f
  $cSqrt :: Data.Data.Constr
  {- Strictness: m -}
20c2d9c25f0b4aca0d0a3db4db41c75f
  $cSrcLoc :: Data.Data.Constr
  {- Strictness: m -}
f7bf2f13f5a67d5c15094b0f9896df64
  $cStatus :: Data.Data.Constr
  {- Strictness: m -}
3836d901c13bc142b62997a709df0847
  $cStop :: Data.Data.Constr
  {- Strictness: m -}
20094871cc5332299e8c72d54c1f0ba6
  $cStringLit :: Data.Data.Constr
  {- Strictness: m -}
738c31dad219448b7840ea4d23a437dd
  $cSub :: Data.Data.Constr
  {- Strictness: m -}
4a5867eac20738fc2f5fde038a61e3bf
  $cSubName :: Data.Data.Constr
  {- Strictness: m -}
99a52517a6757a6be99b3ce4fc3afb2c
  $cSubroutineInterface :: Data.Data.Constr
  {- Strictness: m -}
8ed9a0f69de1ae92102fa75f3e989b3a
  $cTarget :: Data.Data.Constr
  {- Strictness: m -}
286c387e9369cd9646dcf483676bf4e8
  $cTextDecl :: Data.Data.Constr
  {- Strictness: m -}
f38e0def142217022711ad9a3a527fe0
  $cTextStmt :: Data.Data.Constr
  {- Strictness: m -}
e045fe93de1eefcc83bddff22002b6ff
  $cUMinus :: Data.Data.Constr
  {- Strictness: m -}
cec9639850ea5996aa286c80b24f8efa
  $cUnary :: Data.Data.Constr
  {- Strictness: m -}
6c24fc65b96fb80580ec156fa7221106
  $cUnformatted :: Data.Data.Constr
  {- Strictness: m -}
9cef2525b1061faa8822e6395d213a31
  $cUnit :: Data.Data.Constr
  {- Strictness: m -}
bfc8e9f84b35d60d6b8031cf90a76549
  $cUnitNone :: Data.Data.Constr
  {- Strictness: m -}
7358f7b8e35fa7e9369bc479bec10bb7
  $cUnitProduct :: Data.Data.Constr
  {- Strictness: m -}
93e168c38bca9ea3522ba63343ae813b
  $cUnitQuotient :: Data.Data.Constr
  {- Strictness: m -}
a7ac82a36c085fbfec422f8db092340f
  $cUse :: Data.Data.Constr
  {- Strictness: m -}
333cdbd1152d1a94f7b5f3e2955b4779
  $cUseBlock :: Data.Data.Constr
  {- Strictness: m -}
c341f3122eeb16c6c7ccce5576c138c5
  $cUseNil :: Data.Data.Constr
  {- Strictness: m -}
d1e0a1a5252cee5464d8285a145355d5
  $cVar :: Data.Data.Constr
  {- Strictness: m -}
3442576aaa86486b3a4e4f679767de14
  $cVarName :: Data.Data.Constr
  {- Strictness: m -}
4a6a19c3c3b1738330fce7aed88aebd0
  $cVolatile :: Data.Data.Constr
  {- Strictness: m -}
6dfdeef2fe7df233d1c6d9063919c485
  $cWhere :: Data.Data.Constr
  {- Strictness: m -}
2006a549ccd5e983579da918f5fa833f
  $cWrite :: Data.Data.Constr
  {- Strictness: m -}
6fa4367d90cf7c2e048bb6428de4f548
  $cWriteSp :: Data.Data.Constr
  {- Strictness: m -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fDataArg14 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Arg
                                                                       p>_N)
                  (Language.Fortran.$fDataArg_$cgfoldl @ p v)
                  (Language.Fortran.$fDataArg_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Arg p) ->
                   case ds of wild { Language.Fortran.Arg ds1 ds2 ds3 ->
                   Language.Fortran.$cArg })
                  (\ (ds :: Language.Fortran.Arg p) -> Language.Fortran.$tArg)
                  (Language.Fortran.$fDataArg_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Arg p)))
                  (Language.Fortran.$fDataArg6 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Arg p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Arg p>_R)
                  (Language.Fortran.$fDataArg_$cgmapQl @ p v)
                  (Language.Fortran.$fDataArg_$cgmapQr @ p v)
                  (Language.Fortran.$fDataArg_$cgmapQ @ p v)
                  (Language.Fortran.$fDataArg_$cgmapQi @ p v)
                  (Language.Fortran.$fDataArg_$cgmapM @ p v)
                  (Language.Fortran.$fDataArg_$cgmapMp @ p v)
                  (Language.Fortran.$fDataArg_$cgmapMo @ p v) -}
ff09e197ddd4900e127a1e4be2743ad9
  $fDataArg1 :: g -> Data.Data.Qi u g
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ u @ g (ds :: g) -> Language.Fortran.$fDataArg2 @ g @ u) -}
2e3e85fa1d7bd23b6165a2a8b6abbd3a
  $fDataArg10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Arg"#) -}
44e13b03e5b9fbbabf3fbf82b4f73530
  $fDataArg11 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArg12) -}
d11b837ca830c812b930eb265007c084
  $fDataArg12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cArg
                   (GHC.Types.[] @ Data.Data.Constr)) -}
60eb74dcb5c84dd7487aac49718633dc
  $fDataArg13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataArg10) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg14 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Arg p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Arg
                   @ p
                   Language.Fortran.$fDataArg15
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg15 :: Data.Typeable.Internal.TypeRep Language.Fortran.Arg
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Arg
                        2359460476297616621##
                        5217012210755420883##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArg9
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Arg
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
2ce7995746f61b1b331beee834a26c56
  $fDataArg2 :: Data.Data.Qi u g
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ g @ u ->
                 Data.Data.Qi
                   @ *
                   @ u
                   @ g
                   Language.Fortran.$fDataArg3
                   (GHC.Base.Nothing @ u)) -}
ef0f6da38aaaec75d161a2dd69810f41
  $fDataArg3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
86271c530c71e2a28a8e806715875b17
  $fDataArg4 :: g -> [u] -> [u]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ u @ g (ds :: g) (eta :: [u]) -> eta) -}
0c14e8553c58782068b4a76339328da7
  $fDataArg5 :: g -> r -> r
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ r @ g (ds :: g) (eta :: r) -> eta) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg6 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Arg p
    -> Data.Functor.Identity.Identity (Language.Fortran.Arg p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Arg p) ->
                 Language.Fortran.$fDataArg_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
fd326c0f0f30670264ee75a8ab2d22b7
  $fDataArg7 :: g -> g
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ g (v :: g) -> v) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg8 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Arg
                        2359460476297616621##
                        5217012210755420883##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArg9
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Arg
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Arg
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
2e474214409dcd6d483b1c658076e44a
  $fDataArg9 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataArg10) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fDataArgList8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ArgList
                                                                       p>_N)
                  (Language.Fortran.$fDataArgList_$cgfoldl @ p v)
                  (Language.Fortran.$fDataArgList_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.ArgList p) ->
                   case ds of wild { Language.Fortran.ArgList ds1 ds2 ->
                   Language.Fortran.$cArgList })
                  (\ (ds :: Language.Fortran.ArgList p) ->
                   Language.Fortran.$tArgList)
                  (Language.Fortran.$fDataArgList_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.ArgList p)))
                  (Language.Fortran.$fDataArgList1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ArgList p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ArgList p>_R)
                  (Language.Fortran.$fDataArgList_$cgmapQl @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapQr @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapQ @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapQi @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapM @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapMp @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapMo @ p v) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgList p
    -> Data.Functor.Identity.Identity (Language.Fortran.ArgList p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.ArgList p) ->
                 case x0 of wild { Language.Fortran.ArgList a1 a2 ->
                 (Language.Fortran.ArgList
                    @ p
                    (ds @ p $dData1 a1)
                    (ds
                       @ (Language.Fortran.Expr p)
                       (Language.Fortran.$fDataExpr @ p $dData1)
                       a2))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.ArgList p>_R)) }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgList
                        2658788418971500205##
                        5050220201243405606##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgList3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.ArgList
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.ArgList
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
1c465dccd95afa5263d6008b1f6cdb73
  $fDataArgList3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataArgList4) -}
55a24fe5c156f596b6924d1c8fa08726
  $fDataArgList4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ArgList"#) -}
e752e1b8ab200e8993403a4fcc276c79
  $fDataArgList5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArgList6) -}
b0a33134700207981086be6de670e1d6
  $fDataArgList6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cArgList
                   (GHC.Types.[] @ Data.Data.Constr)) -}
becbff37a9030812fcb8357d7acdd41a
  $fDataArgList7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataArgList4) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.ArgList p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ArgList
                   @ p
                   Language.Fortran.$fDataArgList9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.ArgList
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgList
                        2658788418971500205##
                        5050220201243405606##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgList3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.ArgList
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgList p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataArgList2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ArgList p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ArgList <p>_N)) } } } }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ArgList p
    -> c (Language.Fortran.ArgList p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.ArgList p) ->
                 case ds of wild { Language.Fortran.ArgList a1 a2 ->
                 k @ (Language.Fortran.Expr p)
                   @ (Language.Fortran.ArgList p)
                   $dData2
                   (k @ p
                      @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      $dData1
                      (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                         (Language.Fortran.ArgList @ p))
                      a1)
                   a2 }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   lvl295 :: m (p
                                -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                   = GHC.Base.return
                       @ m
                       $dMonad
                       @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                       (Language.Fortran.ArgList @ p)
                 } in
                 \ (ds1 :: Language.Fortran.ArgList p) ->
                 case ds1 of wild { Language.Fortran.ArgList a1 a2 ->
                 let {
                   lvl296 :: m (Language.Fortran.Expr p)
                   = ds @ (Language.Fortran.Expr p) $dData2 a2
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                   @ (Language.Fortran.ArgList p)
                   (let {
                      lvl297 :: m p = ds @ p $dData1 a1
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      lvl295
                      (\ (c' :: p
                                -> Language.Fortran.Expr p -> Language.Fortran.ArgList p) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ p
                         @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                         lvl297
                         (\ (x' :: p) ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                            (c' x'))))
                   (\ (c' :: Language.Fortran.Expr p -> Language.Fortran.ArgList p) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Language.Fortran.Expr p)
                      @ (Language.Fortran.ArgList p)
                      lvl296
                      (\ (x' :: Language.Fortran.Expr p) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (Language.Fortran.ArgList p)
                         (c' x'))) }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgList p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.ArgList p) ->
                 case w363 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 GHC.Types.:
                   @ u
                   (w362 @ p w ww1)
                   (GHC.Types.:
                      @ u
                      (w362
                         @ (Language.Fortran.Expr p)
                         (Language.Fortran.$fDataExpr @ p w)
                         ww2)
                      (GHC.Types.[] @ u)) }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgList p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.ArgList p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w364 of ww2 { Language.Fortran.ArgList ww3 ww4 ->
                 Language.Fortran.$w$cgmapQi1 @ p w @ u ww1 w363 ww3 ww4 } }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgList p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 (\ (ds3 :: Language.Fortran.ArgList p) ->
                  case ds3 of wild { Language.Fortran.ArgList a1 a2 ->
                  (ds
                     (ds ds1 (ds2 @ p $dData1 a1))
                     (ds2 @ (Language.Fortran.Expr p) $dData2 a2))
                    `cast`
                  (Sym (Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.ArgList p>_P)) })
                   `cast`
                 (<Language.Fortran.ArgList p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.ArgList p>_P)) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgList p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.ArgList p) ->
                 case w365 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr1
                   @ p
                   w
                   @ r
                   @ r'
                   w362
                   w363
                   w364
                   ww1
                   ww2 }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataArgList_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ArgList p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ (Language.Fortran.Expr p)
                   @ (Language.Fortran.ArgList p)
                   $dData2
                   (k @ p
                      @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      $dData1
                      (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                         (Language.Fortran.ArgList @ p)))) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fDataArgName5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ArgName
                                                                       p>_N)
                  (Language.Fortran.$fDataArgName_$cgfoldl @ p v)
                  (Language.Fortran.$fDataArgName_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.ArgName p) ->
                   case ds of wild {
                     Language.Fortran.ArgName ds1 ds2 -> Language.Fortran.$cArgName
                     Language.Fortran.ASeq ds1 ds2 ds3 -> Language.Fortran.$cASeq
                     Language.Fortran.NullArg ds1 -> Language.Fortran.$cNullArg })
                  (\ (ds :: Language.Fortran.ArgName p) ->
                   Language.Fortran.$tArgName)
                  (Language.Fortran.$fDataArgName_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.ArgName p)))
                  (Language.Fortran.$fDataArgName1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ArgName p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ArgName p>_R)
                  (Language.Fortran.$fDataArgName_$cgmapQl @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapQr @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapQ @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapQi @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapM @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapMp @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapMo @ p v) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgName p
    -> Data.Functor.Identity.Identity (Language.Fortran.ArgName p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgName
                        4187460949675603402##
                        17695948308021011151##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgName3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.ArgName
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.ArgName
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
6867e85778b2fa18345893dc4582ef9a
  $fDataArgName3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataArgName4) -}
dfc0bc1f3f7246a0941d447b46dfe9ef
  $fDataArgName4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ArgName"#) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.ArgName p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ArgName
                   @ p
                   Language.Fortran.$fDataArgName6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.ArgName
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgName
                        4187460949675603402##
                        17695948308021011151##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgName3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.ArgName
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgName p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataArgName2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ArgName p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ArgName <p>_N)) } } } }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ArgName p
    -> c (Language.Fortran.ArgName p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgName p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgName p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgName p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgName p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fDataArgName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ArgName p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Arg p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataArg8 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Arg p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Arg p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Arg p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Arg <p>_N)) } } } }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Arg p
    -> c (Language.Fortran.Arg p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.ArgName p)
                   = Language.Fortran.$fDataArgName @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Arg p) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 k @ Language.Fortran.SrcSpan
                   @ (Language.Fortran.Arg p)
                   Language.Fortran.$fDataArg_$s$fData(,)
                   (k @ (Language.Fortran.ArgName p)
                      @ (Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                      $dData2
                      (k @ p
                         @ (Language.Fortran.ArgName p
                            -> Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                         $dData1
                         (z @ (p
                               -> Language.Fortran.ArgName p
                               -> Language.Fortran.SrcSpan
                               -> Language.Fortran.Arg p)
                            (Language.Fortran.Arg @ p))
                         a1)
                      a2)
                   a3 }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataArg_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Arg p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Arg p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Arg p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Arg p, GHC.Types.Bool)
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fDataArg_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Arg p>_N)
                   (\ (ds1 :: (Language.Fortran.Arg p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Arg p)
                           x' } })) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Arg p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Arg p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Arg p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Arg p, GHC.Types.Bool)
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fDataArg_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Arg p>_N)
                   (\ (ds1 :: (Language.Fortran.Arg p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Arg p)
                           x' } })) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Arg p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Arg p) ->
                 (Language.Fortran.$fDataArg_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Arg p>_P)
                   (GHC.Types.[] @ u)) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Arg p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Arg p) ->
                 case Language.Fortran.$fDataArg_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Arg p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Arg p
                        -> Data.Functor.Const.Const r (Language.Fortran.Arg p)
                   = Language.Fortran.$fDataArg_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Arg p) -> g x)
                   `cast`
                 (<Language.Fortran.Arg p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Arg p>_P)) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Arg p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Arg p) ->
                 (Language.Fortran.$fDataArg_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Arg p>_P)
                   ds1) -}
2ecf4bb24a966e219012eee596c45ea8
  $fDataArg_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Arg p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.ArgName p)
                   = Language.Fortran.$fDataArgName @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcSpan
                   @ (Language.Fortran.Arg p)
                   Language.Fortran.$fDataArg_$s$fData(,)
                   (k @ (Language.Fortran.ArgName p)
                      @ (Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                      $dData2
                      (k @ p
                         @ (Language.Fortran.ArgName p
                            -> Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                         $dData1
                         (z @ (p
                               -> Language.Fortran.ArgName p
                               -> Language.Fortran.SrcSpan
                               -> Language.Fortran.Arg p)
                            (Language.Fortran.Arg @ p))))) -}
255ed5baf3a7bac11d2528e3a73a7686
  $fDataArg_$s$fData(,) ::
    Data.Data.Data (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ ((,) Language.Fortran.SrcLoc)
                     @ Language.Fortran.SrcLoc
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ (* -> *)
                        @ (,)
                        @ Language.Fortran.SrcLoc
                        Data.Data.$fData(,)10
                        Language.Fortran.$fDataSrcLoc7)
                     Language.Fortran.$fDataSrcLoc7)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(Language.Fortran.SrcLoc,
                                                                      Language.Fortran.SrcLoc)>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                     (z :: forall g. g -> c g)
                     (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case ds of wild { (,) a1 a2 ->
                   k @ Language.Fortran.SrcLoc
                     @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                     Language.Fortran.$fDataSrcLoc
                     (k @ Language.Fortran.SrcLoc
                        @ (Language.Fortran.SrcLoc
                           -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                        Language.Fortran.$fDataSrcLoc
                        (z @ (Language.Fortran.SrcLoc
                              -> Language.Fortran.SrcLoc
                              -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                           (GHC.Tuple.(,)
                              @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc))
                        a1)
                     a2 })
                  (\ @ c :: * -> *
                     (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                     (z :: forall r. r -> c r)
                     (ds :: Data.Data.Constr) ->
                   k @ Language.Fortran.SrcLoc
                     @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                     Language.Fortran.$fDataSrcLoc
                     (k @ Language.Fortran.SrcLoc
                        @ (Language.Fortran.SrcLoc
                           -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                        Language.Fortran.$fDataSrcLoc
                        (z @ (Language.Fortran.SrcLoc
                              -> Language.Fortran.SrcLoc
                              -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                           (GHC.Tuple.(,)
                              @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc))))
                  (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case ds of wild { (,) ds1 ds2 -> Data.Data.$c(,) })
                  (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   Data.Data.$t(,))
                  (\ @ t :: * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d. Data.Data.Data d => c (t d)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)))
                  (Data.Data.$fData(,)_$cdataCast2
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                     (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x0 of wild { (,) a1 a2 ->
                   (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1,
                    ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R)) })
                    `cast`
                  (<forall b1. Data.Data.Data b1 => b1 -> b1>_R
                   ->_R <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case eta of wild { (,) a1 a2 ->
                   (ds
                      (ds
                         ds1
                         (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1))
                      (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                     `cast`
                   (Sym (Data.Functor.Const.N:Const[0]
                             <*>_N
                             <r>_R
                             <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x0 of wild { (,) a1 a2 ->
                   ds
                     (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                     (ds
                        (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                        ds1) })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x0 of wild { (,) a1 a2 ->
                   GHC.Types.:
                     @ u
                     (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                     (GHC.Types.:
                        @ u
                        (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                        (GHC.Types.[] @ u)) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x of wild { (,) a1 a2 ->
                   case ds of wild1 { GHC.Types.I# x1 ->
                   case x1 of wild2 {
                     DEFAULT -> Data.Maybe.fromJust1 @ u
                     0#
                     -> ds1 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1
                     1#
                     -> ds1
                          @ Language.Fortran.SrcLoc
                          Language.Fortran.$fDataSrcLoc
                          a2 } } })
                  (Data.Data.$fData(,)_$cgmapM
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (Data.Data.$fData(,)_$cgmapMp
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (Data.Data.$fData(,)_$cgmapMo
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fDataAttr5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Attr
                                                                       p>_N)
                  (Language.Fortran.$fDataAttr_$cgfoldl @ p v)
                  (Language.Fortran.$fDataAttr_$cgunfold @ p v)
                  (Language.Fortran.$fDataAttr_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Attr p) -> Language.Fortran.$tAttr)
                  (Language.Fortran.$fDataAttr_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Attr p)))
                  (Language.Fortran.$fDataAttr1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Attr p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Attr p>_R)
                  (Language.Fortran.$fDataAttr_$cgmapQl @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapQr @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapQ @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapQi @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapM @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapMp @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapMo @ p v) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Attr p
    -> Data.Functor.Identity.Identity (Language.Fortran.Attr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Attr p) ->
                 Language.Fortran.$fDataAttr_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Attr
                        15144293881790897351##
                        2024379006762117907##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataAttr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Attr
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Attr
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
187cdd396d6510b4c897941a365366cd
  $fDataAttr3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataAttr4) -}
08d8e46944db929a292a41a179a3e64b
  $fDataAttr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Attr"#) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Attr p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Attr
                   @ p
                   Language.Fortran.$fDataAttr6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Attr
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Attr
                        15144293881790897351##
                        2024379006762117907##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataAttr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Attr
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Attr p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataAttr2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Attr p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Attr p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Attr p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Attr <p>_N)) } } } }) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Attr p
    -> c (Language.Fortran.Attr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataAttr_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Attr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Attr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Attr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Attr p, GHC.Types.Bool)
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fDataAttr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Attr p>_N)
                   (\ (ds1 :: (Language.Fortran.Attr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Attr p)
                           x' } })) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Attr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Attr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Attr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Attr p, GHC.Types.Bool)
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fDataAttr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Attr p>_N)
                   (\ (ds1 :: (Language.Fortran.Attr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Attr p)
                           x' } })) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Attr p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Attr p) ->
                 (Language.Fortran.$fDataAttr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Attr p>_P)
                   (GHC.Types.[] @ u)) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Attr p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Attr p) ->
                 case Language.Fortran.$fDataAttr_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Attr p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Attr p
                        -> Data.Functor.Const.Const r (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Attr p) -> g x)
                   `cast`
                 (<Language.Fortran.Attr p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Attr p>_P)) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Attr p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Attr p) ->
                 (Language.Fortran.$fDataAttr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Attr p>_P)
                   ds1) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Attr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
3b46645d85b9c008a9510c0f3d8ec026
  $fDataAttr_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Attr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Attr p) ->
                 case w362 of wild {
                   Language.Fortran.Parameter ds -> Language.Fortran.$cParameter
                   Language.Fortran.Allocatable ds -> Language.Fortran.$cAllocatable
                   Language.Fortran.External ds -> Language.Fortran.$cExternal
                   Language.Fortran.Intent ds ds1 -> Language.Fortran.$cIntent
                   Language.Fortran.Intrinsic ds -> Language.Fortran.$cIntrinsic
                   Language.Fortran.Optional ds -> Language.Fortran.$cOptional
                   Language.Fortran.Pointer ds -> Language.Fortran.$cPointer
                   Language.Fortran.Save ds -> Language.Fortran.$cSave
                   Language.Fortran.Target ds -> Language.Fortran.$cTarget
                   Language.Fortran.Volatile ds -> Language.Fortran.$cVolatile
                   Language.Fortran.Public ds -> Language.Fortran.$cPublic
                   Language.Fortran.Private ds -> Language.Fortran.$cPrivate
                   Language.Fortran.Sequence ds -> Language.Fortran.$cSequence
                   Language.Fortran.Dimension ds ds1 -> Language.Fortran.$cDimension
                   Language.Fortran.MeasureUnit ds ds1
                   -> Language.Fortran.$cMeasureUnit }) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fDataBaseType5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.BaseType
                                                                       p>_N)
                  (Language.Fortran.$fDataBaseType_$cgfoldl @ p v)
                  (Language.Fortran.$fDataBaseType_$cgunfold @ p v)
                  (Language.Fortran.$fDataBaseType_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.BaseType p) ->
                   Language.Fortran.$tBaseType)
                  (Language.Fortran.$fDataBaseType_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.BaseType p)))
                  (Language.Fortran.$fDataBaseType1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.BaseType p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.BaseType p>_R)
                  (Language.Fortran.$fDataBaseType_$cgmapQl @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapQr @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapQ @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapQi @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapM @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapMp @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapMo @ p v) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BaseType p
    -> Data.Functor.Identity.Identity (Language.Fortran.BaseType p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$fDataBaseType_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BaseType
                        9534398033969989978##
                        4387516002846692571##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBaseType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.BaseType
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.BaseType
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
b8d8f6b6880e53699e1f35a837764888
  $fDataBaseType3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataBaseType4) -}
260a0bf32630da06bb58f7f4d638bd97
  $fDataBaseType4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BaseType"#) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.BaseType p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.BaseType
                   @ p
                   Language.Fortran.$fDataBaseType6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.BaseType
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BaseType
                        9534398033969989978##
                        4387516002846692571##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBaseType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.BaseType
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.BaseType p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataBaseType2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.BaseType p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.BaseType <p>_N)) } } } }) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.BaseType p
    -> c (Language.Fortran.BaseType p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.BaseType p) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Integer @ p))
                        a1
                   Language.Fortran.Real a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Real @ p))
                        a1
                   Language.Fortran.Character a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Character @ p))
                        a1
                   Language.Fortran.SomeType a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.SomeType @ p))
                        a1
                   Language.Fortran.DerivedType a1 a2
                   -> k @ (Language.Fortran.SubName p)
                        @ (Language.Fortran.BaseType p)
                        $dData2
                        (k @ p
                           @ (Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                           $dData1
                           (z @ (p
                                 -> Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                              (Language.Fortran.DerivedType @ p))
                           a1)
                        a2
                   Language.Fortran.Recursive a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Recursive @ p))
                        a1
                   Language.Fortran.Pure a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Pure @ p))
                        a1
                   Language.Fortran.Elemental a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Elemental @ p))
                        a1
                   Language.Fortran.Logical a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Logical @ p))
                        a1
                   Language.Fortran.Complex a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Complex @ p))
                        a1 }) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataBaseType_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BaseType p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BaseType p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BaseType p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BaseType p, GHC.Types.Bool)
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fDataBaseType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BaseType p>_N)
                   (\ (ds1 :: (Language.Fortran.BaseType p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BaseType p)
                           x' } })) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BaseType p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BaseType p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BaseType p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BaseType p, GHC.Types.Bool)
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fDataBaseType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BaseType p>_N)
                   (\ (ds1 :: (Language.Fortran.BaseType p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BaseType p)
                           x' } })) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BaseType p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.BaseType p) ->
                 (Language.Fortran.$fDataBaseType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.BaseType p>_P)
                   (GHC.Types.[] @ u)) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BaseType p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.BaseType p) ->
                 case Language.Fortran.$fDataBaseType_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BaseType p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.BaseType p
                        -> Data.Functor.Const.Const r (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.BaseType p) -> g x)
                   `cast`
                 (<Language.Fortran.BaseType p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.BaseType p>_P)) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BaseType p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.BaseType p) ->
                 (Language.Fortran.$fDataBaseType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.BaseType p>_P)
                   ds1) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.BaseType p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.BaseType p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Complex @ p))
                        1#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Integer @ p))
                        2#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Real @ p))
                        3#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Character @ p))
                        4#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.SomeType @ p))
                        5#
                        -> k @ (Language.Fortran.SubName p)
                             @ (Language.Fortran.BaseType p)
                             $dData2
                             (k @ p
                                @ (Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                                $dData1
                                (z @ (p
                                      -> Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                                   (Language.Fortran.DerivedType @ p)))
                        6#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Recursive @ p))
                        7#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Pure @ p))
                        8#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Elemental @ p))
                        9#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Logical @ p)) } } } }) -}
c66c0bcbb42951ba147c66147650e364
  $fDataBaseType_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.BaseType p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w362 :: Language.Fortran.BaseType p) ->
                 case w362 of wild {
                   Language.Fortran.Integer ds -> Language.Fortran.$cInteger
                   Language.Fortran.Real ds -> Language.Fortran.$cReal
                   Language.Fortran.Character ds -> Language.Fortran.$cCharacter
                   Language.Fortran.SomeType ds -> Language.Fortran.$cSomeType
                   Language.Fortran.DerivedType ds ds1
                   -> Language.Fortran.$cDerivedType
                   Language.Fortran.Recursive ds -> Language.Fortran.$cRecursive
                   Language.Fortran.Pure ds -> Language.Fortran.$cPure
                   Language.Fortran.Elemental ds -> Language.Fortran.$cElemental
                   Language.Fortran.Logical ds -> Language.Fortran.$cLogical
                   Language.Fortran.Complex ds -> Language.Fortran.$cComplex }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fDataBinOp6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.BinOp
                                                                       p>_N)
                  (Language.Fortran.$fDataBinOp_$cgfoldl @ p v)
                  (Language.Fortran.$fDataBinOp_$cgunfold @ p v)
                  (Language.Fortran.$fDataBinOp_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.BinOp p) -> Language.Fortran.$tBinOp)
                  (Language.Fortran.$fDataBinOp_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.BinOp p)))
                  (Language.Fortran.$fDataBinOp2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.BinOp p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.BinOp p>_R)
                  (Language.Fortran.$fDataBinOp1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.BinOp p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.BinOp p>_P)
                  (Language.Fortran.$fDataBinOp_$cgmapQr @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapQ @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapQi @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapM @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapMp @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapMo @ p v) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> Data.Functor.Const.Const r (Language.Fortran.BinOp p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData1
                   @ (Data.Functor.Const.Const r)
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)[OneShot]
                      (c :: Data.Functor.Const.Const r (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    ds
                      c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                      (ds2 @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Const.Const r (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                   (\ @ g1 (ds3 :: g1)[OneShot] -> ds1)
                     `cast`
                   (forall (g1 :: <*>_N).
                    <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                   eta) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BinOp p
    -> Data.Functor.Identity.Identity (Language.Fortran.BinOp p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)[OneShot]
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BinOp
                        10905077043289159484##
                        6134286290342796449##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBinOp4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.BinOp
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.BinOp
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
5ee23475e8e5e73fa647acd94c9bf393
  $fDataBinOp4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataBinOp5) -}
ffab2830848f4500366b17cc18c684b0
  $fDataBinOp5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BinOp"#) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.BinOp p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.BinOp
                   @ p
                   Language.Fortran.$fDataBinOp7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.BinOp
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BinOp
                        10905077043289159484##
                        6134286290342796449##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBinOp4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.BinOp
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.BinOp p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataBinOp3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.BinOp p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.BinOp <p>_N)) } } } }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.BinOp p
    -> c (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U> -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)[OneShot]
                      (c :: m (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)
                   eta) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BinOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BinOp p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BinOp p, GHC.Types.Bool)
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fDataBinOp_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)[OneShot]
                         (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                         (y :: d)[OneShot] ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g)[OneShot] ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BinOp p>_N)
                   (\ (ds1 :: (Language.Fortran.BinOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BinOp p)
                           x' } })) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BinOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BinOp p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BinOp p, GHC.Types.Bool)
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fDataBinOp_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)[OneShot]
                         (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                         (y :: d)[OneShot] ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g)[OneShot] ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BinOp p>_N)
                   (\ (ds1 :: (Language.Fortran.BinOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BinOp p)
                           x' } })) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BinOp p -> [u]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.BinOp p) ->
                 (Language.Fortran.$fDataBinOp_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (ds1 :: Data.Data.Qr [u] (d -> b))[OneShot]
                       (x :: d)[OneShot]
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.BinOp p>_P)
                   (GHC.Types.[] @ u)) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BinOp p
    -> u
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.BinOp p) ->
                 case Language.Fortran.$fDataBinOp_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)[OneShot]
                           (ds2 :: Data.Data.Qi u (d -> b))[OneShot]
                           (a1 :: d)[OneShot] ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.BinOp p) ->
                 (Language.Fortran.$fDataBinOp_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (ds3 :: Data.Data.Qr r (d -> b))[OneShot]
                       (x :: d)[OneShot]
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.BinOp p>_P)
                   ds1) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.BinOp p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold2 @ p w @ c w362 w363 ww1 ww5 }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fDataBinOp_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.BinOp p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w362 :: Language.Fortran.BinOp p) ->
                 case w362 of wild {
                   Language.Fortran.Plus ds -> Language.Fortran.$cPlus
                   Language.Fortran.Minus ds -> Language.Fortran.$cMinus
                   Language.Fortran.Mul ds -> Language.Fortran.$cMul
                   Language.Fortran.Div ds -> Language.Fortran.$cDiv
                   Language.Fortran.Or ds -> Language.Fortran.$cOr
                   Language.Fortran.And ds -> Language.Fortran.$cAnd
                   Language.Fortran.Concat ds -> Language.Fortran.$cConcat
                   Language.Fortran.Power ds -> Language.Fortran.$cPower
                   Language.Fortran.RelEQ ds -> Language.Fortran.$cRelEQ
                   Language.Fortran.RelNE ds -> Language.Fortran.$cRelNE
                   Language.Fortran.RelLT ds -> Language.Fortran.$cRelLT
                   Language.Fortran.RelLE ds -> Language.Fortran.$cRelLE
                   Language.Fortran.RelGT ds -> Language.Fortran.$cRelGT
                   Language.Fortran.RelGE ds -> Language.Fortran.$cRelGE }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fDataBlock8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Block
                                                                       p>_N)
                  (Language.Fortran.$fDataBlock_$cgfoldl @ p v)
                  (Language.Fortran.$fDataBlock_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Block p) ->
                   case ds of wild { Language.Fortran.Block ds1 ds2 ds3 ds4 ds5 ds6 ->
                   Language.Fortran.$cBlock })
                  (\ (ds :: Language.Fortran.Block p) -> Language.Fortran.$tBlock)
                  (Language.Fortran.$fDataBlock_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Block p)))
                  (Language.Fortran.$fDataBlock1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Block p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Block p>_R)
                  (Language.Fortran.$fDataBlock_$cgmapQl @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapQr @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapQ @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapQi @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapM @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapMp @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapMo @ p v) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Block p
    -> Data.Functor.Identity.Identity (Language.Fortran.Block p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Block p) ->
                 Language.Fortran.$fDataBlock_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Block
                        11270035641402173581##
                        8631095044655209212##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Block
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Block
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
d227002ff964c9f29387c3fdc07a45c7
  $fDataBlock3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataBlock4) -}
d6c22c83a0ddd72973cacd965f3254c0
  $fDataBlock4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Block"#) -}
d76097beba35911f5096faddde2a461e
  $fDataBlock5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataBlock6) -}
f07404b96c149b460a84d0789de7a844
  $fDataBlock6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBlock
                   (GHC.Types.[] @ Data.Data.Constr)) -}
92fd76d2c0861b4bc54cd99563f89a1f
  $fDataBlock7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataBlock4) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Block p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Block
                   @ p
                   Language.Fortran.$fDataBlock9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Block
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Block
                        11270035641402173581##
                        8631095044655209212##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Block
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Block p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataBlock2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Block p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Block p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Block p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Block <p>_N)) } } } }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Block p
    -> c (Language.Fortran.Block p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.UseBlock p)
                   = Language.Fortran.$fDataUseBlock @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData1
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Block p) ->
                 case ds of wild { Language.Fortran.Block a1 a2 a3 a4 a5 a6 ->
                 k @ (Language.Fortran.Fortran p)
                   @ (Language.Fortran.Block p)
                   $dData5
                   (k @ (Language.Fortran.Decl p)
                      @ (Language.Fortran.Fortran p -> Language.Fortran.Block p)
                      $dData4
                      (k @ Language.Fortran.SrcSpan
                         @ (Language.Fortran.Decl p
                            -> Language.Fortran.Fortran p -> Language.Fortran.Block p)
                         Language.Fortran.$fDataArg_$s$fData(,)
                         (k @ (Language.Fortran.Implicit p)
                            @ (Language.Fortran.SrcSpan
                               -> Language.Fortran.Decl p
                               -> Language.Fortran.Fortran p
                               -> Language.Fortran.Block p)
                            $dData3
                            (k @ (Language.Fortran.UseBlock p)
                               @ (Language.Fortran.Implicit p
                                  -> Language.Fortran.SrcSpan
                                  -> Language.Fortran.Decl p
                                  -> Language.Fortran.Fortran p
                                  -> Language.Fortran.Block p)
                               $dData2
                               (k @ p
                                  @ (Language.Fortran.UseBlock p
                                     -> Language.Fortran.Implicit p
                                     -> Language.Fortran.SrcSpan
                                     -> Language.Fortran.Decl p
                                     -> Language.Fortran.Fortran p
                                     -> Language.Fortran.Block p)
                                  $dData1
                                  (z @ (p
                                        -> Language.Fortran.UseBlock p
                                        -> Language.Fortran.Implicit p
                                        -> Language.Fortran.SrcSpan
                                        -> Language.Fortran.Decl p
                                        -> Language.Fortran.Fortran p
                                        -> Language.Fortran.Block p)
                                     (Language.Fortran.Block @ p))
                                  a1)
                               a2)
                            a3)
                         a4)
                      a5)
                   a6 }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataBlock_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Block p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Block p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Block p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Block p, GHC.Types.Bool)
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fDataBlock_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Block p>_N)
                   (\ (ds1 :: (Language.Fortran.Block p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Block p)
                           x' } })) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Block p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Block p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Block p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Block p, GHC.Types.Bool)
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fDataBlock_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Block p>_N)
                   (\ (ds1 :: (Language.Fortran.Block p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Block p)
                           x' } })) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Block p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Block p) ->
                 (Language.Fortran.$fDataBlock_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Block p>_P)
                   (GHC.Types.[] @ u)) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Block p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Block p) ->
                 case Language.Fortran.$fDataBlock_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Block p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Block p
                        -> Data.Functor.Const.Const r (Language.Fortran.Block p)
                   = Language.Fortran.$fDataBlock_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Block p) -> g x)
                   `cast`
                 (<Language.Fortran.Block p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Block p>_P)) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Block p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Block p) ->
                 (Language.Fortran.$fDataBlock_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Block p>_P)
                   ds1) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fDataBlock_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Block p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.UseBlock p)
                   = Language.Fortran.$fDataUseBlock @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData1
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ (Language.Fortran.Fortran p)
                   @ (Language.Fortran.Block p)
                   $dData5
                   (k @ (Language.Fortran.Decl p)
                      @ (Language.Fortran.Fortran p -> Language.Fortran.Block p)
                      $dData4
                      (k @ Language.Fortran.SrcSpan
                         @ (Language.Fortran.Decl p
                            -> Language.Fortran.Fortran p -> Language.Fortran.Block p)
                         Language.Fortran.$fDataArg_$s$fData(,)
                         (k @ (Language.Fortran.Implicit p)
                            @ (Language.Fortran.SrcSpan
                               -> Language.Fortran.Decl p
                               -> Language.Fortran.Fortran p
                               -> Language.Fortran.Block p)
                            $dData3
                            (k @ (Language.Fortran.UseBlock p)
                               @ (Language.Fortran.Implicit p
                                  -> Language.Fortran.SrcSpan
                                  -> Language.Fortran.Decl p
                                  -> Language.Fortran.Fortran p
                                  -> Language.Fortran.Block p)
                               $dData2
                               (k @ p
                                  @ (Language.Fortran.UseBlock p
                                     -> Language.Fortran.Implicit p
                                     -> Language.Fortran.SrcSpan
                                     -> Language.Fortran.Decl p
                                     -> Language.Fortran.Fortran p
                                     -> Language.Fortran.Block p)
                                  $dData1
                                  (z @ (p
                                        -> Language.Fortran.UseBlock p
                                        -> Language.Fortran.Implicit p
                                        -> Language.Fortran.SrcSpan
                                        -> Language.Fortran.Decl p
                                        -> Language.Fortran.Fortran p
                                        -> Language.Fortran.Block p)
                                     (Language.Fortran.Block @ p)))))))) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fDataDataForm8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.DataForm
                                                                       p>_N)
                  (Language.Fortran.$fDataDataForm_$cgfoldl @ p v)
                  (Language.Fortran.$fDataDataForm_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.DataForm p) ->
                   case ds of wild { Language.Fortran.Data ds1 ds2 ->
                   Language.Fortran.$cData })
                  (\ (ds :: Language.Fortran.DataForm p) ->
                   Language.Fortran.$tDataForm)
                  (Language.Fortran.$fDataDataForm_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.DataForm p)))
                  (Language.Fortran.$fDataDataForm1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.DataForm p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.DataForm p>_R)
                  (Language.Fortran.$fDataDataForm_$cgmapQl @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapQr @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapQ @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapQi @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapM @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapMp @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapMo @ p v) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.DataForm p
    -> Data.Functor.Identity.Identity (Language.Fortran.DataForm p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$fDataDataForm_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.DataForm
                        6255407001957548374##
                        11459957579316560280##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDataForm3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.DataForm
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.DataForm
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
58e2b66a19c8630024a4e44cb04f12dc
  $fDataDataForm3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataDataForm4) -}
bbe5f82be5723aa1edbb2175c60598dc
  $fDataDataForm4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DataForm"#) -}
aa28a64f31fd23eb7713910635b3d337
  $fDataDataForm5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataDataForm6) -}
229635e36e6e670396566a8f3ef642b4
  $fDataDataForm6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cData
                   (GHC.Types.[] @ Data.Data.Constr)) -}
a7e73bc788e055865100d175090a118b
  $fDataDataForm7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataDataForm4) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.DataForm p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.DataForm
                   @ p
                   Language.Fortran.$fDataDataForm9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.DataForm
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.DataForm
                        6255407001957548374##
                        11459957579316560280##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDataForm3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.DataForm
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.DataForm p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataDataForm2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.DataForm p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.DataForm <p>_N)) } } } }) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.DataForm p
    -> c (Language.Fortran.DataForm p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData2
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData3
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data a1 a2 ->
                 k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   @ (Language.Fortran.DataForm p)
                   $dData4
                   (k @ p
                      @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                         -> Language.Fortran.DataForm p)
                      $dData1
                      (z @ (p
                            -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                            -> Language.Fortran.DataForm p)
                         (Language.Fortran.Data @ p))
                      a1)
                   a2 }) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataDataForm_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.DataForm p) ->
                 let {
                   lvl295 :: m (Language.Fortran.DataForm p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.DataForm p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.DataForm p, GHC.Types.Bool)
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fDataDataForm_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.DataForm p>_N)
                   (\ (ds1 :: (Language.Fortran.DataForm p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.DataForm p)
                           x' } })) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.DataForm p) ->
                 let {
                   lvl295 :: m (Language.Fortran.DataForm p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.DataForm p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.DataForm p, GHC.Types.Bool)
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fDataDataForm_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.DataForm p>_N)
                   (\ (ds1 :: (Language.Fortran.DataForm p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.DataForm p)
                           x' } })) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.DataForm p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.DataForm p) ->
                 (Language.Fortran.$fDataDataForm_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.DataForm p>_P)
                   (GHC.Types.[] @ u)) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.DataForm p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.DataForm p) ->
                 case Language.Fortran.$fDataDataForm_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.DataForm p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.DataForm p
                        -> Data.Functor.Const.Const r (Language.Fortran.DataForm p)
                   = Language.Fortran.$fDataDataForm_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.DataForm p) -> g x)
                   `cast`
                 (<Language.Fortran.DataForm p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.DataForm p>_P)) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.DataForm p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.DataForm p) ->
                 (Language.Fortran.$fDataDataForm_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.DataForm p>_P)
                   ds1) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fDataDataForm_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.DataForm p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData2
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData3
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   @ (Language.Fortran.DataForm p)
                   $dData4
                   (k @ p
                      @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                         -> Language.Fortran.DataForm p)
                      $dData1
                      (z @ (p
                            -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                            -> Language.Fortran.DataForm p)
                         (Language.Fortran.Data @ p)))) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fDataDecl5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Decl
                                                                       p>_N)
                  (Language.Fortran.$fDataDecl_$cgfoldl @ p v)
                  (Language.Fortran.$fDataDecl_$cgunfold @ p v)
                  (Language.Fortran.$fDataDecl_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Decl p) -> Language.Fortran.$tDecl)
                  (Language.Fortran.$fDataDecl_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Decl p)))
                  (Language.Fortran.$fDataDecl1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Decl p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Decl p>_R)
                  (Language.Fortran.$fDataDecl_$cgmapQl @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapQr @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapQ @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapQi @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapM @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapMp @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapMo @ p v) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Decl p
    -> Data.Functor.Identity.Identity (Language.Fortran.Decl p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Decl
                        9188850777785548874##
                        14769666604673014076##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDecl3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Decl
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Decl
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
7c2da118e79867d430c58e51be4dadb3
  $fDataDecl3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataDecl4) -}
bbcd459cd60b91a94675ae818f7e11d2
  $fDataDecl4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Decl"#) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Decl p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Decl
                   @ p
                   Language.Fortran.$fDataDecl6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Decl
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Decl
                        9188850777785548874##
                        14769666604673014076##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDecl3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Decl
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Decl p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataDecl2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Decl p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Decl p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Decl p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Decl <p>_N)) } } } }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Decl p
    -> c (Language.Fortran.Decl p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Decl p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Decl p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Decl p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Decl p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Decl p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataDecl_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Decl p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Decl p) ->
                 case w362 of wild {
                   Language.Fortran.Decl ds ds1 ds2 ds3 -> Language.Fortran.$cDecl
                   Language.Fortran.Namelist ds ds1 -> Language.Fortran.$cNamelist
                   Language.Fortran.DataDecl ds ds1 -> Language.Fortran.$cDataDecl
                   Language.Fortran.Equivalence ds ds1 ds2
                   -> Language.Fortran.$cEquivalence
                   Language.Fortran.AttrStmt ds ds1 ds2 -> Language.Fortran.$cAttrStmt
                   Language.Fortran.AccessStmt ds ds1 ds2
                   -> Language.Fortran.$cAccessStmt
                   Language.Fortran.ExternalStmt ds ds1
                   -> Language.Fortran.$cExternalStmt
                   Language.Fortran.Interface ds ds1 ds2
                   -> Language.Fortran.$cInterface
                   Language.Fortran.Common ds ds1 ds2 ds3 -> Language.Fortran.$cCommon
                   Language.Fortran.DerivedTypeDef ds ds1 ds2 ds3 ds4 ds5
                   -> Language.Fortran.$cDerivedTypeDef
                   Language.Fortran.Include ds ds1 -> Language.Fortran.$cInclude
                   Language.Fortran.DSeq ds ds1 ds2 -> Language.Fortran.$cDSeq
                   Language.Fortran.TextDecl ds ds1 -> Language.Fortran.$cTextDecl
                   Language.Fortran.NullDecl ds ds1 -> Language.Fortran.$cNullDecl
                   Language.Fortran.MeasureUnitDef ds ds1 ds2
                   -> Language.Fortran.$cMeasureUnitDef }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fDataExpr5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Expr
                                                                       p>_N)
                  (Language.Fortran.$fDataExpr_$cgfoldl @ p v)
                  (Language.Fortran.$fDataExpr_$cgunfold @ p v)
                  (Language.Fortran.$fDataExpr_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Expr p) -> Language.Fortran.$tExpr)
                  (Language.Fortran.$fDataExpr_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Expr p)))
                  (Language.Fortran.$fDataExpr1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Expr p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Expr p>_R)
                  (Language.Fortran.$fDataExpr_$cgmapQl @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapQr @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapQ @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapQi @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapM @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapMp @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapMo @ p v) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Expr p
    -> Data.Functor.Identity.Identity (Language.Fortran.Expr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Expr p) ->
                 Language.Fortran.$fDataExpr_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Expr
                        17869853342830359556##
                        1287957171183349453##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataExpr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Expr
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Expr
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
3de0df1bce8cf2456248e2bf5909b91b
  $fDataExpr3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataExpr4) -}
24a59b042776adf516c7ab27ee780d28
  $fDataExpr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Expr"#) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Expr p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Expr
                   @ p
                   Language.Fortran.$fDataExpr6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Expr
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Expr
                        17869853342830359556##
                        1287957171183349453##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataExpr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Expr
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Expr p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataExpr2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Expr p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Expr p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Expr p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Expr <p>_N)) } } } }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Expr p
    -> c (Language.Fortran.Expr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataExpr_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Expr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Expr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Expr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Expr p, GHC.Types.Bool)
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fDataExpr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Expr p>_N)
                   (\ (ds1 :: (Language.Fortran.Expr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Expr p)
                           x' } })) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Expr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Expr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Expr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Expr p, GHC.Types.Bool)
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fDataExpr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Expr p>_N)
                   (\ (ds1 :: (Language.Fortran.Expr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Expr p)
                           x' } })) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Expr p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Expr p) ->
                 (Language.Fortran.$fDataExpr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Expr p>_P)
                   (GHC.Types.[] @ u)) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Expr p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Expr p) ->
                 case Language.Fortran.$fDataExpr_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Expr p
                        -> Data.Functor.Const.Const r (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Expr p) -> g x)
                   `cast`
                 (<Language.Fortran.Expr p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Expr p>_P)) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Expr p) ->
                 (Language.Fortran.$fDataExpr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Expr p>_P)
                   ds1) -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Expr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
6304956f2901eead56a8fac1e90d4904
  $fDataExpr_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Expr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Expr p) ->
                 case w362 of wild {
                   Language.Fortran.Con ds ds1 ds2 -> Language.Fortran.$cCon
                   Language.Fortran.ConL ds ds1 ds2 ds3 -> Language.Fortran.$cConL
                   Language.Fortran.ConS ds ds1 ds2 -> Language.Fortran.$cConS
                   Language.Fortran.Var ds ds1 ds2 -> Language.Fortran.$cVar
                   Language.Fortran.Bin ds ds1 ds2 ds3 ds4 -> Language.Fortran.$cBin
                   Language.Fortran.Unary ds ds1 ds2 ds3 -> Language.Fortran.$cUnary
                   Language.Fortran.CallExpr ds ds1 ds2 ds3
                   -> Language.Fortran.$cCallExpr
                   Language.Fortran.NullExpr ds ds1 -> Language.Fortran.$cNullExpr
                   Language.Fortran.Null ds ds1 -> Language.Fortran.$cNull
                   Language.Fortran.ESeq ds ds1 ds2 ds3 -> Language.Fortran.$cESeq
                   Language.Fortran.Bound ds ds1 ds2 ds3 -> Language.Fortran.$cBound
                   Language.Fortran.Sqrt ds ds1 ds2 -> Language.Fortran.$cSqrt
                   Language.Fortran.ArrayCon ds ds1 ds2 -> Language.Fortran.$cArrayCon
                   Language.Fortran.AssgExpr ds ds1 ds2 ds3
                   -> Language.Fortran.$cAssgExpr }) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fDataFortran5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Fortran
                                                                       p>_N)
                  (Language.Fortran.$fDataFortran_$cgfoldl @ p v)
                  (Language.Fortran.$fDataFortran_$cgunfold @ p v)
                  (Language.Fortran.$fDataFortran_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Fortran p) ->
                   Language.Fortran.$tFortran)
                  (Language.Fortran.$fDataFortran_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Fortran p)))
                  (Language.Fortran.$fDataFortran1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Fortran p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Fortran p>_R)
                  (Language.Fortran.$fDataFortran_$cgmapQl @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapQr @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapQ @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapQi @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapM @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapMp @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapMo @ p v) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fortran p
    -> Data.Functor.Identity.Identity (Language.Fortran.Fortran p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$fDataFortran_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        1898037638716600659##
                        3599167482411011499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Fortran
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Fortran
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
b05107e82f44b3195f7cfcd33849be68
  $fDataFortran3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataFortran4) -}
55d10e45a9275588a82d2bba15e007ed
  $fDataFortran4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fortran"#) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Fortran p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Fortran
                   @ p
                   Language.Fortran.$fDataFortran6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Fortran
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        1898037638716600659##
                        3599167482411011499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Fortran
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Fortran p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataFortran2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Fortran p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Fortran <p>_N)) } } } }) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Fortran p
    -> c (Language.Fortran.Fortran p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataFortran_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Fortran p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Fortran p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Fortran p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Fortran p, GHC.Types.Bool)
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fDataFortran_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Fortran p>_N)
                   (\ (ds1 :: (Language.Fortran.Fortran p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Fortran p)
                           x' } })) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Fortran p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Fortran p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Fortran p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Fortran p, GHC.Types.Bool)
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fDataFortran_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Fortran p>_N)
                   (\ (ds1 :: (Language.Fortran.Fortran p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Fortran p)
                           x' } })) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fortran p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Fortran p) ->
                 (Language.Fortran.$fDataFortran_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Fortran p>_P)
                   (GHC.Types.[] @ u)) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fortran p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Fortran p) ->
                 case Language.Fortran.$fDataFortran_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fortran p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Fortran p
                        -> Data.Functor.Const.Const r (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Fortran p) -> g x)
                   `cast`
                 (<Language.Fortran.Fortran p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Fortran p>_P)) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fortran p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Fortran p) ->
                 (Language.Fortran.$fDataFortran_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Fortran p>_P)
                   ds1) -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Fortran p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
cab0cd6287333175c6b9d87427982518
  $fDataFortran_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Fortran p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w362 :: Language.Fortran.Fortran p) ->
                 case w362 of wild {
                   Language.Fortran.Assg ds ds1 ds2 ds3 -> Language.Fortran.$cAssg
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cFor
                   Language.Fortran.DoWhile ds ds1 ds2 ds3
                   -> Language.Fortran.$cDoWhile
                   Language.Fortran.FSeq ds ds1 ds2 ds3 -> Language.Fortran.$cFSeq
                   Language.Fortran.If ds ds1 ds2 ds3 ds4 ds5 -> Language.Fortran.$cIf
                   Language.Fortran.Allocate ds ds1 ds2 ds3
                   -> Language.Fortran.$cAllocate
                   Language.Fortran.Backspace ds ds1 ds2
                   -> Language.Fortran.$cBackspace
                   Language.Fortran.Call ds ds1 ds2 ds3 -> Language.Fortran.$cCall
                   Language.Fortran.Open ds ds1 ds2 -> Language.Fortran.$cOpen
                   Language.Fortran.Close ds ds1 ds2 -> Language.Fortran.$cClose
                   Language.Fortran.Continue ds ds1 -> Language.Fortran.$cContinue
                   Language.Fortran.Cycle ds ds1 ds2 -> Language.Fortran.$cCycle
                   Language.Fortran.DataStmt ds ds1 ds2 -> Language.Fortran.$cDataStmt
                   Language.Fortran.Deallocate ds ds1 ds2 ds3
                   -> Language.Fortran.$cDeallocate
                   Language.Fortran.Endfile ds ds1 ds2 -> Language.Fortran.$cEndfile
                   Language.Fortran.Exit ds ds1 ds2 -> Language.Fortran.$cExit
                   Language.Fortran.Format ds ds1 ds2 -> Language.Fortran.$cFormat
                   Language.Fortran.Forall ds ds1 ds2 ds3 -> Language.Fortran.$cForall
                   Language.Fortran.Goto ds ds1 ds2 -> Language.Fortran.$cGoto
                   Language.Fortran.Nullify ds ds1 ds2 -> Language.Fortran.$cNullify
                   Language.Fortran.Inquire ds ds1 ds2 ds3
                   -> Language.Fortran.$cInquire
                   Language.Fortran.Pause ds ds1 ds2 -> Language.Fortran.$cPause
                   Language.Fortran.Rewind ds ds1 ds2 -> Language.Fortran.$cRewind
                   Language.Fortran.Stop ds ds1 ds2 -> Language.Fortran.$cStop
                   Language.Fortran.Where ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cWhere
                   Language.Fortran.Write ds ds1 ds2 ds3 -> Language.Fortran.$cWrite
                   Language.Fortran.PointerAssg ds ds1 ds2 ds3
                   -> Language.Fortran.$cPointerAssg
                   Language.Fortran.Return ds ds1 ds2 -> Language.Fortran.$cReturn
                   Language.Fortran.Label ds ds1 ds2 ds3 -> Language.Fortran.$cLabel
                   Language.Fortran.Print ds ds1 ds2 ds3 -> Language.Fortran.$cPrint
                   Language.Fortran.ReadS ds ds1 ds2 ds3 -> Language.Fortran.$cReadS
                   Language.Fortran.TextStmt ds ds1 ds2 -> Language.Fortran.$cTextStmt
                   Language.Fortran.NullStmt ds ds1 -> Language.Fortran.$cNullStmt
                   Language.Fortran.SelectStmt ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cSelectStmt
                   Language.Fortran.OpenCLMap ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cOpenCLMap
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cOpenCLReduce
                   Language.Fortran.OpenCLSeq ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cOpenCLSeq
                   Language.Fortran.OpenCLBufferRead ds ds1 ds2
                   -> Language.Fortran.$cOpenCLBufferRead
                   Language.Fortran.OpenCLBufferWrite ds ds1 ds2
                   -> Language.Fortran.$cOpenCLBufferWrite }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fDataFraction6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Fraction
                                                                       p>_N)
                  (Language.Fortran.$fDataFraction_$cgfoldl @ p v)
                  (Language.Fortran.$fDataFraction_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Fraction p) ->
                   case ds of wild {
                     Language.Fortran.IntegerConst ds1 ds2
                     -> Language.Fortran.$cIntegerConst
                     Language.Fortran.FractionConst ds1 ds2 ds3
                     -> Language.Fortran.$cFractionConst
                     Language.Fortran.NullFraction ds1
                     -> Language.Fortran.$cNullFraction })
                  (\ (ds :: Language.Fortran.Fraction p) ->
                   Language.Fortran.$tFraction)
                  (Language.Fortran.$fDataFraction_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Fraction p)))
                  (Language.Fortran.$fDataFraction2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Fraction p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Fraction p>_R)
                  (Language.Fortran.$fDataFraction1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.Fraction p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.Fraction p>_P)
                  (Language.Fortran.$fDataFraction_$cgmapQr @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapQ @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapQi @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapM @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapMp @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapMo @ p v) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fraction p
    -> Data.Functor.Const.Const r (Language.Fortran.Fraction p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Fraction p) ->
                 case eta of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> (ds
                         (ds ds1 (ds2 @ p $dData1 a1))
                         (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Fraction p>_P))
                   Language.Fortran.FractionConst a1 a2 a3
                   -> (ds
                         (ds
                            (ds ds1 (ds2 @ p $dData1 a1))
                            (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                         (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Fraction p>_P))
                   Language.Fortran.NullFraction a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Fraction p>_P)) }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fraction p
    -> Data.Functor.Identity.Identity (Language.Fortran.Fraction p)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Fraction p) ->
                 case x0 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> (Language.Fortran.IntegerConst
                         @ p
                         (ds @ p $dData1 a1)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fraction p>_R))
                   Language.Fortran.FractionConst a1 a2 a3
                   -> (Language.Fortran.FractionConst
                         @ p
                         (ds @ p $dData1 a1)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fraction p>_R))
                   Language.Fortran.NullFraction a1
                   -> (Language.Fortran.NullFraction @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fraction p>_R)) }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fraction
                        1763003010597220149##
                        14474579820754583017##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFraction4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Fraction
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Fraction
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
fc934a99e420a02ccce3029b7ee02938
  $fDataFraction4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataFraction5) -}
75a475495404168c4043ce4efe5a0dae
  $fDataFraction5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fraction"#) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Fraction p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Fraction
                   @ p
                   Language.Fortran.$fDataFraction7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Fraction
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fraction
                        1763003010597220149##
                        14474579820754583017##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFraction4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Fraction
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Fraction p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataFraction3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Fraction p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Fraction <p>_N)) } } } }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Fraction p
    -> c (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           $dData1
                           (z @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                              (Language.Fortran.IntegerConst @ p))
                           a1)
                        a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ GHC.Base.String
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           Data.Data.$fData[]_$s$fData[]
                           (k @ p
                              @ (GHC.Base.String
                                 -> GHC.Base.String -> Language.Fortran.Fraction p)
                              $dData1
                              (z @ (p
                                    -> GHC.Base.String
                                    -> GHC.Base.String
                                    -> Language.Fortran.Fraction p)
                                 (Language.Fortran.FractionConst @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.NullFraction a1
                   -> k @ p
                        @ (Language.Fortran.Fraction p)
                        $dData1
                        (z @ (p -> Language.Fortran.Fraction p)
                           (Language.Fortran.NullFraction @ p))
                        a1 }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U> -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u) ->
                 Language.Fortran.$fDataFraction_$cgmapQr
                   @ p
                   $dData1
                   @ [u]
                   @ u
                   (GHC.Types.: @ u)
                   (GHC.Types.[] @ u)
                   ds) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.Fraction p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi5 @ p w @ u ww1 w363 w364 }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fraction p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Fraction p) ->
                 case x0 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> ds
                        (ds2 @ p $dData1 a1)
                        (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2) ds1)
                   Language.Fortran.FractionConst a1 a2 a3
                   -> ds
                        (ds2 @ p $dData1 a1)
                        (ds
                           (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                           (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3) ds1))
                   Language.Fortran.NullFraction a1
                   -> ds (ds2 @ p $dData1 a1) ds1 }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fDataFraction_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold4 @ p w @ c w362 w363 ww1 ww5 }) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fDataGSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.GSpec
                                                                       p>_N)
                  (Language.Fortran.$fDataGSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataGSpec_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.GSpec p) ->
                   case ds of wild {
                     Language.Fortran.GName ds1 ds2 -> Language.Fortran.$cGName
                     Language.Fortran.GOper ds1 ds2 -> Language.Fortran.$cGOper
                     Language.Fortran.GAssg ds1 -> Language.Fortran.$cGAssg })
                  (\ (ds :: Language.Fortran.GSpec p) -> Language.Fortran.$tGSpec)
                  (Language.Fortran.$fDataGSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.GSpec p)))
                  (Language.Fortran.$fDataGSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.GSpec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.GSpec p>_R)
                  (Language.Fortran.$fDataGSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapMo @ p v) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.GSpec p
    -> Data.Functor.Identity.Identity (Language.Fortran.GSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$fDataGSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.GSpec
                        6411480660480859959##
                        1355495822110532719##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataGSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.GSpec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.GSpec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
6929d60706dc63e34050110a0481f48b
  $fDataGSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataGSpec4) -}
64a152e92b5c05bc23ba53c2d985252a
  $fDataGSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GSpec"#) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.GSpec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.GSpec
                   @ p
                   Language.Fortran.$fDataGSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.GSpec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.GSpec
                        6411480660480859959##
                        1355495822110532719##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataGSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.GSpec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.GSpec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataGSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.GSpec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.GSpec <p>_N)) } } } }) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.GSpec p
    -> c (Language.Fortran.GSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BinOp p)
                   = Language.Fortran.$fDataBinOp @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.GSpec p)
                        $dData3
                        (k @ p
                           @ (Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                           $dData1
                           (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                              (Language.Fortran.GName @ p))
                           a1)
                        a2
                   Language.Fortran.GOper a1 a2
                   -> k @ (Language.Fortran.BinOp p)
                        @ (Language.Fortran.GSpec p)
                        $dData2
                        (k @ p
                           @ (Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                           $dData1
                           (z @ (p -> Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                              (Language.Fortran.GOper @ p))
                           a1)
                        a2
                   Language.Fortran.GAssg a1
                   -> k @ p
                        @ (Language.Fortran.GSpec p)
                        $dData1
                        (z @ (p -> Language.Fortran.GSpec p) (Language.Fortran.GAssg @ p))
                        a1 }) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataGSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.GSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.GSpec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.GSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.GSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fDataGSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.GSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.GSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.GSpec p)
                           x' } })) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.GSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.GSpec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.GSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.GSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fDataGSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.GSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.GSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.GSpec p)
                           x' } })) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.GSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.GSpec p) ->
                 (Language.Fortran.$fDataGSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.GSpec p>_P)
                   (GHC.Types.[] @ u)) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.GSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.GSpec p) ->
                 case Language.Fortran.$fDataGSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.GSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.GSpec p
                        -> Data.Functor.Const.Const r (Language.Fortran.GSpec p)
                   = Language.Fortran.$fDataGSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.GSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.GSpec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.GSpec p>_P)) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.GSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.GSpec p) ->
                 (Language.Fortran.$fDataGSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.GSpec p>_P)
                   ds1) -}
e56028b3291950d607189353469b7d3f
  $fDataGSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.GSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BinOp p)
                   = Language.Fortran.$fDataBinOp @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.GSpec p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.GSpec p)
                             $dData1
                             (z @ (p -> Language.Fortran.GSpec p) (Language.Fortran.GAssg @ p))
                        1#
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.GSpec p)
                             $dData3
                             (k @ p
                                @ (Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                                $dData1
                                (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                                   (Language.Fortran.GName @ p)))
                        2#
                        -> k @ (Language.Fortran.BinOp p)
                             @ (Language.Fortran.GSpec p)
                             $dData2
                             (k @ p
                                @ (Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                                $dData1
                                (z @ (p -> Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                                   (Language.Fortran.GOper @ p))) } } } }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fDataImplicit8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Implicit
                                                                       p>_N)
                  (Language.Fortran.$fDataImplicit_$cgfoldl @ p v)
                  (Language.Fortran.$fDataImplicit_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Implicit p) ->
                   case ds of wild {
                     Language.Fortran.ImplicitNone ds1
                     -> Language.Fortran.$cImplicitNone
                     Language.Fortran.ImplicitNull ds1
                     -> Language.Fortran.$cImplicitNull })
                  (\ (ds :: Language.Fortran.Implicit p) ->
                   Language.Fortran.$tImplicit)
                  (Language.Fortran.$fDataImplicit_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Implicit p)))
                  (Language.Fortran.$fDataImplicit4 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Implicit p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Implicit p>_R)
                  (Language.Fortran.$fDataImplicit3 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.Implicit p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.Implicit p>_P)
                  (Language.Fortran.$fDataImplicit_$cgmapQr @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapQ @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapQi @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapM @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapMp @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapMo @ p v) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit1 ::
    (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.ImplicitNull @ p, GHC.Types.False)) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit2 ::
    (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.ImplicitNone @ p, GHC.Types.False)) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit3 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Implicit p
    -> Data.Functor.Const.Const r (Language.Fortran.Implicit p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Implicit p) ->
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Implicit p>_P))
                   Language.Fortran.ImplicitNull a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Implicit p>_P)) }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit4 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Implicit p
    -> Data.Functor.Identity.Identity (Language.Fortran.Implicit p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Implicit p) ->
                 case x0 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> (Language.Fortran.ImplicitNone @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Implicit p>_R))
                   Language.Fortran.ImplicitNull a1
                   -> (Language.Fortran.ImplicitNull @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Implicit p>_R)) }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit5 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Implicit
                        2442557690173166678##
                        15129477447861538283##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataImplicit6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Implicit
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Implicit
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
2ad7a85519185e62cf397807d30ba092
  $fDataImplicit6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataImplicit7) -}
d6586ea99db97c5779d54e8fef9b525f
  $fDataImplicit7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Implicit"#) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Implicit p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Implicit
                   @ p
                   Language.Fortran.$fDataImplicit9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Implicit
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Implicit
                        2442557690173166678##
                        15129477447861538283##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataImplicit6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Implicit
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Implicit p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataImplicit5 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Implicit p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Implicit <p>_N)) } } } }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Implicit p
    -> c (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (z @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNone @ p))
                        a1
                   Language.Fortran.ImplicitNull a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (z @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNull @ p))
                        a1 }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Implicit p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNone @ p))
                        a1
                   Language.Fortran.ImplicitNull a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNull @ p))
                        a1 }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Implicit p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Implicit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Implicit p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Implicit p, GHC.Types.Bool)
                   @ (Language.Fortran.Implicit p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)[OneShot]
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl296 :: m d = ds @ d $dData2 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl296
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.ImplicitNone a1
                      -> k @ p
                           @ (Language.Fortran.Implicit p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
                              (Language.Fortran.$fDataImplicit2 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <p -> Language.Fortran.Implicit p>_N))
                           a1
                      Language.Fortran.ImplicitNull a1
                      -> k @ p
                           @ (Language.Fortran.Implicit p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
                              (Language.Fortran.$fDataImplicit1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <p -> Language.Fortran.Implicit p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.Implicit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Implicit p)
                           x' } })) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p -> [u]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Implicit p) ->
                 case x0 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u)
                   Language.Fortran.ImplicitNull a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u) }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.Implicit p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi3 @ p w @ u ww1 w363 w364 }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Implicit p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Implicit p) ->
                 case x0 of wild {
                   Language.Fortran.ImplicitNone a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.ImplicitNull a1
                   -> ds (ds2 @ p $dData1 a1) ds1 }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fDataImplicit_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Implicit p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold3 @ p w @ c w362 w363 ww1 ww5 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fDataIntentAttr6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.IntentAttr
                                                                       p>_N)
                  (Language.Fortran.$fDataIntentAttr_$cgfoldl @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.IntentAttr p) ->
                   case ds of wild {
                     Language.Fortran.In ds1 -> Language.Fortran.$cIn
                     Language.Fortran.Out ds1 -> Language.Fortran.$cOut
                     Language.Fortran.InOut ds1 -> Language.Fortran.$cInOut })
                  (\ (ds :: Language.Fortran.IntentAttr p) ->
                   Language.Fortran.$tIntentAttr)
                  (Language.Fortran.$fDataIntentAttr_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p)))
                  (Language.Fortran.$fDataIntentAttr2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.IntentAttr p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.IntentAttr p>_R)
                  (Language.Fortran.$fDataIntentAttr1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.IntentAttr p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.IntentAttr p>_P)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQr @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQ @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQi @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapM @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapMp @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapMo @ p v) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.IntentAttr p
    -> Data.Functor.Const.Const r (Language.Fortran.IntentAttr p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.IntentAttr p) ->
                 case eta of wild {
                   Language.Fortran.In a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.IntentAttr p>_P))
                   Language.Fortran.Out a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.IntentAttr p>_P))
                   Language.Fortran.InOut a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.IntentAttr p>_P)) }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.IntentAttr p
    -> Data.Functor.Identity.Identity (Language.Fortran.IntentAttr p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.IntentAttr p) ->
                 case x0 of wild {
                   Language.Fortran.In a1
                   -> (Language.Fortran.In @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.IntentAttr p>_R))
                   Language.Fortran.Out a1
                   -> (Language.Fortran.Out @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.IntentAttr p>_R))
                   Language.Fortran.InOut a1
                   -> (Language.Fortran.InOut @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.IntentAttr p>_R)) }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.IntentAttr
                        1418980594563321583##
                        15871466327150306728##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataIntentAttr4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.IntentAttr
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.IntentAttr
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
b1b63e591386ac5488a34c3c09273ec9
  $fDataIntentAttr4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$fDataIntentAttr5) -}
22f6814008e6f25242cc1370ef725f87
  $fDataIntentAttr5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IntentAttr"#) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.IntentAttr p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.IntentAttr
                   @ p
                   Language.Fortran.$fDataIntentAttr7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.IntentAttr
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.IntentAttr
                        1418980594563321583##
                        15871466327150306728##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataIntentAttr4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.IntentAttr
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.IntentAttr p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataIntentAttr3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.IntentAttr p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.IntentAttr <p>_N)) } } } }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.IntentAttr p
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.In @ p))
                        a1
                   Language.Fortran.Out a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.Out @ p))
                        a1
                   Language.Fortran.InOut a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.InOut @ p))
                        a1 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.IntentAttr p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.In a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.In @ p))
                        a1
                   Language.Fortran.Out a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.Out @ p))
                        a1
                   Language.Fortran.InOut a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.InOut @ p))
                        a1 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p -> [u]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u) ->
                 Language.Fortran.$fDataIntentAttr_$cgmapQr
                   @ p
                   $dData1
                   @ [u]
                   @ u
                   (GHC.Types.: @ u)
                   (GHC.Types.[] @ u)
                   ds) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.IntentAttr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi6 @ p w @ u ww1 w363 w364 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.IntentAttr p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.IntentAttr p) ->
                 case x0 of wild {
                   Language.Fortran.In a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.Out a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.InOut a1 -> ds (ds2 @ p $dData1 a1) ds1 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fDataIntentAttr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold5 @ p w @ c w362 w363 ww1 ww5 }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec ::
    Data.Data.Data p =>
    Data.Data.Data (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fDataInterfaceSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.InterfaceSpec
                                                                       p>_N)
                  (Language.Fortran.$fDataInterfaceSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.InterfaceSpec p) ->
                   case ds of wild {
                     Language.Fortran.FunctionInterface ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cFunctionInterface
                     Language.Fortran.SubroutineInterface ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cSubroutineInterface
                     Language.Fortran.ModuleProcedure ds1 ds2
                     -> Language.Fortran.$cModuleProcedure })
                  (\ (ds :: Language.Fortran.InterfaceSpec p) ->
                   Language.Fortran.$tInterfaceSpec)
                  (Language.Fortran.$fDataInterfaceSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p)))
                  (Language.Fortran.$fDataInterfaceSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.InterfaceSpec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.InterfaceSpec p>_R)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapMo @ p v) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.InterfaceSpec p
    -> Data.Functor.Identity.Identity
         (Language.Fortran.InterfaceSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.InterfaceSpec p) ->
                 Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.InterfaceSpec
                        4051087511440590505##
                        864161115625639908##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataInterfaceSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.InterfaceSpec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.InterfaceSpec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
bb48eb44b7eefb8644fb1a1fa6f21c92
  $fDataInterfaceSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$fDataInterfaceSpec4) -}
29aa785c5a4e86b3eaeb34cf026af08f
  $fDataInterfaceSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InterfaceSpec"#) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.InterfaceSpec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.InterfaceSpec
                   @ p
                   Language.Fortran.$fDataInterfaceSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.InterfaceSpec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.InterfaceSpec
                        4051087511440590505##
                        864161115625639908##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataInterfaceSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.InterfaceSpec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.InterfaceSpec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataInterfaceSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.InterfaceSpec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.InterfaceSpec <p>_N)) } } } }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.InterfaceSpec p
    -> c (Language.Fortran.InterfaceSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.InterfaceSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.InterfaceSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.InterfaceSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.InterfaceSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.InterfaceSpec p)
                           x' } })) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.InterfaceSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.InterfaceSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.InterfaceSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.InterfaceSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.InterfaceSpec p)
                           x' } })) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.InterfaceSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.InterfaceSpec p) ->
                 (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <[u]>_R <Language.Fortran.InterfaceSpec p>_P)
                   (GHC.Types.[] @ u)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.InterfaceSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.InterfaceSpec p) ->
                 case Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.InterfaceSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.InterfaceSpec p
                        -> Data.Functor.Const.Const r (Language.Fortran.InterfaceSpec p)
                   = Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.InterfaceSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.InterfaceSpec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.InterfaceSpec p>_P)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.InterfaceSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.InterfaceSpec p) ->
                 (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <r>_R <Language.Fortran.InterfaceSpec p>_P)
                   ds1) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fDataInterfaceSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.InterfaceSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec ::
    Data.Data.Data p =>
    Data.Data.Data (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fDataMeasureUnitSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.MeasureUnitSpec
                                                                       p>_N)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.MeasureUnitSpec p) ->
                   case ds of wild {
                     Language.Fortran.UnitProduct ds1 ds2
                     -> Language.Fortran.$cUnitProduct
                     Language.Fortran.UnitQuotient ds1 ds2 ds3
                     -> Language.Fortran.$cUnitQuotient
                     Language.Fortran.UnitNone ds1 -> Language.Fortran.$cUnitNone })
                  (\ (ds :: Language.Fortran.MeasureUnitSpec p) ->
                   Language.Fortran.$tMeasureUnitSpec)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p)))
                  (Language.Fortran.$fDataMeasureUnitSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.MeasureUnitSpec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.MeasureUnitSpec p>_R)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapMo @ p v) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.MeasureUnitSpec p
    -> Data.Functor.Identity.Identity
         (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.MeasureUnitSpec
                        3028355738573783699##
                        18207650571513030677##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataMeasureUnitSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.MeasureUnitSpec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.MeasureUnitSpec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
3a232b93940faf51b49c419d3e1e9d06
  $fDataMeasureUnitSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$fDataMeasureUnitSpec4) -}
987bf4e5998b5566d77f5fcacd9b30d6
  $fDataMeasureUnitSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MeasureUnitSpec"#) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.MeasureUnitSpec
                   @ p
                   Language.Fortran.$fDataMeasureUnitSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.MeasureUnitSpec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.MeasureUnitSpec
                        3028355738573783699##
                        18207650571513030677##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataMeasureUnitSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.MeasureUnitSpec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.MeasureUnitSpec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataMeasureUnitSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.MeasureUnitSpec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.MeasureUnitSpec <p>_N)) } } } }) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.MeasureUnitSpec p
    -> c (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Fraction p)
                   = Language.Fortran.$fDataFraction @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = Data.Data.$fData(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       Data.Data.$fData[]_$s$fData[]
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                       $dData3
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> k @ [(Language.Fortran.MeasureUnit,
                            Language.Fortran.Fraction p)]
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData4
                        (k @ p
                           @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                              -> Language.Fortran.MeasureUnitSpec p)
                           $dData1
                           (z @ (p
                                 -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> Language.Fortran.MeasureUnitSpec p)
                              (Language.Fortran.UnitProduct @ p))
                           a1)
                        a2
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> k @ [(Language.Fortran.MeasureUnit,
                            Language.Fortran.Fraction p)]
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData4
                        (k @ [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                           @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                              -> Language.Fortran.MeasureUnitSpec p)
                           $dData4
                           (k @ p
                              @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> Language.Fortran.MeasureUnitSpec p)
                              $dData1
                              (z @ (p
                                    -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                    -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                    -> Language.Fortran.MeasureUnitSpec p)
                                 (Language.Fortran.UnitQuotient @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.UnitNone a1
                   -> k @ p
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData1
                        (z @ (p -> Language.Fortran.MeasureUnitSpec p)
                           (Language.Fortran.UnitNone @ p))
                        a1 }) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.MeasureUnitSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.MeasureUnitSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.MeasureUnitSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.MeasureUnitSpec p)
                           x' } })) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.MeasureUnitSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.MeasureUnitSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.MeasureUnitSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.MeasureUnitSpec p)
                           x' } })) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.MeasureUnitSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.MeasureUnitSpec p) ->
                 (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <[u]>_R <Language.Fortran.MeasureUnitSpec p>_P)
                   (GHC.Types.[] @ u)) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.MeasureUnitSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.MeasureUnitSpec p) ->
                 case Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.MeasureUnitSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.MeasureUnitSpec p
                        -> Data.Functor.Const.Const r (Language.Fortran.MeasureUnitSpec p)
                   = Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.MeasureUnitSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.MeasureUnitSpec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.MeasureUnitSpec p>_P)) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.MeasureUnitSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.MeasureUnitSpec p) ->
                 (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <r>_R <Language.Fortran.MeasureUnitSpec p>_P)
                   ds1) -}
087eb564eb74f6fb18285d4e97659717
  $fDataMeasureUnitSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Fraction p)
                   = Language.Fortran.$fDataFraction @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = Data.Data.$fData(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       Data.Data.$fData[]_$s$fData[]
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                       $dData3
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.MeasureUnitSpec p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData1
                             (z @ (p -> Language.Fortran.MeasureUnitSpec p)
                                (Language.Fortran.UnitNone @ p))
                        1#
                        -> k @ [(Language.Fortran.MeasureUnit,
                                 Language.Fortran.Fraction p)]
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData4
                             (k @ p
                                @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                   -> Language.Fortran.MeasureUnitSpec p)
                                $dData1
                                (z @ (p
                                      -> [(Language.Fortran.MeasureUnit,
                                           Language.Fortran.Fraction p)]
                                      -> Language.Fortran.MeasureUnitSpec p)
                                   (Language.Fortran.UnitProduct @ p)))
                        2#
                        -> k @ [(Language.Fortran.MeasureUnit,
                                 Language.Fortran.Fraction p)]
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData4
                             (k @ [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                   -> Language.Fortran.MeasureUnitSpec p)
                                $dData4
                                (k @ p
                                   @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                      -> [(Language.Fortran.MeasureUnit,
                                           Language.Fortran.Fraction p)]
                                      -> Language.Fortran.MeasureUnitSpec p)
                                   $dData1
                                   (z @ (p
                                         -> [(Language.Fortran.MeasureUnit,
                                              Language.Fortran.Fraction p)]
                                         -> [(Language.Fortran.MeasureUnit,
                                              Language.Fortran.Fraction p)]
                                         -> Language.Fortran.MeasureUnitSpec p)
                                      (Language.Fortran.UnitQuotient @ p)))) } } } }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fDataProgUnit5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ProgUnit
                                                                       p>_N)
                  (Language.Fortran.$fDataProgUnit_$cgfoldl @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgunfold @ p v)
                  (Language.Fortran.$fDataProgUnit_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.ProgUnit p) ->
                   Language.Fortran.$tProgUnit)
                  (Language.Fortran.$fDataProgUnit_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p)))
                  (Language.Fortran.$fDataProgUnit1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ProgUnit p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ProgUnit p>_R)
                  (Language.Fortran.$fDataProgUnit_$cgmapQl @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapQr @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapQ @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapQi @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapM @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapMp @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapMo @ p v) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ProgUnit p
    -> Data.Functor.Identity.Identity (Language.Fortran.ProgUnit p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.ProgUnit p) ->
                 Language.Fortran.$fDataProgUnit_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ProgUnit
                        6479780727992239168##
                        17397259944912469841##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataProgUnit3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.ProgUnit
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.ProgUnit
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
841edc8dbbd7c394a19ef0edc2568635
  $fDataProgUnit3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataProgUnit4) -}
5a74374714cdc58a053dcdf03bfe01a8
  $fDataProgUnit4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ProgUnit"#) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.ProgUnit p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ProgUnit
                   @ p
                   Language.Fortran.$fDataProgUnit6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.ProgUnit
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ProgUnit
                        6479780727992239168##
                        17397259944912469841##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataProgUnit3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.ProgUnit
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ProgUnit p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataProgUnit2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ProgUnit p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ProgUnit <p>_N)) } } } }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ProgUnit p
    -> c (Language.Fortran.ProgUnit p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataProgUnit_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.ProgUnit p) ->
                 let {
                   lvl295 :: m (Language.Fortran.ProgUnit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.ProgUnit p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.ProgUnit p, GHC.Types.Bool)
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fDataProgUnit_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.ProgUnit p>_N)
                   (\ (ds1 :: (Language.Fortran.ProgUnit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.ProgUnit p)
                           x' } })) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.ProgUnit p) ->
                 let {
                   lvl295 :: m (Language.Fortran.ProgUnit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.ProgUnit p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.ProgUnit p, GHC.Types.Bool)
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fDataProgUnit_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.ProgUnit p>_N)
                   (\ (ds1 :: (Language.Fortran.ProgUnit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.ProgUnit p)
                           x' } })) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ProgUnit p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.ProgUnit p) ->
                 (Language.Fortran.$fDataProgUnit_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.ProgUnit p>_P)
                   (GHC.Types.[] @ u)) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ProgUnit p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.ProgUnit p) ->
                 case Language.Fortran.$fDataProgUnit_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ProgUnit p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.ProgUnit p
                        -> Data.Functor.Const.Const r (Language.Fortran.ProgUnit p)
                   = Language.Fortran.$fDataProgUnit_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.ProgUnit p) -> g x)
                   `cast`
                 (<Language.Fortran.ProgUnit p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.ProgUnit p>_P)) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ProgUnit p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.ProgUnit p) ->
                 (Language.Fortran.$fDataProgUnit_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.ProgUnit p>_P)
                   ds1) -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ProgUnit p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
573fa2fe80c5713ab0c018712ac118d8
  $fDataProgUnit_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.ProgUnit p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: Language.Fortran.ProgUnit p) ->
                 case ds of wild {
                   Language.Fortran.Main ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cMain
                   Language.Fortran.Sub ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cSub
                   Language.Fortran.Function ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cFunction
                   Language.Fortran.Module ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cModule
                   Language.Fortran.BlockData ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cBlockData
                   Language.Fortran.PSeq ds1 ds2 ds3 ds4 -> Language.Fortran.$cPSeq
                   Language.Fortran.Prog ds1 ds2 ds3 -> Language.Fortran.$cProg
                   Language.Fortran.NullProg ds1 ds2 -> Language.Fortran.$cNullProg
                   Language.Fortran.IncludeProg ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cIncludeProg }) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fDataSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Spec
                                                                       p>_N)
                  (Language.Fortran.$fDataSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataSpec_$cgunfold @ p v)
                  (Language.Fortran.$fDataSpec_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Spec p) -> Language.Fortran.$tSpec)
                  (Language.Fortran.$fDataSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Spec p)))
                  (Language.Fortran.$fDataSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Spec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Spec p>_R)
                  (Language.Fortran.$fDataSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapMo @ p v) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Spec p
    -> Data.Functor.Identity.Identity (Language.Fortran.Spec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Spec p) ->
                 Language.Fortran.$fDataSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Spec
                        11142086596812947727##
                        14943008726274983037##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Spec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Spec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
6a2c8f9e8cc00deced0fd4ec66a01b21
  $fDataSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataSpec4) -}
b0c7b0869fa482be0ce8133308ed970c
  $fDataSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Spec"#) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Spec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Spec
                   @ p
                   Language.Fortran.$fDataSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Spec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Spec
                        11142086596812947727##
                        14943008726274983037##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Spec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Spec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Spec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Spec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Spec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Spec <p>_N)) } } } }) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Spec p
    -> c (Language.Fortran.Spec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Spec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Spec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Spec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Spec p, GHC.Types.Bool)
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fDataSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Spec p>_N)
                   (\ (ds1 :: (Language.Fortran.Spec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Spec p)
                           x' } })) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Spec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Spec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Spec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Spec p, GHC.Types.Bool)
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fDataSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Spec p>_N)
                   (\ (ds1 :: (Language.Fortran.Spec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Spec p)
                           x' } })) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Spec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Spec p) ->
                 (Language.Fortran.$fDataSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Spec p>_P)
                   (GHC.Types.[] @ u)) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Spec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Spec p) ->
                 case Language.Fortran.$fDataSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Spec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Spec p
                        -> Data.Functor.Const.Const r (Language.Fortran.Spec p)
                   = Language.Fortran.$fDataSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Spec p) -> g x)
                   `cast`
                 (<Language.Fortran.Spec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Spec p>_P)) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Spec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Spec p) ->
                 (Language.Fortran.$fDataSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Spec p>_P)
                   ds1) -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Spec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
941eca76f3a57e540d54e971b6bf91ab
  $fDataSpec_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Spec p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Spec p) ->
                 case w362 of wild {
                   Language.Fortran.Access ds ds1 -> Language.Fortran.$cAccess
                   Language.Fortran.Action ds ds1 -> Language.Fortran.$cAction
                   Language.Fortran.Advance ds ds1 -> Language.Fortran.$cAdvance
                   Language.Fortran.Blank ds ds1 -> Language.Fortran.$cBlank
                   Language.Fortran.Delim ds ds1 -> Language.Fortran.$cDelim
                   Language.Fortran.Direct ds ds1 -> Language.Fortran.$cDirect
                   Language.Fortran.End ds ds1 -> Language.Fortran.$cEnd
                   Language.Fortran.Err ds ds1 -> Language.Fortran.$cErr
                   Language.Fortran.ExFile ds ds1 -> Language.Fortran.$cExFile
                   Language.Fortran.Exist ds ds1 -> Language.Fortran.$cExist
                   Language.Fortran.Eor ds ds1 -> Language.Fortran.$cEor
                   Language.Fortran.File ds ds1 -> Language.Fortran.$cFile
                   Language.Fortran.FMT ds ds1 -> Language.Fortran.$cFMT
                   Language.Fortran.Form ds ds1 -> Language.Fortran.$cForm
                   Language.Fortran.Formatted ds ds1 -> Language.Fortran.$cFormatted
                   Language.Fortran.Unformatted ds ds1
                   -> Language.Fortran.$cUnformatted
                   Language.Fortran.IOLength ds ds1 -> Language.Fortran.$cIOLength
                   Language.Fortran.IOStat ds ds1 -> Language.Fortran.$cIOStat
                   Language.Fortran.Name ds ds1 -> Language.Fortran.$cName
                   Language.Fortran.Named ds ds1 -> Language.Fortran.$cNamed
                   Language.Fortran.NoSpec ds ds1 -> Language.Fortran.$cNoSpec
                   Language.Fortran.Number ds ds1 -> Language.Fortran.$cNumber
                   Language.Fortran.Floating ds ds1 ds2 -> Language.Fortran.$cFloating
                   Language.Fortran.NextRec ds ds1 -> Language.Fortran.$cNextRec
                   Language.Fortran.NML ds ds1 -> Language.Fortran.$cNML
                   Language.Fortran.Opened ds ds1 -> Language.Fortran.$cOpened
                   Language.Fortran.Pad ds ds1 -> Language.Fortran.$cPad
                   Language.Fortran.Position ds ds1 -> Language.Fortran.$cPosition
                   Language.Fortran.Read ds ds1 -> Language.Fortran.$cRead
                   Language.Fortran.ReadWrite ds ds1 -> Language.Fortran.$cReadWrite
                   Language.Fortran.Rec ds ds1 -> Language.Fortran.$cRec
                   Language.Fortran.Recl ds ds1 -> Language.Fortran.$cRecl
                   Language.Fortran.Sequential ds ds1 -> Language.Fortran.$cSequential
                   Language.Fortran.Size ds ds1 -> Language.Fortran.$cSize
                   Language.Fortran.Status ds ds1 -> Language.Fortran.$cStatus
                   Language.Fortran.StringLit ds ds1 -> Language.Fortran.$cStringLit
                   Language.Fortran.Unit ds ds1 -> Language.Fortran.$cUnit
                   Language.Fortran.WriteSp ds ds1 -> Language.Fortran.$cWriteSp
                   Language.Fortran.Delimiter ds -> Language.Fortran.$cDelimiter }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc :: Data.Data.Data Language.Fortran.SrcLoc
  DFunId
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fDataSrcLoc7
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.SrcLoc>_N)
                  Language.Fortran.$fDataSrcLoc_$cgfoldl
                  Language.Fortran.$fDataSrcLoc_$cgunfold
                  Language.Fortran.$fDataSrcLoc_$ctoConstr
                  Language.Fortran.$fDataSrcLoc_$cdataTypeOf
                  Language.Fortran.$fDataSrcLoc_$cdataCast1
                  Language.Fortran.$fDataSrcLoc_$cdataCast2
                  Language.Fortran.$fDataSrcLoc2
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.SrcLoc>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.SrcLoc>_R)
                  Language.Fortran.$fDataSrcLoc1
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.SrcLoc>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.SrcLoc>_P)
                  Language.Fortran.$fDataSrcLoc_$cgmapQr
                  Language.Fortran.$fDataSrcLoc_$cgmapQ
                  Language.Fortran.$fDataSrcLoc_$cgmapQi
                  Language.Fortran.$fDataSrcLoc_$cgmapM
                  Language.Fortran.$fDataSrcLoc_$cgmapMp
                  Language.Fortran.$fDataSrcLoc_$cgmapMo -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc1 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SrcLoc
    -> Data.Functor.Const.Const r Language.Fortran.SrcLoc
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (w :: r -> r' -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (w364 :: Language.Fortran.SrcLoc) ->
                 case w364 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 (Language.Fortran.$w$cgmapQl @ r @ r' w w362 w363 ww1 ww2 ww3)
                   `cast`
                 (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.SrcLoc>_P)) }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc2 ::
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.SrcLoc
    -> Data.Functor.Identity.Identity Language.Fortran.SrcLoc
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: forall b. Data.Data.Data b => b -> b)
                   (w362 :: Language.Fortran.SrcLoc) ->
                 case w362 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 (Language.Fortran.SrcLoc
                    (w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1)
                    (w @ GHC.Types.Int Data.Data.$fDataInt ww2)
                    (w @ GHC.Types.Int Data.Data.$fDataInt ww3))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.SrcLoc>_R)) }) -}
1b46350317e52dd3004c50c1c05a234d
  $fDataSrcLoc3 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataSrcLoc4) -}
66c388f56af27482f164124afd29b29d
  $fDataSrcLoc4 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cSrcLoc
                   (GHC.Types.[] @ Data.Data.Constr)) -}
477f5e5fc8328eff843a309fdbe2f9a1
  $fDataSrcLoc5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataSrcLoc6) -}
7e1cf4bb89b2119a4040f8ee43602672
  $fDataSrcLoc6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SrcLoc"#) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.SrcLoc
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ *
                        @ Language.Fortran.SrcLoc
                        3748651587269198497##
                        6830777199461934499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSrcLoc8
                        0#
                        GHC.Types.krep$*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ *
                   @ Language.Fortran.SrcLoc
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
46b2399fde87b4a17525d229c9775db2
  $fDataSrcLoc8 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataSrcLoc6) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cdataCast1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c Language.Fortran.SrcLoc)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing @ (c Language.Fortran.SrcLoc)) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c Language.Fortran.SrcLoc)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ t :: * -> * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c Language.Fortran.SrcLoc)) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cdataTypeOf ::
    Language.Fortran.SrcLoc -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Language.Fortran.SrcLoc) -> Language.Fortran.$tSrcLoc) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.SrcLoc
    -> c Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (w :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (w362 :: forall g. g -> c g)
                   (w363 :: Language.Fortran.SrcLoc) ->
                 case w363 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgfoldl @ c w w362 ww1 ww2 ww3 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w :: GHC.Base.Monad m)
                   (w362 :: forall d. Data.Data.Data d => d -> m d)
                   (w363 :: Language.Fortran.SrcLoc) ->
                 case w363 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapM @ m w w362 ww1 ww2 ww3 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgmapMo ::
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)> -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgmapMp ::
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)> -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SrcLoc -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U,U)>m2, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (w :: forall d. Data.Data.Data d => d -> u)
                   (w362 :: Language.Fortran.SrcLoc) ->
                 case w362 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 GHC.Types.:
                   @ u
                   (w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1)
                   (GHC.Types.:
                      @ u
                      (w @ GHC.Types.Int Data.Data.$fDataInt ww2)
                      (GHC.Types.:
                         @ u
                         (w @ GHC.Types.Int Data.Data.$fDataInt ww3)
                         (GHC.Types.[] @ u))) }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SrcLoc
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (w :: GHC.Types.Int)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.SrcLoc) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.SrcLoc ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgmapQi @ u ww1 w362 ww3 ww4 ww5 } }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (w :: r' -> r -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (w364 :: Language.Fortran.SrcLoc) ->
                 case w364 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapQr @ r @ r' w w362 w363 ww1 ww2 ww3 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c Language.Fortran.SrcLoc
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ c :: * -> *
                   (w :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w362 :: forall r. r -> c r)
                   (w363 :: Data.Data.Constr) ->
                 Language.Fortran.$w$cgunfold @ c w w362) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fDataSrcLoc_$ctoConstr ::
    Language.Fortran.SrcLoc -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 ->
                 Language.Fortran.$cSrcLoc }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fDataSubName6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.SubName
                                                                       p>_N)
                  (Language.Fortran.$fDataSubName_$cgfoldl @ p v)
                  (Language.Fortran.$fDataSubName_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.SubName p) ->
                   case ds of wild {
                     Language.Fortran.SubName ds1 ds2 -> Language.Fortran.$cSubName
                     Language.Fortran.NullSubName ds1
                     -> Language.Fortran.$cNullSubName })
                  (\ (ds :: Language.Fortran.SubName p) ->
                   Language.Fortran.$tSubName)
                  (Language.Fortran.$fDataSubName_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.SubName p)))
                  (Language.Fortran.$fDataSubName2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.SubName p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.SubName p>_R)
                  (Language.Fortran.$fDataSubName1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.SubName p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.SubName p>_P)
                  (Language.Fortran.$fDataSubName_$cgmapQr @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapQ @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapQi @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapM @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapMp @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapMo @ p v) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SubName p
    -> Data.Functor.Const.Const r (Language.Fortran.SubName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.SubName p) ->
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> (ds
                         (ds ds1 (ds2 @ p $dData1 a1))
                         (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.SubName p>_P))
                   Language.Fortran.NullSubName a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.SubName p>_P)) }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.SubName p
    -> Data.Functor.Identity.Identity (Language.Fortran.SubName p)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.SubName p) ->
                 case x0 of wild {
                   Language.Fortran.SubName a1 a2
                   -> (Language.Fortran.SubName
                         @ p
                         (ds @ p $dData1 a1)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.SubName p>_R))
                   Language.Fortran.NullSubName a1
                   -> (Language.Fortran.NullSubName @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.SubName p>_R)) }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.SubName
                        984225159571365899##
                        8068956749520935535##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSubName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.SubName
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.SubName
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
3697434081cd5329181740b32b6fa5be
  $fDataSubName4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataSubName5) -}
4d705c5e112ebabfefc40e8913e0307d
  $fDataSubName5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SubName"#) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.SubName p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.SubName
                   @ p
                   Language.Fortran.$fDataSubName7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.SubName
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.SubName
                        984225159571365899##
                        8068956749520935535##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSubName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.SubName
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.SubName p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataSubName3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.SubName p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.SubName p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.SubName p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.SubName <p>_N)) } } } }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.SubName p
    -> c (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.SubName p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.SubName p)
                           $dData1
                           (z @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                              (Language.Fortran.SubName @ p))
                           a1)
                        a2
                   Language.Fortran.NullSubName a1
                   -> k @ p
                        @ (Language.Fortran.SubName p)
                        $dData1
                        (z @ (p -> Language.Fortran.SubName p)
                           (Language.Fortran.NullSubName @ p))
                        a1 }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.SubName p) ->
                 let {
                   $sk :: forall b. m (GHC.Base.String -> b) -> GHC.Base.String -> m b
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ @ b
                       (c :: m (GHC.Base.String -> b))[OneShot]
                       (x :: GHC.Base.String)[OneShot] ->
                     let {
                       lvl295 :: m GHC.Base.String
                       = ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (GHC.Base.String -> b)
                       @ b
                       c
                       (\ (c' :: GHC.Base.String -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ GHC.Base.String
                          @ b
                          lvl295
                          (\ (x' :: GHC.Base.String) ->
                           GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> $sk
                        @ (Language.Fortran.SubName p)
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.SubName p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                              (Language.Fortran.SubName @ p))
                           a1)
                        a2
                   Language.Fortran.NullSubName a1
                   -> k @ p
                        @ (Language.Fortran.SubName p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.SubName p)
                           (Language.Fortran.NullSubName @ p))
                        a1 }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>m2, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.SubName p) ->
                 case w363 of wild {
                   Language.Fortran.SubName a1 a2
                   -> GHC.Types.:
                        @ u
                        (w362 @ p w a1)
                        (GHC.Types.:
                           @ u
                           (w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                           (GHC.Types.[] @ u))
                   Language.Fortran.NullSubName a1
                   -> GHC.Types.: @ u (w362 @ p w a1) (GHC.Types.[] @ u) }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.SubName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi2 @ p w @ u ww1 w363 w364 }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SubName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.SubName p) ->
                 case x0 of wild {
                   Language.Fortran.SubName a1 a2
                   -> ds
                        (ds2 @ p $dData1 a1)
                        (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2) ds1)
                   Language.Fortran.NullSubName a1
                   -> ds (ds2 @ p $dData1 a1) ds1 }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fDataSubName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold1 @ p w @ c w362 w363 ww1 ww5 }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fDataType5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Type
                                                                       p>_N)
                  (Language.Fortran.$fDataType_$cgfoldl @ p v)
                  (Language.Fortran.$fDataType_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Type p) ->
                   case ds of wild {
                     Language.Fortran.BaseType ds1 ds2 ds3 ds4 ds5
                     -> Language.Fortran.$cBaseType
                     Language.Fortran.ArrayT ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cArrayT })
                  (\ (ds :: Language.Fortran.Type p) -> Language.Fortran.$tType)
                  (Language.Fortran.$fDataType_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Type p)))
                  (Language.Fortran.$fDataType1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Type p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Type p>_R)
                  (Language.Fortran.$fDataType_$cgmapQl @ p v)
                  (Language.Fortran.$fDataType_$cgmapQr @ p v)
                  (Language.Fortran.$fDataType_$cgmapQ @ p v)
                  (Language.Fortran.$fDataType_$cgmapQi @ p v)
                  (Language.Fortran.$fDataType_$cgmapM @ p v)
                  (Language.Fortran.$fDataType_$cgmapMp @ p v)
                  (Language.Fortran.$fDataType_$cgmapMo @ p v) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Type p
    -> Data.Functor.Identity.Identity (Language.Fortran.Type p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Type p) ->
                 Language.Fortran.$fDataType_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Type
                        5041943942817465598##
                        7039049096440602731##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Type
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Type
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
f018a87bc2bada37aaac892635323e33
  $fDataType3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataType4) -}
4d40843bf5bbb6297df030922cfe004c
  $fDataType4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Type"#) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Type p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Type
                   @ p
                   Language.Fortran.$fDataType6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Type
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Type
                        5041943942817465598##
                        7039049096440602731##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Type
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Type p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataType2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Type p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Type p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Type p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Type <p>_N)) } } } }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Type p
    -> c (Language.Fortran.Type p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data [Language.Fortran.Attr p]
                   = Data.Data.$fData[] @ (Language.Fortran.Attr p) $dData3
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData6 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData5
                       $dData5
                 } in
                 let {
                   $dData7 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData6
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.Type p)
                        $dData5
                        (k @ (Language.Fortran.Expr p)
                           @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                           $dData5
                           (k @ [Language.Fortran.Attr p]
                              @ (Language.Fortran.Expr p
                                 -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                              $dData4
                              (k @ (Language.Fortran.BaseType p)
                                 @ ([Language.Fortran.Attr p]
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Type p)
                                 $dData2
                                 (k @ p
                                    @ (Language.Fortran.BaseType p
                                       -> [Language.Fortran.Attr p]
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Type p)
                                    $dData1
                                    (z @ (p
                                          -> Language.Fortran.BaseType p
                                          -> [Language.Fortran.Attr p]
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Type p)
                                       (Language.Fortran.BaseType @ p))
                                    a1)
                                 a2)
                              a3)
                           a4)
                        a5
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.Type p)
                        $dData5
                        (k @ (Language.Fortran.Expr p)
                           @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                           $dData5
                           (k @ [Language.Fortran.Attr p]
                              @ (Language.Fortran.Expr p
                                 -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                              $dData4
                              (k @ (Language.Fortran.BaseType p)
                                 @ ([Language.Fortran.Attr p]
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Type p)
                                 $dData2
                                 (k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                    @ (Language.Fortran.BaseType p
                                       -> [Language.Fortran.Attr p]
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Type p)
                                    $dData7
                                    (k @ p
                                       @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                          -> Language.Fortran.BaseType p
                                          -> [Language.Fortran.Attr p]
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Type p)
                                       $dData1
                                       (z @ (p
                                             -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                             -> Language.Fortran.BaseType p
                                             -> [Language.Fortran.Attr p]
                                             -> Language.Fortran.Expr p
                                             -> Language.Fortran.Expr p
                                             -> Language.Fortran.Type p)
                                          (Language.Fortran.ArrayT @ p))
                                       a1)
                                    a2)
                                 a3)
                              a4)
                           a5)
                        a6 }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataType_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Type p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Type p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Type p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Type p, GHC.Types.Bool)
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fDataType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Type p>_N)
                   (\ (ds1 :: (Language.Fortran.Type p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Type p)
                           x' } })) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Type p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Type p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Type p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Type p, GHC.Types.Bool)
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fDataType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Type p>_N)
                   (\ (ds1 :: (Language.Fortran.Type p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Type p)
                           x' } })) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Type p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Type p) ->
                 (Language.Fortran.$fDataType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Type p>_P)
                   (GHC.Types.[] @ u)) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Type p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Type p) ->
                 case Language.Fortran.$fDataType_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Type p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Type p
                        -> Data.Functor.Const.Const r (Language.Fortran.Type p)
                   = Language.Fortran.$fDataType_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Type p) -> g x)
                   `cast`
                 (<Language.Fortran.Type p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Type p>_P)) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Type p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Type p) ->
                 (Language.Fortran.$fDataType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Type p>_P)
                   ds1) -}
6b8210ea10d2538ca4598cfb9584c470
  $fDataType_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Type p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data [Language.Fortran.Attr p]
                   = Data.Data.$fData[] @ (Language.Fortran.Attr p) $dData3
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData6 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData5
                       $dData5
                 } in
                 let {
                   $dData7 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData6
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.Type p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.Type p)
                             $dData5
                             (k @ (Language.Fortran.Expr p)
                                @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                                $dData5
                                (k @ [Language.Fortran.Attr p]
                                   @ (Language.Fortran.Expr p
                                      -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                                   $dData4
                                   (k @ (Language.Fortran.BaseType p)
                                      @ ([Language.Fortran.Attr p]
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Type p)
                                      $dData2
                                      (k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                         @ (Language.Fortran.BaseType p
                                            -> [Language.Fortran.Attr p]
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Type p)
                                         $dData7
                                         (k @ p
                                            @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                               -> Language.Fortran.BaseType p
                                               -> [Language.Fortran.Attr p]
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Type p)
                                            $dData1
                                            (z @ (p
                                                  -> [(Language.Fortran.Expr p,
                                                       Language.Fortran.Expr p)]
                                                  -> Language.Fortran.BaseType p
                                                  -> [Language.Fortran.Attr p]
                                                  -> Language.Fortran.Expr p
                                                  -> Language.Fortran.Expr p
                                                  -> Language.Fortran.Type p)
                                               (Language.Fortran.ArrayT @ p)))))))
                        1#
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.Type p)
                             $dData5
                             (k @ (Language.Fortran.Expr p)
                                @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                                $dData5
                                (k @ [Language.Fortran.Attr p]
                                   @ (Language.Fortran.Expr p
                                      -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                                   $dData4
                                   (k @ (Language.Fortran.BaseType p)
                                      @ ([Language.Fortran.Attr p]
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Type p)
                                      $dData2
                                      (k @ p
                                         @ (Language.Fortran.BaseType p
                                            -> [Language.Fortran.Attr p]
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Type p)
                                         $dData1
                                         (z @ (p
                                               -> Language.Fortran.BaseType p
                                               -> [Language.Fortran.Attr p]
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Type p)
                                            (Language.Fortran.BaseType @ p)))))) } } } }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fDataUnaryOp8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.UnaryOp
                                                                       p>_N)
                  (Language.Fortran.$fDataUnaryOp_$cgfoldl @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.UnaryOp p) ->
                   case ds of wild {
                     Language.Fortran.UMinus ds1 -> Language.Fortran.$cUMinus
                     Language.Fortran.Not ds1 -> Language.Fortran.$cNot })
                  (\ (ds :: Language.Fortran.UnaryOp p) ->
                   Language.Fortran.$tUnaryOp)
                  (Language.Fortran.$fDataUnaryOp_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p)))
                  (Language.Fortran.$fDataUnaryOp4 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.UnaryOp p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.UnaryOp p>_R)
                  (Language.Fortran.$fDataUnaryOp3 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.UnaryOp p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.UnaryOp p>_P)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQr @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQ @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQi @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapM @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapMp @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapMo @ p v) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp1 :: (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.Not @ p, GHC.Types.False)) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp2 :: (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.UMinus @ p, GHC.Types.False)) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp3 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UnaryOp p
    -> Data.Functor.Const.Const r (Language.Fortran.UnaryOp p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.UnaryOp p) ->
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.UnaryOp p>_P))
                   Language.Fortran.Not a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.UnaryOp p>_P)) }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp4 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.UnaryOp p
    -> Data.Functor.Identity.Identity (Language.Fortran.UnaryOp p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.UnaryOp p) ->
                 case x0 of wild {
                   Language.Fortran.UMinus a1
                   -> (Language.Fortran.UMinus @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.UnaryOp p>_R))
                   Language.Fortran.Not a1
                   -> (Language.Fortran.Not @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.UnaryOp p>_R)) }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp5 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UnaryOp
                        2406080142223468931##
                        3604077026223734859##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUnaryOp6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.UnaryOp
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.UnaryOp
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
f86895c0a1a10387ed1ccabacb9dc49e
  $fDataUnaryOp6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataUnaryOp7) -}
6de433c0824f9cc87f2727931d42fd16
  $fDataUnaryOp7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UnaryOp"#) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.UnaryOp p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.UnaryOp
                   @ p
                   Language.Fortran.$fDataUnaryOp9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.UnaryOp
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UnaryOp
                        2406080142223468931##
                        3604077026223734859##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUnaryOp6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.UnaryOp
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.UnaryOp p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataUnaryOp5 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.UnaryOp p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.UnaryOp <p>_N)) } } } }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.UnaryOp p
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (z @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.UMinus @ p))
                        a1
                   Language.Fortran.Not a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (z @ (p -> Language.Fortran.UnaryOp p) (Language.Fortran.Not @ p))
                        a1 }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.UMinus @ p))
                        a1
                   Language.Fortran.Not a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.Not @ p))
                        a1 }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 let {
                   lvl295 :: m (Language.Fortran.UnaryOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.UnaryOp p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.UnaryOp p, GHC.Types.Bool)
                   @ (Language.Fortran.UnaryOp p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)[OneShot]
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl296 :: m d = ds @ d $dData2 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl296
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.UMinus a1
                      -> k @ p
                           @ (Language.Fortran.UnaryOp p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
                              (Language.Fortran.$fDataUnaryOp2 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.UnaryOp p>_N))
                           a1
                      Language.Fortran.Not a1
                      -> k @ p
                           @ (Language.Fortran.UnaryOp p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
                              (Language.Fortran.$fDataUnaryOp1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.UnaryOp p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.UnaryOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.UnaryOp p)
                           x' } })) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p -> [u]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.UnaryOp p) ->
                 case x0 of wild {
                   Language.Fortran.UMinus a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u)
                   Language.Fortran.Not a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u) }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.UnaryOp p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi7 @ p w @ u ww1 w363 w364 }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UnaryOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.UnaryOp p) ->
                 case x0 of wild {
                   Language.Fortran.UMinus a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.Not a1 -> ds (ds2 @ p $dData1 a1) ds1 }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fDataUnaryOp_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold6 @ p w @ c w362 w363 ww1 ww5 }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fDataUseBlock8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.UseBlock
                                                                       p>_N)
                  (Language.Fortran.$fDataUseBlock_$cgfoldl @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.UseBlock p) ->
                   case ds of wild { Language.Fortran.UseBlock ds1 ds2 ->
                   Language.Fortran.$cUseBlock })
                  (\ (ds :: Language.Fortran.UseBlock p) ->
                   Language.Fortran.$tUseBlock)
                  (Language.Fortran.$fDataUseBlock_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p)))
                  (Language.Fortran.$fDataUseBlock1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.UseBlock p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.UseBlock p>_R)
                  (Language.Fortran.$fDataUseBlock_$cgmapQl @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapQr @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapQ @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapQi @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapM @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapMp @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapMo @ p v) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.UseBlock p
    -> Data.Functor.Identity.Identity (Language.Fortran.UseBlock p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.UseBlock p) ->
                 case x0 of wild { Language.Fortran.UseBlock a1 a2 ->
                 (Language.Fortran.UseBlock
                    @ p
                    (ds
                       @ (Language.Fortran.Uses p)
                       (Language.Fortran.$fDataUses @ p $dData1)
                       a1)
                    (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.UseBlock p>_R)) }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UseBlock
                        3173672121419574053##
                        9222787055978102566##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUseBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.UseBlock
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.UseBlock
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
b7e2ea0935bd1a65cae3827e063170e4
  $fDataUseBlock3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataUseBlock4) -}
b4756de4062c5b6be45a50526baa6a50
  $fDataUseBlock4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UseBlock"#) -}
56db77813df75e861c8c3e151f86cc14
  $fDataUseBlock5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataUseBlock6) -}
63b64e02d98d1bd3f9f749ccf1a17696
  $fDataUseBlock6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cUseBlock
                   (GHC.Types.[] @ Data.Data.Constr)) -}
655e774a93f61858da7d7b38d7c58394
  $fDataUseBlock7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataUseBlock4) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.UseBlock p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.UseBlock
                   @ p
                   Language.Fortran.$fDataUseBlock9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.UseBlock
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UseBlock
                        3173672121419574053##
                        9222787055978102566##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUseBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.UseBlock
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.UseBlock p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataUseBlock2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.UseBlock p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.UseBlock <p>_N)) } } } }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.UseBlock p
    -> c (Language.Fortran.UseBlock p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.UseBlock p) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData2
                      (z @ (Language.Fortran.Uses p
                            -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.UseBlock @ p))
                      a1)
                   a2 }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 let {
                   lvl295 :: m (Language.Fortran.Uses p
                                -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                   = GHC.Base.return
                       @ m
                       $dMonad
                       @ (Language.Fortran.Uses p
                          -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                       (Language.Fortran.UseBlock @ p)
                 } in
                 \ (ds1 :: Language.Fortran.UseBlock p) ->
                 case ds1 of wild { Language.Fortran.UseBlock a1 a2 ->
                 let {
                   lvl296 :: m Language.Fortran.SrcLoc
                   = ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                   @ (Language.Fortran.UseBlock p)
                   (let {
                      lvl297 :: m (Language.Fortran.Uses p)
                      = ds @ (Language.Fortran.Uses p) $dData2 a1
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Language.Fortran.Uses p
                         -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      lvl295
                      (\ (c' :: Language.Fortran.Uses p
                                -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Language.Fortran.Uses p)
                         @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         lvl297
                         (\ (x' :: Language.Fortran.Uses p) ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                            (c' x'))))
                   (\ (c' :: Language.Fortran.SrcLoc
                             -> Language.Fortran.UseBlock p) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.UseBlock p)
                      lvl296
                      (\ (x' :: Language.Fortran.SrcLoc) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (Language.Fortran.UseBlock p)
                         (c' x'))) }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UseBlock p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.UseBlock p) ->
                 case w363 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 GHC.Types.:
                   @ u
                   (w362
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p w)
                      ww1)
                   (GHC.Types.:
                      @ u
                      (w362 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc ww2)
                      (GHC.Types.[] @ u)) }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UseBlock p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.UseBlock p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w364 of ww2 { Language.Fortran.UseBlock ww3 ww4 ->
                 Language.Fortran.$w$cgmapQi4 @ p w @ u ww1 w363 ww3 ww4 } }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UseBlock p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 (\ (ds3 :: Language.Fortran.UseBlock p) ->
                  case ds3 of wild { Language.Fortran.UseBlock a1 a2 ->
                  (ds
                     (ds ds1 (ds2 @ (Language.Fortran.Uses p) $dData2 a1))
                     (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                    `cast`
                  (Sym (Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.UseBlock p>_P)) })
                   `cast`
                 (<Language.Fortran.UseBlock p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.UseBlock p>_P)) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UseBlock p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.UseBlock p) ->
                 case w365 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr2
                   @ p
                   w
                   @ r
                   @ r'
                   w362
                   w363
                   w364
                   ww1
                   ww2 }) -}
68ba21623f3e340277f6ee2081f0e743
  $fDataUseBlock_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.UseBlock p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData2
                      (z @ (Language.Fortran.Uses p
                            -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.UseBlock @ p)))) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fDataUses5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Uses
                                                                       p>_N)
                  (Language.Fortran.$fDataUses_$cgfoldl @ p v)
                  (Language.Fortran.$fDataUses_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Uses p) ->
                   case ds of wild {
                     Language.Fortran.Use ds1 ds2 ds3 ds4 -> Language.Fortran.$cUse
                     Language.Fortran.UseNil ds1 -> Language.Fortran.$cUseNil })
                  (\ (ds :: Language.Fortran.Uses p) -> Language.Fortran.$tUses)
                  (Language.Fortran.$fDataUses_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Uses p)))
                  (Language.Fortran.$fDataUses1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Uses p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Uses p>_R)
                  (Language.Fortran.$fDataUses_$cgmapQl @ p v)
                  (Language.Fortran.$fDataUses_$cgmapQr @ p v)
                  (Language.Fortran.$fDataUses_$cgmapQ @ p v)
                  (Language.Fortran.$fDataUses_$cgmapQi @ p v)
                  (Language.Fortran.$fDataUses_$cgmapM @ p v)
                  (Language.Fortran.$fDataUses_$cgmapMp @ p v)
                  (Language.Fortran.$fDataUses_$cgmapMo @ p v) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Uses p
    -> Data.Functor.Identity.Identity (Language.Fortran.Uses p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Uses
                        9335191301300359584##
                        14913659259380547358##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUses3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Uses
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Uses
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
8ced80f03b71b84819ec12d6a5d8f11d
  $fDataUses3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataUses4) -}
600582c8d0883b5d7f0f23f1214fc68c
  $fDataUses4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Uses"#) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Uses p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Uses
                   @ p
                   Language.Fortran.$fDataUses6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Uses
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Uses
                        9335191301300359584##
                        14913659259380547358##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUses3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Uses
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Uses p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataUses2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Uses p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Uses p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Uses p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Uses <p>_N)) } } } }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Uses p
    -> c (Language.Fortran.Uses p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
8347678f6676bd3eacaa7f87ac9bd303
  $fDataUses_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Uses p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fDataVarName9 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.VarName
                                                                       p>_N)
                  (Language.Fortran.$fDataVarName_$cgfoldl @ p v)
                  (Language.Fortran.$fDataVarName_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.VarName p) ->
                   case ds of wild { Language.Fortran.VarName ds1 ds2 ->
                   Language.Fortran.$cVarName })
                  (\ (ds :: Language.Fortran.VarName p) ->
                   Language.Fortran.$tVarName)
                  (Language.Fortran.$fDataVarName_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.VarName p)))
                  (Language.Fortran.$fDataVarName2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.VarName p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.VarName p>_R)
                  (Language.Fortran.$fDataVarName1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.VarName p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.VarName p>_P)
                  (Language.Fortran.$fDataVarName_$cgmapQr @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapQ @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapQi @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapM @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapMp @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapMo @ p v) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.VarName p
    -> Data.Functor.Const.Const r (Language.Fortran.VarName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r -> r' -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.VarName p) ->
                 case w365 of ww { Language.Fortran.VarName ww1 ww2 ->
                 (Language.Fortran.$w$cgmapQl1
                    @ p
                    w
                    @ r
                    @ r'
                    w362
                    w363
                    w364
                    ww1
                    ww2)
                   `cast`
                 (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.VarName p>_P)) }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName10 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.VarName
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.VarName
                        758275414034097677##
                        18215223083819119344##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataVarName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.VarName
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.VarName p
    -> Data.Functor.Identity.Identity (Language.Fortran.VarName p)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.VarName p) ->
                 case x0 of wild { Language.Fortran.VarName a1 a2 ->
                 (Language.Fortran.VarName
                    @ p
                    (ds @ p $dData1 a1)
                    (ds @ Language.Fortran.Variable Data.Data.$fData[]_$s$fData[] a2))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.VarName p>_R)) }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.VarName
                        758275414034097677##
                        18215223083819119344##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataVarName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.VarName
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.VarName
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
ebd147b4a9e17e87c78a310863492c64
  $fDataVarName4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataVarName5) -}
8754c0bf1d77d2f4ea1cf1b406cf2916
  $fDataVarName5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VarName"#) -}
45c21683c3c33bcf0d52c548b616440a
  $fDataVarName6 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataVarName7) -}
08bcd0deca8e9a51451458354b6dd988
  $fDataVarName7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cVarName
                   (GHC.Types.[] @ Data.Data.Constr)) -}
cf2d16ba4d0a514c980c05669a855e37
  $fDataVarName8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataVarName5) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName9 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.VarName p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.VarName
                   @ p
                   Language.Fortran.$fDataVarName10
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.VarName p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataVarName3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.VarName p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.VarName p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.VarName p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.VarName <p>_N)) } } } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.VarName p
    -> c (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.VarName p) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      $dData1
                      (z @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p))
                      a1)
                   a2 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (w364 :: Language.Fortran.VarName p) ->
                 case w364 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapM1 @ p w @ m w362 w363 ww1 ww2 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.VarName p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.VarName p) ->
                 case x0 of wild { Language.Fortran.VarName a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ p $dData1 a1)
                   (GHC.Types.:
                      @ u
                      (ds @ Language.Fortran.Variable Data.Data.$fData[]_$s$fData[] a2)
                      (GHC.Types.[] @ u)) }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.VarName p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.VarName p) ->
                 case x of wild { Language.Fortran.VarName a1 a2 ->
                 case ds of wild1 { GHC.Types.I# x1 ->
                 case x1 of wild2 {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> ds1 @ p $dData1 a1
                   1#
                   -> ds1
                        @ Language.Fortran.Variable
                        Data.Data.$fData[]_$s$fData[]
                        a2 } } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.VarName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.VarName p) ->
                 case w365 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr3
                   @ p
                   w
                   @ r
                   @ r'
                   w362
                   w363
                   w364
                   ww1
                   ww2 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fDataVarName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.VarName p)
  {- Arity: 4, Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      $dData1
                      (z @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p)))) -}
2ecf4bb24a966e219012eee596c45ea8
  $fEqArg ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fEqArg_$c== @ p v)
                  (Language.Fortran.$fEqArg_$c/= @ p v) -}
6304956f2901eead56a8fac1e90d4904
  $fEqArgList ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fEqArgList_$c==1 @ p v)
                  (Language.Fortran.$fEqArgList_$c/= @ p v) -}
6304956f2901eead56a8fac1e90d4904
  $fEqArgList_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgList p
    -> Language.Fortran.ArgList p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.ArgList p)
                   (y :: Language.Fortran.ArgList p) ->
                 case x of wild { Language.Fortran.ArgList a1 a2 ->
                 case y of wild1 { Language.Fortran.ArgList b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArgList_$c== @ p $dEq a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
6304956f2901eead56a8fac1e90d4904
  $fEqArgList_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Expr p
    -> Language.Fortran.Expr p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
6304956f2901eead56a8fac1e90d4904
  $fEqArgList_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgList p
    -> Language.Fortran.ArgList p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.ArgList p)
                   (w363 :: Language.Fortran.ArgList p) ->
                 case w362 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.ArgList ww4 ww5 ->
                 Language.Fortran.$w$c==2 @ p w ww1 ww2 ww4 ww5 } }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fEqArgName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fEqArg_$c==2 @ p v)
                  (Language.Fortran.$fEqArgName_$c/= @ p v) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fEqArgName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgName p
    -> Language.Fortran.ArgName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.ArgName p)
                   (y :: Language.Fortran.ArgName p) ->
                 case Language.Fortran.$fEqArg_$c==2 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fEqArg_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Arg p -> Language.Fortran.Arg p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Arg p)
                   (y :: Language.Fortran.Arg p) ->
                 case Language.Fortran.$fEqArg_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fEqArg_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Arg p -> Language.Fortran.Arg p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.Arg p)
                   (w363 :: Language.Fortran.Arg p) ->
                 case w362 of ww { Language.Fortran.Arg ww1 ww2 ww3 ->
                 case w363 of ww4 { Language.Fortran.Arg ww5 ww6 ww7 ->
                 Language.Fortran.$w$c== @ p w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fEqArg_$c==1 ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcLoc)
                   (w362 :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 case w362 of ww4 { Language.Fortran.SrcLoc ww5 ww6 ww7 ->
                 Language.Fortran.$w$c==1 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fEqArg_$c==2 ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgName p
    -> Language.Fortran.ArgName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
3b46645d85b9c008a9510c0f3d8ec026
  $fEqAttr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fEqAttr_$c== @ p v)
                  (Language.Fortran.$fEqAttr_$c/= @ p v) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fEqAttr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Attr p
    -> Language.Fortran.Attr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Attr p)
                   (y :: Language.Fortran.Attr p) ->
                 case Language.Fortran.$fEqAttr_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fEqAttr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Attr p
    -> Language.Fortran.Attr p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
c66c0bcbb42951ba147c66147650e364
  $fEqBaseType ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fEqBaseType_$c== @ p v)
                  (Language.Fortran.$fEqBaseType_$c/= @ p v) -}
c66c0bcbb42951ba147c66147650e364
  $fEqBaseType_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.BaseType p
    -> Language.Fortran.BaseType p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.BaseType p)
                   (y :: Language.Fortran.BaseType p) ->
                 case Language.Fortran.$fEqBaseType_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c66c0bcbb42951ba147c66147650e364
  $fEqBaseType_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.BaseType p
    -> Language.Fortran.BaseType p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.BaseType p)
                   (ds1 :: Language.Fortran.BaseType p) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Integer b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Real a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Real b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Character a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Character b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.SomeType a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.SomeType b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.DerivedType a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.DerivedType b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqBaseType_$c==1 @ p $dEq a2 b2 } }
                   Language.Fortran.Recursive a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Recursive b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Pure a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Pure b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Elemental a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Elemental b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Logical a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Logical b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Complex a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Complex b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fEqBaseType_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.SubName p
    -> Language.Fortran.SubName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.SubName p)
                   (ds1 :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> case ds1 of wild1 {
                        Language.Fortran.SubName b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 }
                        Language.Fortran.NullSubName ipv -> GHC.Types.False }
                   Language.Fortran.NullSubName a1
                   -> case ds1 of wild1 {
                        Language.Fortran.SubName ipv ipv1 -> GHC.Types.False
                        Language.Fortran.NullSubName b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fEqBinOp ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fEqBinOp_$c== @ p v)
                  (Language.Fortran.$fEqBinOp_$c/= @ p v) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fEqBinOp_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.BinOp p
    -> Language.Fortran.BinOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.BinOp p)
                   (y :: Language.Fortran.BinOp p) ->
                 case Language.Fortran.$fEqBinOp_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fEqBinOp_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.BinOp p
    -> Language.Fortran.BinOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U> -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fEqBlock ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fEqBlock_$c== @ p v)
                  (Language.Fortran.$fEqBlock_$c/= @ p v) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fEqBlock_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Block p
    -> Language.Fortran.Block p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Block p)
                   (y :: Language.Fortran.Block p) ->
                 case Language.Fortran.$fEqBlock_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fEqBlock_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Block p
    -> Language.Fortran.Block p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Block p)
                   (ds1 :: Language.Fortran.Block p) ->
                 case ds of wild { Language.Fortran.Block a1 a2 a3 a4 a5 a6 ->
                 case ds1 of wild1 { Language.Fortran.Block b1 b2 b3 b4 b5 b6 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case a2 of wild3 { Language.Fortran.UseBlock a7 a8 ->
                      case b2 of wild4 { Language.Fortran.UseBlock b7 b8 ->
                      case Language.Fortran.$fEqBlock_$c==4 @ p $dEq a7 b7 of wild5 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case a8 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                           case b8 of ww4 { Language.Fortran.SrcLoc ww5 ww6 ww7 ->
                           case GHC.Base.eqString ww1 ww5 of wild6 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww2 of wild7 { GHC.Types.I# x ->
                                case ww6 of wild8 { GHC.Types.I# y ->
                                case GHC.Prim.==# x y of lwild {
                                  DEFAULT -> GHC.Types.False
                                  1#
                                  -> case ww3 of wild9 { GHC.Types.I# x1 ->
                                     case ww7 of wild10 { GHC.Types.I# y1 ->
                                     case GHC.Prim.==# x1 y1 of lwild1 {
                                       DEFAULT -> GHC.Types.False
                                       1#
                                       -> case Language.Fortran.$fEqBlock_$c==3
                                                 @ p
                                                 $dEq
                                                 a3
                                                 b3 of wild11 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case a4 of ww8 { (,) ww9 ww10 ->
                                               case b4 of ww11 { (,) ww12 ww13 ->
                                               case ww9 of ww14 { Language.Fortran.SrcLoc ww15 ww16 ww17 ->
                                               case ww12 of ww18 { Language.Fortran.SrcLoc ww19 ww20 ww21 ->
                                               case GHC.Base.eqString ww15 ww19 of wild12 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> case ww16 of wild13 { GHC.Types.I# x2 ->
                                                    case ww20 of wild14 { GHC.Types.I# y2 ->
                                                    case GHC.Prim.==# x2 y2 of lwild2 {
                                                      DEFAULT -> GHC.Types.False
                                                      1#
                                                      -> case ww17 of wild15 { GHC.Types.I# x3 ->
                                                         case ww21 of wild16 { GHC.Types.I# y3 ->
                                                         case GHC.Prim.==# x3 y3 of lwild3 {
                                                           DEFAULT -> GHC.Types.False
                                                           1#
                                                           -> case ww10 of ww22 { Language.Fortran.SrcLoc ww23 ww24 ww25 ->
                                                              case ww13 of ww26 { Language.Fortran.SrcLoc ww27 ww28 ww29 ->
                                                              case GHC.Base.eqString
                                                                     ww23
                                                                     ww27 of wild17 {
                                                                GHC.Types.False -> GHC.Types.False
                                                                GHC.Types.True
                                                                -> case ww24 of wild18 { GHC.Types.I# x4 ->
                                                                   case ww28 of wild19 { GHC.Types.I# y4 ->
                                                                   case GHC.Prim.==#
                                                                          x4
                                                                          y4 of lwild4 {
                                                                     DEFAULT -> GHC.Types.False
                                                                     1#
                                                                     -> case ww25 of wild20 { GHC.Types.I# x5 ->
                                                                        case ww29 of wild21 { GHC.Types.I# y5 ->
                                                                        case GHC.Prim.==#
                                                                               x5
                                                                               y5 of lwild5 {
                                                                          DEFAULT -> GHC.Types.False
                                                                          1#
                                                                          -> case Language.Fortran.$fEqBlock_$c==2
                                                                                    @ p
                                                                                    $dEq
                                                                                    a5
                                                                                    b5 of wild22 {
                                                                               GHC.Types.False
                                                                               -> GHC.Types.False
                                                                               GHC.Types.True
                                                                               -> Language.Fortran.$fEqBlock_$c==1
                                                                                    @ p
                                                                                    $dEq
                                                                                    a6
                                                                                    b6 } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }) -}
cab0cd6287333175c6b9d87427982518
  $fEqBlock_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fortran p
    -> Language.Fortran.Fortran p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fEqBlock_$c==2 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Decl p
    -> Language.Fortran.Decl p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
c7dcda169fba71f63c925de5ef25cb00
  $fEqBlock_$c==3 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Implicit p
    -> Language.Fortran.Implicit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Implicit p)
                   (ds1 :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> case ds1 of wild1 {
                        Language.Fortran.ImplicitNone b1 -> GHC.Classes.== @ p $dEq a1 b1
                        Language.Fortran.ImplicitNull ipv -> GHC.Types.False }
                   Language.Fortran.ImplicitNull a1
                   -> case ds1 of wild1 {
                        Language.Fortran.ImplicitNone ipv -> GHC.Types.False
                        Language.Fortran.ImplicitNull b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fEqBlock_$c==4 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.Uses p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fEqDataForm ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fEqDataForm_$c== @ p v)
                  (Language.Fortran.$fEqDataForm_$c/= @ p v) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fEqDataForm_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.DataForm p
    -> Language.Fortran.DataForm p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.DataForm p)
                   (y :: Language.Fortran.DataForm p) ->
                 case Language.Fortran.$fEqDataForm_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fEqDataForm_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.DataForm p
    -> Language.Fortran.DataForm p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Expr p)
                   = Language.Fortran.$fEqExpr @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = GHC.Classes.$fEq(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dEq1
                       $dEq1
                 } in
                 \ (ds :: Language.Fortran.DataForm p)
                   (ds1 :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data a1 a2 ->
                 case ds1 of wild1 { Language.Fortran.Data b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                        $dEq2
                        a2
                        b2 } } }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fEqDecl ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fEqBlock_$c==2 @ p v)
                  (Language.Fortran.$fEqDecl_$c/= @ p v) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fEqDecl_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Decl p
    -> Language.Fortran.Decl p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Decl p)
                   (y :: Language.Fortran.Decl p) ->
                 case Language.Fortran.$fEqBlock_$c==2 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6304956f2901eead56a8fac1e90d4904
  $fEqExpr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fEqArgList_$c== @ p v)
                  (Language.Fortran.$fEqExpr_$c/= @ p v) -}
6304956f2901eead56a8fac1e90d4904
  $fEqExpr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Expr p
    -> Language.Fortran.Expr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Expr p)
                   (y :: Language.Fortran.Expr p) ->
                 case Language.Fortran.$fEqArgList_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cab0cd6287333175c6b9d87427982518
  $fEqFortran ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fEqBlock_$c==1 @ p v)
                  (Language.Fortran.$fEqFortran_$c/= @ p v) -}
cab0cd6287333175c6b9d87427982518
  $fEqFortran_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fortran p
    -> Language.Fortran.Fortran p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Fortran p)
                   (y :: Language.Fortran.Fortran p) ->
                 case Language.Fortran.$fEqBlock_$c==1 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fEqFraction ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fEqFraction_$c== @ p v)
                  (Language.Fortran.$fEqFraction_$c/= @ p v) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fEqFraction_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fraction p
    -> Language.Fortran.Fraction p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Fraction p)
                   (y :: Language.Fortran.Fraction p) ->
                 case Language.Fortran.$fEqFraction_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fEqFraction_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fraction p
    -> Language.Fortran.Fraction p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Fraction p)
                   (ds1 :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.IntegerConst b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 } }
                   Language.Fortran.FractionConst a1 a2 a3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.FractionConst b1 b2 b3
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Base.eqString a2 b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> GHC.Base.eqString a3 b3 } } }
                   Language.Fortran.NullFraction a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.NullFraction b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
e56028b3291950d607189353469b7d3f
  $fEqGSpec ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fEqGSpec_$c== @ p v)
                  (Language.Fortran.$fEqGSpec_$c/= @ p v) -}
e56028b3291950d607189353469b7d3f
  $fEqGSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.GSpec p
    -> Language.Fortran.GSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.GSpec p)
                   (y :: Language.Fortran.GSpec p) ->
                 case Language.Fortran.$fEqGSpec_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e56028b3291950d607189353469b7d3f
  $fEqGSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.GSpec p
    -> Language.Fortran.GSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.GSpec p)
                   (ds1 :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GName b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqArgList_$c== @ p $dEq a2 b2 } }
                   Language.Fortran.GOper a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GOper b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqBinOp_$c== @ p $dEq a2 b2 } }
                   Language.Fortran.GAssg a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GAssg b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fEqImplicit ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fEqBlock_$c==3 @ p v)
                  (Language.Fortran.$fEqImplicit_$c/= @ p v) -}
c7dcda169fba71f63c925de5ef25cb00
  $fEqImplicit_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Implicit p
    -> Language.Fortran.Implicit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Implicit p)
                   (y :: Language.Fortran.Implicit p) ->
                 case Language.Fortran.$fEqBlock_$c==3 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fEqIntentAttr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fEqIntentAttr_$c== @ p v)
                  (Language.Fortran.$fEqIntentAttr_$c/= @ p v) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fEqIntentAttr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.IntentAttr p
    -> Language.Fortran.IntentAttr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.IntentAttr p)
                   (y :: Language.Fortran.IntentAttr p) ->
                 case Language.Fortran.$fEqIntentAttr_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fEqIntentAttr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.IntentAttr p
    -> Language.Fortran.IntentAttr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.IntentAttr p)
                   (ds1 :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.In b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Out a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Out b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.InOut a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.InOut b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fEqInterfaceSpec ::
    GHC.Classes.Eq p =>
    GHC.Classes.Eq (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fEqInterfaceSpec_$c== @ p v)
                  (Language.Fortran.$fEqInterfaceSpec_$c/= @ p v) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fEqInterfaceSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.InterfaceSpec p)
                   (y :: Language.Fortran.InterfaceSpec p) ->
                 case Language.Fortran.$fEqInterfaceSpec_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fEqInterfaceSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
087eb564eb74f6fb18285d4e97659717
  $fEqMeasureUnitSpec ::
    GHC.Classes.Eq p =>
    GHC.Classes.Eq (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fEqMeasureUnitSpec_$c== @ p v)
                  (Language.Fortran.$fEqMeasureUnitSpec_$c/= @ p v) -}
087eb564eb74f6fb18285d4e97659717
  $fEqMeasureUnitSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.MeasureUnitSpec p)
                   (y :: Language.Fortran.MeasureUnitSpec p) ->
                 case Language.Fortran.$fEqMeasureUnitSpec_$c==
                        @ p
                        $dEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
087eb564eb74f6fb18285d4e97659717
  $fEqMeasureUnitSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Fraction p)
                   = Language.Fortran.$fEqFraction @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = GHC.Classes.$fEq(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       GHC.Classes.$fEq[]_$s$fEq[]1
                       $dEq1
                 } in
                 \ (ds :: Language.Fortran.MeasureUnitSpec p)
                   (ds1 :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitProduct b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                  $dEq2
                                  a2
                                  b2 } }
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitQuotient b1 b2 b3
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                       $dEq2
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                       $dEq2
                                       a3
                                       b3 } } }
                   Language.Fortran.UnitNone a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitNone b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fEqProgUnit ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fEqProgUnit_$c== @ p v)
                  (Language.Fortran.$fEqProgUnit_$c/= @ p v) -}
573fa2fe80c5713ab0c018712ac118d8
  $fEqProgUnit_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ProgUnit p
    -> Language.Fortran.ProgUnit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.ProgUnit p)
                   (y :: Language.Fortran.ProgUnit p) ->
                 case Language.Fortran.$fEqProgUnit_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fEqProgUnit_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.ProgUnit p
    -> Language.Fortran.ProgUnit p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
941eca76f3a57e540d54e971b6bf91ab
  $fEqSpec ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fEqSpec_$c== @ p v)
                  (Language.Fortran.$fEqSpec_$c/= @ p v) -}
941eca76f3a57e540d54e971b6bf91ab
  $fEqSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Spec p
    -> Language.Fortran.Spec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Spec p)
                   (y :: Language.Fortran.Spec p) ->
                 case Language.Fortran.$fEqSpec_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
941eca76f3a57e540d54e971b6bf91ab
  $fEqSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Spec p
    -> Language.Fortran.Spec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fEqSrcLoc :: GHC.Classes.Eq Language.Fortran.SrcLoc
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fEqArg_$c==1
                  Language.Fortran.$fEqSrcLoc_$c/= -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fEqSrcLoc_$c/= ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.Fortran.SrcLoc) (y :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqArg_$c==1 x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fEqSubName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fEqBaseType_$c==1 @ p v)
                  (Language.Fortran.$fEqSubName_$c/= @ p v) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fEqSubName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.SubName p
    -> Language.Fortran.SubName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.SubName p)
                   (y :: Language.Fortran.SubName p) ->
                 case Language.Fortran.$fEqBaseType_$c==1 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fEqType ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fEqType_$c== @ p v)
                  (Language.Fortran.$fEqType_$c/= @ p v) -}
6b8210ea10d2538ca4598cfb9584c470
  $fEqType_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Type p
    -> Language.Fortran.Type p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Type p)
                   (y :: Language.Fortran.Type p) ->
                 case Language.Fortran.$fEqType_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fEqType_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Type p
    -> Language.Fortran.Type p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Expr p)
                   = Language.Fortran.$fEqExpr @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = GHC.Classes.$fEq(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dEq1
                       $dEq1
                 } in
                 let {
                   $dEq3 :: GHC.Classes.Eq (Language.Fortran.Attr p)
                   = Language.Fortran.$fEqAttr @ p $dEq
                 } in
                 let {
                   lvl295 :: Language.Fortran.Expr p
                             -> Language.Fortran.Expr p -> GHC.Types.Bool
                   = Language.Fortran.$fEqArgList_$c== @ p $dEq
                 } in
                 \ (ds :: Language.Fortran.Type p)
                   (ds1 :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> case ds1 of wild1 {
                        Language.Fortran.BaseType b1 b2 b3 b4 b5
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case Language.Fortran.$fEqBaseType_$c==
                                       @ p
                                       $dEq
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Classes.$fEq[]_$c==
                                            @ (Language.Fortran.Attr p)
                                            $dEq3
                                            a3
                                            b3 of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case lvl295 a4 b4 of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True -> lvl295 a5 b5 } } } }
                        Language.Fortran.ArrayT ipv ipv1 ipv2 ipv3 ipv4 ipv5
                        -> GHC.Types.False }
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> case ds1 of wild1 {
                        Language.Fortran.BaseType ipv ipv1 ipv2 ipv3 ipv4
                        -> GHC.Types.False
                        Language.Fortran.ArrayT b1 b2 b3 b4 b5 b6
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                                       $dEq2
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case Language.Fortran.$fEqBaseType_$c==
                                            @ p
                                            $dEq
                                            a3
                                            b3 of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case GHC.Classes.$fEq[]_$c==
                                                 @ (Language.Fortran.Attr p)
                                                 $dEq3
                                                 a4
                                                 b4 of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case lvl295 a5 b5 of wild6 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True -> lvl295 a6 b6 } } } } } } }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fEqUnaryOp ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fEqUnaryOp_$c== @ p v)
                  (Language.Fortran.$fEqUnaryOp_$c/= @ p v) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fEqUnaryOp_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.UnaryOp p
    -> Language.Fortran.UnaryOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.UnaryOp p)
                   (y :: Language.Fortran.UnaryOp p) ->
                 case Language.Fortran.$fEqUnaryOp_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fEqUnaryOp_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.UnaryOp p
    -> Language.Fortran.UnaryOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.UnaryOp p)
                   (ds1 :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1
                   -> case ds1 of wild1 {
                        Language.Fortran.UMinus b1 -> GHC.Classes.== @ p $dEq a1 b1
                        Language.Fortran.Not ipv -> GHC.Types.False }
                   Language.Fortran.Not a1
                   -> case ds1 of wild1 {
                        Language.Fortran.UMinus ipv -> GHC.Types.False
                        Language.Fortran.Not b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
68ba21623f3e340277f6ee2081f0e743
  $fEqUseBlock ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fEqUseBlock_$c== @ p v)
                  (Language.Fortran.$fEqUseBlock_$c/= @ p v) -}
68ba21623f3e340277f6ee2081f0e743
  $fEqUseBlock_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.UseBlock p
    -> Language.Fortran.UseBlock p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.UseBlock p)
                   (y :: Language.Fortran.UseBlock p) ->
                 case x of wild { Language.Fortran.UseBlock a1 a2 ->
                 case y of wild1 { Language.Fortran.UseBlock b1 b2 ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArg_$c==1 a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
68ba21623f3e340277f6ee2081f0e743
  $fEqUseBlock_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.UseBlock p
    -> Language.Fortran.UseBlock p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.UseBlock p)
                   (w363 :: Language.Fortran.UseBlock p) ->
                 case w362 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.UseBlock ww4 ww5 ->
                 Language.Fortran.$w$c==3 @ p w ww1 ww2 ww4 ww5 } }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fEqUses ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fEqBlock_$c==4 @ p v)
                  (Language.Fortran.$fEqUses_$c/= @ p v) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fEqUses_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.Uses p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Uses p)
                   (y :: Language.Fortran.Uses p) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
361ec85699986b0b7f4d68a05374d64d
  $fEqVarName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fEqVarName_$c== @ p v)
                  (Language.Fortran.$fEqVarName_$c/= @ p v) -}
361ec85699986b0b7f4d68a05374d64d
  $fEqVarName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.VarName p)
                   (y :: Language.Fortran.VarName p) ->
                 case x of wild { Language.Fortran.VarName a1 a2 ->
                 case y of wild1 { Language.Fortran.VarName b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fEqVarName_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c==4 @ p w ww1 ww2 ww4 ww5 } }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fFunctorArg :: GHC.Base.Functor Language.Fortran.Arg
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Arg
                  Language.Fortran.$fFunctorArg_$cfmap
                  Language.Fortran.$fFunctorArg_$c<$ -}
6304956f2901eead56a8fac1e90d4904
  $fFunctorArgList :: GHC.Base.Functor Language.Fortran.ArgList
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ArgList
                  Language.Fortran.$fFunctorArgList_$cfmap
                  Language.Fortran.$fFunctorArgList_$c<$ -}
6304956f2901eead56a8fac1e90d4904
  $fFunctorArgList_$c<$ ::
    a -> Language.Fortran.ArgList b -> Language.Fortran.ArgList a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.ArgList b) ->
                 case ds of wild { Language.Fortran.ArgList a1 a2 ->
                 Language.Fortran.ArgList
                   @ a
                   z
                   (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2) }) -}
6304956f2901eead56a8fac1e90d4904
  $fFunctorArgList_$c<$1 ::
    a -> Language.Fortran.Expr b -> Language.Fortran.Expr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
6304956f2901eead56a8fac1e90d4904
  $fFunctorArgList_$cfmap ::
    (a -> b)
    -> Language.Fortran.ArgList a -> Language.Fortran.ArgList b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.ArgList a) ->
                 case ds of wild { Language.Fortran.ArgList a1 a2 ->
                 Language.Fortran.ArgList
                   @ b
                   (f94 a1)
                   (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a2) }) -}
6304956f2901eead56a8fac1e90d4904
  $fFunctorArgList_$cfmap1 ::
    (a -> b) -> Language.Fortran.Expr a -> Language.Fortran.Expr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fFunctorArgName :: GHC.Base.Functor Language.Fortran.ArgName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ArgName
                  Language.Fortran.$fFunctorArg_$cfmap1
                  Language.Fortran.$fFunctorArg_$c<$1 -}
2ecf4bb24a966e219012eee596c45ea8
  $fFunctorArg_$c<$ ::
    a -> Language.Fortran.Arg b -> Language.Fortran.Arg a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.Arg b) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 Language.Fortran.Arg
                   @ a
                   z
                   (Language.Fortran.$fFunctorArg_$c<$1 @ a @ b z a2)
                   a3 }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fFunctorArg_$c<$1 ::
    a -> Language.Fortran.ArgName b -> Language.Fortran.ArgName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
2ecf4bb24a966e219012eee596c45ea8
  $fFunctorArg_$cfmap ::
    (a -> b) -> Language.Fortran.Arg a -> Language.Fortran.Arg b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.Arg a) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 Language.Fortran.Arg
                   @ b
                   (f94 a1)
                   (Language.Fortran.$fFunctorArg_$cfmap1 @ a @ b f94 a2)
                   a3 }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fFunctorArg_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.ArgName a -> Language.Fortran.ArgName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
3b46645d85b9c008a9510c0f3d8ec026
  $fFunctorAttr :: GHC.Base.Functor Language.Fortran.Attr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Attr
                  Language.Fortran.$fFunctorAttr_$cfmap
                  Language.Fortran.$fFunctorAttr_$c<$ -}
3b46645d85b9c008a9510c0f3d8ec026
  $fFunctorAttr_$c<$ ::
    a -> Language.Fortran.Attr b -> Language.Fortran.Attr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.Attr b) ->
                 case ds of wild {
                   Language.Fortran.Parameter a1 -> Language.Fortran.Parameter @ a z
                   Language.Fortran.Allocatable a1
                   -> Language.Fortran.Allocatable @ a z
                   Language.Fortran.External a1 -> Language.Fortran.External @ a z
                   Language.Fortran.Intent a1 a2
                   -> Language.Fortran.Intent
                        @ a
                        z
                        (Language.Fortran.$fFunctorAttr_$c<$3 @ a @ b z a2)
                   Language.Fortran.Intrinsic a1 -> Language.Fortran.Intrinsic @ a z
                   Language.Fortran.Optional a1 -> Language.Fortran.Optional @ a z
                   Language.Fortran.Pointer a1 -> Language.Fortran.Pointer @ a z
                   Language.Fortran.Save a1 -> Language.Fortran.Save @ a z
                   Language.Fortran.Target a1 -> Language.Fortran.Target @ a z
                   Language.Fortran.Volatile a1 -> Language.Fortran.Volatile @ a z
                   Language.Fortran.Public a1 -> Language.Fortran.Public @ a z
                   Language.Fortran.Private a1 -> Language.Fortran.Private @ a z
                   Language.Fortran.Sequence a1 -> Language.Fortran.Sequence @ a z
                   Language.Fortran.Dimension a1 a2
                   -> Language.Fortran.Dimension
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           (\ (b4 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a4,
                             Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a5) })
                           a2)
                   Language.Fortran.MeasureUnit a1 a2
                   -> Language.Fortran.MeasureUnit
                        @ a
                        z
                        (Language.Fortran.$fFunctorAttr_$c<$1 @ a @ b z a2) }) -}
087eb564eb74f6fb18285d4e97659717
  $fFunctorAttr_$c<$1 ::
    a
    -> Language.Fortran.MeasureUnitSpec b
    -> Language.Fortran.MeasureUnitSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.Fortran.MeasureUnitSpec b) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> Language.Fortran.UnitProduct
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction b)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$c<$2 @ a @ b z a5) })
                           a2)
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> Language.Fortran.UnitQuotient
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction b)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$c<$2 @ a @ b z a5) })
                           a2)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           (\ (b7 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction b)) ->
                            case b7 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$c<$2 @ a @ b z a5) })
                           a3)
                   Language.Fortran.UnitNone a1
                   -> Language.Fortran.UnitNone @ a z }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fFunctorAttr_$c<$2 ::
    a -> Language.Fortran.Fraction b -> Language.Fortran.Fraction a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.Fraction b) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst @ a z a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst @ a z a2 a3
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ a z }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fFunctorAttr_$c<$3 ::
    a -> Language.Fortran.IntentAttr b -> Language.Fortran.IntentAttr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.IntentAttr b) ->
                 case ds of wild {
                   Language.Fortran.In a1 -> Language.Fortran.In @ a z
                   Language.Fortran.Out a1 -> Language.Fortran.Out @ a z
                   Language.Fortran.InOut a1 -> Language.Fortran.InOut @ a z }) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fFunctorAttr_$cfmap ::
    (a -> b) -> Language.Fortran.Attr a -> Language.Fortran.Attr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.Attr a) ->
                 case ds of wild {
                   Language.Fortran.Parameter a1
                   -> Language.Fortran.Parameter @ b (f94 a1)
                   Language.Fortran.Allocatable a1
                   -> Language.Fortran.Allocatable @ b (f94 a1)
                   Language.Fortran.External a1
                   -> Language.Fortran.External @ b (f94 a1)
                   Language.Fortran.Intent a1 a2
                   -> Language.Fortran.Intent
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorAttr_$cfmap3 @ a @ b f94 a2)
                   Language.Fortran.Intrinsic a1
                   -> Language.Fortran.Intrinsic @ b (f94 a1)
                   Language.Fortran.Optional a1
                   -> Language.Fortran.Optional @ b (f94 a1)
                   Language.Fortran.Pointer a1
                   -> Language.Fortran.Pointer @ b (f94 a1)
                   Language.Fortran.Save a1 -> Language.Fortran.Save @ b (f94 a1)
                   Language.Fortran.Target a1 -> Language.Fortran.Target @ b (f94 a1)
                   Language.Fortran.Volatile a1
                   -> Language.Fortran.Volatile @ b (f94 a1)
                   Language.Fortran.Public a1 -> Language.Fortran.Public @ b (f94 a1)
                   Language.Fortran.Private a1
                   -> Language.Fortran.Private @ b (f94 a1)
                   Language.Fortran.Sequence a1
                   -> Language.Fortran.Sequence @ b (f94 a1)
                   Language.Fortran.Dimension a1 a2
                   -> Language.Fortran.Dimension
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                            case b1 of wild1 { (,) a4 a5 ->
                            (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a4,
                             Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a5) })
                           a2)
                   Language.Fortran.MeasureUnit a1 a2
                   -> Language.Fortran.MeasureUnit
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorAttr_$cfmap1 @ a @ b f94 a2) }) -}
087eb564eb74f6fb18285d4e97659717
  $fFunctorAttr_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.MeasureUnitSpec a
    -> Language.Fortran.MeasureUnitSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.MeasureUnitSpec a) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> Language.Fortran.UnitProduct
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b2 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b2 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f94 a5) })
                           a2)
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> Language.Fortran.UnitQuotient
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b2 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b2 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f94 a5) })
                           a2)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f94 a5) })
                           a3)
                   Language.Fortran.UnitNone a1
                   -> Language.Fortran.UnitNone @ b (f94 a1) }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fFunctorAttr_$cfmap2 ::
    (a -> b)
    -> Language.Fortran.Fraction a -> Language.Fortran.Fraction b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.Fraction a) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst @ b (f94 a1) a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst @ b (f94 a1) a2 a3
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ b (f94 a1) }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fFunctorAttr_$cfmap3 ::
    (a -> b)
    -> Language.Fortran.IntentAttr a -> Language.Fortran.IntentAttr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.IntentAttr a) ->
                 case ds of wild {
                   Language.Fortran.In a1 -> Language.Fortran.In @ b (f94 a1)
                   Language.Fortran.Out a1 -> Language.Fortran.Out @ b (f94 a1)
                   Language.Fortran.InOut a1
                   -> Language.Fortran.InOut @ b (f94 a1) }) -}
c66c0bcbb42951ba147c66147650e364
  $fFunctorBaseType :: GHC.Base.Functor Language.Fortran.BaseType
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.BaseType
                  Language.Fortran.$fFunctorBaseType_$cfmap
                  Language.Fortran.$fFunctorBaseType_$c<$ -}
c66c0bcbb42951ba147c66147650e364
  $fFunctorBaseType_$c<$ ::
    a -> Language.Fortran.BaseType b -> Language.Fortran.BaseType a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.Fortran.BaseType b) ->
                 case ds of wild {
                   Language.Fortran.Integer a1 -> Language.Fortran.Integer @ a z
                   Language.Fortran.Real a1 -> Language.Fortran.Real @ a z
                   Language.Fortran.Character a1 -> Language.Fortran.Character @ a z
                   Language.Fortran.SomeType a1 -> Language.Fortran.SomeType @ a z
                   Language.Fortran.DerivedType a1 a2
                   -> Language.Fortran.DerivedType
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z a2)
                   Language.Fortran.Recursive a1 -> Language.Fortran.Recursive @ a z
                   Language.Fortran.Pure a1 -> Language.Fortran.Pure @ a z
                   Language.Fortran.Elemental a1 -> Language.Fortran.Elemental @ a z
                   Language.Fortran.Logical a1 -> Language.Fortran.Logical @ a z
                   Language.Fortran.Complex a1 -> Language.Fortran.Complex @ a z }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fFunctorBaseType_$c<$1 ::
    a -> Language.Fortran.SubName b -> Language.Fortran.SubName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.SubName b) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2 -> Language.Fortran.SubName @ a z a2
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ a z }) -}
c66c0bcbb42951ba147c66147650e364
  $fFunctorBaseType_$cfmap ::
    (a -> b)
    -> Language.Fortran.BaseType a -> Language.Fortran.BaseType b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.BaseType a) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> Language.Fortran.Integer @ b (f94 a1)
                   Language.Fortran.Real a1 -> Language.Fortran.Real @ b (f94 a1)
                   Language.Fortran.Character a1
                   -> Language.Fortran.Character @ b (f94 a1)
                   Language.Fortran.SomeType a1
                   -> Language.Fortran.SomeType @ b (f94 a1)
                   Language.Fortran.DerivedType a1 a2
                   -> Language.Fortran.DerivedType
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94 a2)
                   Language.Fortran.Recursive a1
                   -> Language.Fortran.Recursive @ b (f94 a1)
                   Language.Fortran.Pure a1 -> Language.Fortran.Pure @ b (f94 a1)
                   Language.Fortran.Elemental a1
                   -> Language.Fortran.Elemental @ b (f94 a1)
                   Language.Fortran.Logical a1
                   -> Language.Fortran.Logical @ b (f94 a1)
                   Language.Fortran.Complex a1
                   -> Language.Fortran.Complex @ b (f94 a1) }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fFunctorBaseType_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.SubName a -> Language.Fortran.SubName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.SubName a) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> Language.Fortran.SubName @ b (f94 a1) a2
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ b (f94 a1) }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fFunctorBinOp :: GHC.Base.Functor Language.Fortran.BinOp
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.BinOp
                  Language.Fortran.$fFunctorBinOp_$cfmap
                  Language.Fortran.$fFunctorBinOp_$c<$ -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fFunctorBinOp_$c<$ ::
    a -> Language.Fortran.BinOp b -> Language.Fortran.BinOp a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.BinOp b) ->
                 case ds of wild {
                   Language.Fortran.Plus a1 -> Language.Fortran.Plus @ a z
                   Language.Fortran.Minus a1 -> Language.Fortran.Minus @ a z
                   Language.Fortran.Mul a1 -> Language.Fortran.Mul @ a z
                   Language.Fortran.Div a1 -> Language.Fortran.Div @ a z
                   Language.Fortran.Or a1 -> Language.Fortran.Or @ a z
                   Language.Fortran.And a1 -> Language.Fortran.And @ a z
                   Language.Fortran.Concat a1 -> Language.Fortran.Concat @ a z
                   Language.Fortran.Power a1 -> Language.Fortran.Power @ a z
                   Language.Fortran.RelEQ a1 -> Language.Fortran.RelEQ @ a z
                   Language.Fortran.RelNE a1 -> Language.Fortran.RelNE @ a z
                   Language.Fortran.RelLT a1 -> Language.Fortran.RelLT @ a z
                   Language.Fortran.RelLE a1 -> Language.Fortran.RelLE @ a z
                   Language.Fortran.RelGT a1 -> Language.Fortran.RelGT @ a z
                   Language.Fortran.RelGE a1 -> Language.Fortran.RelGE @ a z }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fFunctorBinOp_$cfmap ::
    (a -> b) -> Language.Fortran.BinOp a -> Language.Fortran.BinOp b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.BinOp a) ->
                 case ds of wild {
                   Language.Fortran.Plus a1 -> Language.Fortran.Plus @ b (f94 a1)
                   Language.Fortran.Minus a1 -> Language.Fortran.Minus @ b (f94 a1)
                   Language.Fortran.Mul a1 -> Language.Fortran.Mul @ b (f94 a1)
                   Language.Fortran.Div a1 -> Language.Fortran.Div @ b (f94 a1)
                   Language.Fortran.Or a1 -> Language.Fortran.Or @ b (f94 a1)
                   Language.Fortran.And a1 -> Language.Fortran.And @ b (f94 a1)
                   Language.Fortran.Concat a1 -> Language.Fortran.Concat @ b (f94 a1)
                   Language.Fortran.Power a1 -> Language.Fortran.Power @ b (f94 a1)
                   Language.Fortran.RelEQ a1 -> Language.Fortran.RelEQ @ b (f94 a1)
                   Language.Fortran.RelNE a1 -> Language.Fortran.RelNE @ b (f94 a1)
                   Language.Fortran.RelLT a1 -> Language.Fortran.RelLT @ b (f94 a1)
                   Language.Fortran.RelLE a1 -> Language.Fortran.RelLE @ b (f94 a1)
                   Language.Fortran.RelGT a1 -> Language.Fortran.RelGT @ b (f94 a1)
                   Language.Fortran.RelGE a1
                   -> Language.Fortran.RelGE @ b (f94 a1) }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fFunctorBlock :: GHC.Base.Functor Language.Fortran.Block
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Block
                  Language.Fortran.$fFunctorBlock_$cfmap
                  Language.Fortran.$fFunctorBlock_$c<$ -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fFunctorBlock_$c<$ ::
    a -> Language.Fortran.Block b -> Language.Fortran.Block a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S,1*U(A,1*U(1*U,U),1*U,U,1*U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w362 :: Language.Fortran.Block b) ->
                 case w362 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Language.Fortran.Block
                   @ a
                   w
                   (Language.Fortran.$fFunctorBlock_$c<$4 @ a @ b w ww2)
                   (Language.Fortran.$fFunctorBlock_$c<$3 @ a @ b w ww3)
                   ww4
                   (Language.Fortran.$fFunctorBlock_$c<$2 @ a @ b w ww5)
                   (Language.Fortran.$fFunctorBlock_$c<$1 @ a @ b w ww6) }) -}
cab0cd6287333175c6b9d87427982518
  $fFunctorBlock_$c<$1 ::
    a -> Language.Fortran.Fortran b -> Language.Fortran.Fortran a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fFunctorBlock_$c<$2 ::
    a -> Language.Fortran.Decl b -> Language.Fortran.Decl a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
c7dcda169fba71f63c925de5ef25cb00
  $fFunctorBlock_$c<$3 ::
    a -> Language.Fortran.Implicit b -> Language.Fortran.Implicit a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.Implicit b) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ a z
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ a z }) -}
68ba21623f3e340277f6ee2081f0e743
  $fFunctorBlock_$c<$4 ::
    a -> Language.Fortran.UseBlock b -> Language.Fortran.UseBlock a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.UseBlock b) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ a
                   (Language.Fortran.$fFunctorBlock_$c<$5 @ a @ b z a1)
                   a2 }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fFunctorBlock_$c<$5 ::
    a -> Language.Fortran.Uses b -> Language.Fortran.Uses a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fFunctorBlock_$cfmap ::
    (a -> b) -> Language.Fortran.Block a -> Language.Fortran.Block b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S,1*U(U,1*U(1*U,U),1*U,U,1*U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w362 :: Language.Fortran.Block a) ->
                 case w362 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Language.Fortran.Block
                   @ b
                   (w ww1)
                   (Language.Fortran.$fFunctorBlock_$cfmap4 @ a @ b w ww2)
                   (Language.Fortran.$fFunctorBlock_$cfmap3 @ a @ b w ww3)
                   ww4
                   (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b w ww5)
                   (Language.Fortran.$fFunctorBlock_$cfmap1 @ a @ b w ww6) }) -}
cab0cd6287333175c6b9d87427982518
  $fFunctorBlock_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.Fortran a -> Language.Fortran.Fortran b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fFunctorBlock_$cfmap2 ::
    (a -> b) -> Language.Fortran.Decl a -> Language.Fortran.Decl b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
c7dcda169fba71f63c925de5ef25cb00
  $fFunctorBlock_$cfmap3 ::
    (a -> b)
    -> Language.Fortran.Implicit a -> Language.Fortran.Implicit b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.Implicit a) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ b (f94 a1)
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ b (f94 a1) }) -}
68ba21623f3e340277f6ee2081f0e743
  $fFunctorBlock_$cfmap4 ::
    (a -> b)
    -> Language.Fortran.UseBlock a -> Language.Fortran.UseBlock b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.UseBlock a) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ b
                   (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b f94 a1)
                   a2 }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fFunctorBlock_$cfmap5 ::
    (a -> b) -> Language.Fortran.Uses a -> Language.Fortran.Uses b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fFunctorDataForm :: GHC.Base.Functor Language.Fortran.DataForm
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.DataForm
                  Language.Fortran.$fFunctorDataForm_$cfmap
                  Language.Fortran.$fFunctorDataForm_$c<$ -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fFunctorDataForm_$c<$ ::
    a -> Language.Fortran.DataForm b -> Language.Fortran.DataForm a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w362 :: Language.Fortran.DataForm b) ->
                 case w362 of ww { Language.Fortran.Data ww1 ww2 ->
                 Language.Fortran.Data
                   @ a
                   w
                   (GHC.Base.map
                      @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                      @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                      (\ (b4 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                       case b4 of wild { (,) a1 a2 ->
                       (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b w a1,
                        Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b w a2) })
                      ww2) }) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fFunctorDataForm_$cfmap ::
    (a -> b)
    -> Language.Fortran.DataForm a -> Language.Fortran.DataForm b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w362 :: Language.Fortran.DataForm a) ->
                 case w362 of ww { Language.Fortran.Data ww1 ww2 ->
                 Language.Fortran.Data
                   @ b
                   (w ww1)
                   (GHC.Base.map
                      @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                      @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                      (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                       case b1 of wild { (,) a1 a2 ->
                       (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b w a1,
                        Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b w a2) })
                      ww2) }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fFunctorDecl :: GHC.Base.Functor Language.Fortran.Decl
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Decl
                  Language.Fortran.$fFunctorBlock_$cfmap2
                  Language.Fortran.$fFunctorBlock_$c<$2 -}
6304956f2901eead56a8fac1e90d4904
  $fFunctorExpr :: GHC.Base.Functor Language.Fortran.Expr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Expr
                  Language.Fortran.$fFunctorArgList_$cfmap1
                  Language.Fortran.$fFunctorArgList_$c<$1 -}
cab0cd6287333175c6b9d87427982518
  $fFunctorFortran :: GHC.Base.Functor Language.Fortran.Fortran
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Fortran
                  Language.Fortran.$fFunctorBlock_$cfmap1
                  Language.Fortran.$fFunctorBlock_$c<$1 -}
a134d1ad73ea84faa62900e29f13ad6f
  $fFunctorFraction :: GHC.Base.Functor Language.Fortran.Fraction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Fraction
                  Language.Fortran.$fFunctorAttr_$cfmap2
                  Language.Fortran.$fFunctorAttr_$c<$2 -}
e56028b3291950d607189353469b7d3f
  $fFunctorGSpec :: GHC.Base.Functor Language.Fortran.GSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.GSpec
                  Language.Fortran.$fFunctorGSpec_$cfmap
                  Language.Fortran.$fFunctorGSpec_$c<$ -}
e56028b3291950d607189353469b7d3f
  $fFunctorGSpec_$c<$ ::
    a -> Language.Fortran.GSpec b -> Language.Fortran.GSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.GSpec b) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> Language.Fortran.GName
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.GOper a1 a2
                   -> Language.Fortran.GOper
                        @ a
                        z
                        (Language.Fortran.$fFunctorBinOp_$c<$ @ a @ b z a2)
                   Language.Fortran.GAssg a1 -> Language.Fortran.GAssg @ a z }) -}
e56028b3291950d607189353469b7d3f
  $fFunctorGSpec_$cfmap ::
    (a -> b) -> Language.Fortran.GSpec a -> Language.Fortran.GSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.GSpec a) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> Language.Fortran.GName
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a2)
                   Language.Fortran.GOper a1 a2
                   -> Language.Fortran.GOper
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBinOp_$cfmap @ a @ b f94 a2)
                   Language.Fortran.GAssg a1
                   -> Language.Fortran.GAssg @ b (f94 a1) }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fFunctorImplicit :: GHC.Base.Functor Language.Fortran.Implicit
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Implicit
                  Language.Fortran.$fFunctorBlock_$cfmap3
                  Language.Fortran.$fFunctorBlock_$c<$3 -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fFunctorIntentAttr :: GHC.Base.Functor Language.Fortran.IntentAttr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.IntentAttr
                  Language.Fortran.$fFunctorAttr_$cfmap3
                  Language.Fortran.$fFunctorAttr_$c<$3 -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fFunctorInterfaceSpec ::
    GHC.Base.Functor Language.Fortran.InterfaceSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.InterfaceSpec
                  Language.Fortran.$fFunctorInterfaceSpec_$cfmap
                  Language.Fortran.$fFunctorInterfaceSpec_$c<$ -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fFunctorInterfaceSpec_$c<$ ::
    a
    -> Language.Fortran.InterfaceSpec b
    -> Language.Fortran.InterfaceSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.Fortran.InterfaceSpec b) ->
                 case ds of wild {
                   Language.Fortran.FunctionInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.FunctionInterface
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z a2)
                        (Language.Fortran.$fFunctorArg_$c<$ @ a @ b z a3)
                        (Language.Fortran.$fFunctorBlock_$c<$5 @ a @ b z a4)
                        (Language.Fortran.$fFunctorBlock_$c<$3 @ a @ b z a5)
                        (Language.Fortran.$fFunctorBlock_$c<$2 @ a @ b z a6)
                   Language.Fortran.SubroutineInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.SubroutineInterface
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z a2)
                        (Language.Fortran.$fFunctorArg_$c<$ @ a @ b z a3)
                        (Language.Fortran.$fFunctorBlock_$c<$5 @ a @ b z a4)
                        (Language.Fortran.$fFunctorBlock_$c<$3 @ a @ b z a5)
                        (Language.Fortran.$fFunctorBlock_$c<$2 @ a @ b z a6)
                   Language.Fortran.ModuleProcedure a1 a2
                   -> Language.Fortran.ModuleProcedure
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.SubName b)
                           @ (Language.Fortran.SubName a)
                           (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z)
                           a2) }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fFunctorInterfaceSpec_$cfmap ::
    (a -> b)
    -> Language.Fortran.InterfaceSpec a
    -> Language.Fortran.InterfaceSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.InterfaceSpec a) ->
                 case ds of wild {
                   Language.Fortran.FunctionInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.FunctionInterface
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94 a2)
                        (Language.Fortran.$fFunctorArg_$cfmap @ a @ b f94 a3)
                        (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b f94 a4)
                        (Language.Fortran.$fFunctorBlock_$cfmap3 @ a @ b f94 a5)
                        (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b f94 a6)
                   Language.Fortran.SubroutineInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.SubroutineInterface
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94 a2)
                        (Language.Fortran.$fFunctorArg_$cfmap @ a @ b f94 a3)
                        (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b f94 a4)
                        (Language.Fortran.$fFunctorBlock_$cfmap3 @ a @ b f94 a5)
                        (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b f94 a6)
                   Language.Fortran.ModuleProcedure a1 a2
                   -> Language.Fortran.ModuleProcedure
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.SubName a)
                           @ (Language.Fortran.SubName b)
                           (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94)
                           a2) }) -}
087eb564eb74f6fb18285d4e97659717
  $fFunctorMeasureUnitSpec ::
    GHC.Base.Functor Language.Fortran.MeasureUnitSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.MeasureUnitSpec
                  Language.Fortran.$fFunctorAttr_$cfmap1
                  Language.Fortran.$fFunctorAttr_$c<$1 -}
573fa2fe80c5713ab0c018712ac118d8
  $fFunctorProgUnit :: GHC.Base.Functor Language.Fortran.ProgUnit
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ProgUnit
                  Language.Fortran.$fFunctorProgUnit_$cfmap
                  Language.Fortran.$fFunctorProgUnit_$c<$ -}
573fa2fe80c5713ab0c018712ac118d8
  $fFunctorProgUnit_$c<$ ::
    a -> Language.Fortran.ProgUnit b -> Language.Fortran.ProgUnit a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
573fa2fe80c5713ab0c018712ac118d8
  $fFunctorProgUnit_$cfmap ::
    (a -> b)
    -> Language.Fortran.ProgUnit a -> Language.Fortran.ProgUnit b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
941eca76f3a57e540d54e971b6bf91ab
  $fFunctorSpec :: GHC.Base.Functor Language.Fortran.Spec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Spec
                  Language.Fortran.$fFunctorSpec_$cfmap
                  Language.Fortran.$fFunctorSpec_$c<$ -}
941eca76f3a57e540d54e971b6bf91ab
  $fFunctorSpec_$c<$ ::
    a -> Language.Fortran.Spec b -> Language.Fortran.Spec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.Spec b) ->
                 case ds of wild {
                   Language.Fortran.Access a1 a2
                   -> Language.Fortran.Access
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Action a1 a2
                   -> Language.Fortran.Action
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Advance a1 a2
                   -> Language.Fortran.Advance
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Blank a1 a2
                   -> Language.Fortran.Blank
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Delim a1 a2
                   -> Language.Fortran.Delim
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Direct a1 a2
                   -> Language.Fortran.Direct
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.End a1 a2
                   -> Language.Fortran.End
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Err a1 a2
                   -> Language.Fortran.Err
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.ExFile a1 a2
                   -> Language.Fortran.ExFile
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Exist a1 a2
                   -> Language.Fortran.Exist
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Eor a1 a2
                   -> Language.Fortran.Eor
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.File a1 a2
                   -> Language.Fortran.File
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.FMT a1 a2
                   -> Language.Fortran.FMT
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Form a1 a2
                   -> Language.Fortran.Form
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Formatted a1 a2
                   -> Language.Fortran.Formatted
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Unformatted a1 a2
                   -> Language.Fortran.Unformatted
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.IOLength a1 a2
                   -> Language.Fortran.IOLength
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.IOStat a1 a2
                   -> Language.Fortran.IOStat
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Name a1 a2
                   -> Language.Fortran.Name
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Named a1 a2
                   -> Language.Fortran.Named
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.NoSpec a1 a2
                   -> Language.Fortran.NoSpec
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Number a1 a2
                   -> Language.Fortran.Number
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Floating a1 a2 a3
                   -> Language.Fortran.Floating
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a3)
                   Language.Fortran.NextRec a1 a2
                   -> Language.Fortran.NextRec
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.NML a1 a2
                   -> Language.Fortran.NML
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Opened a1 a2
                   -> Language.Fortran.Opened
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Pad a1 a2
                   -> Language.Fortran.Pad
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Position a1 a2
                   -> Language.Fortran.Position
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Read a1 a2
                   -> Language.Fortran.Read
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.ReadWrite a1 a2
                   -> Language.Fortran.ReadWrite
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Rec a1 a2
                   -> Language.Fortran.Rec
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Recl a1 a2
                   -> Language.Fortran.Recl
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Sequential a1 a2
                   -> Language.Fortran.Sequential
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Size a1 a2
                   -> Language.Fortran.Size
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Status a1 a2
                   -> Language.Fortran.Status
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.StringLit a1 a2
                   -> Language.Fortran.StringLit @ a z a2
                   Language.Fortran.Unit a1 a2
                   -> Language.Fortran.Unit
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.WriteSp a1 a2
                   -> Language.Fortran.WriteSp
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Delimiter a1
                   -> Language.Fortran.Delimiter @ a z }) -}
941eca76f3a57e540d54e971b6bf91ab
  $fFunctorSpec_$cfmap ::
    (a -> b) -> Language.Fortran.Spec a -> Language.Fortran.Spec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fFunctorSubName :: GHC.Base.Functor Language.Fortran.SubName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SubName
                  Language.Fortran.$fFunctorBaseType_$cfmap1
                  Language.Fortran.$fFunctorBaseType_$c<$1 -}
6b8210ea10d2538ca4598cfb9584c470
  $fFunctorType :: GHC.Base.Functor Language.Fortran.Type
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Type
                  Language.Fortran.$fFunctorType_$cfmap
                  Language.Fortran.$fFunctorType_$c<$ -}
6b8210ea10d2538ca4598cfb9584c470
  $fFunctorType_$c<$ ::
    a -> Language.Fortran.Type b -> Language.Fortran.Type a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.Type b) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> Language.Fortran.BaseType
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$ @ a @ b z a2)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr b)
                           @ (Language.Fortran.Attr a)
                           (Language.Fortran.$fFunctorAttr_$c<$ @ a @ b z)
                           a3)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a4)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a5)
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.ArrayT
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           (\ (b4 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                            case b4 of wild1 { (,) a7 a8 ->
                            (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a7,
                             Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a8) })
                           a2)
                        (Language.Fortran.$fFunctorBaseType_$c<$ @ a @ b z a3)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr b)
                           @ (Language.Fortran.Attr a)
                           (Language.Fortran.$fFunctorAttr_$c<$ @ a @ b z)
                           a4)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a5)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a6) }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fFunctorType_$cfmap ::
    (a -> b) -> Language.Fortran.Type a -> Language.Fortran.Type b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.Type a) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> Language.Fortran.BaseType
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap @ a @ b f94 a2)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr a)
                           @ (Language.Fortran.Attr b)
                           (Language.Fortran.$fFunctorAttr_$cfmap @ a @ b f94)
                           a3)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a4)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a5)
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.ArrayT
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                            case b1 of wild1 { (,) a7 a8 ->
                            (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a7,
                             Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a8) })
                           a2)
                        (Language.Fortran.$fFunctorBaseType_$cfmap @ a @ b f94 a3)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr a)
                           @ (Language.Fortran.Attr b)
                           (Language.Fortran.$fFunctorAttr_$cfmap @ a @ b f94)
                           a4)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a5)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a6) }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fFunctorUnaryOp :: GHC.Base.Functor Language.Fortran.UnaryOp
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.UnaryOp
                  Language.Fortran.$fFunctorUnaryOp_$cfmap
                  Language.Fortran.$fFunctorUnaryOp_$c<$ -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fFunctorUnaryOp_$c<$ ::
    a -> Language.Fortran.UnaryOp b -> Language.Fortran.UnaryOp a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.UnaryOp b) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1 -> Language.Fortran.UMinus @ a z
                   Language.Fortran.Not a1 -> Language.Fortran.Not @ a z }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fFunctorUnaryOp_$cfmap ::
    (a -> b)
    -> Language.Fortran.UnaryOp a -> Language.Fortran.UnaryOp b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.UnaryOp a) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1 -> Language.Fortran.UMinus @ b (f94 a1)
                   Language.Fortran.Not a1 -> Language.Fortran.Not @ b (f94 a1) }) -}
68ba21623f3e340277f6ee2081f0e743
  $fFunctorUseBlock :: GHC.Base.Functor Language.Fortran.UseBlock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.UseBlock
                  Language.Fortran.$fFunctorBlock_$cfmap4
                  Language.Fortran.$fFunctorBlock_$c<$4 -}
8347678f6676bd3eacaa7f87ac9bd303
  $fFunctorUses :: GHC.Base.Functor Language.Fortran.Uses
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Uses
                  Language.Fortran.$fFunctorBlock_$cfmap5
                  Language.Fortran.$fFunctorBlock_$c<$5 -}
361ec85699986b0b7f4d68a05374d64d
  $fFunctorVarName :: GHC.Base.Functor Language.Fortran.VarName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.VarName
                  Language.Fortran.$fFunctorVarName_$cfmap
                  Language.Fortran.$fFunctorVarName_$c<$ -}
361ec85699986b0b7f4d68a05374d64d
  $fFunctorVarName_$c<$ ::
    a -> Language.Fortran.VarName b -> Language.Fortran.VarName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.VarName b) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName @ a z a2 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fFunctorVarName_$cfmap ::
    (a -> b)
    -> Language.Fortran.VarName a -> Language.Fortran.VarName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.VarName a) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName @ b (f94 a1) a2 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName ::
    GHC.Classes.Ord p => GHC.Classes.Ord (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Ord p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fOrdVarName_$cp1Ord @ p v)
                  (Language.Fortran.$fOrdVarName_$ccompare @ p v)
                  (Language.Fortran.$fOrdVarName_$c< @ p v)
                  (Language.Fortran.$fOrdVarName_$c<= @ p v)
                  (\ (a :: Language.Fortran.VarName p)
                     (b :: Language.Fortran.VarName p) ->
                   Language.Fortran.$fOrdVarName_$c< @ p v b a)
                  (Language.Fortran.$fOrdVarName_$c>= @ p v)
                  (Language.Fortran.$fOrdVarName_$cmax @ p v)
                  (Language.Fortran.$fOrdVarName_$cmin @ p v) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$c< ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c< @ p w ww1 ww2 ww4 ww5 } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$c<= ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c<= @ p w ww1 ww2 ww4 ww5 } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$c>= ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c>= @ p w ww1 ww2 ww4 ww5 } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$ccompare ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$ccompare @ p w ww1 ww2 ww4 ww5 } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$cmax ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.compare @ p w ww4 ww1 of wild {
                   GHC.Types.LT -> Language.Fortran.VarName @ p ww1 ww2
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww5 ww2 of wild1 {
                        DEFAULT -> Language.Fortran.VarName @ p ww4 ww5
                        GHC.Types.LT -> Language.Fortran.VarName @ p ww1 ww2 }
                   GHC.Types.GT -> Language.Fortran.VarName @ p ww4 ww5 } } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$cmin ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.compare @ p w ww4 ww1 of wild {
                   GHC.Types.LT -> Language.Fortran.VarName @ p ww4 ww5
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww5 ww2 of wild1 {
                        DEFAULT -> Language.Fortran.VarName @ p ww1 ww2
                        GHC.Types.LT -> Language.Fortran.VarName @ p ww4 ww5 }
                   GHC.Types.GT -> Language.Fortran.VarName @ p ww1 ww2 } } }) -}
361ec85699986b0b7f4d68a05374d64d
  $fOrdVarName_$cp1Ord ::
    GHC.Classes.Ord p => GHC.Classes.Eq (Language.Fortran.VarName p)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dOrd :: GHC.Classes.Ord p) ->
                 Language.Fortran.$fEqVarName @ p (GHC.Classes.$p1Ord @ p $dOrd)) -}
361ec85699986b0b7f4d68a05374d64d
  $fReadVarName ::
    GHC.Read.Read p => GHC.Read.Read (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Read.Read p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fReadVarName_$creadsPrec @ p v)
                  (Language.Fortran.$fReadVarName_$creadList @ p v)
                  (Language.Fortran.$fReadVarName1 @ p v)
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Language.Fortran.VarName
                                     p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Language.Fortran.VarName p>_R))
                  (Language.Fortran.$fReadVarName_$creadListPrec @ p v) -}
361ec85699986b0b7f4d68a05374d64d
  $fReadVarName1 ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Language.Fortran.VarName p -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ p
                   ($dRead :: GHC.Read.Read p)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Language.Fortran.VarName p
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$fRead()6
                   @ (Language.Fortran.VarName p)
                   (\ (c :: Text.ParserCombinators.ReadPrec.Prec)
                      @ b1
                      (eta2 :: Language.Fortran.VarName p
                               -> Text.ParserCombinators.ReadP.P b1) ->
                    case c of wild { GHC.Types.I# x ->
                    case GHC.Prim.<=# x 10# of lwild {
                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                      1#
                      -> let {
                           lvl295 :: Text.ParserCombinators.ReadP.P b1
                           = let {
                               lvl296 :: Text.ParserCombinators.ReadP.P b1
                               = ((GHC.Read.readPrec @ p $dRead)
                                    `cast`
                                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <p>_R)
                                    Language.Fortran.$fReadVarName2)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.N:ReadP[0] <p>_R)
                                   @ b1
                                   (\ (a1 :: p) ->
                                    GHC.Read.$fRead()6
                                      @ GHC.Base.String
                                      GHC.Read.$fReadChar2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <GHC.Base.String>_R))
                                      Language.Fortran.$fReadVarName2
                                      @ b1
                                      (\ (a2 :: Language.Fortran.Variable) ->
                                       eta2 (Language.Fortran.VarName @ p a1 a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b1
                               (\ (a3 :: Text.Read.Lex.Lexeme) ->
                                case a3 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                                  Text.Read.Lex.Ident a1
                                  -> case GHC.Base.eqString
                                            a1
                                            Language.Fortran.$fDataVarName8 of wild2 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                                       GHC.Types.True -> lvl296 } })
                         } in
                         let {
                           k :: () -> Text.ParserCombinators.ReadP.P b1
                             {- Arity: 1, Strictness: <L,A>,
                                Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl295) -}
                           = \ (a3 :: ()) -> lvl295
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b1
                           (\ (a :: GHC.Base.String) ->
                            Text.ParserCombinators.ReadP.skipSpaces2 a @ b1 k) } })
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Language.Fortran.VarName
                                      p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Language.Fortran.VarName p>_R))
                   eta
                   @ b
                   eta1) -}
4ce6fdbc81442cc300bb3dfc5957415d
  $fReadVarName2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
361ec85699986b0b7f4d68a05374d64d
  $fReadVarName_$creadList ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadP.ReadS [Language.Fortran.VarName p]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Language.Fortran.VarName p]
                   (((GHC.Read.list
                        @ (Language.Fortran.VarName p)
                        (Language.Fortran.$fReadVarName1 @ p $dRead)
                          `cast`
                        ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <Language.Fortran.VarName
                                           p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Language.Fortran.VarName p>_R)))
                       `cast`
                     (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <[Language.Fortran.VarName p]>_R)
                       GHC.Read.$fRead()8)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <[Language.Fortran.VarName p]>_R)
                      @ [Language.Fortran.VarName p]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Language.Fortran.VarName p]))) -}
361ec85699986b0b7f4d68a05374d64d
  $fReadVarName_$creadListPrec ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Language.Fortran.VarName p]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) ->
                 GHC.Read.list
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fReadVarName1 @ p $dRead)
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Language.Fortran.VarName
                                      p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Language.Fortran.VarName p>_R))) -}
361ec85699986b0b7f4d68a05374d64d
  $fReadVarName_$creadsPrec ::
    GHC.Read.Read p =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (Language.Fortran.VarName p)
  {- Arity: 2, Strictness: <L,U(A,A,C(C1(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fReadVarName1
                      @ p
                      $dRead
                      n
                      @ (Language.Fortran.VarName p)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Language.Fortran.VarName p)))) -}
2ecf4bb24a966e219012eee596c45ea8
  $fShowArg ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fShowArg_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowArg_$cshow @ p v)
                  (Language.Fortran.$fShowArg_$cshowList @ p v) -}
106d0fa12802b6e33de039ab8de906e1
  $fShowArg1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (",c"#) -}
d4c1b7848b2f2b9e81752cf404ce68ba
  $fShowArg10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Arg "#) -}
d99440b8ced8817dd4eb7c72dccaad83
  $fShowArg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{l"#) -}
92b1d79b9bba4c90720b8432917f9f42
  $fShowArg3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowArg4) -}
603086004a95857611d46c17a67280c9
  $fShowArg4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
33e296323e07f876a5c732af068e39a0
  $fShowArg5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", col = "#) -}
372904c79f9088fa5105bab4b991bb90
  $fShowArg6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", line = "#) -}
5ea7c0040373a2d84baf41bf5fb8ad6e
  $fShowArg7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{"#) -}
4bcd38b0ef22d0f7d93ea89022d5e98f
  $fShowArg8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowArg9) -}
13f6ea7436a85bd7bcfa1766a69ccc8e
  $fShowArg9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("compact"#) -}
6304956f2901eead56a8fac1e90d4904
  $fShowArgList ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fShowArgList_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowArgList_$cshow @ p v)
                  (Language.Fortran.$fShowArgList_$cshowList @ p v) -}
7083969affebc00ad96320bf30009862
  $fShowArgList1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ArgList "#) -}
6304956f2901eead56a8fac1e90d4904
  $fShowArgList_$cshow ::
    GHC.Show.Show p => Language.Fortran.ArgList p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ArgList p) ->
                 Language.Fortran.$fShowArgList_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6304956f2901eead56a8fac1e90d4904
  $fShowArgList_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ArgList p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.ArgList p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ArgList p)
                   (Language.Fortran.$fShowArgList_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
6304956f2901eead56a8fac1e90d4904
  $fShowArgList_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ArgList p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.ArgList p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.ArgList ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec2 @ p w ww1 ww3 ww4 } }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fShowArgName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fShowArgName_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowArgName_$cshow @ p v)
                  (Language.Fortran.$fShowArgName_$cshowList @ p v) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fShowArgName_$cshow ::
    GHC.Show.Show p => Language.Fortran.ArgName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ArgName p) ->
                 Language.Fortran.$fShowArgName_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fShowArgName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ArgName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.ArgName p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ArgName p)
                   (Language.Fortran.$fShowArgName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $fShowArgName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ArgName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.ArgName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec1 @ p w ww1 w363 }) -}
2ecf4bb24a966e219012eee596c45ea8
  $fShowArg_$cshow ::
    GHC.Show.Show p => Language.Fortran.Arg p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p ($dShow :: GHC.Show.Show p) (x :: Language.Fortran.Arg p) ->
                 Language.Fortran.$fShowArg_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2ecf4bb24a966e219012eee596c45ea8
  $fShowArg_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Arg p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Arg p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fShowArg_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
2ecf4bb24a966e219012eee596c45ea8
  $fShowArg_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Arg p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Arg p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.Arg ww3 ww4 ww5 ->
                 Language.Fortran.$w$cshowsPrec @ p w ww1 ww3 ww4 ww5 } }) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fShowAttr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fShowAttr_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowAttr_$cshow @ p v)
                  (Language.Fortran.$fShowAttr_$cshowList @ p v) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fShowAttr_$cshow ::
    GHC.Show.Show p => Language.Fortran.Attr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Attr p) ->
                 Language.Fortran.$fShowAttr_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fShowAttr_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Attr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Attr p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fShowAttr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
3b46645d85b9c008a9510c0f3d8ec026
  $fShowAttr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Attr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Attr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec4 @ p w ww1 w363 }) -}
c66c0bcbb42951ba147c66147650e364
  $fShowBaseType ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fShowBaseType_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowBaseType_$cshow @ p v)
                  (Language.Fortran.$fShowBaseType_$cshowList @ p v) -}
c66c0bcbb42951ba147c66147650e364
  $fShowBaseType_$cshow ::
    GHC.Show.Show p => Language.Fortran.BaseType p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$fShowBaseType_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c66c0bcbb42951ba147c66147650e364
  $fShowBaseType_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.BaseType p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.BaseType p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fShowBaseType_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
c66c0bcbb42951ba147c66147650e364
  $fShowBaseType_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.BaseType p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.BaseType p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec5 @ p w ww1 w363 }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fShowBinOp ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fShowBinOp_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowBinOp_$cshow @ p v)
                  (Language.Fortran.$fShowBinOp_$cshowList @ p v) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fShowBinOp_$cshow ::
    GHC.Show.Show p => Language.Fortran.BinOp p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fShowBinOp_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fShowBinOp_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.BinOp p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.BinOp p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fShowBinOp_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $fShowBinOp_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.BinOp p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.BinOp p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec6 @ p w ww1 w363 }) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fShowBlock ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowBlock_$cshow @ p v)
                  (Language.Fortran.$fShowBlock_$cshowList @ p v) -}
7a9c3756a3d593e94ba3c79449fd5b84
  $fShowBlock1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Block "#) -}
017aadd8674b53ad000fbb8969bc26e1
  $fShowBlock2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowBlock3) -}
ad71dad81f1cb66aebd88eff648d3d7c
  $fShowBlock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ImplicitNull "#) -}
3f03a85587115042eed8346b30d31894
  $fShowBlock4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowBlock5) -}
1ddce0f76546735c0eaf184f246a4b3a
  $fShowBlock5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ImplicitNone "#) -}
f13a4d5fde32e1de741c59c2d1796723
  $fShowBlock6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UseBlock "#) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fShowBlock_$cshow ::
    GHC.Show.Show p => Language.Fortran.Block p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U(1*U,U(U,U(U),U(U))),1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))),U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Block p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fShowBlock_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Block p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Block p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
c8f6dc9d55c3b3cbc94e3fb30057f310
  $fShowBlock_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Block p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U(1*U,U(U,U(U),U(U))),1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))),U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Block p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.Block ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Language.Fortran.$w$cshowsPrec7
                   @ p
                   w
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8 } }) -}
cab0cd6287333175c6b9d87427982518
  $fShowBlock_$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Fortran p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)> -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowBlock_$cshowsPrec2 ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Decl p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)> -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fShowDataForm ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fShowDataForm_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowDataForm_$cshow @ p v)
                  (Language.Fortran.$fShowDataForm_$cshowList @ p v) -}
527ec2e067e3f14b546b5c7b7708afce
  $fShowDataForm1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Data "#) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fShowDataForm_$cshow ::
    GHC.Show.Show p => Language.Fortran.DataForm p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$fShowDataForm_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fShowDataForm_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.DataForm p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.DataForm p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fShowDataForm_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
a8200bcb3a17c34f3b24a4ee00c063ea
  $fShowDataForm_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.DataForm p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.DataForm p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.Data ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec11 @ p w ww1 ww3 ww4 } }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowDecl ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec2 @ p v)
                  (Language.Fortran.$fShowDecl_$cshow @ p v)
                  (Language.Fortran.$fShowDecl_$cshowList @ p v) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowDecl_$cshow ::
    GHC.Show.Show p => Language.Fortran.Decl p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Decl p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec2
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowDecl_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Decl p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Decl p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Decl p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec2
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
6304956f2901eead56a8fac1e90d4904
  $fShowExpr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fShowExpr_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowExpr_$cshow @ p v)
                  (Language.Fortran.$fShowExpr_$cshowList @ p v) -}
6304956f2901eead56a8fac1e90d4904
  $fShowExpr_$cshow ::
    GHC.Show.Show p => Language.Fortran.Expr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Expr p) ->
                 Language.Fortran.$fShowExpr_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6304956f2901eead56a8fac1e90d4904
  $fShowExpr_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Expr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Expr p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fShowExpr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
6304956f2901eead56a8fac1e90d4904
  $fShowExpr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Expr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec3 @ p w ww1 w363 }) -}
cab0cd6287333175c6b9d87427982518
  $fShowFortran ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec1 @ p v)
                  (Language.Fortran.$fShowFortran_$cshow @ p v)
                  (Language.Fortran.$fShowFortran_$cshowList @ p v) -}
cab0cd6287333175c6b9d87427982518
  $fShowFortran_$cshow ::
    GHC.Show.Show p => Language.Fortran.Fortran p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec1
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cab0cd6287333175c6b9d87427982518
  $fShowFortran_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Fortran p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Fortran p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec1
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fShowFraction ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fShowFraction_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowFraction_$cshow @ p v)
                  (Language.Fortran.$fShowFraction_$cshowList @ p v) -}
7a012479a4dff2ee9545de8b8f94f640
  $fShowFraction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowFraction2) -}
c74179933261d9871f6f6175ebe5d813
  $fShowFraction2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NullFraction "#) -}
6e7e52271b6146529c01613bb4395165
  $fShowFraction3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("FractionConst "#) -}
d276d3d9631e59b2843d0878805094a7
  $fShowFraction4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IntegerConst "#) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fShowFraction_$cshow ::
    GHC.Show.Show p => Language.Fortran.Fraction p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Fraction p) ->
                 Language.Fortran.$fShowFraction_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fShowFraction_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Fraction p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Fraction p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Fraction p)
                   (Language.Fortran.$fShowFraction_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
a134d1ad73ea84faa62900e29f13ad6f
  $fShowFraction_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Fraction p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Fraction p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec12 @ p w ww1 w363 }) -}
e56028b3291950d607189353469b7d3f
  $fShowGSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fShowGSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowGSpec_$cshow @ p v)
                  (Language.Fortran.$fShowGSpec_$cshowList @ p v) -}
ff94375c3c07e5ca7a04b789d130b4b8
  $fShowGSpec1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowGSpec2) -}
e9575b414224491daedda43b5b7aa283
  $fShowGSpec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GAssg "#) -}
02595228de8a864f16dd23120efa36bf
  $fShowGSpec3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GOper "#) -}
4f2a548a7f842cea4da039bcf9a118f7
  $fShowGSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GName "#) -}
e56028b3291950d607189353469b7d3f
  $fShowGSpec_$cshow ::
    GHC.Show.Show p => Language.Fortran.GSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$fShowGSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e56028b3291950d607189353469b7d3f
  $fShowGSpec_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.GSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.GSpec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fShowGSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
e56028b3291950d607189353469b7d3f
  $fShowGSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.GSpec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.GSpec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec13 @ p w ww1 w363 }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fShowImplicit ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fShowImplicit_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowImplicit_$cshow @ p v)
                  (Language.Fortran.$fShowImplicit_$cshowList @ p v) -}
c7dcda169fba71f63c925de5ef25cb00
  $fShowImplicit_$cshow ::
    GHC.Show.Show p => Language.Fortran.Implicit p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Implicit p) ->
                 case x of wild {
                   Language.Fortran.ImplicitNone b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowBlock4
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.ImplicitNull b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowBlock2
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
c7dcda169fba71f63c925de5ef25cb00
  $fShowImplicit_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Implicit p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Implicit p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Implicit p)
                   (Language.Fortran.$fShowImplicit_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
c7dcda169fba71f63c925de5ef25cb00
  $fShowImplicit_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Implicit p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Implicit p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec8 @ p w ww1 w363 }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fShowIntentAttr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fShowIntentAttr_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowIntentAttr_$cshow @ p v)
                  (Language.Fortran.$fShowIntentAttr_$cshowList @ p v) -}
a8745d1dbf185c18ead67e2988980105
  $fShowIntentAttr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowIntentAttr2) -}
1bbd8aa386f556230eb1b4b4efae827e
  $fShowIntentAttr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InOut "#) -}
2823c141fcb75e616bb2567835e81fca
  $fShowIntentAttr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowIntentAttr4) -}
2b4e562056ca89c460425a10d1679762
  $fShowIntentAttr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Out "#) -}
2847680126b5f85b1c9741d2ed36809f
  $fShowIntentAttr5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowIntentAttr6) -}
87c2a5fd9c8368a1d03f7feb982d764a
  $fShowIntentAttr6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("In "#) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fShowIntentAttr_$cshow ::
    GHC.Show.Show p => Language.Fortran.IntentAttr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.IntentAttr p) ->
                 case x of wild {
                   Language.Fortran.In b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr5
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.Out b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr3
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.InOut b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fShowIntentAttr_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.IntentAttr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.IntentAttr p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.IntentAttr p)
                   (Language.Fortran.$fShowIntentAttr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $fShowIntentAttr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.IntentAttr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.IntentAttr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec14 @ p w ww1 w363 }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowInterfaceSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fShowInterfaceSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowInterfaceSpec_$cshow @ p v)
                  (Language.Fortran.$fShowInterfaceSpec_$cshowList @ p v) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowInterfaceSpec_$cshow ::
    GHC.Show.Show p =>
    Language.Fortran.InterfaceSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.InterfaceSpec p) ->
                 Language.Fortran.$fShowInterfaceSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowInterfaceSpec_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.InterfaceSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.InterfaceSpec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fShowInterfaceSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $fShowInterfaceSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.InterfaceSpec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.InterfaceSpec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec15 @ p w ww1 w363 }) -}
087eb564eb74f6fb18285d4e97659717
  $fShowMeasureUnitSpec ::
    GHC.Show.Show p =>
    GHC.Show.Show (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshow @ p v)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshowList @ p v) -}
087eb564eb74f6fb18285d4e97659717
  $fShowMeasureUnitSpec_$cshow ::
    GHC.Show.Show p =>
    Language.Fortran.MeasureUnitSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
087eb564eb74f6fb18285d4e97659717
  $fShowMeasureUnitSpec_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.MeasureUnitSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.MeasureUnitSpec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
087eb564eb74f6fb18285d4e97659717
  $fShowMeasureUnitSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.MeasureUnitSpec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec16 @ p w ww1 w363 }) -}
573fa2fe80c5713ab0c018712ac118d8
  $fShowProgUnit ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fShowProgUnit_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowProgUnit_$cshow @ p v)
                  (Language.Fortran.$fShowProgUnit_$cshowList @ p v) -}
573fa2fe80c5713ab0c018712ac118d8
  $fShowProgUnit_$cshow ::
    GHC.Show.Show p => Language.Fortran.ProgUnit p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ProgUnit p) ->
                 Language.Fortran.$fShowProgUnit_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
573fa2fe80c5713ab0c018712ac118d8
  $fShowProgUnit_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ProgUnit p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.ProgUnit p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fShowProgUnit_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
573fa2fe80c5713ab0c018712ac118d8
  $fShowProgUnit_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ProgUnit p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)> -}
941eca76f3a57e540d54e971b6bf91ab
  $fShowSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fShowSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowSpec_$cshow @ p v)
                  (Language.Fortran.$fShowSpec_$cshowList @ p v) -}
941eca76f3a57e540d54e971b6bf91ab
  $fShowSpec_$cshow ::
    GHC.Show.Show p => Language.Fortran.Spec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Spec p) ->
                 Language.Fortran.$fShowSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
941eca76f3a57e540d54e971b6bf91ab
  $fShowSpec_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Spec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Spec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fShowSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
941eca76f3a57e540d54e971b6bf91ab
  $fShowSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Spec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Spec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec17 @ p w ww1 w363 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fShowSrcLoc :: GHC.Show.Show Language.Fortran.SrcLoc
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fShowSrcLoc_$cshowsPrec
                  Language.Fortran.$fShowSrcLoc_$cshow
                  Language.Fortran.$fShowSrcLoc_$cshowList -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fShowSrcLoc1 ::
    Language.Fortran.SrcLoc -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SLL),1*U(U,1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.Fortran.SrcLoc)
                   (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Language.Fortran.$fShowSrcLoc_$cshow x))
                   s) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fShowSrcLoc_$cshow :: Language.Fortran.SrcLoc -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SLL),1*U(U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cshow ww1 ww2 ww3 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fShowSrcLoc_$cshowList ::
    [Language.Fortran.SrcLoc] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Language.Fortran.SrcLoc]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.Fortran.SrcLoc
                   Language.Fortran.$fShowSrcLoc1
                   ls
                   s) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $fShowSrcLoc_$cshowsPrec ::
    GHC.Types.Int -> Language.Fortran.SrcLoc -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SLL),1*U(U,1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Language.Fortran.SrcLoc)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Language.Fortran.$fShowSrcLoc_$cshow x))
                   s) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fShowSubName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fShowSubName_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowSubName_$cshow @ p v)
                  (Language.Fortran.$fShowSubName_$cshowList @ p v) -}
8d98d8f793362bac742b2734bc5d3358
  $fShowSubName1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowSubName2) -}
853244ceb0be62a2b9561f0becf37072
  $fShowSubName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NullSubName "#) -}
de959ef76e3b2806ecd9890b2f8fefa4
  $fShowSubName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SubName "#) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fShowSubName_$cshow ::
    GHC.Show.Show p => Language.Fortran.SubName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.SubName p) ->
                 Language.Fortran.$fShowSubName_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fShowSubName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.SubName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.SubName p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.SubName p)
                   (Language.Fortran.$fShowSubName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $fShowSubName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.SubName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.SubName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec18 @ p w ww1 w363 }) -}
6b8210ea10d2538ca4598cfb9584c470
  $fShowType ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fShowType_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowType_$cshow @ p v)
                  (Language.Fortran.$fShowType_$cshowList @ p v) -}
6b8210ea10d2538ca4598cfb9584c470
  $fShowType_$cshow ::
    GHC.Show.Show p => Language.Fortran.Type p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Type p) ->
                 Language.Fortran.$fShowType_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6b8210ea10d2538ca4598cfb9584c470
  $fShowType_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Type p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Type p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fShowType_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
6b8210ea10d2538ca4598cfb9584c470
  $fShowType_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Type p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Type p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec19 @ p w ww1 w363 }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fShowUnaryOp ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fShowUnaryOp_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowUnaryOp_$cshow @ p v)
                  (Language.Fortran.$fShowUnaryOp_$cshowList @ p v) -}
de9f3f0ebad27e4ba5751b622094ea9d
  $fShowUnaryOp1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowUnaryOp2) -}
cd2be9f416857e7ada55158813124b75
  $fShowUnaryOp2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Not "#) -}
ad4583cbe918ad4d40538b54eee37037
  $fShowUnaryOp3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowUnaryOp4) -}
2e9fd9c8c5393beedf8521e0d747e4db
  $fShowUnaryOp4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UMinus "#) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fShowUnaryOp_$cshow ::
    GHC.Show.Show p => Language.Fortran.UnaryOp p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.UnaryOp p) ->
                 case x of wild {
                   Language.Fortran.UMinus b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowUnaryOp3
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.Not b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowUnaryOp1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fShowUnaryOp_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.UnaryOp p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.UnaryOp p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.UnaryOp p)
                   (Language.Fortran.$fShowUnaryOp_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $fShowUnaryOp_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.UnaryOp p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.UnaryOp p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec20 @ p w ww1 w363 }) -}
68ba21623f3e340277f6ee2081f0e743
  $fShowUseBlock ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fShowUseBlock_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowUseBlock_$cshow @ p v)
                  (Language.Fortran.$fShowUseBlock_$cshowList @ p v) -}
68ba21623f3e340277f6ee2081f0e743
  $fShowUseBlock_$cshow ::
    GHC.Show.Show p => Language.Fortran.UseBlock p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(1*U,U(U,U(U),U(U)))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.UseBlock p) ->
                 Language.Fortran.$fShowUseBlock_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68ba21623f3e340277f6ee2081f0e743
  $fShowUseBlock_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.UseBlock p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.UseBlock p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.UseBlock p)
                   (Language.Fortran.$fShowUseBlock_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
68ba21623f3e340277f6ee2081f0e743
  $fShowUseBlock_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.UseBlock p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(1*U,U(U,U(U),U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.UseBlock p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.UseBlock ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec9 @ p w ww1 ww3 ww4 } }) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fShowUses ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fShowUses_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowUses_$cshow @ p v)
                  (Language.Fortran.$fShowUses_$cshowList @ p v) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fShowUses_$cshow ::
    GHC.Show.Show p => Language.Fortran.Uses p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Uses p) ->
                 Language.Fortran.$fShowUses_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fShowUses_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Uses p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Uses p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Uses p)
                   (Language.Fortran.$fShowUses_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
8347678f6676bd3eacaa7f87ac9bd303
  $fShowUses_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Uses p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Uses p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec10 @ p w ww1 w363 }) -}
361ec85699986b0b7f4d68a05374d64d
  $fShowVarName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fShowVarName_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowVarName_$cshow @ p v)
                  (Language.Fortran.$fShowVarName_$cshowList @ p v) -}
08bba18605fff61e100a413a2b074f6f
  $fShowVarName1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VarName "#) -}
361ec85699986b0b7f4d68a05374d64d
  $fShowVarName_$cshow ::
    GHC.Show.Show p => Language.Fortran.VarName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.VarName p) ->
                 Language.Fortran.$fShowVarName_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
361ec85699986b0b7f4d68a05374d64d
  $fShowVarName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.VarName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.VarName p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fShowVarName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
361ec85699986b0b7f4d68a05374d64d
  $fShowVarName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.VarName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.VarName ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec21 @ p w ww1 ww3 ww4 } }) -}
81e0a6d625974c87c04f91afb1091e0a
  $fSpanBlock :: Language.Fortran.Span (Language.Fortran.Block a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U,U),A,A)>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanBlock_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Block a>_N)) -}
a0489d3002a36642ce0d3a68ea4e5d58
  $fSpanBlock_$csrcSpan ::
    Language.Fortran.Block a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U,U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Block a) ->
                 case ds of wild { Language.Fortran.Block ds1 ds2 ds3 sp ds4 ds5 ->
                 sp }) -}
81e0a6d625974c87c04f91afb1091e0a
  $fSpanDecl :: Language.Fortran.Span (Language.Fortran.Decl a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanDecl_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Decl a>_N)) -}
a84fbf7b776131bbe949653a8b655fcb
  $fSpanDecl1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
77244fa557f126c8ad5bb7a7eec984b4
  $fSpanDecl_$csrcSpan ::
    Language.Fortran.Decl a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Decl a) ->
                 case ds of wild {
                   DEFAULT -> Language.Fortran.$fSpanDecl1
                   Language.Fortran.Decl ds1 sp ds2 ds3 -> sp
                   Language.Fortran.Equivalence x sp ds1 -> sp
                   Language.Fortran.Common ds1 sp ds2 ds3 -> sp
                   Language.Fortran.DerivedTypeDef x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.NullDecl ds1 sp -> sp
                   Language.Fortran.MeasureUnitDef x sp ds1 -> sp }) -}
81e0a6d625974c87c04f91afb1091e0a
  $fSpanExpr :: Language.Fortran.Span (Language.Fortran.Expr a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanExpr_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Expr a>_N)) -}
21549c1c0b1b3bc863b06d03047a111e
  $fSpanExpr1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
e23841e914a7feba93068bc07438b332
  $fSpanExpr_$csrcSpan ::
    Language.Fortran.Expr a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Expr a) ->
                 case ds of wild {
                   Language.Fortran.Con x sp ds1 -> sp
                   Language.Fortran.ConL ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fSpanExpr1
                   Language.Fortran.ConS x sp ds1 -> sp
                   Language.Fortran.Var x sp ds1 -> sp
                   Language.Fortran.Bin x sp ds1 ds2 ds3 -> sp
                   Language.Fortran.Unary x sp ds1 ds2 -> sp
                   Language.Fortran.CallExpr x sp ds1 ds2 -> sp
                   Language.Fortran.NullExpr x sp -> sp
                   Language.Fortran.Null x sp -> sp
                   Language.Fortran.ESeq x sp ds1 ds2 -> sp
                   Language.Fortran.Bound x sp ds1 ds2 -> sp
                   Language.Fortran.Sqrt x sp ds1 -> sp
                   Language.Fortran.ArrayCon x sp ds1 -> sp
                   Language.Fortran.AssgExpr x sp ds1 ds2 -> sp }) -}
81e0a6d625974c87c04f91afb1091e0a
  $fSpanFortran :: Language.Fortran.Span (Language.Fortran.Fortran a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanFortran_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Fortran a>_N)) -}
58e76bb02582be5cd7a1002ff280acdd
  $fSpanFortran1 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
cb213a68b114f2e342761765f659d1a5
  $fSpanFortran_$csrcSpan ::
    Language.Fortran.Fortran a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Fortran a) ->
                 case ds of wild {
                   Language.Fortran.Assg x sp e1 e2 -> sp
                   Language.Fortran.For x sp v e1 e2 e3 fs -> sp
                   Language.Fortran.DoWhile x sp e fs -> sp
                   Language.Fortran.FSeq x sp f94 f95 -> sp
                   Language.Fortran.If x sp e f94 fes f95 -> sp
                   Language.Fortran.Allocate x sp e1 e2 -> sp
                   Language.Fortran.Backspace x sp ds1 -> sp
                   Language.Fortran.Call x sp e as -> sp
                   Language.Fortran.Open x sp s -> sp
                   Language.Fortran.Close x sp s -> sp
                   Language.Fortran.Continue x sp -> sp
                   Language.Fortran.Cycle x sp s -> sp
                   Language.Fortran.DataStmt x sp ds1 -> sp
                   Language.Fortran.Deallocate x sp es e -> sp
                   Language.Fortran.Endfile x sp s -> sp
                   Language.Fortran.Exit x sp s -> sp
                   Language.Fortran.Format x sp ds1 -> sp
                   Language.Fortran.Forall x sp es f94 -> sp
                   Language.Fortran.Goto x sp s -> sp
                   Language.Fortran.Nullify x sp e -> sp
                   Language.Fortran.Inquire x sp s e -> sp
                   Language.Fortran.Pause x sp ds1 -> sp
                   Language.Fortran.Rewind x sp s -> sp
                   Language.Fortran.Stop x sp e -> sp
                   Language.Fortran.Where x sp e f94 ds1 -> sp
                   Language.Fortran.Write x sp s e -> sp
                   Language.Fortran.PointerAssg x sp e1 e2 -> sp
                   Language.Fortran.Return x sp e -> sp
                   Language.Fortran.Label x sp s f94 -> sp
                   Language.Fortran.Print x sp e es -> sp
                   Language.Fortran.ReadS x sp s e -> sp
                   Language.Fortran.TextStmt x sp s -> sp
                   Language.Fortran.NullStmt x sp -> sp
                   Language.Fortran.SelectStmt x sp e fes ds1 -> sp
                   Language.Fortran.OpenCLMap x sp e1 e2 ds1 ds2 f94 -> sp
                   Language.Fortran.OpenCLReduce x sp e1 e2 ds1 ds2 e3 f94 -> sp
                   Language.Fortran.OpenCLSeq ipv ipv1 ipv2 ipv3 ipv4
                   -> Language.Fortran.$fSpanFortran1
                   Language.Fortran.OpenCLBufferRead ds1 sp ds2 -> sp
                   Language.Fortran.OpenCLBufferWrite ds1 sp ds2 -> sp }) -}
81e0a6d625974c87c04f91afb1091e0a
  $fSpanProgUnit ::
    Language.Fortran.Span (Language.Fortran.ProgUnit a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanProgUnit_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0]
                          <Language.Fortran.ProgUnit a>_N)) -}
95f7b4061734ce063d011037a525c9bb
  $fSpanProgUnit1 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
a03bb18dee4678b30cd96443810df830
  $fSpanProgUnit_$csrcSpan ::
    Language.Fortran.ProgUnit a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.ProgUnit a) ->
                 case ds of wild {
                   Language.Fortran.Main x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.Sub x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.Function x sp ds1 ds2 ds3 ds4 ds5 -> sp
                   Language.Fortran.Module x sp ds1 ds2 ds3 ds4 ds5 -> sp
                   Language.Fortran.BlockData x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.PSeq x sp ds1 ds2 -> sp
                   Language.Fortran.Prog x sp ds1 -> sp
                   Language.Fortran.NullProg x sp -> sp
                   Language.Fortran.IncludeProg ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fSpanProgUnit1 }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedArg :: Language.Fortran.Tagged Language.Fortran.Arg
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArg_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Arg>_N)) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedArgList :: Language.Fortran.Tagged Language.Fortran.ArgList
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArgList_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ArgList>_N)) -}
4a82c94435ccced5c807e7d22f7af978
  $fTaggedArgList_$ctag :: Language.Fortran.ArgList a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.ArgList a) ->
                 case ds of wild { Language.Fortran.ArgList x ds1 -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedArgName :: Language.Fortran.Tagged Language.Fortran.ArgName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArgName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ArgName>_N)) -}
ae35bc677f1a9ba73a76aa7500bb0c77
  $fTaggedArgName_$ctag :: Language.Fortran.ArgName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.ArgName a) ->
                 case ds of wild {
                   Language.Fortran.ArgName x ds1 -> x
                   Language.Fortran.ASeq x ds1 ds2 -> x
                   Language.Fortran.NullArg x -> x }) -}
b4e0b35ff4b56b158377c114568ce94a
  $fTaggedArg_$ctag :: Language.Fortran.Arg a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Arg a) ->
                 case ds of wild { Language.Fortran.Arg x ds1 ds2 -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedAttr :: Language.Fortran.Tagged Language.Fortran.Attr
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedAttr_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Attr>_N)) -}
2be82aeac15aec9c1692c0ae23875574
  $fTaggedAttr1 :: a
  {- Strictness: x -}
8e42df9a77657ab0c7bd21a274a97faa
  $fTaggedAttr_$ctag :: Language.Fortran.Attr a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Attr a) ->
                 case ds of wild {
                   Language.Fortran.Parameter x -> x
                   Language.Fortran.Allocatable x -> x
                   Language.Fortran.External x -> x
                   Language.Fortran.Intent x ds1 -> x
                   Language.Fortran.Intrinsic x -> x
                   Language.Fortran.Optional x -> x
                   Language.Fortran.Pointer x -> x
                   Language.Fortran.Save x -> x
                   Language.Fortran.Target x -> x
                   Language.Fortran.Volatile x -> x
                   Language.Fortran.Public x -> x
                   Language.Fortran.Private x -> x
                   Language.Fortran.Sequence x -> x
                   Language.Fortran.Dimension x ds1 -> x
                   Language.Fortran.MeasureUnit ipv ipv1
                   -> Language.Fortran.$fTaggedAttr1 @ a }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedBaseType ::
    Language.Fortran.Tagged Language.Fortran.BaseType
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedBaseType_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.BaseType>_N)) -}
86542846ed8ff3d939b1ee9aff6258ab
  $fTaggedBaseType_$ctag :: Language.Fortran.BaseType a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.BaseType a) ->
                 case ds of wild {
                   Language.Fortran.Integer x -> x
                   Language.Fortran.Real x -> x
                   Language.Fortran.Character x -> x
                   Language.Fortran.SomeType x -> x
                   Language.Fortran.DerivedType x ds1 -> x
                   Language.Fortran.Recursive x -> x
                   Language.Fortran.Pure x -> x
                   Language.Fortran.Elemental x -> x
                   Language.Fortran.Logical x -> x
                   Language.Fortran.Complex x -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedDataForm ::
    Language.Fortran.Tagged Language.Fortran.DataForm
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedDataForm_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.DataForm>_N)) -}
ee34cafc72d76f016be358cd458d30a4
  $fTaggedDataForm_$ctag :: Language.Fortran.DataForm a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.DataForm a) ->
                 case ds of wild { Language.Fortran.Data x ds1 -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedDecl :: Language.Fortran.Tagged Language.Fortran.Decl
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedDecl_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Decl>_N)) -}
d87a60e6d82c424d097346d32cc093b7
  $fTaggedDecl_$ctag :: Language.Fortran.Decl a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Decl a) ->
                 case ds of wild {
                   Language.Fortran.Decl x ds1 ds2 ds3 -> x
                   Language.Fortran.Namelist x ds1 -> x
                   Language.Fortran.DataDecl x ds1 -> x
                   Language.Fortran.Equivalence x sp ds1 -> x
                   Language.Fortran.AttrStmt x ds1 ds2 -> x
                   Language.Fortran.AccessStmt x ds1 ds2 -> x
                   Language.Fortran.ExternalStmt x ds1 -> x
                   Language.Fortran.Interface x ds1 ds2 -> x
                   Language.Fortran.Common x ds1 ds2 ds3 -> x
                   Language.Fortran.DerivedTypeDef x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Include x ds1 -> x
                   Language.Fortran.DSeq x ds1 ds2 -> x
                   Language.Fortran.TextDecl x ds1 -> x
                   Language.Fortran.NullDecl x ds1 -> x
                   Language.Fortran.MeasureUnitDef x ds1 ds2 -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedExpr :: Language.Fortran.Tagged Language.Fortran.Expr
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedExpr_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Expr>_N)) -}
a41b916d914bf0f8c62a6348b80e4a28
  $fTaggedExpr_$ctag :: Language.Fortran.Expr a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Expr a) ->
                 case ds of wild {
                   Language.Fortran.Con x sp ds1 -> x
                   Language.Fortran.ConL x sp ds1 ds2 -> x
                   Language.Fortran.ConS x sp ds1 -> x
                   Language.Fortran.Var x sp ds1 -> x
                   Language.Fortran.Bin x sp ds1 ds2 ds3 -> x
                   Language.Fortran.Unary x sp ds1 ds2 -> x
                   Language.Fortran.CallExpr x sp ds1 ds2 -> x
                   Language.Fortran.NullExpr x ds1 -> x
                   Language.Fortran.Null x ds1 -> x
                   Language.Fortran.ESeq x sp ds1 ds2 -> x
                   Language.Fortran.Bound x sp ds1 ds2 -> x
                   Language.Fortran.Sqrt x sp ds1 -> x
                   Language.Fortran.ArrayCon x sp ds1 -> x
                   Language.Fortran.AssgExpr x sp ds1 ds2 -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedFortran :: Language.Fortran.Tagged Language.Fortran.Fortran
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedFortran_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.Fortran>_N)) -}
7df90113edcc4e202526c31d43b80623
  $fTaggedFortran1 :: a
  {- Strictness: x -}
08433789906068ee74def9fec8d62e5a
  $fTaggedFortran_$ctag :: Language.Fortran.Fortran a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Fortran a) ->
                 case ds of wild {
                   DEFAULT -> Language.Fortran.$fTaggedFortran1 @ a
                   Language.Fortran.Assg x s e1 e2 -> x
                   Language.Fortran.For x s v e1 e2 e3 fs -> x
                   Language.Fortran.DoWhile x sp e fs -> x
                   Language.Fortran.FSeq x sp f94 f95 -> x
                   Language.Fortran.If x sp e f94 fes f95 -> x
                   Language.Fortran.Allocate x sp e1 e2 -> x
                   Language.Fortran.Backspace x sp ds1 -> x
                   Language.Fortran.Call x sp e as -> x
                   Language.Fortran.Open x sp s -> x
                   Language.Fortran.Close x sp s -> x
                   Language.Fortran.Continue x sp -> x
                   Language.Fortran.Cycle x sp s -> x
                   Language.Fortran.DataStmt x sp ds1 -> x
                   Language.Fortran.Deallocate x sp es e -> x
                   Language.Fortran.Endfile x sp s -> x
                   Language.Fortran.Exit x sp s -> x
                   Language.Fortran.Format x sp ds1 -> x
                   Language.Fortran.Forall x sp es f94 -> x
                   Language.Fortran.Goto x sp s -> x
                   Language.Fortran.Nullify x sp e -> x
                   Language.Fortran.Inquire x sp s e -> x
                   Language.Fortran.Pause x sp ds1 -> x
                   Language.Fortran.Rewind x sp s -> x
                   Language.Fortran.Stop x sp e -> x
                   Language.Fortran.Where x sp e f94 ds1 -> x
                   Language.Fortran.Write x sp s e -> x
                   Language.Fortran.PointerAssg x sp e1 e2 -> x
                   Language.Fortran.Return x sp e -> x
                   Language.Fortran.Label x sp s f94 -> x
                   Language.Fortran.Print x sp e es -> x
                   Language.Fortran.ReadS x sp s e -> x
                   Language.Fortran.TextStmt x sp s -> x
                   Language.Fortran.NullStmt x sp -> x
                   Language.Fortran.SelectStmt x sp e fes ds1 -> x
                   Language.Fortran.OpenCLMap x sp e1 e2 ds1 ds2 f94 -> x
                   Language.Fortran.OpenCLReduce x sp e1 e2 ds1 ds2 e3 f94 -> x
                   Language.Fortran.OpenCLBufferRead x ds1 ds2 -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedGSpec :: Language.Fortran.Tagged Language.Fortran.GSpec
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedGSpec_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.GSpec>_N)) -}
505939c522ae4cd733486a78128db844
  $fTaggedGSpec_$ctag :: Language.Fortran.GSpec a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.GSpec a) ->
                 case ds of wild {
                   Language.Fortran.GName x ds1 -> x
                   Language.Fortran.GOper x ds1 -> x
                   Language.Fortran.GAssg x -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedImplicit ::
    Language.Fortran.Tagged Language.Fortran.Implicit
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedImplicit_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.Implicit>_N)) -}
2fc18776c1a6891bbab141775d830ccd
  $fTaggedImplicit_$ctag :: Language.Fortran.Implicit a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Implicit a) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone x -> x
                   Language.Fortran.ImplicitNull x -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedProgUnit ::
    Language.Fortran.Tagged Language.Fortran.ProgUnit
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedProgUnit_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ProgUnit>_N)) -}
4b4c01f9f82d1f392f2890a1f7233330
  $fTaggedProgUnit1 :: a
  {- Strictness: x -}
5aa0277c34679f3aaa25898f299429f9
  $fTaggedProgUnit_$ctag :: Language.Fortran.ProgUnit a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.ProgUnit a) ->
                 case ds of wild {
                   Language.Fortran.Main x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Sub x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Function x sp ds1 ds2 ds3 ds4 ds5 -> x
                   Language.Fortran.Module x sp ds1 ds2 ds3 ds4 ds5 -> x
                   Language.Fortran.BlockData x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.PSeq x sp ds1 ds2 -> x
                   Language.Fortran.Prog x sp ds1 -> x
                   Language.Fortran.NullProg x sp -> x
                   Language.Fortran.IncludeProg ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fTaggedProgUnit1 @ a }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedSubName :: Language.Fortran.Tagged Language.Fortran.SubName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedSubName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.SubName>_N)) -}
473203b7a5255e8fc4c83cc7119ee885
  $fTaggedSubName_$ctag :: Language.Fortran.SubName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.SubName a) ->
                 case ds of wild {
                   Language.Fortran.SubName x ds1 -> x
                   Language.Fortran.NullSubName x -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedUses :: Language.Fortran.Tagged Language.Fortran.Uses
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedUses_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Uses>_N)) -}
68bc63b9661b3b0b5d14602bb98a9c7e
  $fTaggedUses_$ctag :: Language.Fortran.Uses a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Uses a) ->
                 case ds of wild {
                   Language.Fortran.Use x ds1 ds2 ds3 -> x
                   Language.Fortran.UseNil x -> x }) -}
c4a9d59142bdad96bc986b9181ed97e9
  $fTaggedVarName :: Language.Fortran.Tagged Language.Fortran.VarName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedVarName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.VarName>_N)) -}
97675ad6fa3e07b2325c3bd57c0557e9
  $fTaggedVarName_$ctag :: Language.Fortran.VarName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.VarName a) ->
                 case ds of wild { Language.Fortran.VarName x ds1 -> x }) -}
2a3a76a95796c9e316d8df6d5acc3004
  $s$fData(,) :: Data.Data.Data ([GHC.Types.Char], [GHC.Types.Char])
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char])
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ ((,) [GHC.Types.Char])
                     @ [GHC.Types.Char]
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ (* -> *)
                        @ (,)
                        @ [GHC.Types.Char]
                        Data.Data.$fData(,)10
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7))
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <([GHC.Types.Char],
                                                                      [GHC.Types.Char])>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                     (z :: forall g. g -> c g)
                     (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case ds of wild { (,) a1 a2 ->
                   k @ [GHC.Types.Char]
                     @ ([GHC.Types.Char], [GHC.Types.Char])
                     Data.Data.$fData[]_$s$fData[]
                     (k @ [GHC.Types.Char]
                        @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char]
                              -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                           (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char]))
                        a1)
                     a2 })
                  (\ @ c :: * -> *
                     (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                     (z :: forall r. r -> c r)
                     (ds :: Data.Data.Constr) ->
                   k @ [GHC.Types.Char]
                     @ ([GHC.Types.Char], [GHC.Types.Char])
                     Data.Data.$fData[]_$s$fData[]
                     (k @ [GHC.Types.Char]
                        @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char]
                              -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                           (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char]))))
                  (\ (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case ds of wild { (,) ds1 ds2 -> Data.Data.$c(,) })
                  (\ (ds :: ([GHC.Types.Char], [GHC.Types.Char])) -> Data.Data.$t(,))
                  (\ @ t :: * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d. Data.Data.Data d => c (t d)) ->
                   GHC.Base.Nothing @ (c ([GHC.Types.Char], [GHC.Types.Char])))
                  (Data.Data.$fData(,)_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                     (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x0 of wild { (,) a1 a2 ->
                   (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1,
                    ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <([GHC.Types.Char], [GHC.Types.Char])>_R)) })
                    `cast`
                  (<forall b1. Data.Data.Data b1 => b1 -> b1>_R
                   ->_R <([GHC.Types.Char], [GHC.Types.Char])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <([GHC.Types.Char], [GHC.Types.Char])>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case eta of wild { (,) a1 a2 ->
                   (ds
                      (ds ds1 (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                      (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2))
                     `cast`
                   (Sym (Data.Functor.Const.N:Const[0]
                             <*>_N <r>_R <([GHC.Types.Char], [GHC.Types.Char])>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <([GHC.Types.Char], [GHC.Types.Char])>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <([GHC.Types.Char], [GHC.Types.Char])>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x0 of wild { (,) a1 a2 ->
                   ds
                     (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                     (ds
                        (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                        ds1) })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x0 of wild { (,) a1 a2 ->
                   GHC.Types.:
                     @ u
                     (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                     (GHC.Types.:
                        @ u
                        (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                        (GHC.Types.[] @ u)) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x of wild { (,) a1 a2 ->
                   case ds of wild1 { GHC.Types.I# x1 ->
                   case x1 of wild2 {
                     DEFAULT -> Data.Maybe.fromJust1 @ u
                     0# -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1
                     1#
                     -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2 } } })
                  (Data.Data.$fData(,)_$cgmapM
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData(,)_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData(,)_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[]) -}
b7ad4db1b5e2cd3a4f9729b69c2efb54
  $s$fData(,)3 ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> Data.Functor.Identity.Identity
         (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 a2 ->
                 (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1,
                  ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R)) }) -}
4e609f32083545c9d8b9f147ef1eeba3
  $s$fData(,)5 ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> Data.Functor.Identity.Identity
         ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 a2 ->
                 (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1,
                  ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([GHC.Types.Char], [GHC.Types.Char])>_R)) }) -}
4fc39776bd0454898ffcd13df0ec85e6
  $s$fData(,)_$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> m (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (w364 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case w364 of ww { (,) ww1 ww2 ->
                 Data.Data.$w$cgmapM
                   @ Language.Fortran.SrcLoc
                   @ Language.Fortran.SrcLoc
                   Language.Fortran.$fDataSrcLoc
                   Language.Fortran.$fDataSrcLoc
                   @ m
                   w362
                   w363
                   ww1
                   ww2 }) -}
1d4c5d317cb88e6309e13e19e9dcecae
  $s$fData(,)_$cgmapM1 ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> m ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (w364 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case w364 of ww { (,) ww1 ww2 ->
                 Data.Data.$w$cgmapM
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]_$s$fData[]
                   Data.Data.$fData[]_$s$fData[]
                   @ m
                   w362
                   w363
                   ww1
                   ww2 }) -}
b17515864da7f10dd9fda2eaf274fcfd
  $s$fData(,)_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc) -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                   (GHC.Types.:
                      @ u
                      (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                      (GHC.Types.[] @ u)) }) -}
00b8ea3298d35f2ca4be902457ff1be3
  $s$fData(,)_$cgmapQ1 ::
    (forall d. Data.Data.Data d => d -> u)
    -> ([GHC.Types.Char], [GHC.Types.Char]) -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                   (GHC.Types.:
                      @ u
                      (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                      (GHC.Types.[] @ u)) }) -}
62ee856c58e0815b9559512dfcad2ce6
  $s$fData(,)_$cgunfold ::
    (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                   Language.Fortran.$fDataSrcLoc
                   (k @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.SrcLoc
                         -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                      Language.Fortran.$fDataSrcLoc
                      (z @ (Language.Fortran.SrcLoc
                            -> Language.Fortran.SrcLoc
                            -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                         (GHC.Tuple.(,)
                            @ Language.Fortran.SrcLoc
                            @ Language.Fortran.SrcLoc)))) -}
6b4fcb7139176f18d5cf93d6fb53733d
  $s$fData(,)_$cgunfold1 ::
    (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ [GHC.Types.Char]
                   @ ([GHC.Types.Char], [GHC.Types.Char])
                   Data.Data.$fData[]_$s$fData[]
                   (k @ [GHC.Types.Char]
                      @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                      Data.Data.$fData[]_$s$fData[]
                      (z @ ([GHC.Types.Char]
                            -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                         (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char])))) -}
533f2c1089cee1d315a4837a4890a240
  $s$fDataMaybe :: Data.Data.Data (GHC.Base.Maybe [GHC.Types.Char])
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [GHC.Types.Char])
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ GHC.Base.Maybe
                     @ [GHC.Types.Char]
                     Data.Data.$fDataMaybe7
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <GHC.Base.Maybe
                                                                       [GHC.Types.Char]>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                     (z :: forall g. g -> c g)
                     (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> z @ (GHC.Base.Maybe [GHC.Types.Char])
                          (GHC.Base.Nothing @ [GHC.Types.Char])
                     GHC.Base.Just a1
                     -> k @ [GHC.Types.Char]
                          @ (GHC.Base.Maybe [GHC.Types.Char])
                          Data.Data.$fData[]_$s$fData[]
                          (z @ ([GHC.Types.Char] -> GHC.Base.Maybe [GHC.Types.Char])
                             (GHC.Base.Just @ [GHC.Types.Char]))
                          a1 })
                  (Data.Data.$fDataMaybe_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case ds of wild {
                     GHC.Base.Nothing -> Data.Data.$cNothing
                     GHC.Base.Just ds1 -> Data.Data.$cJust })
                  (\ (ds :: GHC.Base.Maybe [GHC.Types.Char]) -> Data.Data.$tMaybe)
                  (Data.Data.$fDataMaybe_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (GHC.Base.Maybe [GHC.Types.Char])))
                  (\ (ds :: forall b. Data.Data.Data b => b -> b)
                     (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x0 of wild {
                     GHC.Base.Nothing
                     -> (GHC.Base.Nothing @ [GHC.Types.Char])
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe [GHC.Types.Char]>_R))
                     GHC.Base.Just a1
                     -> (GHC.Base.Just
                           @ [GHC.Types.Char]
                           (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe [GHC.Types.Char]>_R)) })
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <GHC.Base.Maybe [GHC.Types.Char]>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <GHC.Base.Maybe [GHC.Types.Char]>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case eta of wild {
                     GHC.Base.Nothing
                     -> ds1
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P))
                     GHC.Base.Just a1
                     -> (ds
                           ds1
                           (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <GHC.Base.Maybe [GHC.Types.Char]>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> ds1
                     GHC.Base.Just a1
                     -> ds
                          (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                          ds1 })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> GHC.Types.[] @ u
                     GHC.Base.Just a1
                     -> GHC.Types.:
                          @ u
                          (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                          (GHC.Types.[] @ u) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x of wild {
                     GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                     GHC.Base.Just a1
                     -> case ds of wild1 { GHC.Types.I# x1 ->
                        case x1 of wild2 {
                          DEFAULT -> Data.Maybe.fromJust1 @ u
                          0#
                          -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1 } } })
                  (Data.Data.$fDataMaybe_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fDataMaybe_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fDataMaybe_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
56cce34696ca368ab869bf415d94ba01
  $s$fDataMaybe1 :: Data.Data.Data (GHC.Base.Maybe GHC.Types.Int)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ GHC.Base.Maybe
                     @ GHC.Types.Int
                     Data.Data.$fDataMaybe7
                     Data.Data.$fDataInt4)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <GHC.Base.Maybe
                                                                       GHC.Types.Int>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                     (z :: forall g. g -> c g)
                     (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> z @ (GHC.Base.Maybe GHC.Types.Int)
                          (GHC.Base.Nothing @ GHC.Types.Int)
                     GHC.Base.Just a1
                     -> k @ GHC.Types.Int
                          @ (GHC.Base.Maybe GHC.Types.Int)
                          Data.Data.$fDataInt
                          (z @ (GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int)
                             (GHC.Base.Just @ GHC.Types.Int))
                          a1 })
                  (Data.Data.$fDataMaybe_$cgunfold
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                   case ds of wild {
                     GHC.Base.Nothing -> Data.Data.$cNothing
                     GHC.Base.Just ds1 -> Data.Data.$cJust })
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Int) -> Data.Data.$tMaybe)
                  (Data.Data.$fDataMaybe_$cdataCast1
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (GHC.Base.Maybe GHC.Types.Int)))
                  (\ (ds :: forall b. Data.Data.Data b => b -> b)
                     (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x0 of wild {
                     GHC.Base.Nothing
                     -> (GHC.Base.Nothing @ GHC.Types.Int)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe GHC.Types.Int>_R))
                     GHC.Base.Just a1
                     -> (GHC.Base.Just
                           @ GHC.Types.Int
                           (ds @ GHC.Types.Int Data.Data.$fDataInt a1))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe GHC.Types.Int>_R)) })
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <GHC.Base.Maybe GHC.Types.Int>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <GHC.Base.Maybe GHC.Types.Int>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: GHC.Base.Maybe GHC.Types.Int) ->
                   case eta of wild {
                     GHC.Base.Nothing
                     -> ds1
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P))
                     GHC.Base.Just a1
                     -> (ds ds1 (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1))
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <GHC.Base.Maybe GHC.Types.Int>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> ds1
                     GHC.Base.Just a1
                     -> ds (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1) ds1 })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> GHC.Types.[] @ u
                     GHC.Base.Just a1
                     -> GHC.Types.:
                          @ u
                          (ds @ GHC.Types.Int Data.Data.$fDataInt a1)
                          (GHC.Types.[] @ u) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x of wild {
                     GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                     GHC.Base.Just a1
                     -> case ds of wild1 { GHC.Types.I# x1 ->
                        case x1 of wild2 {
                          DEFAULT -> Data.Maybe.fromJust1 @ u
                          0# -> ds1 @ GHC.Types.Int Data.Data.$fDataInt a1 } } })
                  (Data.Data.$fDataMaybe_$cgmapM @ GHC.Types.Int Data.Data.$fDataInt)
                  (Data.Data.$fDataMaybe_$cgmapMp
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (Data.Data.$fDataMaybe_$cgmapMo
                     @ GHC.Types.Int
                     Data.Data.$fDataInt) -}
7e601f84429a1ce6571fb90a188205db
  $s$fDataMaybe2 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe GHC.Types.Int
    -> Data.Functor.Const.Const r (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: GHC.Base.Maybe GHC.Types.Int) ->
                 case eta of wild {
                   GHC.Base.Nothing
                   -> ds1
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P))
                   GHC.Base.Just a1
                   -> (ds ds1 (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P)) }) -}
8641d0d21f60228c7603bd3b99580942
  $s$fDataMaybe3 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> Data.Functor.Const.Const r (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case eta of wild {
                   GHC.Base.Nothing
                   -> ds1
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P))
                   GHC.Base.Just a1
                   -> (ds
                         ds1
                         (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P)) }) -}
24ba36b127bc4c20f009798fe644b1d2
  $s$fDataMaybe4 ::
    (forall b. Data.Data.Data b => b -> b)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing
                   -> (GHC.Base.Nothing @ [GHC.Types.Char])
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe [GHC.Types.Char]>_R))
                   GHC.Base.Just a1
                   -> (GHC.Base.Just
                         @ [GHC.Types.Char]
                         (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe [GHC.Types.Char]>_R)) }) -}
5fc3512cb6df0973917ae6697bb59020
  $s$fDataMaybe6 ::
    (forall b. Data.Data.Data b => b -> b)
    -> GHC.Base.Maybe GHC.Types.Int
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing
                   -> (GHC.Base.Nothing @ GHC.Types.Int)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe GHC.Types.Int>_R))
                   GHC.Base.Just a1
                   -> (GHC.Base.Just
                         @ GHC.Types.Int
                         (ds @ GHC.Types.Int Data.Data.$fDataInt a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe GHC.Types.Int>_R)) }) -}
0a52e45a0b808a05d40f042719586529
  $s$fDataMaybe7 ::
    Data.Typeable.Internal.TypeRep (GHC.Base.Maybe [GHC.Types.Char])
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ GHC.Base.Maybe
                   @ [GHC.Types.Char]
                   Data.Data.$fDataMaybe7
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Types.Char
                      Data.Data.$fData[]3
                      Data.Data.$fDataChar7)) -}
b75bb71a9e63201d2784e910a2a35ef3
  $s$fDataMaybe8 ::
    Data.Typeable.Internal.TypeRep (GHC.Base.Maybe GHC.Types.Int)
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ GHC.Base.Maybe
                   @ GHC.Types.Int
                   Data.Data.$fDataMaybe7
                   Data.Data.$fDataInt4) -}
418da5aae827c2caf6a987bad762afce
  $s$fDataMaybe_$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> c (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 3, Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> z @ (GHC.Base.Maybe [GHC.Types.Char])
                        (GHC.Base.Nothing @ [GHC.Types.Char])
                   GHC.Base.Just a1
                   -> k @ [GHC.Types.Char]
                        @ (GHC.Base.Maybe [GHC.Types.Char])
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char] -> GHC.Base.Maybe [GHC.Types.Char])
                           (GHC.Base.Just @ [GHC.Types.Char]))
                        a1 }) -}
fc3b3ccdee55d2e590f576450fc3ffb5
  $s$fDataMaybe_$cgfoldl1 ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.Maybe GHC.Types.Int
    -> c (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 3, Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> z @ (GHC.Base.Maybe GHC.Types.Int)
                        (GHC.Base.Nothing @ GHC.Types.Int)
                   GHC.Base.Just a1
                   -> k @ GHC.Types.Int
                        @ (GHC.Base.Maybe GHC.Types.Int)
                        Data.Data.$fDataInt
                        (z @ (GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int)
                           (GHC.Base.Just @ GHC.Types.Int))
                        a1 }) -}
d40e4aaa002d2bcf664466440dfb6346
  $s$fDataMaybe_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe [GHC.Types.Char] -> [u]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ u
                   GHC.Base.Just a1
                   -> GHC.Types.:
                        @ u
                        (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                        (GHC.Types.[] @ u) }) -}
af9e7caeb3c0a464255c0366b752d5d6
  $s$fDataMaybe_$cgmapQ1 ::
    (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe GHC.Types.Int -> [u]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ u
                   GHC.Base.Just a1
                   -> GHC.Types.:
                        @ u
                        (ds @ GHC.Types.Int Data.Data.$fDataInt a1)
                        (GHC.Types.[] @ u) }) -}
ec3bed13d27bcd255f5dcc2f8eefc00e
  $s$fDataMaybe_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                   GHC.Base.Just a1
                   -> case ds of wild1 { GHC.Types.I# x1 ->
                      case x1 of wild2 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0#
                        -> ds1
                             @ [GHC.Types.Char]
                             Data.Data.$fData[]_$s$fData[]
                             a1 } } }) -}
7cf6b62ed399dbf2187c8917ebf21fb5
  $s$fDataMaybe_$cgmapQi1 ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe GHC.Types.Int
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                   GHC.Base.Just a1
                   -> case ds of wild1 { GHC.Types.I# x1 ->
                      case x1 of wild2 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> ds1 @ GHC.Types.Int Data.Data.$fDataInt a1 } } }) -}
aed1e74d74f5d63b7f1f0c4b06a99417
  $s$fDataMaybe_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just a1
                   -> ds
                        (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                        ds1 }) -}
4f82f8711ab5e92500f0f0758f5a3747
  $s$fDataMaybe_$cgmapQr1 ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe GHC.Types.Int
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just a1
                   -> ds (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1) ds1 }) -}
f3ec10273e53d9312443ac2c577cfafb
  $s$fDataMaybe_$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 3,
     Strictness: <L,1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Data.Data.$w$cgunfold10
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]_$s$fData[]
                   @ c
                   w362
                   w363
                   ww1
                   ww5 }) -}
da72aec00a507b0f903e13b973485b98
  $s$fDataMaybe_$cgunfold1 ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 3,
     Strictness: <L,1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Data.Data.$w$cgunfold10
                   @ GHC.Types.Int
                   Data.Data.$fDataInt
                   @ c
                   w362
                   w363
                   ww1
                   ww5 }) -}
86ac4f4bc52540dddeaad4e5d9b73716
  $s$fData[] :: Data.Data.Data [[GHC.Types.Char]]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [[GHC.Types.Char]]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[[GHC.Types.Char]]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: [[GHC.Types.Char]]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [[GHC.Types.Char]]) -> Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c [[GHC.Types.Char]]))
                  (Data.Data.$fData[]_$cgmapT
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQr
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQ
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQi
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
47248f1805d109d39385f2ec3470db0e
  $s$fData[]1 ::
    Data.Data.Data
      [(Language.Fortran.Variable, Language.Fortran.Variable)]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ ((,) [GHC.Types.Char])
                        @ [GHC.Types.Char]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ (,)
                           @ [GHC.Types.Char]
                           Data.Data.$fData(,)10
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7)))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[(Language.Fortran.Variable,
                                                                       Language.Fortran.Variable)]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgunfold
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (\ (ds :: [(Language.Fortran.Variable,
                              Language.Fortran.Variable)]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [(Language.Fortran.Variable,
                              Language.Fortran.Variable)]) ->
                   Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c [(Language.Fortran.Variable, Language.Fortran.Variable)]))
                  (Data.Data.$fData[]_$cgmapT
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQl
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQr
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQ
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQi
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapM
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapMp
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapMo
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)) -}
01fd15eccf3fcb95735aa4946cb50086
  $s$fData[]7 :: Data.Typeable.Internal.TypeRep [[GHC.Types.Char]]
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]3
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Types.Char
                      Data.Data.$fData[]3
                      Data.Data.$fDataChar7)) -}
1dfca9f5816d5695beb3a4d03bc95adc
  $s$fEq(,) :: GHC.Classes.Eq ([GHC.Types.Char], [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char])
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]1)
                  Language.Fortran.$s$fEq(,)_$s$fEq(,)_$c/= -}
6d3f3a3778134aaf5f6bba541b00de66
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    ([GHC.Types.Char], [GHC.Types.Char])
    -> ([GHC.Types.Char], [GHC.Types.Char]) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: ([GHC.Types.Char], [GHC.Types.Char]))
                   (y :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Base.eqString a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
212fd2e5c383561c485d986def868979
  $s$fEqMaybe :: GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Int)
                     (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1 -> GHC.Classes.eqInt a1 b1 } })
                  Language.Fortran.$s$fEqMaybe_$s$fEqMaybe_$c/= -}
bc8ca12e911c7b26cae5f6239152ab19
  $s$fEqMaybe_$c== ::
    GHC.Base.Maybe GHC.Types.Int
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Int)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.eqInt a1 b1 } }) -}
df3552e2083c23408564ff09b18e3bba
  $s$fEqMaybe_$s$fEqMaybe_$c/= ::
    GHC.Base.Maybe GHC.Types.Int
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: GHC.Base.Maybe GHC.Types.Int)
                   (y :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case GHC.Classes.eqInt a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
aad5d0f91ca70bc37c37d49a3cbf3d37
  $tArg :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArg13
                   Language.Fortran.$fDataArg11) -}
26412a1f33281eb898992899c7b0d554
  $tArgList :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArgList7
                   Language.Fortran.$fDataArgList5) -}
05457330695276ae60f826ab94363064
  $tArgName :: Data.Data.DataType
  {- Strictness: m -}
3aca49693ff4df478545fee6a4caf809
  $tAttr :: Data.Data.DataType
  {- Strictness: m -}
217d47d5010f5ccb06be4d5325d5ff48
  $tBaseType :: Data.Data.DataType
  {- Strictness: m -}
8585a58ab575cda5b1127e5d797511b4
  $tBinOp :: Data.Data.DataType
  {- Strictness: m -}
89b170ec543ed3c97d1301e7b6412e0c
  $tBlock :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataBlock7
                   Language.Fortran.$fDataBlock5) -}
4ade97b618499443a6adcb76848c3a02
  $tDataForm :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataDataForm7
                   Language.Fortran.$fDataDataForm5) -}
aabee56e5dd21c0780bcdb5fbe54334d
  $tDecl :: Data.Data.DataType
  {- Strictness: m -}
572296f581277beea5289ab03372160f
  $tExpr :: Data.Data.DataType
  {- Strictness: m -}
710af197125c699c80629938fa1c612e
  $tFortran :: Data.Data.DataType
  {- Strictness: m -}
5725ced8189337814fa34b96bf914fe3
  $tFraction :: Data.Data.DataType
  {- Strictness: m -}
6f68469903087b7bf547e596b2519d39
  $tGSpec :: Data.Data.DataType
  {- Strictness: m -}
700137e2b2ae31047b057fd6b0e6f7bb
  $tImplicit :: Data.Data.DataType
  {- Strictness: m -}
6bb9f33902e45218906102297101c459
  $tIntentAttr :: Data.Data.DataType
  {- Strictness: m -}
73506184a901b805ae8384d293a62daf
  $tInterfaceSpec :: Data.Data.DataType
  {- Strictness: m -}
ccbc0252c9e3df9bff4c5904f8cc15a1
  $tMeasureUnitSpec :: Data.Data.DataType
  {- Strictness: m -}
2d8b67c0387a9b9a0b75c1cf2003f447
  $tProgUnit :: Data.Data.DataType
  {- Strictness: m -}
d7041ce46cf72a15f23a55c5eaab3d2f
  $tSpec :: Data.Data.DataType
  {- Strictness: m -}
66d49e4415afa125ba853dfdc16b3dff
  $tSrcLoc :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataSrcLoc5
                   Language.Fortran.$fDataSrcLoc3) -}
177cccb361be5fdafd0eeb8375e3c725
  $tSubName :: Data.Data.DataType
  {- Strictness: m -}
d1c57b51d8ce90db3b8762968e67a196
  $tType :: Data.Data.DataType
  {- Strictness: m -}
5bd0f9927af152dc29f0324aedb61758
  $tUnaryOp :: Data.Data.DataType
  {- Strictness: m -}
dced037f0bb4e7862159cbe264879d5d
  $tUseBlock :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataUseBlock7
                   Language.Fortran.$fDataUseBlock5) -}
139957811ecdd6f698930d66dac4908c
  $tUses :: Data.Data.DataType
  {- Strictness: m -}
62903f305b89f1a5016f64b0c33fd709
  $tVarName :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataVarName8
                   Language.Fortran.$fDataVarName6) -}
79dff113a6cf14f2f49ae3b5089acb10
  $tc'ASeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4237248215703099803##
                   4754110689937139466##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ASeq2
                   1#
                   Language.Fortran.$tc'ASeq1) -}
90f68b46d4f315cbea09d508ff233ed0
  $tc'ASeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b0566b604e05c50e0511f5bf12bf7e50
  $tc'ASeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ASeq3) -}
5b8e8390ade623ad5c02d463ec81ad1a
  $tc'ASeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ASeq"#) -}
80738cf501a5d56a66e530d18df27f71
  $tc'Access :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11401392469762725528##
                   3791558735454631466##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Access2
                   1#
                   Language.Fortran.$tc'Access1) -}
7971e2b1d8e15248808dc28c4780ae07
  $tc'Access1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
74c311474814292a7d0c259ac650475c
  $tc'Access2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Access3) -}
552e5a2f702ed043af1ab1eceae70889
  $tc'Access3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Access"#) -}
8ddf121431512366e99df59e3ef0083c
  $tc'AccessStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6257397677012001455##
                   333726045473351032##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AccessStmt2
                   1#
                   Language.Fortran.$tc'AccessStmt1) -}
b4a422a5066992a4ef3ec437dd08e1c1
  $tc'AccessStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2ea5993490195ca1367f03f38808dd21
  $tc'AccessStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'AccessStmt3) -}
dbcbbeb9acfab1f5da9677f8cd748e0e
  $tc'AccessStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AccessStmt"#) -}
be9fb1e0ff3f3c986e8760bb4d9dc1b7
  $tc'Action :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3466438629983624827##
                   17836353563751936330##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Action1
                   1#
                   Language.Fortran.$tc'Access1) -}
a9033d2a49899d9d93f5897ab0cc3e38
  $tc'Action1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Action2) -}
99d40410fc9b579d2e169dea78c00a82
  $tc'Action2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Action"#) -}
1ebbd893bcb6d782a2ea8c7e143d54b5
  $tc'Advance :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1833153302572932376##
                   2783972359557351470##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Advance1
                   1#
                   Language.Fortran.$tc'Access1) -}
615769835216f1d70648ed7a98d4be6b
  $tc'Advance1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Advance2) -}
4d100222f24405358f95fa94b1851d51
  $tc'Advance2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Advance"#) -}
ce3ce86b55c740950a7540ef0cc022a3
  $tc'Allocatable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8960491002594778179##
                   10036112753958701443##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Allocatable2
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
05a14eef0bcb562bff29b2fb2829e9b3
  $tc'Allocatable1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d5f4443f7ae5a5a45ba601f69611cd5b
  $tc'Allocatable2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Allocatable3) -}
22b3f1baf85f03395d4e992fa7c17b80
  $tc'Allocatable3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Allocatable"#) -}
1481b3d3f25f7d8bc27b8e8e2c58c7bd
  $tc'Allocate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12510159952991250402##
                   4050072483253214759##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Allocate2
                   1#
                   Language.Fortran.$tc'Allocate1) -}
276d78e45ef0a741a47d8614026d496d
  $tc'Allocate1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2e9c76247ee21f9612ac69d4f866d4df
  $tc'Allocate2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Allocate3) -}
08d18cda9c56bf688d40f5f351192e19
  $tc'Allocate3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Allocate"#) -}
a9eeb76a23a7033c495ce5d5d3b0e92a
  $tc'And :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4624904058144135821##
                   13484378429422803035##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'And2
                   1#
                   Language.Fortran.$tc'And1) -}
208a8b5b97cba77de0c4b286b683ad30
  $tc'And1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1c3252cb3d0c61c105e5bc483cd2e4e2
  $tc'And2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'And3) -}
a9ad7e939e1900c8dd9d45828a2aa99d
  $tc'And3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'And"#) -}
34a36eac5860b4183e0f31171b17cdfa
  $tc'Arg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2501554400486158121##
                   2366884041521490842##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Arg2
                   1#
                   Language.Fortran.$tc'Arg1) -}
92b3c9c25d525cb3473e40ee0530f2ed
  $tc'Arg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
70867ad3832c2ffa40c0b45b3b9cc149
  $tc'Arg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Arg3) -}
63c187a84df6bdc6954ee1ff46b49cfe
  $tc'Arg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Arg"#) -}
2ffd66ef1dda7d3743b4f17f3eac7c3d
  $tc'ArgList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16752355448582664323##
                   10217178917208792720##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArgList2
                   1#
                   Language.Fortran.$tc'ArgList1) -}
2266e2b55260172bd3e349ba9059690c
  $tc'ArgList1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
360a3fe44ac0bdeb3e6d3f69099613e9
  $tc'ArgList2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArgList3) -}
ae381421a4d97286428042768b9b182f
  $tc'ArgList3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArgList"#) -}
3ea44f1aed11dee9db9270af508fa5f4
  $tc'ArgName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1790824389330188845##
                   11757079199517529293##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArgName2
                   1#
                   Language.Fortran.$tc'ArgName1) -}
68b4f8171929705b5fc881008a8f4dcb
  $tc'ArgName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5df49aec2fadc70a09f69e9c042a6892
  $tc'ArgName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArgName3) -}
103900e9a9856f4e974b3301b3bd0024
  $tc'ArgName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArgName"#) -}
9b12798cc7c70c6224f8814b403aee6a
  $tc'ArrayCon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8236290881537670455##
                   3551604772063094460##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArrayCon2
                   1#
                   Language.Fortran.$tc'ArrayCon1) -}
836370994e723f440eb22fdb93297e26
  $tc'ArrayCon1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f3aa679d0a9e9aa1d7eae5281cf5d690
  $tc'ArrayCon2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArrayCon3) -}
9aebbb978dcf3948bbced37184877c79
  $tc'ArrayCon3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArrayCon"#) -}
2bf974a3e614c43f7c8dab0dd81746dd
  $tc'ArrayT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10912436281120811245##
                   17953499356212179297##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArrayT2
                   1#
                   Language.Fortran.$tc'ArrayT1) -}
380baedb1712bfd75fbbc2eb279ea5f7
  $tc'ArrayT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1032cff6f353ed3513c110495c5dea48
  $tc'ArrayT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArrayT3) -}
d5ae441802cb8e6cb910d9136ced8428
  $tc'ArrayT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArrayT"#) -}
7fd3d62f405592f2f6aa1aab67242808
  $tc'Assg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2805264015156318488##
                   3352550197954176892##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Assg1
                   1#
                   Language.Fortran.$tc'Allocate1) -}
b6a66ba06e462dd7acf31b783269e2c0
  $tc'Assg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Assg2) -}
72970467bfa6e288db68e81eb1635d94
  $tc'Assg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Assg"#) -}
6c8bca0164e3588abf121d59c550bc8e
  $tc'AssgExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15872640529052700421##
                   7551451126237492024##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AssgExpr2
                   1#
                   Language.Fortran.$tc'AssgExpr1) -}
2e33fb515f92e53295ed5bb6ebf35afd
  $tc'AssgExpr1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
48836c6b6d1cf4cde5c829fa857bf8b3
  $tc'AssgExpr2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'AssgExpr3) -}
7b9178d5554c41790dd8edf9b3740197
  $tc'AssgExpr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AssgExpr"#) -}
0e326693371080a724a3bcb454220cc7
  $tc'AttrStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14699968256260223253##
                   4221201990731573920##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AttrStmt2
                   1#
                   Language.Fortran.$tc'AttrStmt1) -}
f64e3088ca1d21f843a0ec78ca2fe870
  $tc'AttrStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
22cac7ac553ccf5021340e55ab62cef1
  $tc'AttrStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'AttrStmt3) -}
25e3322da43f2f3ca1a5a98f371e4453
  $tc'AttrStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AttrStmt"#) -}
e99193311e39359c80adb708c4785630
  $tc'Backspace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16464960625697938757##
                   485745005153459385##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Backspace2
                   1#
                   Language.Fortran.$tc'Backspace1) -}
f9f8d01e3092d7c2ca3488ca409e892f
  $tc'Backspace1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e98229c0af4fabad0c8095f50d4c3c46
  $tc'Backspace2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Backspace3) -}
16e085ec91e98c0c8164a08408d8ccaa
  $tc'Backspace3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Backspace"#) -}
05d9bcf969e666f30df62d1da2594f02
  $tc'BaseType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17373389839685984068##
                   7682085210555603311##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'BaseType2
                   1#
                   Language.Fortran.$tc'BaseType1) -}
b0b4392f77b8f9742ccf03885deff09a
  $tc'BaseType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
21fb695384d3137a83b2aa0524e50f2e
  $tc'BaseType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'BaseType3) -}
81050283793942fe9a9554fccd700b35
  $tc'BaseType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BaseType"#) -}
3f2f788745d1909a595fe3ad00dbd04b
  $tc'Bin :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17353688811913845802##
                   2005168554674163467##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Bin2
                   1#
                   Language.Fortran.$tc'Bin1) -}
8abf3bae35a1d8a69b9b96fdc7e4a0b6
  $tc'Bin1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c140808f08a97f0fe0f136bef5407ab5
  $tc'Bin2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Bin3) -}
4915566992e5de9eb5d153d6b3b232a0
  $tc'Bin3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bin"#) -}
622ec702ec5cc1d0268aa59867dee2d1
  $tc'Blank :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2385709772822644251##
                   12443080985075528525##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Blank1
                   1#
                   Language.Fortran.$tc'Access1) -}
320c508fd75240ef43830b6ccfd1e9e8
  $tc'Blank1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Blank2) -}
f1dd3d06d59ea0b6b18b1b76beafa143
  $tc'Blank2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Blank"#) -}
3f610e8b255b4b7f1dda6c8a5ae29578
  $tc'Block :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16574720040940088580##
                   10327826536489238498##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Block2
                   1#
                   Language.Fortran.$tc'Block1) -}
51e6951965b6fd300cfe247e3b5b9674
  $tc'Block1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f001e8ab716b0b486d8206256662e4b4
  $tc'Block2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Block3) -}
5b3552ccde81a3e874a7a14e453c80a4
  $tc'Block3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Block"#) -}
f1a44df14f0ac3748dc487f6b75fc1c4
  $tc'BlockData :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   72863264580154958##
                   5940670870020551725##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'BlockData2
                   1#
                   Language.Fortran.$tc'BlockData1) -}
1bbef525fa9d5e1fc3742f6d6be05522
  $tc'BlockData1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
276077a24f75f86d48db1c7c2de793fe
  $tc'BlockData2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'BlockData3) -}
4dd0af0fff0f0dfe62058001d8e25146
  $tc'BlockData3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BlockData"#) -}
400676d7aabb7e20f0313eee92ac3527
  $tc'Bound :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5291214850877060415##
                   17101734320560490841##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Bound2
                   1#
                   Language.Fortran.$tc'Bound1) -}
c6dbd6a25bdb5f68bb411e2321c2f293
  $tc'Bound1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cc50d57914eeb04df2ccd1c63a001561
  $tc'Bound2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Bound3) -}
21f146c166a4a1f23c12ad731ff9c660
  $tc'Bound3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bound"#) -}
5a570d4219ee1f396a1f372654fe3536
  $tc'C:Span :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14487930876262241053##
                   16794898622939156701##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'C:Span2
                   1#
                   Language.Fortran.$tc'C:Span1) -}
e3cc764e36e5ffe07693a98485a0fcc4
  $tc'C:Span1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f35cbe66fc621bd849097a3e446fb453
  $tc'C:Span2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'C:Span3) -}
cf1489f8ce2eb6b90b25036feb994d4d
  $tc'C:Span3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:Span"#) -}
0cf32e2fdedada4a8cb7bff11971912c
  $tc'Call :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8324842320115453880##
                   12730316765896925476##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Call2
                   1#
                   Language.Fortran.$tc'Call1) -}
ea972a41a0feca3b5f8ecc1368b0adc0
  $tc'Call1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
de4b309e86d9cbba7bb4900c2673152b
  $tc'Call2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Call3) -}
2a85ca470052634634a4a8aa4626aaf7
  $tc'Call3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Call"#) -}
68261abf2532ea01ef20c7a1df1501c7
  $tc'CallExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2455797080050362010##
                   17462070845832416479##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'CallExpr2
                   1#
                   Language.Fortran.$tc'CallExpr1) -}
08dcd0f442ff996cfb263b7fda59a560
  $tc'CallExpr1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b22dadc2fb6c332fe77483c654ac9304
  $tc'CallExpr2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'CallExpr3) -}
df7a21ac1e14b656b1d9c0948ffd1e5c
  $tc'CallExpr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CallExpr"#) -}
4a8f0427c4b535a37103d51dfa68c7d6
  $tc'Character :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3843909483321091218##
                   3291986317470032181##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Character2
                   1#
                   Language.Fortran.$tc'Character1) -}
06f11e3bb47eb3365626d176ea2ef7e3
  $tc'Character1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2139b947998513f387fee08ae7520cd2
  $tc'Character2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Character3) -}
843777d81570bc48eb31d5aaf3b04e2f
  $tc'Character3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Character"#) -}
3394aba27e8d09816db6be4d24aac8e7
  $tc'Close :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12728125086950706788##
                   4707925038119233218##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Close1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
03988a2bcefff6b7bf0edde2766f9169
  $tc'Close1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Close2) -}
320757135b768cf0eda41bb3933ef0c7
  $tc'Close2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Close"#) -}
6a6c0869592e05d73e227c955acc8f28
  $tc'Common :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10301364787366615661##
                   9930067784562791843##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Common2
                   1#
                   Language.Fortran.$tc'Common1) -}
6d38d9d536b9215cc4c17206384c61d2
  $tc'Common1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e397dc86e37f2c54b8ed17846415f18e
  $tc'Common2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Common3) -}
164082b994312b009f969e03b7467680
  $tc'Common3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Common"#) -}
3738d7ea797d84cd654482938c820f20
  $tc'Complex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10187690948996838333##
                   9679692705510488981##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Complex1
                   1#
                   Language.Fortran.$tc'Character1) -}
aa3b277aae3ab0431d18745a12ef16fa
  $tc'Complex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Complex2) -}
c1d79e88fa1fa76c20194b291ff297b8
  $tc'Complex2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Complex"#) -}
1f620416091e9a2ab52250ba4bea9ead
  $tc'Con :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13350435498021652911##
                   14613938727283532352##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Con2
                   1#
                   Language.Fortran.$tc'Con1) -}
add92ad887bd5b1223c701469e305e15
  $tc'Con1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
24ec0b3651595b376d3db68003d7dea5
  $tc'Con2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Con3) -}
8fd0a59a0233b400b386a98dbd4bc5c6
  $tc'Con3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Con"#) -}
b6a3ca11040d70580369822bcaac0f06
  $tc'ConL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17704963030230047450##
                   5421375319533983675##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ConL2
                   1#
                   Language.Fortran.$tc'ConL1) -}
e8d79345788f0e31057f2e983f5ce0ba
  $tc'ConL1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2e7ba71bf41b19941e0388cf774ddc57
  $tc'ConL2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ConL3) -}
9d3aa2bbce0c9e8a397dd03bb30aa6dc
  $tc'ConL3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ConL"#) -}
2a534587b299924e28abb9627647864c
  $tc'ConS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11435132398767934297##
                   1787303172922599552##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ConS1
                   1#
                   Language.Fortran.$tc'Con1) -}
08247d61c16dd81343d576f15a807ae6
  $tc'ConS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ConS2) -}
5c051dedb2a17ed1843be4ea953e467d
  $tc'ConS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ConS"#) -}
4f1dc8aa0171c988901f443151ff0e7b
  $tc'Concat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3029396516678851930##
                   12876411302857840923##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Concat1
                   1#
                   Language.Fortran.$tc'And1) -}
a944d4939b7c178036067e87235b118d
  $tc'Concat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Concat2) -}
efd63297fd0c1a47eee4c66566840242
  $tc'Concat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Concat"#) -}
4bba7fcb9a6593161e1906db5f82204c
  $tc'Continue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7966315544848200080##
                   15327590934969838868##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Continue2
                   1#
                   Language.Fortran.$tc'Continue1) -}
c3427ba3ac4d485ba0941d07bc6282ee
  $tc'Continue1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e470f0c480504ba148e3a4e690f0ce59
  $tc'Continue2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Continue3) -}
41ac0b4be1e658a98beb9c75708d9308
  $tc'Continue3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Continue"#) -}
42f0397f09a96e48cd6db57cc10775f4
  $tc'Cycle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11605552797912239676##
                   5640134253540614871##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Cycle2
                   1#
                   Language.Fortran.$tc'Cycle1) -}
e775396ea4a5527da8bd4b077ad4fff7
  $tc'Cycle1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
29432224d1c0f4fb2e9f0d623aa8d9a5
  $tc'Cycle2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Cycle3) -}
9a3d484b45078de596c7db9c102e7878
  $tc'Cycle3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Cycle"#) -}
81e7a6e9e4ee369cd7e1e72177ad6673
  $tc'DSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12732958504085513973##
                   15475124706179849423##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DSeq2
                   1#
                   Language.Fortran.$tc'DSeq1) -}
a1034e3d7d84a88d67563c28b0ab319a
  $tc'DSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
227b270ed05e691ff87603b4a077ace0
  $tc'DSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DSeq3) -}
c4fb7c50dbff926e6131679881479843
  $tc'DSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DSeq"#) -}
33098f6a302e87a2a30790cfcaf5aa47
  $tc'Data :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2142306129527098707##
                   1534745682251852993##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Data2
                   1#
                   Language.Fortran.$tc'Data1) -}
14be37cfc1cca4578115d54861d602c0
  $tc'Data1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6cab1d5da86229661c2a2e2467726947
  $tc'Data2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Data3) -}
ebdb50a625faf3f633dc8075ed2242d5
  $tc'Data3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Data"#) -}
a1ca16e1322619b601215a63af0b3074
  $tc'DataDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2697510846399934087##
                   2307855298590060833##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DataDecl2
                   1#
                   Language.Fortran.$tc'DataDecl1) -}
2956138b5df957319df7f765013c6f7f
  $tc'DataDecl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b142b38214926819726afe6f625823df
  $tc'DataDecl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DataDecl3) -}
b5debeca8b01da168a49e4df6bcd88b1
  $tc'DataDecl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DataDecl"#) -}
ff35e2be5a4fc2acbe453dbd8749d180
  $tc'DataStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11282091933823746379##
                   3253315402853549628##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DataStmt2
                   1#
                   Language.Fortran.$tc'DataStmt1) -}
daee2efefb1523c3d5ea6b58dc8aad94
  $tc'DataStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
81ea699fed22f41595669a85fda93e98
  $tc'DataStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DataStmt3) -}
b86074a8be621b5a7250f376062d9a6d
  $tc'DataStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DataStmt"#) -}
f074f9e76c38157f681a3a2c99eb6e93
  $tc'Deallocate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9316540554611160947##
                   14376802214522289162##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Deallocate2
                   1#
                   Language.Fortran.$tc'Deallocate1) -}
1c4a63cfa60620e017368ec0d641d746
  $tc'Deallocate1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cc2f4268cee0a7b743bcf60765af5776
  $tc'Deallocate2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Deallocate3) -}
3eb4f5685ae77e2d3f156ed25ee2a206
  $tc'Deallocate3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Deallocate"#) -}
cbd0d2467e48004da809229406d60ae9
  $tc'Decl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   336432076160067517##
                   4216765496655555466##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Decl2
                   1#
                   Language.Fortran.$tc'Decl1) -}
b141dbbc246426e2489d323542217a30
  $tc'Decl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e2d745aad7dd689c5e4e03be1951bec7
  $tc'Decl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Decl3) -}
4a134fd9673639f57b94c233536ed7af
  $tc'Decl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Decl"#) -}
e8869f8af6719c63a33b5516a9d85c1f
  $tc'Delim :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   84182534637600070##
                   4526287737400387803##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Delim1
                   1#
                   Language.Fortran.$tc'Access1) -}
f4510d9a6db78bdede81afd6ded716a8
  $tc'Delim1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Delim2) -}
136cf92bdf30cc5578ca77995288b4e7
  $tc'Delim2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Delim"#) -}
deaf8a198023b3f5915e9d3384494ffa
  $tc'Delimiter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16513135876431850856##
                   11148670885000378737##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Delimiter2
                   1#
                   Language.Fortran.$tc'Delimiter1) -}
3b52858f26206132784e7fe8c135a6c7
  $tc'Delimiter1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8667fc3e0d9068f57ad3e4ef64778fad
  $tc'Delimiter2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Delimiter3) -}
d87c26547083f5768a41d7db82a1d430
  $tc'Delimiter3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Delimiter"#) -}
1c4bb1b1e02320d945db4911f036e45c
  $tc'DerivedType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3297756634097226832##
                   1252029687144664618##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DerivedType2
                   1#
                   Language.Fortran.$tc'DerivedType1) -}
3d1158a1917347f7cf312856e5862765
  $tc'DerivedType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6f96ede7324f849a3097440d200b090e
  $tc'DerivedType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DerivedType3) -}
c52eb8def63f621ad65614fb0e3ea06c
  $tc'DerivedType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DerivedType"#) -}
fdec6ac3596cfad04ef19e14552eaa50
  $tc'DerivedTypeDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1126152859623371531##
                   13000827197436305515##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DerivedTypeDef2
                   1#
                   Language.Fortran.$tc'DerivedTypeDef1) -}
61bcf9eef07155fa561badb9e556156c
  $tc'DerivedTypeDef1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d1842178e30abff9fcbfc132304d8c9a
  $tc'DerivedTypeDef2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'DerivedTypeDef3) -}
7b056a798ccbb417700addebed0dc80c
  $tc'DerivedTypeDef3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DerivedTypeDef"#) -}
37d9ebf6b4e63a6bca15eb9a817ea0f5
  $tc'Dimension :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9749893020849303792##
                   6319714697160807228##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Dimension2
                   1#
                   Language.Fortran.$tc'Dimension1) -}
098f4efd1201bb7422aef7f9584d01cc
  $tc'Dimension1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
59b0fe9fafda22043066c5ab98e742f5
  $tc'Dimension2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Dimension3) -}
02631b7152b050f6442191af7739e7d9
  $tc'Dimension3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Dimension"#) -}
e3f8a7bbeef0eee02629b6be2c6c8451
  $tc'Direct :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15380445485501958332##
                   5565850722041945048##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Direct1
                   1#
                   Language.Fortran.$tc'Access1) -}
234c6eb1d6ecb6934923ffa372fdaaf9
  $tc'Direct1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Direct2) -}
a2af804004ab9dc97b5d8960ef3bf622
  $tc'Direct2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Direct"#) -}
3fb580946942f3dfee70cebab7a3ad4f
  $tc'Div :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4111605410602778145##
                   17781389164407384797##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Div1
                   1#
                   Language.Fortran.$tc'And1) -}
7a94c152de5a933c1a19c543ea2c01f1
  $tc'Div1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Div2) -}
62461a0cb69c253571d59b2bf1f44aae
  $tc'Div2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Div"#) -}
502700b3637c43f365074cb22eca368e
  $tc'DoWhile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7582459357999986985##
                   12865894526938492546##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DoWhile2
                   1#
                   Language.Fortran.$tc'DoWhile1) -}
57ec37ee2f52f4f9db4f7b9e8b4bef79
  $tc'DoWhile1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ba04cac768688e415812c9b6a1ec7c2c
  $tc'DoWhile2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DoWhile3) -}
ea2e49e1a3a8c09ce32e07640895cd1a
  $tc'DoWhile3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DoWhile"#) -}
473fe801e93be45a0ade7dbc6d9f8f29
  $tc'ESeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18326368173155731224##
                   505232363083887518##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ESeq1
                   1#
                   Language.Fortran.$tc'Bound1) -}
c1f2d3876e31b7367715a735507c64f8
  $tc'ESeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ESeq2) -}
2e8b173628d3c9c52615d4054202fff9
  $tc'ESeq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ESeq"#) -}
6cedc52aa67283ac7184fd00a90de1f0
  $tc'Elemental :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8632732502513078825##
                   17052459323660333905##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Elemental1
                   1#
                   Language.Fortran.$tc'Character1) -}
b62dfc39ba3f37734042d11c41033504
  $tc'Elemental1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Elemental2) -}
3a7461bdf3b724cc12c6df53dcd13095
  $tc'Elemental2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Elemental"#) -}
c35c9c410f1cb496e19c49a7466e9dc3
  $tc'End :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14474474006846866303##
                   2536940498323142434##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'End1
                   1#
                   Language.Fortran.$tc'Access1) -}
7df9ebddc4b921328cbbc1684004ecc3
  $tc'End1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'End2) -}
cb79699b31c41ef6c306afaa0a144e7d
  $tc'End2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'End"#) -}
139519b37f9c89205959edd07235a0f3
  $tc'Endfile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   915005947818720733##
                   17550862023883610074##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Endfile1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
a67388d93be0a6ccaab7e78e2285b455
  $tc'Endfile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Endfile2) -}
ecb66baedb949d202f1caf479bd13b61
  $tc'Endfile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Endfile"#) -}
a1b39bb463153739cd8a7a00c524e8d3
  $tc'Eor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6118266927738909927##
                   3157164112072818720##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Eor1
                   1#
                   Language.Fortran.$tc'Access1) -}
3f0d4fe60f3fb7cfd5a869b7da5e96d4
  $tc'Eor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Eor2) -}
db402a554546840ef27944c6ef9c55f6
  $tc'Eor2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Eor"#) -}
681e0e410f0726b247ef5f587ad4f974
  $tc'Equivalence :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15659971016753946731##
                   1578384924020113406##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Equivalence2
                   1#
                   Language.Fortran.$tc'Equivalence1) -}
53152c187f930dc80d32564ad99e1fbb
  $tc'Equivalence1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
63e0d3a12469f2671a3e91d3df7e9690
  $tc'Equivalence2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Equivalence3) -}
5189f89264ba48201bd93b92ae7cd01e
  $tc'Equivalence3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Equivalence"#) -}
dc2f9e49a22acdc0bcac39c203f03211
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14782886239657748262##
                   11810587505385705592##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Err1
                   1#
                   Language.Fortran.$tc'Access1) -}
5876bbcf8f9ddca930892c7f13224bd2
  $tc'Err1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Err2) -}
5028f18b00394d8ee86bc9e26de729e2
  $tc'Err2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Err"#) -}
57cb53a1358f38dba736007424376c8c
  $tc'ExFile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2288863202188999702##
                   7719497390283203345##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ExFile1
                   1#
                   Language.Fortran.$tc'Access1) -}
9f4917b866217f8530b0213b3fd65064
  $tc'ExFile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ExFile2) -}
8a8f7448890f12cddac1a1dea52021cc
  $tc'ExFile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ExFile"#) -}
531dba589497ac7c92662fe54e77c330
  $tc'Exist :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8541539175929007239##
                   7111154036931150529##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Exist1
                   1#
                   Language.Fortran.$tc'Access1) -}
4e6ed13aa0f6008333f52eb0b3d0178a
  $tc'Exist1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Exist2) -}
cb6cd2dd69d28417d3b4eb4d0e491b18
  $tc'Exist2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Exist"#) -}
b277251662c72e02247e73092e44c094
  $tc'Exit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11127613170364425945##
                   15364362884655817153##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Exit1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
19c3eac3b98e3ea32e874386490fb173
  $tc'Exit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Exit2) -}
b496f4710864d722b447593e13a27200
  $tc'Exit2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Exit"#) -}
d6a31bdf4196392573cac5e92156a2c9
  $tc'External :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12929083415913723155##
                   1491399689063069199##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'External1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
58c338f68275830eccaca6168c1b5bf3
  $tc'External1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'External2) -}
086b4fcc7df17e78a1ab05f959cec451
  $tc'External2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'External"#) -}
c2c7b2e3d33014d5fceb9d13488f9c46
  $tc'ExternalStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7672278947898358179##
                   1331723610664327161##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ExternalStmt2
                   1#
                   Language.Fortran.$tc'ExternalStmt1) -}
0b84cea416f77bac468c15e6e7a2e3e5
  $tc'ExternalStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d8dc995f60f7895df108c4b51ba52e2f
  $tc'ExternalStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ExternalStmt3) -}
c00843451e3cca1a3ace43716ce74073
  $tc'ExternalStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ExternalStmt"#) -}
2cc08e09eee6c70e1662119070f9ef64
  $tc'FMT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   632972381310670993##
                   14196053898532131310##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FMT1
                   1#
                   Language.Fortran.$tc'Access1) -}
1c99ddbe953684a93b22a1b0ebed93d5
  $tc'FMT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'FMT2) -}
5b27ffbf92a38c70e4133c7702756de0
  $tc'FMT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FMT"#) -}
957ecd1d89117ab4d82ba5812649e432
  $tc'FSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17891084014451777641##
                   814051546940160935##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FSeq2
                   1#
                   Language.Fortran.$tc'FSeq1) -}
909d2b7a7bad9d15f2b33c4d0590a941
  $tc'FSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b3924e3ad13ed1a7303001e166c6f0b6
  $tc'FSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'FSeq3) -}
17cbb3ec801184afacfcf6a7c26db7b1
  $tc'FSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FSeq"#) -}
e77cb2496f2828d68b280999d483f53e
  $tc'File :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17126233696170291216##
                   8939159096251435721##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'File1
                   1#
                   Language.Fortran.$tc'Access1) -}
2c45489bb90a2963af0519f70647f3ad
  $tc'File1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'File2) -}
5f2ba7ed39a73db900f5c9f32ad75724
  $tc'File2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'File"#) -}
fbc8ae44b9ac0434705b0a7a9ea29459
  $tc'Floating :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2238222118763257593##
                   16463319561055989641##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Floating2
                   1#
                   Language.Fortran.$tc'Floating1) -}
a285bb5520d944478d2432aba6b410d1
  $tc'Floating1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a6ed0b04db941912cb2fddb485d0a0c9
  $tc'Floating2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Floating3) -}
c6c49b600d9e8479a342e5f9709455f1
  $tc'Floating3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Floating"#) -}
e36ead1fa83e9c8f1491efb991285334
  $tc'For :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16159445376765729924##
                   10721701256510518454##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'For2
                   1#
                   Language.Fortran.$tc'For1) -}
f3906c03999340bce88cf9a750b3e9a5
  $tc'For1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8eb8f75700cb196c71180c47021a6d71
  $tc'For2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'For3) -}
c260e9a23604a8084336d9732572278c
  $tc'For3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'For"#) -}
0fd9a7a49833ae9dd2936547bad4d45d
  $tc'Forall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2782570702613886607##
                   9358590738133387719##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Forall2
                   1#
                   Language.Fortran.$tc'Forall1) -}
b1fe8264571bfdc9b5330e89637e2fe4
  $tc'Forall1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4daaecdbc754c45cca3fab1aee9547c8
  $tc'Forall2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Forall3) -}
ef0d4a429b81024d2eeddf2672252a36
  $tc'Forall3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Forall"#) -}
6ac12a4c720118a336a1825adafcd14d
  $tc'Form :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14231483304315265912##
                   16427470153903664640##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Form1
                   1#
                   Language.Fortran.$tc'Access1) -}
0107fd84f3e117529f027f27be742149
  $tc'Form1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Form2) -}
2946c8d0b18357382df1f800174bfc9e
  $tc'Form2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Form"#) -}
e31ca32ba3797812f8db10e353f66f1a
  $tc'Format :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16008349525951648690##
                   2009517476794418413##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Format1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
abf2ce4c77e609736ffa05d383e954ba
  $tc'Format1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Format2) -}
70ece6fba74cefc3886b363df9faf8ce
  $tc'Format2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Format"#) -}
6e1edb4d48953f51467bc4114cb617cb
  $tc'Formatted :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7820104043015878158##
                   4202695941699019303##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Formatted1
                   1#
                   Language.Fortran.$tc'Access1) -}
d9cd031f2c289386b791a817cfd5db70
  $tc'Formatted1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Formatted2) -}
9d0c8b5b4524a0811c74fca044c4741f
  $tc'Formatted2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Formatted"#) -}
0eef242d8a660442322e41fcfd0debba
  $tc'FractionConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14333271625386323485##
                   2654391022020247898##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FractionConst2
                   1#
                   Language.Fortran.$tc'FractionConst1) -}
c67b48c8b0ace63e94ec51e9cc6d3df3
  $tc'FractionConst1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
02e4cdfeaef83a25f2a6a0e0857ff7e9
  $tc'FractionConst2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'FractionConst3) -}
bf732696e258493c4c1c64221c745b8e
  $tc'FractionConst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FractionConst"#) -}
c4fb039e18ecb90e65f1759aa31ba585
  $tc'Function :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17428066210666457283##
                   1415984087642641686##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Function2
                   1#
                   Language.Fortran.$tc'Function1) -}
d49382c40d0856a78bfe3dee98df2ded
  $tc'Function1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7ac95a59db22920d668953f490728320
  $tc'Function2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Function3) -}
6a2ea9fb9bd997d210f25cc81df023da
  $tc'Function3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Function"#) -}
9d4860cffcfad477950da11f2ffd2709
  $tc'FunctionInterface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9760562965676218702##
                   13331669637220189000##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FunctionInterface2
                   1#
                   Language.Fortran.$tc'FunctionInterface1) -}
22b71b494b90d73a915a647275f4d7a8
  $tc'FunctionInterface1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
186bdfc2143a4134f2d0b9f4b7cb898b
  $tc'FunctionInterface2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'FunctionInterface3) -}
f3a8016c7733ee07cdcb2e931b11fc0f
  $tc'FunctionInterface3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FunctionInterface"#) -}
13b78c58948031cf8e605fe6d66648b7
  $tc'GAssg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10242485286810826645##
                   17291003052039797270##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GAssg2
                   1#
                   Language.Fortran.$tc'GAssg1) -}
92a2a7b2ea4e7b612b5e530cefdbe659
  $tc'GAssg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1134c86a93988bc4b0233437f0237d23
  $tc'GAssg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'GAssg3) -}
3949d53203e04bd6dc341ec36e23cdf8
  $tc'GAssg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GAssg"#) -}
849f132230d9a6bdbd69aeeb04962889
  $tc'GName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1188414196501652330##
                   2804056277092556217##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GName2
                   1#
                   Language.Fortran.$tc'GName1) -}
bed7e9bb91777521998f3b7d1abf6f44
  $tc'GName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
982cbc0324a01087f3fb0bce6868ccc2
  $tc'GName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'GName3) -}
feb03bf555939f083cd29e805458d0cf
  $tc'GName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GName"#) -}
b8fdafa56a414ff934f6c5effeaeb1e9
  $tc'GOper :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7077362207493651039##
                   15811227390998983245##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GOper2
                   1#
                   Language.Fortran.$tc'GOper1) -}
efc3472a6648f7421d6af0081b7b815e
  $tc'GOper1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f9f68112898369576e6f4436e37eb5b2
  $tc'GOper2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'GOper3) -}
7f6180048a9e7007329b1c4a5a9d0ac7
  $tc'GOper3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GOper"#) -}
ce328decfc01c3bb22e63c8d9d8984aa
  $tc'Goto :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18287247205061338020##
                   15199814717210698977##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Goto1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
c7cb7b47d3b9d8853ef0e98326b0b5dc
  $tc'Goto1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Goto2) -}
c84a47d112be338a8f7444e3fc53dfca
  $tc'Goto2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Goto"#) -}
9116417bd4e73afdd9f985f141d77871
  $tc'IOLength :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9660264594758914208##
                   16889967836756314275##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IOLength1
                   1#
                   Language.Fortran.$tc'Access1) -}
9846c2f2798f1ba9a71b4a5c531a211a
  $tc'IOLength1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'IOLength2) -}
5aa4cae645ea09ec3e8bc28a5792864c
  $tc'IOLength2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IOLength"#) -}
b7e0c2f27580f38135707b8b19524cd7
  $tc'IOStat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10164944896803169008##
                   10978296265988297679##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IOStat1
                   1#
                   Language.Fortran.$tc'Access1) -}
eac9b643c3ca80b94c1f13343c6e4c5e
  $tc'IOStat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'IOStat2) -}
030ecef5d1fcadbbfc16d4d21ac64055
  $tc'IOStat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IOStat"#) -}
c9c37bf3feb6d464af5d88f4adba659e
  $tc'If :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1503701106578214660##
                   12264239306839291217##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'If2
                   1#
                   Language.Fortran.$tc'If1) -}
f4fd4f16cd9c45b7358e40f14a30f452
  $tc'If1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fbadbd6b2dcdb63cfc47b488ed9082c7
  $tc'If2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'If3) -}
e6946523d9bca2cb92a8244009d2d36f
  $tc'If3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'If"#) -}
38cd99afa1cf7c2a692f42b030f02504
  $tc'ImplicitNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9472136552573724622##
                   3453093569053880877##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ImplicitNone2
                   1#
                   Language.Fortran.$tc'ImplicitNone1) -}
f18b36a77e1cb467e76840b592444dec
  $tc'ImplicitNone1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1da4c3eebce0017171ff8b3d6104b86f
  $tc'ImplicitNone2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ImplicitNone3) -}
7146f19c18788370b9ee001361ac0e99
  $tc'ImplicitNone3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ImplicitNone"#) -}
994ca5103b9048ba4e8337b8e0f952ea
  $tc'ImplicitNull :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4943059172184175224##
                   8457253058463524256##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ImplicitNull1
                   1#
                   Language.Fortran.$tc'ImplicitNone1) -}
1672b6a34b342a7837aec946dc1f6d24
  $tc'ImplicitNull1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ImplicitNull2) -}
83eb9aa3f06e90b37f0cd3a1a6205327
  $tc'ImplicitNull2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ImplicitNull"#) -}
87f17aa5857fc4a9da2ee811e6cb6fde
  $tc'In :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11175559947764629193##
                   4358892559849384786##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'In2
                   1#
                   Language.Fortran.$tc'In1) -}
619cc81786541d7794f416cec075b4e1
  $tc'In1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f882e38ac71d303bb4a383a8a3d5d689
  $tc'In2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'In3) -}
ae8ee96f894fb9e89c7aa428cc2a4995
  $tc'In3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'In"#) -}
391c86cd74f9ea9ad1828a47ee1ff0c2
  $tc'InOut :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16986077887498722363##
                   1626232206293342421##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'InOut1
                   1#
                   Language.Fortran.$tc'In1) -}
22eeae4782abf8f0963077125a593bda
  $tc'InOut1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'InOut2) -}
f2a5c00d9010892c137939104d75482d
  $tc'InOut2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'InOut"#) -}
3baba4e6575da8dc107a2e1491474ddf
  $tc'Include :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15369697305153526206##
                   13355334257676492152##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Include2
                   1#
                   Language.Fortran.$tc'Include1) -}
ff4b320856c24f278570ba03289788f1
  $tc'Include1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
050276db45e72f42373838710526c80e
  $tc'Include2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Include3) -}
a7f7ba3733036479c93d37972684e6aa
  $tc'Include3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Include"#) -}
9c127ec56da0a962dfa71aa3a5aa378a
  $tc'IncludeProg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14941268301037115755##
                   17309805146909708719##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IncludeProg2
                   1#
                   Language.Fortran.$tc'IncludeProg1) -}
7a18741ae5f322ff248af158a191fdc4
  $tc'IncludeProg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
89e2a55b6514496602ac1220f04e699b
  $tc'IncludeProg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'IncludeProg3) -}
050c32bf17840226a072cc6ad210d4c8
  $tc'IncludeProg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IncludeProg"#) -}
848adb0a8bcd6f2d8ac2ef874dec4438
  $tc'Inquire :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17893264830422601572##
                   11127073009094168275##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Inquire2
                   1#
                   Language.Fortran.$tc'Inquire1) -}
8b03999bb95b762297c7493bab1d5868
  $tc'Inquire1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ade2ef6c0e926c7e335615a1299e34ec
  $tc'Inquire2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Inquire3) -}
4772108392f6dc9cd6631587aa27a135
  $tc'Inquire3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Inquire"#) -}
d144d18a419c6a742e6267f536802d0c
  $tc'Integer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8259942839732825793##
                   9255321748674856131##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Integer1
                   1#
                   Language.Fortran.$tc'Character1) -}
6281537cbdda97129e4977afc6737bc7
  $tc'Integer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Integer2) -}
e725ef607122b2be6bd8d7220d59acec
  $tc'Integer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Integer"#) -}
781118c2f3f3b2171e9f67b5f3490fca
  $tc'IntegerConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18199993229131260252##
                   3302812133013202748##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IntegerConst2
                   1#
                   Language.Fortran.$tc'IntegerConst1) -}
ab3b58d417436c029bd7ff683ce26532
  $tc'IntegerConst1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d4df72669d2699a0aaa6d54bc01328b6
  $tc'IntegerConst2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'IntegerConst3) -}
5feb96232f718f7c94868f7874aafbd9
  $tc'IntegerConst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IntegerConst"#) -}
98bebca65ab403b3fbd352b1ea220070
  $tc'Intent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8457668679615015172##
                   15414035429753587981##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Intent2
                   1#
                   Language.Fortran.$tc'Intent1) -}
3a17f5ed5f05a7397cee30dbda0bf8ba
  $tc'Intent1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b6ce825ab750db95fa0bf155ca64926d
  $tc'Intent2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Intent3) -}
96e8227f89b99ab3f5b673a4b9e48356
  $tc'Intent3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Intent"#) -}
0bba7a4d338fdaca71cb3fb6fc190c67
  $tc'Interface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14468256371779663067##
                   17347541874319073939##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Interface2
                   1#
                   Language.Fortran.$tc'Interface1) -}
5c716f96843802e6a15a0e984a4f123e
  $tc'Interface1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
38b70a719f9fbf65ab1d2fbe500250a5
  $tc'Interface2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Interface3) -}
e7750642d91b2843678ae565dd320b44
  $tc'Interface3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Interface"#) -}
aa781f212ee88f524ef901f3b6e6940a
  $tc'Intrinsic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5816248770524037825##
                   16968764775024697130##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Intrinsic1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
c103fec617114835e5d6f6aaacf9f9be
  $tc'Intrinsic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Intrinsic2) -}
dc44d966e56a6bcbd8bfeb00dea38dce
  $tc'Intrinsic2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Intrinsic"#) -}
c726ab35b64acec961d764a752b36300
  $tc'Label :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   478564379734627003##
                   8796833194248266065##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Label2
                   1#
                   Language.Fortran.$tc'Label1) -}
324adeeef8516334bb671ff0eaf06bfa
  $tc'Label1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
51201744840169478e9fe944d1d0ce5f
  $tc'Label2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Label3) -}
bc9945d70be1ebc82245179a53b54947
  $tc'Label3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Label"#) -}
24f01b43834ad9dd737e7727c4e1816d
  $tc'Logical :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7050616448520019106##
                   8471194427265652165##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Logical1
                   1#
                   Language.Fortran.$tc'Character1) -}
85cee501fd91514f725b132fe1e8b412
  $tc'Logical1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Logical2) -}
7ee7640c23a993706d0bc2ce721e5757
  $tc'Logical2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Logical"#) -}
fec424d9fbff0a0b50e4c3b00baffb50
  $tc'Main :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16097998149823148175##
                   5820559211587432208##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Main2
                   1#
                   Language.Fortran.$tc'Main1) -}
e4a52764c03140f50a2f7e799dcbce42
  $tc'Main1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
78df458718c33bb372facc330006b743
  $tc'Main2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Main3) -}
e1a24ed234b3365e444a5b9193ba0915
  $tc'Main3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Main"#) -}
7678d331b29ad92ecc016619f70d31ed
  $tc'MeasureUnit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15016986920153233932##
                   1077359641554033800##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'MeasureUnit2
                   1#
                   Language.Fortran.$tc'MeasureUnit1) -}
4374e5e97deb1c9672e4ed097fa5d3c9
  $tc'MeasureUnit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ea05eec89a4658139a81c4229eacf37d
  $tc'MeasureUnit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'MeasureUnit3) -}
08f4664891769f84dac4b36dc491ecc4
  $tc'MeasureUnit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'MeasureUnit"#) -}
ab3f653f252df2f2828512fa0fb9fd22
  $tc'MeasureUnitDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4305212976064404519##
                   17360587647546237375##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'MeasureUnitDef2
                   1#
                   Language.Fortran.$tc'MeasureUnitDef1) -}
617f09929c4cef3441c3ee47347b85cc
  $tc'MeasureUnitDef1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
57f4dc8a3101db66b999b0108ba30e65
  $tc'MeasureUnitDef2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'MeasureUnitDef3) -}
49e0072bb326c44cc7761bd556d949b2
  $tc'MeasureUnitDef3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'MeasureUnitDef"#) -}
4b58ec68cc38205264945ae184a375e3
  $tc'Minus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14113371743275178384##
                   2966150319484690592##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Minus1
                   1#
                   Language.Fortran.$tc'And1) -}
5b2dbf20884daa22de3a60d35be65d66
  $tc'Minus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Minus2) -}
6064273f4a78a825c066a8cdca543ebf
  $tc'Minus2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Minus"#) -}
f302936ecda819ade39a84bcd9db1795
  $tc'Module :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11357085809620460087##
                   14634606787274600470##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Module2
                   1#
                   Language.Fortran.$tc'Module1) -}
75d4a3f077ea19df49a911d4f00551c2
  $tc'Module1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5d7053a98e3b418149c063433da5637f
  $tc'Module2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Module3) -}
eeceec4872eca0ed25a79025bf76e931
  $tc'Module3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Module"#) -}
c513e4eed673f6df4a27fea285f0d62c
  $tc'ModuleProcedure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2075412336871987838##
                   928079530603022053##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ModuleProcedure2
                   1#
                   Language.Fortran.$tc'ModuleProcedure1) -}
0ed031a7c98fac9f7d8a7301e5583d6f
  $tc'ModuleProcedure1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a4df338df4b78f0679163eeaf7a753d1
  $tc'ModuleProcedure2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ModuleProcedure3) -}
3592b041c9611207a94583df9f87cf88
  $tc'ModuleProcedure3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ModuleProcedure"#) -}
2f0492af2aca1897e3c1d11255e44504
  $tc'Mul :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2038370064888665257##
                   2020466240250612338##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Mul1
                   1#
                   Language.Fortran.$tc'And1) -}
069e1e9f8ab0212bb1175808ecce12bd
  $tc'Mul1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Mul2) -}
3fb7f57a45192885cd7d500acf8f1141
  $tc'Mul2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Mul"#) -}
d2ddd9abfe9d912bd52c61eb7eedd5bf
  $tc'NML :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5830202244699042873##
                   8123056590607863021##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NML1
                   1#
                   Language.Fortran.$tc'Access1) -}
84a25e094e5b0d8e99fe5da3f99b006d
  $tc'NML1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NML2) -}
5c7f9aac45bcc2cd85223b96b8b38180
  $tc'NML2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NML"#) -}
f98848475d3f76f06b64ba1bce18c3ea
  $tc'Name :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13021857320997253934##
                   9885514555127517181##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Name1
                   1#
                   Language.Fortran.$tc'Access1) -}
afd5bf0be178fa36cde50d9fbe65029c
  $tc'Name1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Name2) -}
8f5fd4efc37537a454c580b4c00c1815
  $tc'Name2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Name"#) -}
6f9642f9025d7ac5c475286a7a7b1a6d
  $tc'Named :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4924292453854336540##
                   17732297062136202412##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Named1
                   1#
                   Language.Fortran.$tc'Access1) -}
f245d191332d1596a41fc6de08542d38
  $tc'Named1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Named2) -}
e9aa75d22f4cfd39b0c15f21560ec5d0
  $tc'Named2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Named"#) -}
c8972d5fa16a7def0fd1e0207cf4c83d
  $tc'Namelist :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11021396866477863017##
                   14597245604283955967##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Namelist2
                   1#
                   Language.Fortran.$tc'Namelist1) -}
0e425e4d3322e14ecb65a0fe3ae48b4c
  $tc'Namelist1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
dfb83f92dc8262fab6e800a9134874f9
  $tc'Namelist2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Namelist3) -}
68e5d275e4e300c178e7aa4f9bc14528
  $tc'Namelist3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Namelist"#) -}
b31d1b16fa75d24765c5d217c600f315
  $tc'NextRec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   884523089310641941##
                   13664741291330946321##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NextRec1
                   1#
                   Language.Fortran.$tc'Access1) -}
20063d3a25bf28ae58f6cb7963baea75
  $tc'NextRec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NextRec2) -}
d035a77a761c17d04986e2f556381864
  $tc'NextRec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NextRec"#) -}
6b581116d5a9a0d1a29ddc9cb78439db
  $tc'NoSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10482646857812316943##
                   3709728957303162097##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NoSpec1
                   1#
                   Language.Fortran.$tc'Access1) -}
1bd451faee90308453f64d708059920c
  $tc'NoSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NoSpec2) -}
aec786d1155afe5664a3a3c9d3e60803
  $tc'NoSpec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NoSpec"#) -}
41effe452477d6e0680f31144ba35357
  $tc'Not :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9971301355323326205##
                   15377824919848234608##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Not2
                   1#
                   Language.Fortran.$tc'Not1) -}
b47f84d055352eca7e1eed21297b2c6c
  $tc'Not1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cd04934ec6103682ac10c096f8bbc3bb
  $tc'Not2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Not3) -}
7d84b9a551bff7694439ed0cf31b056f
  $tc'Not3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Not"#) -}
242b1357d6f4bfaec5979195ed7657fe
  $tc'Null :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1572211049736181912##
                   12221683188862725509##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Null2
                   1#
                   Language.Fortran.$tc'Null1) -}
31ed48c42fd3401d7dd765345e775d3f
  $tc'Null1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a784d868c71da8c2144a88689bcd9f53
  $tc'Null2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Null3) -}
920430fe051a2ccf47b3b2631cfe6a32
  $tc'Null3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Null"#) -}
541ec2f2f0bd544354f7683bc08dc60e
  $tc'NullArg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5720583667333492965##
                   13449825523253744191##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullArg2
                   1#
                   Language.Fortran.$tc'NullArg1) -}
b9ed21c85f935a0c7eeced5cbf9459ea
  $tc'NullArg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
693df6f2a92947fa08acbedcff653686
  $tc'NullArg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullArg3) -}
f6fc4ef81b8bdde4a137fda707718c3b
  $tc'NullArg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullArg"#) -}
142ba12e21a635ef5089883fb8a41fa2
  $tc'NullDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11861795481132500433##
                   17138992469592466749##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullDecl2
                   1#
                   Language.Fortran.$tc'NullDecl1) -}
d756e66858510dfd6deb474ca9566faf
  $tc'NullDecl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cdd445f6d857c4043071d1f021628687
  $tc'NullDecl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullDecl3) -}
2e78cde0ed6a25fe539465a26c3d8e17
  $tc'NullDecl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullDecl"#) -}
71642c2c64f35fc7da95ec68f2bd0c7c
  $tc'NullExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14983510827122780776##
                   16022844510050123920##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullExpr1
                   1#
                   Language.Fortran.$tc'Null1) -}
b6e9f7da23bba55c3eb4278b07a832fd
  $tc'NullExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullExpr2) -}
0daa30363355b118b0cebbd3b1afa613
  $tc'NullExpr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullExpr"#) -}
cf966143aa8f7953178f7485dbe21346
  $tc'NullFraction :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7249750864002852639##
                   3813412565119869610##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullFraction2
                   1#
                   Language.Fortran.$tc'NullFraction1) -}
f5b8b92a4481d48e5ea62df6cf815f01
  $tc'NullFraction1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
dbfc1d467911ae178915a53a956e7ed3
  $tc'NullFraction2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'NullFraction3) -}
e1475d6cf87e70ad35a0e3b4df834d2b
  $tc'NullFraction3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullFraction"#) -}
e6dafe1a2d562d90c3aece3b6f717e6a
  $tc'NullProg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   113361837446044569##
                   14017843197873787123##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullProg2
                   1#
                   Language.Fortran.$tc'NullProg1) -}
e33060181b78bde69ae70275eeddd869
  $tc'NullProg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3ed75781e09a591759f543b433d9b307
  $tc'NullProg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullProg3) -}
15fb338e2f5a9eef22f2b2f98f1c4763
  $tc'NullProg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullProg"#) -}
31e9edc01c08ffea95ae2840ce6f07fb
  $tc'NullStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5362473547408699545##
                   6220311462614101265##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullStmt1
                   1#
                   Language.Fortran.$tc'Continue1) -}
39a2b9053a7b8a2ba1120e748eeb6ded
  $tc'NullStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullStmt2) -}
c494b3cf548d11ffad4a8ec5a0bc9027
  $tc'NullStmt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullStmt"#) -}
42d1e771fb14c416b54f662cfd59151d
  $tc'NullSubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10964241437959559676##
                   16975426328904730405##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullSubName2
                   1#
                   Language.Fortran.$tc'NullSubName1) -}
bb0b9514cf97969c13bfa43358d21733
  $tc'NullSubName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bfbfdb7a3124432f21513198d703e4c1
  $tc'NullSubName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullSubName3) -}
628acf0b9162b10e5bbd0192b1681170
  $tc'NullSubName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullSubName"#) -}
2ca55d34e863a8fc643b920ca8e63b17
  $tc'Nullify :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9616619553124956725##
                   17027806653584218607##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Nullify2
                   1#
                   Language.Fortran.$tc'Nullify1) -}
a6c16a8980a94e178bebb9b58ce73637
  $tc'Nullify1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
13fc1987c3a42fe3e4cd276c51447f38
  $tc'Nullify2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Nullify3) -}
f1ee5a971a19865076816d80fa0aea7f
  $tc'Nullify3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Nullify"#) -}
1c41a90c7d5bca4d317cf2dc16675b2b
  $tc'Number :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2891125449500802254##
                   12158440786394886601##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Number1
                   1#
                   Language.Fortran.$tc'Access1) -}
ee010d11cae41a59bea3fe00e6762351
  $tc'Number1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Number2) -}
32709386db5f87bde76e820a1a59e5aa
  $tc'Number2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Number"#) -}
21dac37e4921da45dce9ad9e6077bdde
  $tc'Open :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8603998176487157136##
                   17501866861428072066##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Open1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
bc4ffd533d534ddc16e952c73bdddd5a
  $tc'Open1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Open2) -}
435686d18eb4bd41e170639bfacb2881
  $tc'Open2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Open"#) -}
6aeea86095a875df92af86f5a64c22d3
  $tc'OpenCLBufferRead :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15463165677726051202##
                   6409701655821550517##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLBufferRead2
                   1#
                   Language.Fortran.$tc'OpenCLBufferRead1) -}
c2809d0faba19a4eadb802fef136077c
  $tc'OpenCLBufferRead1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a24f8d077b9c6c38b94a941905055c6c
  $tc'OpenCLBufferRead2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'OpenCLBufferRead3) -}
3c5baeb657cf8d38e58dc3719641d6aa
  $tc'OpenCLBufferRead3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLBufferRead"#) -}
96d00f01fa833f9e5652a3fd2271362e
  $tc'OpenCLBufferWrite :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9856923472332097978##
                   14903622286997682927##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLBufferWrite1
                   1#
                   Language.Fortran.$tc'OpenCLBufferRead1) -}
09aadc6002370412b89a09e5d6c2ad4d
  $tc'OpenCLBufferWrite1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'OpenCLBufferWrite2) -}
457031b97a2897471a6ecfeaa28ad92f
  $tc'OpenCLBufferWrite2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLBufferWrite"#) -}
ca002f184479520a2f17cbf5fae93636
  $tc'OpenCLMap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7715168690598125139##
                   4905507852293665780##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLMap2
                   1#
                   Language.Fortran.$tc'OpenCLMap1) -}
71c46178768d0c1f5bb78b193942eaf3
  $tc'OpenCLMap1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0e1195d0db4bab73b23902942435cab6
  $tc'OpenCLMap2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'OpenCLMap3) -}
84da2725bb36330b77d919ab00f0efc1
  $tc'OpenCLMap3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLMap"#) -}
fed1b7bdee79279b40dcd6e6e1e96714
  $tc'OpenCLReduce :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11811921943467940804##
                   15057003964141684336##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLReduce2
                   1#
                   Language.Fortran.$tc'OpenCLReduce1) -}
e7be94fbd569e44259cd1558a865ed65
  $tc'OpenCLReduce1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
22c1003b96c01d1da91884c185664144
  $tc'OpenCLReduce2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'OpenCLReduce3) -}
7c567b5f618aa30d45826177296df4e2
  $tc'OpenCLReduce3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLReduce"#) -}
f9b71fdfcad8e57d0920b1fb38822858
  $tc'OpenCLSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7504390140950803805##
                   13055362620249418896##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLSeq2
                   1#
                   Language.Fortran.$tc'OpenCLSeq1) -}
a65464b995ab09aac1a28b78f2ca692e
  $tc'OpenCLSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
30dd6c491319e3964c6fbc57dbf9216b
  $tc'OpenCLSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'OpenCLSeq3) -}
7b5f34e6f12e30660d0c668f1fd777b2
  $tc'OpenCLSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLSeq"#) -}
3f702dbc42541158cd12d5ac3d7669c5
  $tc'Opened :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17933420709633128661##
                   10770003255441802903##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Opened1
                   1#
                   Language.Fortran.$tc'Access1) -}
42708aebb682d48dbf6582bb5fe0e385
  $tc'Opened1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Opened2) -}
e7ba31a1d4696611c1f7b6904ba3dc17
  $tc'Opened2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Opened"#) -}
4e853b80ee1448f92340244c2e7a5661
  $tc'Optional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4971137100962061449##
                   11993125587778601134##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Optional1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
2a063950a7ba8e22760ba07b230a8acd
  $tc'Optional1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Optional2) -}
d37aa1c2c447f63c5219006f4c44602c
  $tc'Optional2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Optional"#) -}
47c524a9234cb79d0f53d7d24985c6d2
  $tc'Or :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18101075245730580582##
                   10043693520350585372##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Or1
                   1#
                   Language.Fortran.$tc'And1) -}
4f39a32e22f469bfc7255f86ceeb6b53
  $tc'Or1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Or2) -}
e643fd14618ee99c2a882609eb99d7ba
  $tc'Or2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Or"#) -}
10b3da88b46c28ff3830afd3e0dd65a1
  $tc'Out :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17131769019528217881##
                   6822417422073771737##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Out1
                   1#
                   Language.Fortran.$tc'In1) -}
12b0c25c7fb59ab4a1383dfc92cafb04
  $tc'Out1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Out2) -}
8204da8846c411d2ae114b510a151038
  $tc'Out2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Out"#) -}
fee4a72649c861fe063dacb41562ba6e
  $tc'PSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15229612023861146026##
                   17152985949065729652##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'PSeq2
                   1#
                   Language.Fortran.$tc'PSeq1) -}
5d4ec3ea1c5548c255584d641cc85b38
  $tc'PSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
33c7568494dc9a926571fc5102bad30c
  $tc'PSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'PSeq3) -}
12aa9bb8878eda21b149643d46b68ad9
  $tc'PSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PSeq"#) -}
efd2cf2af7beac88493f26f574d4145d
  $tc'Pad :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10604404734575640606##
                   6563164295150565432##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pad1
                   1#
                   Language.Fortran.$tc'Access1) -}
1da8119e4c9b7ba88fb4deafd3081be7
  $tc'Pad1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pad2) -}
bb797e3836d9d63f249b8fa74fd3516c
  $tc'Pad2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pad"#) -}
39af1fe56a35a8580175bdf53ffb5d8a
  $tc'Parameter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12962135868885182074##
                   9794826010302011204##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Parameter1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
697c3c132adb57be3275a81236639360
  $tc'Parameter1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Parameter2) -}
f1d81ba70ea9b30b4b492641b5bfabbc
  $tc'Parameter2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Parameter"#) -}
5509fae10a025da066393988dde5fd2c
  $tc'Pause :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11937112287569321782##
                   14910638325118055646##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pause1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
198e3ca3b3a8fdd75c4e786b53135fa4
  $tc'Pause1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pause2) -}
f381ac75b45b3a5adb1c994ccddcb5d6
  $tc'Pause2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pause"#) -}
bf145893b11d02c5db7fe4fe37852cd1
  $tc'Plus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15560008095108179882##
                   9335563894339597494##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Plus1
                   1#
                   Language.Fortran.$tc'And1) -}
06112ee4ab3b3fb62bef4abbd6806dd2
  $tc'Plus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Plus2) -}
9b9fba554cb0608af6b232a085cf87c7
  $tc'Plus2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Plus"#) -}
d95a514079775d716c35bb5a10f79f26
  $tc'Pointer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   565152426773251112##
                   11115774514754499156##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pointer1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
3d8b903892c01b84a156dfa6811f2a06
  $tc'Pointer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pointer2) -}
cabf4b006359ec43fb2e97252a6a338f
  $tc'Pointer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pointer"#) -}
63102a30e774b283c62f1e5fc4ab6eda
  $tc'PointerAssg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17150938524558393344##
                   18007440076243492673##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'PointerAssg1
                   1#
                   Language.Fortran.$tc'Allocate1) -}
58e458e6d569571a3428706192c8ffcb
  $tc'PointerAssg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'PointerAssg2) -}
1772b92e7b02b54c43c664ce16f555a1
  $tc'PointerAssg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PointerAssg"#) -}
bfd2f4fc70c3796a3cef3278e08cbdf3
  $tc'Position :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6055907235933460619##
                   233059503554298823##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Position1
                   1#
                   Language.Fortran.$tc'Access1) -}
ae927c1913af4d2ad50210c15f0b74cc
  $tc'Position1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Position2) -}
5ff699a6453b4416910de5a361e67a55
  $tc'Position2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Position"#) -}
39c4a195f9f99d4ec62dd5d274988574
  $tc'Power :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7772408661200156707##
                   1649097711200380290##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Power1
                   1#
                   Language.Fortran.$tc'And1) -}
4d790f6ce290c76c41a9b96737385a91
  $tc'Power1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Power2) -}
06e0542cd37808e2340aee40c4b818a0
  $tc'Power2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Power"#) -}
b66dde9ecb3d8d6d05ff3c582d14e731
  $tc'Print :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3056071710072415325##
                   16776876238929285419##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Print2
                   1#
                   Language.Fortran.$tc'Print1) -}
65a4a2a914c98cc956297ed18dd310ec
  $tc'Print1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a0541251bcac8b5569fe40e75cf95a53
  $tc'Print2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Print3) -}
abdfc74bcf85af8c2086dad31ce89727
  $tc'Print3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Print"#) -}
653d7f173f09fca62d905b7ac2dca351
  $tc'Private :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3703614099383826844##
                   17296934331692962277##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Private1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
47049ac4110c6d906256480f69f68251
  $tc'Private1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Private2) -}
f700d4a0947ef41eb1957e62cf795da9
  $tc'Private2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Private"#) -}
671825345a36005dc0adaa07797b986a
  $tc'Prog :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3623552912122716135##
                   13101790010425892280##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Prog2
                   1#
                   Language.Fortran.$tc'Prog1) -}
d886905f223bd4d048c16a52c9886ce7
  $tc'Prog1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e27928fe2b95b65d5976f243b2c2a893
  $tc'Prog2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Prog3) -}
0b9ff1712ffaa9ae2f331d5c46319840
  $tc'Prog3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Prog"#) -}
8a44eebe8d4119f31159e7de9b183187
  $tc'Public :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12668167594138879358##
                   14166681619779425408##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Public1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
85076bd83707888e28936900b929eda1
  $tc'Public1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Public2) -}
5e21eb80af36e9727ee15c4a35a3133b
  $tc'Public2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Public"#) -}
b4c9f6e2e0eb783d7d2a4e97ab8cc4e0
  $tc'Pure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4856394807234383367##
                   7675780921664732116##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pure1
                   1#
                   Language.Fortran.$tc'Character1) -}
5da0fc51e026e4785a7e7f238df35cd4
  $tc'Pure1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pure2) -}
97b6902c43b134dbcf049585ec6ccc73
  $tc'Pure2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pure"#) -}
dd5ec68a79598af23723b984e418e68f
  $tc'Read :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15923705582411201746##
                   7833856632237309376##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Read1
                   1#
                   Language.Fortran.$tc'Access1) -}
670f1922483926ccc2647288c70e1fd6
  $tc'Read1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Read2) -}
322edfc194ace23eec7cf09bd2362999
  $tc'Read2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Read"#) -}
757ce14c01d68fbeeea003a8aebd2e2a
  $tc'ReadS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14300530302305912817##
                   1704815471662770278##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ReadS1
                   1#
                   Language.Fortran.$tc'Inquire1) -}
c82e52d9e0356282d9c4ddc35adefd29
  $tc'ReadS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ReadS2) -}
c0b05b809e9e5b8dbcfe9dd2df69b8b8
  $tc'ReadS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ReadS"#) -}
dde015586a00a7c0a3cd5b5b198931d9
  $tc'ReadWrite :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9439199972593900313##
                   2397563842896655391##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ReadWrite1
                   1#
                   Language.Fortran.$tc'Access1) -}
804ab034b7aca88f13473649492d24a8
  $tc'ReadWrite1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ReadWrite2) -}
0ed1c35cf499326716552e8582e96aee
  $tc'ReadWrite2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ReadWrite"#) -}
6686d5e81774f7afbbbba6c18b9c158e
  $tc'Real :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5539475473592569734##
                   7134485829731127780##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Real1
                   1#
                   Language.Fortran.$tc'Character1) -}
2fefe985da5dcd5ce529985878037738
  $tc'Real1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Real2) -}
6413a7f24f937d86e921726dc842e2bf
  $tc'Real2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Real"#) -}
86c0f9d85b9a5ddad54dfdac641c6a79
  $tc'Rec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7552063585152631958##
                   6810369327294020774##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Rec1
                   1#
                   Language.Fortran.$tc'Access1) -}
f82373a0c6aefa891a499b3df6ca2ce7
  $tc'Rec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Rec2) -}
50ee84c748f8d3265ece33a0a75b10c7
  $tc'Rec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rec"#) -}
7bf86d671c66cb706d26c1dafb23ddc4
  $tc'Recl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3314133702972807426##
                   5277843578931075673##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Recl1
                   1#
                   Language.Fortran.$tc'Access1) -}
ed7582948d3708b39fd87349a79e42f9
  $tc'Recl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Recl2) -}
497bae6331a1b70c84b92cc41423934d
  $tc'Recl2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Recl"#) -}
e3360fde5534cf0af751853b57d79efd
  $tc'Recursive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1845959869431617798##
                   16845465404741941906##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Recursive1
                   1#
                   Language.Fortran.$tc'Character1) -}
53777f07b279ad39b5273beb2913e7cb
  $tc'Recursive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Recursive2) -}
de7c4fccbae9bb8c0a4b496c062e4be0
  $tc'Recursive2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Recursive"#) -}
e81e22e5ac2c0f772003629d557520c6
  $tc'RelEQ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14248682003262268276##
                   11725485734831057220##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelEQ1
                   1#
                   Language.Fortran.$tc'And1) -}
2d1dd68f3a9dbc7630f8c17414b4ad5a
  $tc'RelEQ1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelEQ2) -}
06d32f9f3e664970ca46220333b29de2
  $tc'RelEQ2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelEQ"#) -}
e90783794dc20d293daf96d4f105110f
  $tc'RelGE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13574648283946276498##
                   12608796428108682338##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelGE1
                   1#
                   Language.Fortran.$tc'And1) -}
556044a7a582a742c46ae4fb4916eea4
  $tc'RelGE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelGE2) -}
62493bba9e56eb928a507777affe157f
  $tc'RelGE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelGE"#) -}
4b69f08b5e6c1f26113e4f9c60cae8a6
  $tc'RelGT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10987597993052815301##
                   8427892320218242694##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelGT1
                   1#
                   Language.Fortran.$tc'And1) -}
69184e8903138c05c3c88c9e0bf08e56
  $tc'RelGT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelGT2) -}
635584a45de50996597d8b4668b9f0c8
  $tc'RelGT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelGT"#) -}
4764da88f2f466147903c531f4d22222
  $tc'RelLE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3767405372793603494##
                   6601489045289885284##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelLE1
                   1#
                   Language.Fortran.$tc'And1) -}
226c368ead57dcf67d24b4e857370237
  $tc'RelLE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelLE2) -}
ced20bf62ef9cb3f5f3c025e2f319849
  $tc'RelLE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelLE"#) -}
0f5eb18e22f663fdfbab9251acab08a4
  $tc'RelLT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6809575119391277436##
                   11637895360744003166##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelLT1
                   1#
                   Language.Fortran.$tc'And1) -}
933a2a02c1e10b51b33ba7bfa5b99f6d
  $tc'RelLT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelLT2) -}
a11860ae1c34360d0d28cd09fb5e23fc
  $tc'RelLT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelLT"#) -}
a84114ba74745ae62a9e5f643827b2f7
  $tc'RelNE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1816065717619496456##
                   7023845515240470107##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelNE1
                   1#
                   Language.Fortran.$tc'And1) -}
9085f02065cc90c2473686086d13919c
  $tc'RelNE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelNE2) -}
1b5284aa7ee7b0d8e41deb5e1ca6baf7
  $tc'RelNE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelNE"#) -}
8484dcc7050ba23546a2a5bb5747a582
  $tc'Return :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9635946528474366263##
                   9790568047254074845##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Return2
                   1#
                   Language.Fortran.$tc'Return1) -}
7d6a1516d00072ceb3b0f6b1cd7525b9
  $tc'Return1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4cb79ea9d7bd53efcad074c738774a6c
  $tc'Return2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Return3) -}
5196d0feb56bbc1bbf4994cef9527054
  $tc'Return3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Return"#) -}
381bcc8879e756abcd356a74357f1d26
  $tc'Rewind :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8874162170058376603##
                   2812965978761094766##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Rewind1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
202ff566ef4028c71e216de3d7bf5a7a
  $tc'Rewind1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Rewind2) -}
2dca4c3c145ee157ac9de0b098fb294e
  $tc'Rewind2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rewind"#) -}
c3aba56a310c370e8bfe85de40a87bad
  $tc'Save :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8279191042395692378##
                   2639023612008317405##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Save1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
1c685aab1948c7036895fcb34f5cb369
  $tc'Save1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Save2) -}
75c34bf24ac8dbda66c331fdb7dc49d2
  $tc'Save2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Save"#) -}
9cf53082585cd085b548b9aef3242f50
  $tc'SelectStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13619126015527806526##
                   6215651766066752406##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SelectStmt2
                   1#
                   Language.Fortran.$tc'SelectStmt1) -}
0401f043854534c99eac80659997b65e
  $tc'SelectStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
41aac6cff0a073508ef9f09e8fff5801
  $tc'SelectStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SelectStmt3) -}
44d5c46d36e3175c0ae14ef31596b97d
  $tc'SelectStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SelectStmt"#) -}
1ac0f351b1afa3ce2648b0cf14b78455
  $tc'Sequence :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14484260177596635821##
                   5867960762244524443##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sequence1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
248e0696150d409128fe94ba8134ecb5
  $tc'Sequence1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sequence2) -}
6869882d285247fdb564adedb1c9e9ee
  $tc'Sequence2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sequence"#) -}
3a9c6ff724fd2147c9a8817f9fab1374
  $tc'Sequential :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17309757458066018442##
                   11509638640297797591##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sequential1
                   1#
                   Language.Fortran.$tc'Access1) -}
fe8cffa01f20f55f75f098fc58d4f2c0
  $tc'Sequential1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sequential2) -}
810f465d53e2f28749f1a3e2b1356925
  $tc'Sequential2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sequential"#) -}
c685c5ff41ef5defc30e7a36ce3ee18b
  $tc'Size :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2811175570982422602##
                   15146569757791444189##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Size1
                   1#
                   Language.Fortran.$tc'Access1) -}
93c7e441f0c775c38d4ceeae5aa9d4fe
  $tc'Size1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Size2) -}
315a893d3573fa8769c2c0fb2f2347a3
  $tc'Size2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Size"#) -}
cc7920e4549445dad05b4423457dc443
  $tc'SomeType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2594617454112775499##
                   5859425442762858508##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SomeType1
                   1#
                   Language.Fortran.$tc'Character1) -}
6a4e971a0744bfa644b6ed5adfcc6610
  $tc'SomeType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SomeType2) -}
f039339026af6978eded6b5e4fae2e59
  $tc'SomeType2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SomeType"#) -}
95ea08d63152fb975a0545bd88d0c901
  $tc'Sqrt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12252625989427299571##
                   12939086087547026314##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sqrt2
                   1#
                   Language.Fortran.$tc'Sqrt1) -}
04ec93c98907fb347270444ef3d85b19
  $tc'Sqrt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2543f59c5b2ba4aa025060c094426f0a
  $tc'Sqrt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sqrt3) -}
cb8d5a934aac4e48d3b8eab19bec67cc
  $tc'Sqrt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sqrt"#) -}
1929c7c2376828c39e7861416efae276
  $tc'SrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7322528328155857647##
                   14841076657241533024##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SrcLoc2
                   0#
                   Language.Fortran.$tc'SrcLoc1) -}
334d76db2915341b6530b477be4c8e02
  $tc'SrcLoc1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4ae2abd921ba2c6a005988de35dd00b0
  $tc'SrcLoc2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SrcLoc3) -}
1b0f15ed6d8fd5e6e69709d686231dfc
  $tc'SrcLoc3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SrcLoc"#) -}
11a35d496e012eefe3255328a227cf9c
  $tc'Status :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6752437595661367227##
                   9586578797786112954##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Status1
                   1#
                   Language.Fortran.$tc'Access1) -}
d8624c1ffabde3fe35309dc8dfed40ff
  $tc'Status1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Status2) -}
3669f1c6572101bb4f9aa231b419d7b4
  $tc'Status2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Status"#) -}
fe990b844c573c8fe5610bccb35f7228
  $tc'Stop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16183680300539594599##
                   1443909933207732104##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Stop1
                   1#
                   Language.Fortran.$tc'Return1) -}
c376266de0444969fbdf245d091e8cb7
  $tc'Stop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Stop2) -}
bc6938e881b67f5428479580d0ca4363
  $tc'Stop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Stop"#) -}
706eb61083df3e74ff8c9b62970cdb55
  $tc'StringLit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15033230774608170859##
                   15692163922042415171##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'StringLit2
                   1#
                   Language.Fortran.$tc'StringLit1) -}
cb3230276c6d5a1ed327307f2f441ade
  $tc'StringLit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
36931749be5409a21ee9f010c0f8ad23
  $tc'StringLit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'StringLit3) -}
aba99d7d721266c9e9371b7f379be790
  $tc'StringLit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringLit"#) -}
f523039639e455196a89ea0ce0fc5d82
  $tc'Sub :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1228473709586813028##
                   17691146471727562543##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sub2
                   1#
                   Language.Fortran.$tc'Sub1) -}
eb091919a3cf267e82e1718f1e155c82
  $tc'Sub1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
185625ceb6d8498a7eedb06f9f5a96ce
  $tc'Sub2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sub3) -}
2ed0eaad264cabd2e246fb43cbb06b50
  $tc'Sub3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sub"#) -}
ee30ef43d72e3ea4ca0f14b120451583
  $tc'SubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9752840872230175110##
                   6117246320424294648##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SubName2
                   1#
                   Language.Fortran.$tc'SubName1) -}
27d38c90c9fd853247da34a31a9c8b95
  $tc'SubName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e0c8f1147e5e671fca9fc20a927354fb
  $tc'SubName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SubName3) -}
88d27323933d0f415f48dfbd3cc4ae71
  $tc'SubName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SubName"#) -}
49b7146389ff6b60e98081d1c292fee3
  $tc'SubroutineInterface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12474575863917064560##
                   5198372863276056659##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SubroutineInterface1
                   1#
                   Language.Fortran.$tc'FunctionInterface1) -}
b3f342405b8e15e150adc721986a9098
  $tc'SubroutineInterface1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'SubroutineInterface2) -}
5436942db7f94bf64648f53a43c7373c
  $tc'SubroutineInterface2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SubroutineInterface"#) -}
d0e84bab3a8fc1c7045e86540c372506
  $tc'Target :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   971519306816803383##
                   16946680829655807655##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Target1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
603fc5860f46b044eb0a99ab23896567
  $tc'Target1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Target2) -}
20594984eb5218e9a93c7de33e0dda51
  $tc'Target2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Target"#) -}
88b8f6c1392cdf73040f3b70ad8dbc84
  $tc'TextDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8321710899354353620##
                   12830115682887398836##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'TextDecl2
                   1#
                   Language.Fortran.$tc'TextDecl1) -}
1971c23389bc8351372b8d0c7e7d147a
  $tc'TextDecl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fecc99d84e2b5bf5f276536cfcbac5bd
  $tc'TextDecl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'TextDecl3) -}
caaebd73ca1da08c448c37e37c6b8a26
  $tc'TextDecl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TextDecl"#) -}
e4fb32696385aad15567788a675131b8
  $tc'TextStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6607506987562594105##
                   352633188162150602##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'TextStmt1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
a376f6a449eefdddad0b08ce9a86fbe5
  $tc'TextStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'TextStmt2) -}
ee23b2c6e585f40526e4b073aa1ac327
  $tc'TextStmt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TextStmt"#) -}
14b379d8f3e60c8d22c88ad08dce91d1
  $tc'UMinus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3309421295860860216##
                   9159004079951785696##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UMinus1
                   1#
                   Language.Fortran.$tc'Not1) -}
7eeb51548be2620656c44860711a22e1
  $tc'UMinus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UMinus2) -}
2558212f59d5dd378aa26c94a6b02072
  $tc'UMinus2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UMinus"#) -}
e79440031a44cba43fd3ee0fc95ca387
  $tc'Unary :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   58263566849514572##
                   10164862385491095296##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unary2
                   1#
                   Language.Fortran.$tc'Unary1) -}
75361a0e6d54d34429153334950a0d8d
  $tc'Unary1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a3401d7ef90f08beb797ba300fbb9c0e
  $tc'Unary2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Unary3) -}
5e4a1a09f848ea2e5ca935f2255ecd92
  $tc'Unary3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unary"#) -}
7b7a310a6ab6f8498344bf9974db0957
  $tc'Unformatted :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15835295034619065288##
                   6187604486220266153##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unformatted1
                   1#
                   Language.Fortran.$tc'Access1) -}
926359615e4dcda17a8ddcb13e80977e
  $tc'Unformatted1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Unformatted2) -}
1f8258c738fcd992739776b9f09db34f
  $tc'Unformatted2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unformatted"#) -}
4ab603f3361625667a01e38f16e83948
  $tc'Unit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6815517502065545243##
                   15127018118649726035##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unit1
                   1#
                   Language.Fortran.$tc'Access1) -}
202bb337f79791148a0eb0ff93345771
  $tc'Unit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Unit2) -}
be551e8545e8e8358c819bb0de6e5da7
  $tc'Unit2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unit"#) -}
d8bc927db9463998a74a9495c2601c63
  $tc'UnitNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8914149656620438034##
                   8905262113339278000##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitNone2
                   1#
                   Language.Fortran.$tc'UnitNone1) -}
82b345bd6fd774c5a9bd84c3496821d9
  $tc'UnitNone1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5a813f8bc6ce513ac72a98f577c65b27
  $tc'UnitNone2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UnitNone3) -}
7a75fa56e31059aa90a27de6ea68ab92
  $tc'UnitNone3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnitNone"#) -}
c0aac70c1b3b2a11f5edd09ec660570e
  $tc'UnitProduct :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2608213371149270419##
                   2612483917947488445##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitProduct2
                   1#
                   Language.Fortran.$tc'UnitProduct1) -}
4046279b6a099810a4e57dfc8b95968f
  $tc'UnitProduct1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d84b206fbc4cde71a38a105209e133df
  $tc'UnitProduct2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UnitProduct3) -}
df0138e6f691fe7c7cb6c1d5e68d6034
  $tc'UnitProduct3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnitProduct"#) -}
a45fe72d331b7ec961c92450853eb32f
  $tc'UnitQuotient :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   435532235601083816##
                   2417980328518684973##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitQuotient2
                   1#
                   Language.Fortran.$tc'UnitQuotient1) -}
d6c03f6c43c3aac0ec7e2f9318aba321
  $tc'UnitQuotient1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4366758afe82c8a90d237d10eaafa41b
  $tc'UnitQuotient2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'UnitQuotient3) -}
c97019df4ff964032473d1cec4ab8c00
  $tc'UnitQuotient3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnitQuotient"#) -}
140c957408493f9676c74a9848f209fc
  $tc'Use :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1379198337130908195##
                   11083895932721249474##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Use2
                   1#
                   Language.Fortran.$tc'Use1) -}
24bd600e32c9dc9ddd30821c2d7b16a9
  $tc'Use1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
864b0e341bca4ac8726ee5b00f16d59b
  $tc'Use2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Use3) -}
a6af9537aedd3e78901b5e3fbda5482c
  $tc'Use3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Use"#) -}
9ca9c914039bd58f6027e26c808cbee1
  $tc'UseBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2030585413605511543##
                   17385144921840946016##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UseBlock2
                   1#
                   Language.Fortran.$tc'UseBlock1) -}
d411dcb0f10eea606bdf9e2247a4426c
  $tc'UseBlock1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
42b8cedf8eaac0f3dddd51760ad6a52b
  $tc'UseBlock2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UseBlock3) -}
6a599e2a520d166d977db1ca0a59b88b
  $tc'UseBlock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UseBlock"#) -}
d2b5adf6be9404c2f233ffa010385a95
  $tc'UseNil :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12279741077027516421##
                   6732113721234370933##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UseNil2
                   1#
                   Language.Fortran.$tc'UseNil1) -}
1c34294c77549d8c81cd58c4b589ae5c
  $tc'UseNil1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5b56f022fa28901f04a1e60241b0a81c
  $tc'UseNil2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UseNil3) -}
d0642d62d59f481eeafd9435ffd2401f
  $tc'UseNil3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UseNil"#) -}
1eed7b9fa3304e345cb60b9ec89ee422
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16669363448633623493##
                   8197471470891694527##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Var2
                   1#
                   Language.Fortran.$tc'Var1) -}
7bcf06e0c059b66575cd73dd61a8c7b4
  $tc'Var1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8f8c568dfa6063a1f5653f3b54e9d12f
  $tc'Var2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Var3) -}
4c44056aa41eba0738cb1e4614fd4547
  $tc'Var3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Var"#) -}
32f788a58cc42557b9a08affbb97f440
  $tc'VarName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12862369275295356948##
                   11475274504764584017##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'VarName2
                   1#
                   Language.Fortran.$tc'VarName1) -}
478f125148d2df14d92e7d1f95f6cb70
  $tc'VarName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
add8cfbb2aaceb25944613b0266f7298
  $tc'VarName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'VarName3) -}
bc66c02cc53f8ee77cc893b664e39015
  $tc'VarName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'VarName"#) -}
6075e6aa1a267c6de806d44cedaa90ca
  $tc'Volatile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17159210549562875931##
                   8065662202627238596##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Volatile1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
c6f96177f1b81107c73c5a8e3762884c
  $tc'Volatile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Volatile2) -}
5ceb00406d66456a2f717729febd402b
  $tc'Volatile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Volatile"#) -}
212cffedec416d2c2aed1f37b928f805
  $tc'Where :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3624341716164205237##
                   97947780981871448##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Where2
                   1#
                   Language.Fortran.$tc'Where1) -}
12a44d61241d68c06b4dd55e10da9dda
  $tc'Where1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3002270038cbd80007bb95216a7cc5e0
  $tc'Where2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Where3) -}
86142e146d2f8fd8b84070706fb2f958
  $tc'Where3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Where"#) -}
4066cb362361810820b3e73c4c4aeef9
  $tc'Write :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17797068374026581086##
                   17130339544239204737##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Write1
                   1#
                   Language.Fortran.$tc'Inquire1) -}
aab1ce6f3a0884e664754a39fa2c735d
  $tc'Write1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Write2) -}
b604717270dbbe37d1803ad9a8a9672a
  $tc'Write2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Write"#) -}
8807759aa71cb272208a1d153ff17244
  $tc'WriteSp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4321755148234034122##
                   1437172262900319841##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'WriteSp1
                   1#
                   Language.Fortran.$tc'Access1) -}
0d1788a2a7785016a332ff9e70b8a593
  $tc'WriteSp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'WriteSp2) -}
ebec11c71362cd2766d72ada9126b899
  $tc'WriteSp2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'WriteSp"#) -}
83a3ee0385a6fea685a46ed460afe83c
  $tcArg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2359460476297616621##
                   5217012210755420883##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataArg9
                   0#
                   GHC.Types.krep$*Arr*) -}
8283b2706f39240f9ff0ca11b12b8f33
  $tcArgList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2658788418971500205##
                   5050220201243405606##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataArgList3
                   0#
                   GHC.Types.krep$*Arr*) -}
599268d58bb22bfc934a9841411e0b37
  $tcArgName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4187460949675603402##
                   17695948308021011151##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataArgName3
                   0#
                   GHC.Types.krep$*Arr*) -}
38b132ba9381634c752dc951e2c6a159
  $tcAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15144293881790897351##
                   2024379006762117907##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataAttr3
                   0#
                   GHC.Types.krep$*Arr*) -}
cff6ef6e00bd566450ef8b014a1ad06b
  $tcBaseType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9534398033969989978##
                   4387516002846692571##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataBaseType3
                   0#
                   GHC.Types.krep$*Arr*) -}
786d87ad2f09cb18b2de20f5bce9df51
  $tcBinOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10905077043289159484##
                   6134286290342796449##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataBinOp4
                   0#
                   GHC.Types.krep$*Arr*) -}
bc059bc4bad6bf8a1a8d932a3d4c44c8
  $tcBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11270035641402173581##
                   8631095044655209212##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataBlock3
                   0#
                   GHC.Types.krep$*Arr*) -}
7f90dfde0cf86075980aa0c6c95994bb
  $tcDataForm :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6255407001957548374##
                   11459957579316560280##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataDataForm3
                   0#
                   GHC.Types.krep$*Arr*) -}
add33f014bbadbcd7dd5695b6449bfd4
  $tcDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9188850777785548874##
                   14769666604673014076##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataDecl3
                   0#
                   GHC.Types.krep$*Arr*) -}
0d2a6039955d77385695da0169157e84
  $tcExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17869853342830359556##
                   1287957171183349453##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataExpr3
                   0#
                   GHC.Types.krep$*Arr*) -}
2fc386febf45e53d4ac3486565cb69e9
  $tcFortran :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1898037638716600659##
                   3599167482411011499##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataFortran3
                   0#
                   GHC.Types.krep$*Arr*) -}
12c1663121735f014c24e809f2ace7d3
  $tcFraction :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1763003010597220149##
                   14474579820754583017##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataFraction4
                   0#
                   GHC.Types.krep$*Arr*) -}
6e493d8bc32b478d85dd692d13d77111
  $tcGSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6411480660480859959##
                   1355495822110532719##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataGSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
01f7e97e07a6e30b33b6777ad4c96e9a
  $tcImplicit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2442557690173166678##
                   15129477447861538283##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataImplicit6
                   0#
                   GHC.Types.krep$*Arr*) -}
b0266e810cbd61bae9d605bb42bb0126
  $tcIntentAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1418980594563321583##
                   15871466327150306728##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataIntentAttr4
                   0#
                   GHC.Types.krep$*Arr*) -}
fc110fb98c1bd5e752376a592a59e5c5
  $tcInterfaceSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4051087511440590505##
                   864161115625639908##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataInterfaceSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
849eaeba635105292e2f138dca0f5a36
  $tcMeasureUnitSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3028355738573783699##
                   18207650571513030677##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataMeasureUnitSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
238f834f3cd43fabacd4fa5fdee5b659
  $tcProgUnit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6479780727992239168##
                   17397259944912469841##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataProgUnit3
                   0#
                   GHC.Types.krep$*Arr*) -}
961b079eb5505596877233eb26d97b54
  $tcSpan :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4750833281608780138##
                   10470094186842552036##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcSpan2
                   0#
                   Language.Fortran.$tcSpan1) -}
16e54d239e2bfb482d634c5d87e358ce
  $tcSpan1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9e7ce9886068b7b21913aafbce22f976
  $tcSpan2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tcSpan3) -}
35cc813753ddafd1832e4acba12c6327
  $tcSpan3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Span"#) -}
264fd285bf95f0c50d94c964a812edda
  $tcSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11142086596812947727##
                   14943008726274983037##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
0a9282b3f180de3e45e38b9f10550bea
  $tcSrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3748651587269198497##
                   6830777199461934499##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataSrcLoc8
                   0#
                   GHC.Types.krep$*) -}
45d8fd75b04443e251e38ccd1b0507e3
  $tcSubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   984225159571365899##
                   8068956749520935535##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataSubName4
                   0#
                   GHC.Types.krep$*Arr*) -}
1a60a5028dc6b017ce87707a56bde8da
  $tcTagged :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   782403429795807129##
                   15414912083521512492##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcTagged2
                   0#
                   Language.Fortran.$tcTagged1) -}
86d9d842b15588e37a196dab477fadd9
  $tcTagged1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e593d6982d91937a8d6c73f4c4562736
  $tcTagged2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tcTagged3) -}
804f843acbf1de3051c51e86cc2cc828
  $tcTagged3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tagged"#) -}
bcaacbe9204033be006d23ddc7ea77c0
  $tcType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5041943942817465598##
                   7039049096440602731##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataType3
                   0#
                   GHC.Types.krep$*Arr*) -}
d983fdebcec2a71f0c87e7b4f67caf92
  $tcUnaryOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2406080142223468931##
                   3604077026223734859##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataUnaryOp6
                   0#
                   GHC.Types.krep$*Arr*) -}
aaac3b0a8fc61347b24dd5f0b03bda04
  $tcUseBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3173672121419574053##
                   9222787055978102566##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataUseBlock3
                   0#
                   GHC.Types.krep$*Arr*) -}
0a1048fc4b0e080a4652fb7f8e025791
  $tcUses :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9335191301300359584##
                   14913659259380547358##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataUses3
                   0#
                   GHC.Types.krep$*Arr*) -}
96696b8bfa965777e56cf52e4b782bc4
  $tcVarName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   758275414034097677##
                   18215223083819119344##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataVarName4
                   0#
                   GHC.Types.krep$*Arr*) -}
c609bfffe28518e234fc34c6352e2fdf
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.Fortran.$trModule3
                   Language.Fortran.$trModule1) -}
84d17b18456bbcfc53c5bab7e2547043
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$trModule2) -}
50d6829278f0bcddbcec1798713b1b66
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.Fortran"#) -}
f7a18dfb9344f957db365ccc2bf8b120
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$trModule4) -}
255b232ca4fc8f4939d389c3eac892d9
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
82f81f3c767f999d032660f1d5fc9585
  $w$c< ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.True
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$c<1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.False }) -}
5f948fefc0b8d2de3646745c6e24f215
  $w$c<= ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww2 ww of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww3 ww1 of wild1 {
                        DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.GT -> GHC.Types.True }) -}
229c51bc5a9063812d5ee03a878554c4
  $w$c== ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> GHC.Types.Bool
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))><L,U><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.ArgName p)
                   (ww2 :: Language.Fortran.SrcSpan)
                   (ww3 :: p)
                   (ww4 :: Language.Fortran.ArgName p)
                   (ww5 :: Language.Fortran.SrcSpan) ->
                 case GHC.Classes.== @ p w ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArg_$c==2 @ p w ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww2 of ww6 { (,) ww7 ww8 ->
                           case ww5 of ww9 { (,) ww10 ww11 ->
                           case ww7 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                           case ww10 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                           case GHC.Base.eqString ww13 ww17 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww14 of wild3 { GHC.Types.I# x ->
                                case ww18 of wild4 { GHC.Types.I# y ->
                                case GHC.Prim.==# x y of lwild {
                                  DEFAULT -> GHC.Types.False
                                  1#
                                  -> case ww15 of wild5 { GHC.Types.I# x1 ->
                                     case ww19 of wild6 { GHC.Types.I# y1 ->
                                     case GHC.Prim.==# x1 y1 of lwild1 {
                                       DEFAULT -> GHC.Types.False
                                       1#
                                       -> Language.Fortran.$fEqArg_$c==1
                                            ww8
                                            ww11 } } } } } } } } } } } } }) -}
b74ca35de18720c93856fbbecec1192a
  $w$c==1 ::
    GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U(U)><S,1*U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: GHC.Types.Int) ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.==# x y of lwild {
                        DEFAULT -> GHC.Types.False
                        1# -> GHC.Classes.eqInt ww2 ww5 } } } }) -}
6304956f2901eead56a8fac1e90d4904
  $w$c==2 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Expr p
    -> p
    -> Language.Fortran.Expr p
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Expr p)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Expr p) ->
                 case GHC.Classes.== @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> Language.Fortran.$fEqArgList_$c== @ p w ww1 ww3 }) -}
c30f73e4d4883546a03844eb37336882
  $w$c==3 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U(1*U,1*U(U),1*U(U))><S,1*U><L,1*U(1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc)
                   (ww2 :: Language.Fortran.Uses p)
                   (ww3 :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> Language.Fortran.$fEqArg_$c==1 ww1 ww3 }) -}
08b25d6cbdf34c01ab8af4c1702718b9
  $w$c==4 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.== @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Base.eqString ww1 ww3 }) -}
232df559aafaf497ddeb73d93949d1e4
  $w$c>= ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3 of wild1 {
                        DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.GT -> GHC.Types.True }) -}
7e645410c8685c8061ebc81d23b7c4b5
  $w$ccompare ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Ordering
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.GT }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $w$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> c Language.Fortran.SrcLoc
  {- Arity: 5,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ c :: * -> *
                   (w :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (w362 :: forall g. g -> c g)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (w @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (w @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (w362
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)
                         ww)
                      ww1)
                   ww2) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $w$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> m Language.Fortran.SrcLoc
  {- Arity: 5,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ m :: * -> *
                   (w :: GHC.Base.Monad m)
                   (w362 :: forall d. Data.Data.Data d => d -> m d)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 let {
                   $sk :: forall b. m (GHC.Types.Int -> b) -> GHC.Types.Int -> m b
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ @ b
                       (c :: m (GHC.Types.Int -> b))
                       (x :: GHC.Types.Int)[OneShot] ->
                     let {
                       lvl295 :: m GHC.Types.Int
                       = w362 @ GHC.Types.Int Data.Data.$fDataInt x
                     } in
                     GHC.Base.>>=
                       @ m
                       w
                       @ (GHC.Types.Int -> b)
                       @ b
                       c
                       (\ (c' :: GHC.Types.Int -> b) ->
                        GHC.Base.>>=
                          @ m
                          w
                          @ GHC.Types.Int
                          @ b
                          lvl295
                          (\ (x' :: GHC.Types.Int) -> GHC.Base.return @ m w @ b (c' x')))
                 } in
                 $sk
                   @ Language.Fortran.SrcLoc
                   ($sk
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      (let {
                         lvl295 :: m GHC.Base.String
                         = w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww
                       } in
                       GHC.Base.>>=
                         @ m
                         w
                         @ (GHC.Base.String
                            -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         (GHC.Base.return
                            @ m
                            w
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)
                         (\ (c' :: GHC.Base.String
                                   -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc) ->
                          GHC.Base.>>=
                            @ m
                            w
                            @ GHC.Base.String
                            @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            lvl295
                            (\ (x' :: GHC.Base.String) ->
                             GHC.Base.return
                               @ m
                               w
                               @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                               (c' x'))))
                      ww1)
                   ww2) -}
361ec85699986b0b7f4d68a05374d64d
  $w$cgmapM1 ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> p -> Language.Fortran.Variable -> m (Language.Fortran.VarName p)
  {- Arity: 5,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 let {
                   lvl295 :: m Language.Fortran.Variable
                   = w363
                       @ Language.Fortran.Variable
                       Data.Data.$fData[]_$s$fData[]
                       ww1
                 } in
                 GHC.Base.>>=
                   @ m
                   w362
                   @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                   @ (Language.Fortran.VarName p)
                   (let {
                      lvl296 :: m p = w363 @ p w ww
                    } in
                    GHC.Base.>>=
                      @ m
                      w362
                      @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      (GHC.Base.return
                         @ m
                         w362
                         @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p))
                      (\ (c' :: p
                                -> Language.Fortran.Variable -> Language.Fortran.VarName p) ->
                       GHC.Base.>>=
                         @ m
                         w362
                         @ p
                         @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                         lvl296
                         (\ (x' :: p) ->
                          GHC.Base.return
                            @ m
                            w362
                            @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                            (c' x'))))
                   (\ (c' :: Language.Fortran.Variable
                             -> Language.Fortran.VarName p) ->
                    GHC.Base.>>=
                      @ m
                      w362
                      @ Language.Fortran.Variable
                      @ (Language.Fortran.VarName p)
                      lvl295
                      (\ (x' :: Language.Fortran.Variable) ->
                       GHC.Base.return
                         @ m
                         w362
                         @ (Language.Fortran.VarName p)
                         (c' x')))) -}
f3ec5f820497e4cb535f28008184e1b6
  $w$cgmapQi ::
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> u
  {- Arity: 5,
     Strictness: <S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ u
                   (ww :: GHC.Prim.Int#)
                   (w :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1
                   1# -> w @ GHC.Types.Int Data.Data.$fDataInt ww2
                   2# -> w @ GHC.Types.Int Data.Data.$fDataInt ww3 }) -}
6304956f2901eead56a8fac1e90d4904
  $w$cgmapQi1 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> p
    -> Language.Fortran.Expr p
    -> u
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Expr p) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> w362 @ p w ww1
                   1#
                   -> w362
                        @ (Language.Fortran.Expr p)
                        (Language.Fortran.$fDataExpr @ p w)
                        ww2 }) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $w$cgmapQi2 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.SubName p) ->
                 case w363 of wild {
                   Language.Fortran.SubName a1 a2
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w362 @ p w a1
                        1# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2 }
                   Language.Fortran.NullSubName a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
c7dcda169fba71f63c925de5ef25cb00
  $w$cgmapQi3 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.Implicit p) ->
                 case w363 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.ImplicitNull a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
9bbab47a1f8f6f41e0b169b36e7c3164
  $w$cgmapQi4 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> u
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: Language.Fortran.Uses p)
                   (ww2 :: Language.Fortran.SrcLoc) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0#
                   -> w362
                        @ (Language.Fortran.Uses p)
                        (Language.Fortran.$fDataUses @ p w)
                        ww1
                   1#
                   -> w362
                        @ Language.Fortran.SrcLoc
                        Language.Fortran.$fDataSrcLoc
                        ww2 }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $w$cgmapQi5 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.Fraction p) ->
                 case w363 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w362 @ p w a1
                        1# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2 }
                   Language.Fortran.FractionConst a1 a2 a3
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w362 @ p w a1
                        1# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2
                        2# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3 }
                   Language.Fortran.NullFraction a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $w$cgmapQi6 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.IntentAttr p) ->
                 case w363 of wild {
                   Language.Fortran.In a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.Out a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.InOut a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $w$cgmapQi7 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.UnaryOp p) ->
                 case w363 of wild {
                   Language.Fortran.UMinus a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.Not a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
dfb943d028a773855ae6ebbbfe5cfce4
  $w$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 6,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
     Unfolding: (\ @ r
                   @ r'
                   (w :: r -> r' -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w (w (w w362
                         (w363 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww))
                      (w363 @ GHC.Types.Int Data.Data.$fDataInt ww1))
                   (w363 @ GHC.Types.Int Data.Data.$fDataInt ww2)) -}
d2d3d6ad7f9922bd74e7c8d706cb4ff6
  $w$cgmapQl1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Variable
    -> r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r -> r' -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 w362
                   (w362 w363 (w364 @ p w ww))
                   (w364
                      @ Language.Fortran.Variable
                      Data.Data.$fData[]_$s$fData[]
                      ww1)) -}
40d7b0b4f4929da9b08425770dd25be4
  $w$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 6,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ r
                   @ r'
                   (w :: r' -> r -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w (w363 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww)
                   (w (w363 @ GHC.Types.Int Data.Data.$fDataInt ww1)
                      (w (w363 @ GHC.Types.Int Data.Data.$fDataInt ww2) w362))) -}
6304956f2901eead56a8fac1e90d4904
  $w$cgmapQr1 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 6,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Expr p) ->
                 w362
                   (w364 @ p w ww)
                   (w362
                      (w364
                         @ (Language.Fortran.Expr p)
                         (Language.Fortran.$fDataExpr @ p w)
                         ww1)
                      w363)) -}
cd1a4627e32d5f398f8d64521edcfb85
  $w$cgmapQr2 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 6,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc) ->
                 w362
                   (w364
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p w)
                      ww)
                   (w362
                      (w364 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc ww1)
                      w363)) -}
eda7a21a121b13ea416567e965be29c9
  $w$cgmapQr3 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Variable
    -> r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 w362
                   (w364 @ p w ww)
                   (w362
                      (w364
                         @ Language.Fortran.Variable
                         Data.Data.$fData[]_$s$fData[]
                         ww1)
                      w363)) -}
46c6d78d8d8ad90615ee6b6136237ffd
  $w$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r) -> c Language.Fortran.SrcLoc
  {- Arity: 2, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ c :: * -> *
                   (w :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w362 :: forall r. r -> c r) ->
                 w @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (w @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (w @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (w362
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)))) -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $w$cgunfold1 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.SubName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.SubName p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.SubName p)
                             w
                             (w363
                                @ (p -> Language.Fortran.SubName p)
                                (Language.Fortran.NullSubName @ p))
                        1#
                        -> w362
                             @ GHC.Base.String
                             @ (Language.Fortran.SubName p)
                             Data.Data.$fData[]_$s$fData[]
                             (w362
                                @ p
                                @ (GHC.Base.String -> Language.Fortran.SubName p)
                                w
                                (w363
                                   @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                                   (Language.Fortran.SubName @ p))) } } }) -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $w$cgunfold2 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.BinOp p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0] -}
c7dcda169fba71f63c925de5ef25cb00
  $w$cgunfold3 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.Implicit p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.Implicit p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.Implicit p)
                             w
                             (w363
                                @ (p -> Language.Fortran.Implicit p)
                                (Language.Fortran.ImplicitNull @ p))
                        1#
                        -> w362
                             @ p
                             @ (Language.Fortran.Implicit p)
                             w
                             (w363
                                @ (p -> Language.Fortran.Implicit p)
                                (Language.Fortran.ImplicitNone @ p)) } } }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $w$cgunfold4 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.Fraction p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.Fraction p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.Fraction p)
                             w
                             (w363
                                @ (p -> Language.Fortran.Fraction p)
                                (Language.Fortran.NullFraction @ p))
                        1#
                        -> w362
                             @ GHC.Base.String
                             @ (Language.Fortran.Fraction p)
                             Data.Data.$fData[]_$s$fData[]
                             (w362
                                @ p
                                @ (GHC.Base.String -> Language.Fortran.Fraction p)
                                w
                                (w363
                                   @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                                   (Language.Fortran.IntegerConst @ p)))
                        2#
                        -> w362
                             @ GHC.Base.String
                             @ (Language.Fortran.Fraction p)
                             Data.Data.$fData[]_$s$fData[]
                             (w362
                                @ GHC.Base.String
                                @ (GHC.Base.String -> Language.Fortran.Fraction p)
                                Data.Data.$fData[]_$s$fData[]
                                (w362
                                   @ p
                                   @ (GHC.Base.String
                                      -> GHC.Base.String -> Language.Fortran.Fraction p)
                                   w
                                   (w363
                                      @ (p
                                         -> GHC.Base.String
                                         -> GHC.Base.String
                                         -> Language.Fortran.Fraction p)
                                      (Language.Fortran.FractionConst @ p)))) } } }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $w$cgunfold5 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.IntentAttr p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w363
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.InOut @ p))
                        1#
                        -> w362
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w363
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.In @ p))
                        2#
                        -> w362
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w363
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.Out @ p)) } } }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $w$cgunfold6 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.UnaryOp p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.UnaryOp p)
                             w
                             (w363
                                @ (p -> Language.Fortran.UnaryOp p)
                                (Language.Fortran.Not @ p))
                        1#
                        -> w362
                             @ p
                             @ (Language.Fortran.UnaryOp p)
                             w
                             (w363
                                @ (p -> Language.Fortran.UnaryOp p)
                                (Language.Fortran.UMinus @ p)) } } }) -}
8e118fec379cb224efef19c0b25201db
  $w$cshow ::
    GHC.Base.String
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U(U)><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 case GHC.Base.eqString ww Language.Fortran.$fShowArg8 of wild {
                   GHC.Types.False
                   -> GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowArg7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           ww
                           (GHC.CString.unpackAppendCString#
                              Language.Fortran.$fShowArg6
                              (case ww1 of ww3 { GHC.Types.I# ww4 ->
                               case GHC.Show.$wshowSignedInt
                                      0#
                                      ww4
                                      (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                               GHC.Base.++_$s++
                                 @ GHC.Types.Char
                                 (GHC.CString.unpackAppendCString#
                                    Language.Fortran.$fShowArg5
                                    (case ww2 of ww8 { GHC.Types.I# ww9 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww9
                                            (GHC.Types.[]
                                               @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                                     GHC.Base.++_$s++
                                       @ GHC.Types.Char
                                       Language.Fortran.$fShowArg3
                                       ww11
                                       ww12 } }))
                                 ww6
                                 ww7 } })))
                   GHC.Types.True
                   -> GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowArg2
                        (case ww1 of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++_$s++
                           @ GHC.Types.Char
                           (GHC.CString.unpackAppendCString#
                              Language.Fortran.$fShowArg1
                              (case ww2 of ww8 { GHC.Types.I# ww9 ->
                               case GHC.Show.$wshowSignedInt
                                      0#
                                      ww9
                                      (GHC.Types.[] @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                               GHC.Base.++_$s++
                                 @ GHC.Types.Char
                                 Language.Fortran.$fShowArg3
                                 ww11
                                 ww12 } }))
                           ww6
                           ww7 } }) }) -}
be7d6dfd506a3181c8919589d321d289
  $w$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U><L,U(U(U,U(U),U(U)),U(U,U(U),U(U)))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.ArgName p)
                   (ww3 :: Language.Fortran.SrcSpan) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   f95 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec1 @ p w 11# ww2
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Language.Fortran.$fShowArg10
                       (f94
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f95
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (case ww3 of ww4 { (,) ww5 ww6 ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)4
                                      (case ww5 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                                       GHC.Base.++
                                         @ GHC.Types.Char
                                         (Language.Fortran.$w$cshow ww8 ww9 ww10)
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.showList__1
                                            (GHC.Show.$fShow(,)_$sgo1
                                               (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)
                                               (\ (s :: GHC.Base.String)[OneShot] ->
                                                case ww6 of ww11 { Language.Fortran.SrcLoc ww12 ww13 ww14 ->
                                                GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Language.Fortran.$w$cshow ww12 ww13 ww14)
                                                  s })
                                               (GHC.Types.[] @ GHC.Show.ShowS))) }) })))))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p1
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
7dbcccb83ec422e5f4dcc4667e1f64fb
  $w$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.ArgName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
8347678f6676bd3eacaa7f87ac9bd303
  $w$cshowsPrec10 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Uses p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
fdc9c4c4875de40f3b0e2741aa10af1e
  $w$cshowsPrec11 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: [(Language.Fortran.Expr p, Language.Fortran.Expr p)]) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Language.Fortran.$fShowDataForm1
                       (f94
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (case ww2 of wild {
                                [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 x
                                : x1 xs
                                -> GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showList__3
                                     (case x1 of ww3 { (,) ww4 ww5 ->
                                      GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.$fShow(,)4
                                        (Language.Fortran.$w$cshowsPrec3
                                           @ p
                                           w
                                           0#
                                           ww4
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showList__1
                                              (GHC.Show.$fShow(,)_$sgo1
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.$fShow(,)2
                                                    (let {
                                                       lvl295 :: [GHC.Types.Char]
                                                       = GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.showList__2
                                                           x
                                                     } in
                                                     letrec {
                                                       showl :: [(Language.Fortran.Expr p,
                                                                  Language.Fortran.Expr p)]
                                                                -> GHC.Base.String
                                                         {- Arity: 1, Strictness: <S,1*U> -}
                                                       = \ (ds2 :: [(Language.Fortran.Expr p,
                                                                     Language.Fortran.Expr p)]) ->
                                                         case ds2 of wild1 {
                                                           [] -> lvl295
                                                           : y ys
                                                           -> GHC.Types.:
                                                                @ GHC.Types.Char
                                                                GHC.Show.showList__1
                                                                (case y of ww6 { (,) ww7 ww8 ->
                                                                 GHC.Types.:
                                                                   @ GHC.Types.Char
                                                                   GHC.Show.$fShow(,)4
                                                                   (Language.Fortran.$w$cshowsPrec3
                                                                      @ p
                                                                      w
                                                                      0#
                                                                      ww7
                                                                      (GHC.Types.:
                                                                         @ GHC.Types.Char
                                                                         GHC.Show.showList__1
                                                                         (GHC.Show.$fShow(,)_$sgo1
                                                                            (GHC.Types.:
                                                                               @ GHC.Types.Char
                                                                               GHC.Show.$fShow(,)2
                                                                               (showl ys))
                                                                            (Language.Fortran.$w$cshowsPrec3
                                                                               @ p
                                                                               w
                                                                               0#
                                                                               ww8)
                                                                            (GHC.Types.[]
                                                                               @ GHC.Show.ShowS)))) }) }
                                                     } in
                                                     showl xs))
                                                 (Language.Fortran.$w$cshowsPrec3 @ p w 0# ww5)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))) }) })))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p1
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
a134d1ad73ea84faa62900e29f13ad6f
  $w$cshowsPrec12 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Fraction p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.Fraction p) ->
                 case w362 of wild {
                   Language.Fortran.IntegerConst b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowFraction4
                             (f94
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b2
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowFraction4
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Show.showLitString
                                            b2
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.$fShow(,)3
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.$fShow(,)2
                                                  x))))))) }
                   Language.Fortran.FractionConst b1 b2 b3
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      let {
                        p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.CString.unpackAppendCString#
                            Language.Fortran.$fShowFraction3
                            (f94
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.$fShow(,)3
                                     (GHC.Show.showLitString
                                        b2
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.$fShow(,)3
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showSpace1
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.$fShow(,)3
                                                 (GHC.Show.showLitString
                                                    b3
                                                    (GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.$fShow(,)3
                                                       x)))))))))
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT -> p1
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }
                   Language.Fortran.NullFraction b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowFraction1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowFraction1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
e56028b3291950d607189353469b7d3f
  $w$cshowsPrec13 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.GSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.GSpec p) ->
                 case w362 of wild {
                   Language.Fortran.GName b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Fortran.$w$cshowsPrec3 @ p w 11# b2
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowGSpec4
                             (f94 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowGSpec4
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }
                   Language.Fortran.GOper b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Fortran.$w$cshowsPrec6 @ p w 11# b2
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowGSpec3
                             (f94 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowGSpec3
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }
                   Language.Fortran.GAssg b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowGSpec1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowGSpec1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
99ba40de9dfc0f3564a116b2fbf4b556
  $w$cshowsPrec14 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.IntentAttr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.IntentAttr p) ->
                 case w362 of wild {
                   Language.Fortran.In b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr5
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr5
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.Out b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr3
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.InOut b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr1
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
e30f41d3f2effdd4b4a22fa8cf8c0055
  $w$cshowsPrec15 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.InterfaceSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
087eb564eb74f6fb18285d4e97659717
  $w$cshowsPrec16 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
941eca76f3a57e540d54e971b6bf91ab
  $w$cshowsPrec17 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Spec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
3c0e7e5e2ace2b7b36167e7f447bc3f1
  $w$cshowsPrec18 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.SubName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.SubName p) ->
                 case w362 of wild {
                   Language.Fortran.SubName b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowSubName3
                             (f94
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b2
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowSubName3
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Show.showLitString
                                            b2
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.$fShow(,)3
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.$fShow(,)2
                                                  x))))))) }
                   Language.Fortran.NullSubName b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowSubName1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowSubName1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
6b8210ea10d2538ca4598cfb9584c470
  $w$cshowsPrec19 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Type p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
6304956f2901eead56a8fac1e90d4904
  $w$cshowsPrec2 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> p -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Expr p) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec3 @ p w 11# ww2
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowArgList1
                        (f94 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Language.Fortran.$fShowArgList1
                           (f94
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }) -}
4833d7c6dcf496f3fab6f7f83a4d80df
  $w$cshowsPrec20 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.UnaryOp p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.UnaryOp p) ->
                 case w362 of wild {
                   Language.Fortran.UMinus b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowUnaryOp3 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowUnaryOp3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.Not b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowUnaryOp1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowUnaryOp1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
4f520a9575c27c5572ed66bc1f651689
  $w$cshowsPrec21 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> p -> Language.Fortran.Variable -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Variable) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowVarName1
                        (f94
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.$fShow(,)3
                                 (GHC.Show.showLitString
                                    ww2
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Language.Fortran.$fShowVarName1
                           (f94
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.$fShow(,)3
                                    (GHC.Show.showLitString
                                       ww2
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          GHC.Show.$fShow(,)3
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.$fShow(,)2
                                             x))))))) }) -}
6304956f2901eead56a8fac1e90d4904
  $w$cshowsPrec3 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
3b46645d85b9c008a9510c0f3d8ec026
  $w$cshowsPrec4 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Attr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
c66c0bcbb42951ba147c66147650e364
  $w$cshowsPrec5 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.BaseType p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
64bb8ea1ee9f5a8f0460e13355fb6f83
  $w$cshowsPrec6 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.BinOp p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
f9d908d96c17d105c21aacb87c9cf367
  $w$cshowsPrec7 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> Language.Fortran.UseBlock p
    -> Language.Fortran.Implicit p
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.Decl p
    -> Language.Fortran.Fortran p
    -> GHC.Show.ShowS
  {- Arity: 8,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U(1*U,U(U,U(U),U(U)))><L,1*U><L,U(U(U,U(U),U(U)),U(U,U(U),U(U)))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.UseBlock p)
                   (ww3 :: Language.Fortran.Implicit p)
                   (ww4 :: Language.Fortran.SrcSpan)
                   (ww5 :: Language.Fortran.Decl p)
                   (ww6 :: Language.Fortran.Fortran p) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   f95 :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww7 { Language.Fortran.UseBlock ww8 ww9 ->
                     Language.Fortran.$w$cshowsPrec9 @ p w 11# ww8 ww9 }
                 } in
                 let {
                   f96 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec8 @ p w 11# ww3
                 } in
                 let {
                   f97 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$fShowBlock_$cshowsPrec2
                       @ p
                       w
                       Language.Fortran.$fReadVarName2
                       ww5
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$fShowBlock_$cshowsPrec1
                       @ p
                       w
                       Language.Fortran.$fReadVarName2
                       ww6
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Language.Fortran.$fShowBlock1
                       (f94
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f95
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (f96
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (case ww4 of ww7 { (,) ww8 ww9 ->
                                          GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)4
                                            (case ww8 of ww10 { Language.Fortran.SrcLoc ww11 ww12 ww13 ->
                                             GHC.Base.++
                                               @ GHC.Types.Char
                                               (Language.Fortran.$w$cshow ww11 ww12 ww13)
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.showList__1
                                                  (GHC.Show.$fShow(,)_$sgo1
                                                     (GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.$fShow(,)2
                                                        (GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.showSpace1
                                                           (f97
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Char
                                                                 GHC.Show.showSpace1
                                                                 (g x)))))
                                                     (\ (s :: GHC.Base.String)[OneShot] ->
                                                      case ww9 of ww14 { Language.Fortran.SrcLoc ww15 ww16 ww17 ->
                                                      GHC.Base.++
                                                        @ GHC.Types.Char
                                                        (Language.Fortran.$w$cshow ww15 ww16 ww17)
                                                        s })
                                                     (GHC.Types.[] @ GHC.Show.ShowS))) }) })))))))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p1
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
c7dcda169fba71f63c925de5ef25cb00
  $w$cshowsPrec8 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Implicit p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.Implicit p) ->
                 case w362 of wild {
                   Language.Fortran.ImplicitNone b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowBlock4 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowBlock4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.ImplicitNull b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowBlock2 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowBlock2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
917d7f655c188037bca20faed24bafcc
  $w$cshowsPrec9 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,1*U><L,U(U,U(U),U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: Language.Fortran.Uses p)
                   (ww2 :: Language.Fortran.SrcLoc) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec10 @ p w 11# ww1
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowBlock6
                        (f94
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                               GHC.Base.++
                                 @ GHC.Types.Char
                                 (Language.Fortran.$w$cshow ww4 ww5 ww6)
                                 x })))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Language.Fortran.$fShowBlock6
                           (f94
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                                  GHC.Base.++
                                    @ GHC.Types.Char
                                    (Language.Fortran.$w$cshow ww4 ww5 ww6)
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x) })))) }) -}
2ecf4bb24a966e219012eee596c45ea8
  data Arg p
    = Arg p (Language.Fortran.ArgName p) Language.Fortran.SrcSpan
6304956f2901eead56a8fac1e90d4904
  data ArgList p = ArgList p (Language.Fortran.Expr p)
7dbcccb83ec422e5f4dcc4667e1f64fb
  data ArgName p
    = ArgName p GHC.Base.String
    | ASeq p (Language.Fortran.ArgName p) (Language.Fortran.ArgName p)
    | NullArg p
3b46645d85b9c008a9510c0f3d8ec026
  data Attr p
    = Parameter p
    | Allocatable p
    | External p
    | Intent p (Language.Fortran.IntentAttr p)
    | Intrinsic p
    | Optional p
    | Pointer p
    | Save p
    | Target p
    | Volatile p
    | Public p
    | Private p
    | Sequence p
    | Dimension p [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
    | MeasureUnit p (Language.Fortran.MeasureUnitSpec p)
c66c0bcbb42951ba147c66147650e364
  data BaseType p
    = Integer p
    | Real p
    | Character p
    | SomeType p
    | DerivedType p (Language.Fortran.SubName p)
    | Recursive p
    | Pure p
    | Elemental p
    | Logical p
    | Complex p
64bb8ea1ee9f5a8f0460e13355fb6f83
  data BinOp p
    = Plus p
    | Minus p
    | Mul p
    | Div p
    | Or p
    | And p
    | Concat p
    | Power p
    | RelEQ p
    | RelNE p
    | RelLT p
    | RelLE p
    | RelGT p
    | RelGE p
c8f6dc9d55c3b3cbc94e3fb30057f310
  data Block p
    = Block p
            (Language.Fortran.UseBlock p)
            (Language.Fortran.Implicit p)
            Language.Fortran.SrcSpan
            (Language.Fortran.Decl p)
            (Language.Fortran.Fortran p)
a8200bcb3a17c34f3b24a4ee00c063ea
  data DataForm p
    = Data p [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
e30f41d3f2effdd4b4a22fa8cf8c0055
  data Decl p
    = Decl p
           Language.Fortran.SrcSpan
           [(Language.Fortran.Expr p, Language.Fortran.Expr p,
             GHC.Base.Maybe GHC.Types.Int)]
           (Language.Fortran.Type p)
    | Namelist p [(Language.Fortran.Expr p, [Language.Fortran.Expr p])]
    | DataDecl p (Language.Fortran.DataForm p)
    | Equivalence p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | AttrStmt p
               (Language.Fortran.Attr p)
               [(Language.Fortran.Expr p, Language.Fortran.Expr p,
                 GHC.Base.Maybe GHC.Types.Int)]
    | AccessStmt p (Language.Fortran.Attr p) [Language.Fortran.GSpec p]
    | ExternalStmt p [GHC.Base.String]
    | Interface p
                (GHC.Base.Maybe (Language.Fortran.GSpec p))
                [Language.Fortran.InterfaceSpec p]
    | Common p
             Language.Fortran.SrcSpan
             (GHC.Base.Maybe GHC.Base.String)
             [Language.Fortran.Expr p]
    | DerivedTypeDef p
                     Language.Fortran.SrcSpan
                     (Language.Fortran.SubName p)
                     [Language.Fortran.Attr p]
                     [Language.Fortran.Attr p]
                     [Language.Fortran.Decl p]
    | Include p (Language.Fortran.Expr p)
    | DSeq p (Language.Fortran.Decl p) (Language.Fortran.Decl p)
    | TextDecl p GHC.Base.String
    | NullDecl p Language.Fortran.SrcSpan
    | MeasureUnitDef p
                     Language.Fortran.SrcSpan
                     [(Language.Fortran.MeasureUnit,
                       Language.Fortran.MeasureUnitSpec p)]
6304956f2901eead56a8fac1e90d4904
  data Expr p
    = Con p Language.Fortran.SrcSpan GHC.Base.String
    | ConL p Language.Fortran.SrcSpan GHC.Types.Char GHC.Base.String
    | ConS p Language.Fortran.SrcSpan GHC.Base.String
    | Var p
          Language.Fortran.SrcSpan
          [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
    | Bin p
          Language.Fortran.SrcSpan
          (Language.Fortran.BinOp p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
    | Unary p
            Language.Fortran.SrcSpan
            (Language.Fortran.UnaryOp p)
            (Language.Fortran.Expr p)
    | CallExpr p
               Language.Fortran.SrcSpan
               (Language.Fortran.Expr p)
               (Language.Fortran.ArgList p)
    | NullExpr p Language.Fortran.SrcSpan
    | Null p Language.Fortran.SrcSpan
    | ESeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.Expr p)
    | Bound p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            (Language.Fortran.Expr p)
    | Sqrt p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | ArrayCon p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | AssgExpr p
               Language.Fortran.SrcSpan
               GHC.Base.String
               (Language.Fortran.Expr p)
cab0cd6287333175c6b9d87427982518
  data Fortran p
    = Assg p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.Expr p)
    | For p
          Language.Fortran.SrcSpan
          (Language.Fortran.VarName p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Fortran p)
    | DoWhile p
              Language.Fortran.SrcSpan
              (Language.Fortran.Expr p)
              (Language.Fortran.Fortran p)
    | FSeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.Fortran p)
           (Language.Fortran.Fortran p)
    | If p
         Language.Fortran.SrcSpan
         (Language.Fortran.Expr p)
         (Language.Fortran.Fortran p)
         [(Language.Fortran.Expr p, Language.Fortran.Fortran p)]
         (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | Allocate p
               Language.Fortran.SrcSpan
               (Language.Fortran.Expr p)
               (Language.Fortran.Expr p)
    | Backspace p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Call p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.ArgList p)
    | Open p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Close p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Continue p Language.Fortran.SrcSpan
    | Cycle p Language.Fortran.SrcSpan GHC.Base.String
    | DataStmt p Language.Fortran.SrcSpan (Language.Fortran.DataForm p)
    | Deallocate p
                 Language.Fortran.SrcSpan
                 [Language.Fortran.Expr p]
                 (Language.Fortran.Expr p)
    | Endfile p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Exit p Language.Fortran.SrcSpan GHC.Base.String
    | Format p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Forall p
             Language.Fortran.SrcSpan
             ([(GHC.Base.String, Language.Fortran.Expr p,
                Language.Fortran.Expr p, Language.Fortran.Expr p)],
              Language.Fortran.Expr p)
             (Language.Fortran.Fortran p)
    | Goto p Language.Fortran.SrcSpan GHC.Base.String
    | Nullify p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | Inquire p
              Language.Fortran.SrcSpan
              [Language.Fortran.Spec p]
              [Language.Fortran.Expr p]
    | Pause p Language.Fortran.SrcSpan GHC.Base.String
    | Rewind p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Stop p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | Where p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            (Language.Fortran.Fortran p)
            (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | Write p
            Language.Fortran.SrcSpan
            [Language.Fortran.Spec p]
            [Language.Fortran.Expr p]
    | PointerAssg p
                  Language.Fortran.SrcSpan
                  (Language.Fortran.Expr p)
                  (Language.Fortran.Expr p)
    | Return p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | Label p
            Language.Fortran.SrcSpan
            GHC.Base.String
            (Language.Fortran.Fortran p)
    | Print p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            [Language.Fortran.Expr p]
    | ReadS p
            Language.Fortran.SrcSpan
            [Language.Fortran.Spec p]
            [Language.Fortran.Expr p]
    | TextStmt p Language.Fortran.SrcSpan GHC.Base.String
    | NullStmt p Language.Fortran.SrcSpan
    | SelectStmt p
                 Language.Fortran.SrcSpan
                 (Language.Fortran.Expr p)
                 [(Language.Fortran.Expr p, Language.Fortran.Fortran p)]
                 (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | OpenCLMap p
                Language.Fortran.SrcSpan
                [Language.Fortran.VarName p]
                [Language.Fortran.VarName p]
                [(Language.Fortran.VarName p, Language.Fortran.Expr p,
                  Language.Fortran.Expr p, Language.Fortran.Expr p)]
                [Language.Fortran.VarName p]
                (Language.Fortran.Fortran p)
    | OpenCLReduce p
                   Language.Fortran.SrcSpan
                   [Language.Fortran.VarName p]
                   [Language.Fortran.VarName p]
                   [(Language.Fortran.VarName p, Language.Fortran.Expr p,
                     Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   [Language.Fortran.VarName p]
                   [(Language.Fortran.VarName p, Language.Fortran.Expr p)]
                   (Language.Fortran.Fortran p)
    | OpenCLSeq p
                Language.Fortran.SrcSpan
                [Language.Fortran.VarName p]
                [Language.Fortran.VarName p]
                (Language.Fortran.Fortran p)
    | OpenCLBufferRead p
                       Language.Fortran.SrcSpan
                       (Language.Fortran.VarName p)
    | OpenCLBufferWrite p
                        Language.Fortran.SrcSpan
                        (Language.Fortran.VarName p)
a134d1ad73ea84faa62900e29f13ad6f
  data Fraction p
    = IntegerConst p GHC.Base.String
    | FractionConst p GHC.Base.String GHC.Base.String
    | NullFraction p
e56028b3291950d607189353469b7d3f
  data GSpec p
    = GName p (Language.Fortran.Expr p)
    | GOper p (Language.Fortran.BinOp p)
    | GAssg p
c7dcda169fba71f63c925de5ef25cb00
  data Implicit p = ImplicitNone p | ImplicitNull p
99ba40de9dfc0f3564a116b2fbf4b556
  data IntentAttr p = In p | Out p | InOut p
e30f41d3f2effdd4b4a22fa8cf8c0055
  data InterfaceSpec p
    = FunctionInterface p
                        (Language.Fortran.SubName p)
                        (Language.Fortran.Arg p)
                        (Language.Fortran.Uses p)
                        (Language.Fortran.Implicit p)
                        (Language.Fortran.Decl p)
    | SubroutineInterface p
                          (Language.Fortran.SubName p)
                          (Language.Fortran.Arg p)
                          (Language.Fortran.Uses p)
                          (Language.Fortran.Implicit p)
                          (Language.Fortran.Decl p)
    | ModuleProcedure p [Language.Fortran.SubName p]
832e55d90283a09ab7214c1d945be7fc
  type MeasureUnit = GHC.Base.String
087eb564eb74f6fb18285d4e97659717
  data MeasureUnitSpec p
    = UnitProduct p
                  [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
    | UnitQuotient p
                   [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
    | UnitNone p
ed98f86f6a2ef4dfd4f51776f30af2a3
  type ProgName = GHC.Base.String
573fa2fe80c5713ab0c018712ac118d8
  data ProgUnit p
    = Main p
           Language.Fortran.SrcSpan
           (Language.Fortran.SubName p)
           (Language.Fortran.Arg p)
           (Language.Fortran.Block p)
           [Language.Fortran.ProgUnit p]
    | Sub p
          Language.Fortran.SrcSpan
          (GHC.Base.Maybe (Language.Fortran.BaseType p))
          (Language.Fortran.SubName p)
          (Language.Fortran.Arg p)
          (Language.Fortran.Block p)
    | Function p
               Language.Fortran.SrcSpan
               (GHC.Base.Maybe (Language.Fortran.BaseType p))
               (Language.Fortran.SubName p)
               (Language.Fortran.Arg p)
               (GHC.Base.Maybe (Language.Fortran.VarName p))
               (Language.Fortran.Block p)
    | Module p
             Language.Fortran.SrcSpan
             (Language.Fortran.SubName p)
             (Language.Fortran.Uses p)
             (Language.Fortran.Implicit p)
             (Language.Fortran.Decl p)
             [Language.Fortran.ProgUnit p]
    | BlockData p
                Language.Fortran.SrcSpan
                (Language.Fortran.SubName p)
                (Language.Fortran.Uses p)
                (Language.Fortran.Implicit p)
                (Language.Fortran.Decl p)
    | PSeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.ProgUnit p)
           (Language.Fortran.ProgUnit p)
    | Prog p Language.Fortran.SrcSpan (Language.Fortran.ProgUnit p)
    | NullProg p Language.Fortran.SrcSpan
    | IncludeProg p
                  Language.Fortran.SrcSpan
                  (Language.Fortran.Decl p)
                  (GHC.Base.Maybe (Language.Fortran.Fortran p))
607f4435fb994a8c5b83bd9f7709b3c3
  type Program p = [Language.Fortran.ProgUnit p]
9ccb7f28066125b5105892e1a6d9c4ef
  type Renames =
    [(Language.Fortran.Variable, Language.Fortran.Variable)]
81e0a6d625974c87c04f91afb1091e0a
  class Span t where
    srcSpan :: t -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    {-# MINIMAL srcSpan #-}
941eca76f3a57e540d54e971b6bf91ab
  data Spec p
    = Access p (Language.Fortran.Expr p)
    | Action p (Language.Fortran.Expr p)
    | Advance p (Language.Fortran.Expr p)
    | Blank p (Language.Fortran.Expr p)
    | Delim p (Language.Fortran.Expr p)
    | Direct p (Language.Fortran.Expr p)
    | End p (Language.Fortran.Expr p)
    | Err p (Language.Fortran.Expr p)
    | ExFile p (Language.Fortran.Expr p)
    | Exist p (Language.Fortran.Expr p)
    | Eor p (Language.Fortran.Expr p)
    | File p (Language.Fortran.Expr p)
    | FMT p (Language.Fortran.Expr p)
    | Form p (Language.Fortran.Expr p)
    | Formatted p (Language.Fortran.Expr p)
    | Unformatted p (Language.Fortran.Expr p)
    | IOLength p (Language.Fortran.Expr p)
    | IOStat p (Language.Fortran.Expr p)
    | Name p (Language.Fortran.Expr p)
    | Named p (Language.Fortran.Expr p)
    | NoSpec p (Language.Fortran.Expr p)
    | Number p (Language.Fortran.Expr p)
    | Floating p (Language.Fortran.Expr p) (Language.Fortran.Expr p)
    | NextRec p (Language.Fortran.Expr p)
    | NML p (Language.Fortran.Expr p)
    | Opened p (Language.Fortran.Expr p)
    | Pad p (Language.Fortran.Expr p)
    | Position p (Language.Fortran.Expr p)
    | Read p (Language.Fortran.Expr p)
    | ReadWrite p (Language.Fortran.Expr p)
    | Rec p (Language.Fortran.Expr p)
    | Recl p (Language.Fortran.Expr p)
    | Sequential p (Language.Fortran.Expr p)
    | Size p (Language.Fortran.Expr p)
    | Status p (Language.Fortran.Expr p)
    | StringLit p GHC.Base.String
    | Unit p (Language.Fortran.Expr p)
    | WriteSp p (Language.Fortran.Expr p)
    | Delimiter p
46c6d78d8d8ad90615ee6b6136237ffd
  data SrcLoc
    = SrcLoc {srcFilename :: GHC.Base.String,
              srcLine :: GHC.Types.Int,
              srcColumn :: GHC.Types.Int}
667dadf32292a4602702274000a648d8
  type SrcSpan = (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
3c0e7e5e2ace2b7b36167e7f447bc3f1
  data SubName p = SubName p GHC.Base.String | NullSubName p
c4a9d59142bdad96bc986b9181ed97e9
  class Tagged (d :: * -> *) where
    tag :: d a -> a
    {-# MINIMAL tag #-}
6b8210ea10d2538ca4598cfb9584c470
  data Type p
    = BaseType p
               (Language.Fortran.BaseType p)
               [Language.Fortran.Attr p]
               (Language.Fortran.Expr p)
               (Language.Fortran.Expr p)
    | ArrayT p
             [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
             (Language.Fortran.BaseType p)
             [Language.Fortran.Attr p]
             (Language.Fortran.Expr p)
             (Language.Fortran.Expr p)
4833d7c6dcf496f3fab6f7f83a4d80df
  data UnaryOp p = UMinus p | Not p
68ba21623f3e340277f6ee2081f0e743
  data UseBlock p
    = UseBlock (Language.Fortran.Uses p) Language.Fortran.SrcLoc
8347678f6676bd3eacaa7f87ac9bd303
  data Uses p
    = Use p
          (GHC.Base.String, Language.Fortran.Renames)
          (Language.Fortran.Uses p)
          p
    | UseNil p
361ec85699986b0b7f4d68a05374d64d
  data VarName p = VarName p Language.Fortran.Variable
f35fa69b9470c42233515abfffd338e2
  type Variable = GHC.Base.String
46c6d78d8d8ad90615ee6b6136237ffd
  srcColumn :: Language.Fortran.SrcLoc -> GHC.Types.Int
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds3 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  srcFilename :: Language.Fortran.SrcLoc -> GHC.Base.String
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds1 }) -}
46c6d78d8d8ad90615ee6b6136237ffd
  srcLine :: Language.Fortran.SrcLoc -> GHC.Types.Int
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds2 }) -}
instance Data.Data.Data [Language.Fortran.Arg]
  = Language.Fortran.$fDataArg
instance Data.Data.Data [Language.Fortran.ArgList]
  = Language.Fortran.$fDataArgList
instance Data.Data.Data [Language.Fortran.ArgName]
  = Language.Fortran.$fDataArgName
instance Data.Data.Data [Language.Fortran.Attr]
  = Language.Fortran.$fDataAttr
instance Data.Data.Data [Language.Fortran.BaseType]
  = Language.Fortran.$fDataBaseType
instance Data.Data.Data [Language.Fortran.BinOp]
  = Language.Fortran.$fDataBinOp
instance Data.Data.Data [Language.Fortran.Block]
  = Language.Fortran.$fDataBlock
instance Data.Data.Data [Language.Fortran.DataForm]
  = Language.Fortran.$fDataDataForm
instance Data.Data.Data [Language.Fortran.Decl]
  = Language.Fortran.$fDataDecl
instance Data.Data.Data [Language.Fortran.Expr]
  = Language.Fortran.$fDataExpr
instance Data.Data.Data [Language.Fortran.Fortran]
  = Language.Fortran.$fDataFortran
instance Data.Data.Data [Language.Fortran.Fraction]
  = Language.Fortran.$fDataFraction
instance Data.Data.Data [Language.Fortran.GSpec]
  = Language.Fortran.$fDataGSpec
instance Data.Data.Data [Language.Fortran.Implicit]
  = Language.Fortran.$fDataImplicit
instance Data.Data.Data [Language.Fortran.IntentAttr]
  = Language.Fortran.$fDataIntentAttr
instance Data.Data.Data [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fDataInterfaceSpec
instance Data.Data.Data [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fDataMeasureUnitSpec
instance Data.Data.Data [Language.Fortran.ProgUnit]
  = Language.Fortran.$fDataProgUnit
instance Data.Data.Data [Language.Fortran.Spec]
  = Language.Fortran.$fDataSpec
instance Data.Data.Data [Language.Fortran.SrcLoc]
  = Language.Fortran.$fDataSrcLoc
instance Data.Data.Data [Language.Fortran.SubName]
  = Language.Fortran.$fDataSubName
instance Data.Data.Data [Language.Fortran.Type]
  = Language.Fortran.$fDataType
instance Data.Data.Data [Language.Fortran.UnaryOp]
  = Language.Fortran.$fDataUnaryOp
instance Data.Data.Data [Language.Fortran.UseBlock]
  = Language.Fortran.$fDataUseBlock
instance Data.Data.Data [Language.Fortran.Uses]
  = Language.Fortran.$fDataUses
instance Data.Data.Data [Language.Fortran.VarName]
  = Language.Fortran.$fDataVarName
instance GHC.Classes.Eq [Language.Fortran.Arg]
  = Language.Fortran.$fEqArg
instance GHC.Classes.Eq [Language.Fortran.ArgList]
  = Language.Fortran.$fEqArgList
instance GHC.Classes.Eq [Language.Fortran.ArgName]
  = Language.Fortran.$fEqArgName
instance GHC.Classes.Eq [Language.Fortran.Attr]
  = Language.Fortran.$fEqAttr
instance GHC.Classes.Eq [Language.Fortran.BaseType]
  = Language.Fortran.$fEqBaseType
instance GHC.Classes.Eq [Language.Fortran.BinOp]
  = Language.Fortran.$fEqBinOp
instance GHC.Classes.Eq [Language.Fortran.Block]
  = Language.Fortran.$fEqBlock
instance GHC.Classes.Eq [Language.Fortran.DataForm]
  = Language.Fortran.$fEqDataForm
instance GHC.Classes.Eq [Language.Fortran.Decl]
  = Language.Fortran.$fEqDecl
instance GHC.Classes.Eq [Language.Fortran.Expr]
  = Language.Fortran.$fEqExpr
instance GHC.Classes.Eq [Language.Fortran.Fortran]
  = Language.Fortran.$fEqFortran
instance GHC.Classes.Eq [Language.Fortran.Fraction]
  = Language.Fortran.$fEqFraction
instance GHC.Classes.Eq [Language.Fortran.GSpec]
  = Language.Fortran.$fEqGSpec
instance GHC.Classes.Eq [Language.Fortran.Implicit]
  = Language.Fortran.$fEqImplicit
instance GHC.Classes.Eq [Language.Fortran.IntentAttr]
  = Language.Fortran.$fEqIntentAttr
instance GHC.Classes.Eq [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fEqInterfaceSpec
instance GHC.Classes.Eq [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fEqMeasureUnitSpec
instance GHC.Classes.Eq [Language.Fortran.ProgUnit]
  = Language.Fortran.$fEqProgUnit
instance GHC.Classes.Eq [Language.Fortran.Spec]
  = Language.Fortran.$fEqSpec
instance GHC.Classes.Eq [Language.Fortran.SrcLoc]
  = Language.Fortran.$fEqSrcLoc
instance GHC.Classes.Eq [Language.Fortran.SubName]
  = Language.Fortran.$fEqSubName
instance GHC.Classes.Eq [Language.Fortran.Type]
  = Language.Fortran.$fEqType
instance GHC.Classes.Eq [Language.Fortran.UnaryOp]
  = Language.Fortran.$fEqUnaryOp
instance GHC.Classes.Eq [Language.Fortran.UseBlock]
  = Language.Fortran.$fEqUseBlock
instance GHC.Classes.Eq [Language.Fortran.Uses]
  = Language.Fortran.$fEqUses
instance GHC.Classes.Eq [Language.Fortran.VarName]
  = Language.Fortran.$fEqVarName
instance GHC.Base.Functor [Language.Fortran.Arg]
  = Language.Fortran.$fFunctorArg
instance GHC.Base.Functor [Language.Fortran.ArgList]
  = Language.Fortran.$fFunctorArgList
instance GHC.Base.Functor [Language.Fortran.ArgName]
  = Language.Fortran.$fFunctorArgName
instance GHC.Base.Functor [Language.Fortran.Attr]
  = Language.Fortran.$fFunctorAttr
instance GHC.Base.Functor [Language.Fortran.BaseType]
  = Language.Fortran.$fFunctorBaseType
instance GHC.Base.Functor [Language.Fortran.BinOp]
  = Language.Fortran.$fFunctorBinOp
instance GHC.Base.Functor [Language.Fortran.Block]
  = Language.Fortran.$fFunctorBlock
instance GHC.Base.Functor [Language.Fortran.DataForm]
  = Language.Fortran.$fFunctorDataForm
instance GHC.Base.Functor [Language.Fortran.Decl]
  = Language.Fortran.$fFunctorDecl
instance GHC.Base.Functor [Language.Fortran.Expr]
  = Language.Fortran.$fFunctorExpr
instance GHC.Base.Functor [Language.Fortran.Fortran]
  = Language.Fortran.$fFunctorFortran
instance GHC.Base.Functor [Language.Fortran.Fraction]
  = Language.Fortran.$fFunctorFraction
instance GHC.Base.Functor [Language.Fortran.GSpec]
  = Language.Fortran.$fFunctorGSpec
instance GHC.Base.Functor [Language.Fortran.Implicit]
  = Language.Fortran.$fFunctorImplicit
instance GHC.Base.Functor [Language.Fortran.IntentAttr]
  = Language.Fortran.$fFunctorIntentAttr
instance GHC.Base.Functor [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fFunctorInterfaceSpec
instance GHC.Base.Functor [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fFunctorMeasureUnitSpec
instance GHC.Base.Functor [Language.Fortran.ProgUnit]
  = Language.Fortran.$fFunctorProgUnit
instance GHC.Base.Functor [Language.Fortran.Spec]
  = Language.Fortran.$fFunctorSpec
instance GHC.Base.Functor [Language.Fortran.SubName]
  = Language.Fortran.$fFunctorSubName
instance GHC.Base.Functor [Language.Fortran.Type]
  = Language.Fortran.$fFunctorType
instance GHC.Base.Functor [Language.Fortran.UnaryOp]
  = Language.Fortran.$fFunctorUnaryOp
instance GHC.Base.Functor [Language.Fortran.UseBlock]
  = Language.Fortran.$fFunctorUseBlock
instance GHC.Base.Functor [Language.Fortran.Uses]
  = Language.Fortran.$fFunctorUses
instance GHC.Base.Functor [Language.Fortran.VarName]
  = Language.Fortran.$fFunctorVarName
instance GHC.Classes.Ord [Language.Fortran.VarName]
  = Language.Fortran.$fOrdVarName
instance GHC.Read.Read [Language.Fortran.VarName]
  = Language.Fortran.$fReadVarName
instance GHC.Show.Show [Language.Fortran.Arg]
  = Language.Fortran.$fShowArg
instance GHC.Show.Show [Language.Fortran.ArgList]
  = Language.Fortran.$fShowArgList
instance GHC.Show.Show [Language.Fortran.ArgName]
  = Language.Fortran.$fShowArgName
instance GHC.Show.Show [Language.Fortran.Attr]
  = Language.Fortran.$fShowAttr
instance GHC.Show.Show [Language.Fortran.BaseType]
  = Language.Fortran.$fShowBaseType
instance GHC.Show.Show [Language.Fortran.BinOp]
  = Language.Fortran.$fShowBinOp
instance GHC.Show.Show [Language.Fortran.Block]
  = Language.Fortran.$fShowBlock
instance GHC.Show.Show [Language.Fortran.DataForm]
  = Language.Fortran.$fShowDataForm
instance GHC.Show.Show [Language.Fortran.Decl]
  = Language.Fortran.$fShowDecl
instance GHC.Show.Show [Language.Fortran.Expr]
  = Language.Fortran.$fShowExpr
instance GHC.Show.Show [Language.Fortran.Fortran]
  = Language.Fortran.$fShowFortran
instance GHC.Show.Show [Language.Fortran.Fraction]
  = Language.Fortran.$fShowFraction
instance GHC.Show.Show [Language.Fortran.GSpec]
  = Language.Fortran.$fShowGSpec
instance GHC.Show.Show [Language.Fortran.Implicit]
  = Language.Fortran.$fShowImplicit
instance GHC.Show.Show [Language.Fortran.IntentAttr]
  = Language.Fortran.$fShowIntentAttr
instance GHC.Show.Show [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fShowInterfaceSpec
instance GHC.Show.Show [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fShowMeasureUnitSpec
instance GHC.Show.Show [Language.Fortran.ProgUnit]
  = Language.Fortran.$fShowProgUnit
instance GHC.Show.Show [Language.Fortran.Spec]
  = Language.Fortran.$fShowSpec
instance GHC.Show.Show [Language.Fortran.SrcLoc]
  = Language.Fortran.$fShowSrcLoc
instance GHC.Show.Show [Language.Fortran.SubName]
  = Language.Fortran.$fShowSubName
instance GHC.Show.Show [Language.Fortran.Type]
  = Language.Fortran.$fShowType
instance GHC.Show.Show [Language.Fortran.UnaryOp]
  = Language.Fortran.$fShowUnaryOp
instance GHC.Show.Show [Language.Fortran.UseBlock]
  = Language.Fortran.$fShowUseBlock
instance GHC.Show.Show [Language.Fortran.Uses]
  = Language.Fortran.$fShowUses
instance GHC.Show.Show [Language.Fortran.VarName]
  = Language.Fortran.$fShowVarName
instance Language.Fortran.Span [Language.Fortran.Block]
  = Language.Fortran.$fSpanBlock
instance Language.Fortran.Span [Language.Fortran.Decl]
  = Language.Fortran.$fSpanDecl
instance Language.Fortran.Span [Language.Fortran.Expr]
  = Language.Fortran.$fSpanExpr
instance Language.Fortran.Span [Language.Fortran.Fortran]
  = Language.Fortran.$fSpanFortran
instance Language.Fortran.Span [Language.Fortran.ProgUnit]
  = Language.Fortran.$fSpanProgUnit
instance Language.Fortran.Tagged [Language.Fortran.Arg]
  = Language.Fortran.$fTaggedArg
instance Language.Fortran.Tagged [Language.Fortran.ArgList]
  = Language.Fortran.$fTaggedArgList
instance Language.Fortran.Tagged [Language.Fortran.ArgName]
  = Language.Fortran.$fTaggedArgName
instance Language.Fortran.Tagged [Language.Fortran.Attr]
  = Language.Fortran.$fTaggedAttr
instance Language.Fortran.Tagged [Language.Fortran.BaseType]
  = Language.Fortran.$fTaggedBaseType
instance Language.Fortran.Tagged [Language.Fortran.DataForm]
  = Language.Fortran.$fTaggedDataForm
instance Language.Fortran.Tagged [Language.Fortran.Decl]
  = Language.Fortran.$fTaggedDecl
instance Language.Fortran.Tagged [Language.Fortran.Expr]
  = Language.Fortran.$fTaggedExpr
instance Language.Fortran.Tagged [Language.Fortran.Fortran]
  = Language.Fortran.$fTaggedFortran
instance Language.Fortran.Tagged [Language.Fortran.GSpec]
  = Language.Fortran.$fTaggedGSpec
instance Language.Fortran.Tagged [Language.Fortran.Implicit]
  = Language.Fortran.$fTaggedImplicit
instance Language.Fortran.Tagged [Language.Fortran.ProgUnit]
  = Language.Fortran.$fTaggedProgUnit
instance Language.Fortran.Tagged [Language.Fortran.SubName]
  = Language.Fortran.$fTaggedSubName
instance Language.Fortran.Tagged [Language.Fortran.Uses]
  = Language.Fortran.$fTaggedUses
instance Language.Fortran.Tagged [Language.Fortran.VarName]
  = Language.Fortran.$fTaggedVarName
"SPEC/Language.Fortran $fData(,) @ SrcLoc @ SrcLoc" forall (v1 :: Data.Data.Data
                                                                    Language.Fortran.SrcLoc)
                                                           (v :: Data.Data.Data
                                                                   Language.Fortran.SrcLoc)
  Data.Data.$fData(,) @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      v
                      v1
  = Language.Fortran.$fDataArg_$s$fData(,)
"SPEC/Language.Fortran $fData(,) @ [Char] @ [Char]" [orphan] forall (v1 :: Data.Data.Data
                                                                             [GHC.Types.Char])
                                                                    (v :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fData(,) @ [GHC.Types.Char] @ [GHC.Types.Char] v v1
  = Language.Fortran.$s$fData(,)
"SPEC/Language.Fortran $fData(,)3 @ SrcLoc @ SrcLoc" forall ($dData1 :: Data.Data.Data
                                                                          Language.Fortran.SrcLoc)
                                                            ($dData2 :: Data.Data.Data
                                                                          Language.Fortran.SrcLoc)
  Data.Data.$fData(,)3 @ Language.Fortran.SrcLoc
                       @ Language.Fortran.SrcLoc
                       $dData2
                       $dData1
  = Language.Fortran.$s$fData(,)3
"SPEC/Language.Fortran $fData(,)3 @ [Char] @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                   [GHC.Types.Char])
                                                                     ($dData2 :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fData(,)3 @ [GHC.Types.Char]
                       @ [GHC.Types.Char]
                       $dData2
                       $dData1
  = Language.Fortran.$s$fData(,)5
"SPEC/Language.Fortran $fData(,)_$cgmapM @ SrcLoc @ SrcLoc" [0] forall (w362 :: Data.Data.Data
                                                                                  Language.Fortran.SrcLoc)
                                                                       (w :: Data.Data.Data
                                                                               Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapM @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc
                              w
                              w362
  = Language.Fortran.$s$fData(,)_$cgmapM
"SPEC/Language.Fortran $fData(,)_$cgmapM @ [Char] @ [Char]" [orphan] [0] forall (w362 :: Data.Data.Data
                                                                                           [GHC.Types.Char])
                                                                                (w :: Data.Data.Data
                                                                                        [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapM @ [GHC.Types.Char]
                              @ [GHC.Types.Char]
                              w
                              w362
  = Language.Fortran.$s$fData(,)_$cgmapM1
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ SrcLoc @ SrcLoc" forall ($dData1 :: Data.Data.Data
                                                                                 Language.Fortran.SrcLoc)
                                                                   ($dData2 :: Data.Data.Data
                                                                                 Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapQ @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc
                              $dData2
                              $dData1
  = Language.Fortran.$s$fData(,)_$cgmapQ
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ [Char] @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                          [GHC.Types.Char])
                                                                            ($dData2 :: Data.Data.Data
                                                                                          [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQ @ [GHC.Types.Char]
                              @ [GHC.Types.Char]
                              $dData2
                              $dData1
  = Language.Fortran.$s$fData(,)_$cgmapQ1
"SPEC/Language.Fortran $fData(,)_$cgunfold @ SrcLoc @ SrcLoc" forall ($dData1 :: Data.Data.Data
                                                                                   Language.Fortran.SrcLoc)
                                                                     ($dData2 :: Data.Data.Data
                                                                                   Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgunfold @ Language.Fortran.SrcLoc
                                @ Language.Fortran.SrcLoc
                                $dData2
                                $dData1
  = Language.Fortran.$s$fData(,)_$cgunfold
"SPEC/Language.Fortran $fData(,)_$cgunfold @ [Char] @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                            [GHC.Types.Char])
                                                                              ($dData2 :: Data.Data.Data
                                                                                            [GHC.Types.Char])
  Data.Data.$fData(,)_$cgunfold @ [GHC.Types.Char]
                                @ [GHC.Types.Char]
                                $dData2
                                $dData1
  = Language.Fortran.$s$fData(,)_$cgunfold1
"SPEC/Language.Fortran $fDataMaybe @ Int" [orphan] forall (v :: Data.Data.Data
                                                                  GHC.Types.Int)
  Data.Data.$fDataMaybe @ GHC.Types.Int v
  = Language.Fortran.$s$fDataMaybe1
"SPEC/Language.Fortran $fDataMaybe @ [Char]" [orphan] forall (v :: Data.Data.Data
                                                                     [GHC.Types.Char])
  Data.Data.$fDataMaybe @ [GHC.Types.Char] v
  = Language.Fortran.$s$fDataMaybe
"SPEC/Language.Fortran $fDataMaybe3 @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         GHC.Types.Int)
  Data.Data.$fDataMaybe3 @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe2
"SPEC/Language.Fortran $fDataMaybe3 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fDataMaybe3 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe3
"SPEC/Language.Fortran $fDataMaybe4 @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         GHC.Types.Int)
  Data.Data.$fDataMaybe4 @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe6
"SPEC/Language.Fortran $fDataMaybe4 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fDataMaybe4 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe4
"SPEC/Language.Fortran $fDataMaybe6 @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         GHC.Types.Int)
  Data.Data.$fDataMaybe6 @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe8
"SPEC/Language.Fortran $fDataMaybe6 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fDataMaybe6 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe7
"SPEC/Language.Fortran $fDataMaybe_$cgfoldl @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                 GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgfoldl @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgfoldl1
"SPEC/Language.Fortran $fDataMaybe_$cgfoldl @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgfoldl @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgfoldl
"SPEC/Language.Fortran $fDataMaybe_$cgmapQ @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQ @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQ1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQ @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQ @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQ
"SPEC/Language.Fortran $fDataMaybe_$cgmapQi @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                 GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQi @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQi1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQi @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQi @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQi
"SPEC/Language.Fortran $fDataMaybe_$cgmapQr @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                 GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQr @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQr1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQr @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQr @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQr
"SPEC/Language.Fortran $fDataMaybe_$cgunfold @ Int" [orphan] [0] forall (w :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgunfold @ GHC.Types.Int w
  = Language.Fortran.$s$fDataMaybe_$cgunfold1
"SPEC/Language.Fortran $fDataMaybe_$cgunfold @ [Char]" [orphan] [0] forall (w :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgunfold @ [GHC.Types.Char] w
  = Language.Fortran.$s$fDataMaybe_$cgunfold
"SPEC/Language.Fortran $fData[] @ (Variable, Variable)" [orphan] forall (v :: Data.Data.Data
                                                                                (Language.Fortran.Variable,
                                                                                 Language.Fortran.Variable))
  Data.Data.$fData[] @ (Language.Fortran.Variable,
                        Language.Fortran.Variable)
                     v
  = Language.Fortran.$s$fData[]1
"SPEC/Language.Fortran $fData[] @ [Char]" [orphan] forall (v :: Data.Data.Data
                                                                  [GHC.Types.Char])
  Data.Data.$fData[] @ [GHC.Types.Char] v
  = Language.Fortran.$s$fData[]
"SPEC/Language.Fortran $fData[]7 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         [GHC.Types.Char])
  Data.Data.$fData[]7 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fData[]7
"SPEC/Language.Fortran $fEq(,) @ [Char] @ [Char]" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                           [GHC.Types.Char])
                                                                  (v :: GHC.Classes.Eq
                                                                          [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char] @ [GHC.Types.Char] v v1
  = Language.Fortran.$s$fEq(,)
"SPEC/Language.Fortran $fEq(,)_$c/= @ [Char] @ [Char]" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                                   [GHC.Types.Char])
                                                                       ($dEq :: GHC.Classes.Eq
                                                                                  [GHC.Types.Char])
  GHC.Classes.$fEq(,)_$c/= @ [GHC.Types.Char]
                           @ [GHC.Types.Char]
                           $dEq
                           $dEq1
  = Language.Fortran.$s$fEq(,)_$s$fEq(,)_$c/=
"SPEC/Language.Fortran $fEqMaybe @ Int" [orphan] forall (v :: GHC.Classes.Eq
                                                                GHC.Types.Int)
  GHC.Base.$fEqMaybe @ GHC.Types.Int v = Language.Fortran.$s$fEqMaybe
"SPEC/Language.Fortran $fEqMaybe_$c/= @ Int" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                        GHC.Types.Int)
  GHC.Base.$fEqMaybe_$c/= @ GHC.Types.Int $dEq
  = Language.Fortran.$s$fEqMaybe_$s$fEqMaybe_$c/=
"SPEC/Language.Fortran $fEqMaybe_$c== @ Int" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                        GHC.Types.Int)
  GHC.Base.$fEqMaybe_$c== @ GHC.Types.Int $dEq
  = Language.Fortran.$s$fEqMaybe_$c==
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

