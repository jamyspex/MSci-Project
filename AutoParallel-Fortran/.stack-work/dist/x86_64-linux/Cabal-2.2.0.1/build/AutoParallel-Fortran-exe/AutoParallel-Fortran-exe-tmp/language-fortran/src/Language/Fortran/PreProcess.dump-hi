
==================== FINAL INTERFACE ====================
2018-11-16 12:45:06.075729864 UTC

interface main:Language.Fortran.PreProcess 8043
  interface hash: e427466da0b24b34894d3ac959606f78
  ABI hash: 47b67c360f8ca36872bffd445900700c
  export-list hash: dc8c5a11ae0e50d6ff97b9e1c77c40af
  orphan hash: 319962fd97d73ec633cdba95bb5c68cd
  flag hash: a76fcfb0b70774937c5c700cfbe103dd
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.Fortran.PreProcess.parseExpr
  Language.Fortran.PreProcess.pre_process
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0* binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 mtl-2.2.2 parsec-3.1.13.0
                      text-1.2.3.1 transformers-0.5.5.0
orphans: text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.Environment 7fdede11f96719870569cb0da1adac2f
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  parsec-3.1.13.0:Text.Parsec.Char 18e237b7b07beae07475d25f068850cc
import  -/  parsec-3.1.13.0:Text.Parsec.Combinator a9dbf5e1d9693551a5b146ee71dced08
import  -/  parsec-3.1.13.0:Text.Parsec.Pos e50c2afab99d3b473a1dba0ba039aace
import  -/  parsec-3.1.13.0:Text.Parsec.Prim 87b017e30237d731dcc4071aa883ba1c
import  -/  parsec-3.1.13.0:Text.ParserCombinators.Parsec c715a7d4123ce693b60b6632ae019dc5
import  -/  parsec-3.1.13.0:Text.ParserCombinators.Parsec.Prim 53f5e1ef82ea1a66eecf3ad5989b29b2
49c10d28934e4bfbc2088df39c193ae6
  $s$fEqMaybe :: GHC.Classes.Eq (GHC.Base.Maybe [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [GHC.Types.Char])
                  (\ (ds :: GHC.Base.Maybe [GHC.Types.Char])
                     (ds1 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1 -> GHC.Base.eqString a1 b1 } })
                  Language.Fortran.PreProcess.$s$fEqMaybe_$s$fEqMaybe_$c/= -}
377c056727418359cb35854aa035b5cd
  $s$fEqMaybe_$c== ::
    GHC.Base.Maybe [GHC.Types.Char]
    -> GHC.Base.Maybe [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe [GHC.Types.Char])
                   (ds1 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Base.eqString a1 b1 } }) -}
649ce3a7d93dbdcd2e989cdab7df9d14
  $s$fEqMaybe_$s$fEqMaybe_$c/= ::
    GHC.Base.Maybe [GHC.Types.Char]
    -> GHC.Base.Maybe [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x2 :: GHC.Base.Maybe [GHC.Types.Char])
                   (y :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x2 of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
02ab1b277c9eb531a946edef26cc3355
  $s$fStream[]mtok ::
    Text.Parsec.Prim.Stream [tok] Data.Functor.Identity.Identity tok
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ tok.
                  @ [tok]
                  @ Data.Functor.Identity.Identity
                  @ tok
                  Data.Functor.Identity.$fMonadIdentity
                  (Language.Fortran.PreProcess.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
                     @ tok) -}
c3bfc7759d2fd0a04b678605ba5fecb0
  $s$fStream[]mtok_$s$fStream[]mtok_$cuncons ::
    [tok]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (tok, [tok]))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ tok (ds :: [tok]) ->
                 case ds of wild {
                   []
                   -> (GHC.Base.Nothing @ (tok, [tok]))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe (tok, [tok])>_R))
                   : t ts
                   -> (GHC.Base.Just @ (tok, [tok]) (t, ts))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe (tok, [tok])>_R)) }) -}
ca8fa03c7fb88b0ea25e498881c6acb7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.Fortran.PreProcess.$trModule3
                   Language.Fortran.PreProcess.$trModule1) -}
4d0b3a83ed3db1c6d9dd48e42e9a4d59
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.PreProcess.$trModule2) -}
93668ab74716dcb73e40a766e31431ff
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.Fortran.PreProcess"#) -}
fbfaf13c4e3fa2282b4db42ca4d466c6
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.PreProcess.$trModule4) -}
def30d1bb3ab34a299e01c7926b430b5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
1b1e24a97455d7c1f6317fcb92ecefff
  parseExpr :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (file :: GHC.Base.String)
                   (input :: GHC.Base.String) ->
                 case (Text.Parsec.Prim.runPT
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ GHC.Types.Char
                         @ GHC.Types.Int
                         @ [GHC.Types.Char]
                         (Text.ParserCombinators.Parsec.Prim.$s$fStream[]mtok
                            @ GHC.Types.Char)
                         (\ @ b1
                            (s1 :: Text.Parsec.Prim.State
                                     [GHC.Types.Char] GHC.Types.Int)[OneShot]
                            (cok :: [GHC.Types.Char]
                                    -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                    -> Text.Parsec.Error.ParseError
                                    -> Data.Functor.Identity.Identity b1)[OneShot]
                            (cerr :: Text.Parsec.Error.ParseError
                                     -> Data.Functor.Identity.Identity b1)[OneShot]
                            (eok :: [GHC.Types.Char]
                                    -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                    -> Text.Parsec.Error.ParseError
                                    -> Data.Functor.Identity.Identity b1)[OneShot]
                            (eerr :: Text.Parsec.Error.ParseError
                                     -> Data.Functor.Identity.Identity b1)[OneShot] ->
                          let {
                            err :: Text.Parsec.Error.ParseError
                            = case s1 of wild { Text.Parsec.Prim.State ds ds1 ds2 ->
                              case ds1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                              case GHC.Classes.$fOrd[]_$s$ccompare1 ww4 ww4 of wild1 {
                                DEFAULT
                                -> Text.Parsec.Error.ParseError
                                     ww3
                                     (GHC.Types.[] @ Text.Parsec.Error.Message)
                                GHC.Types.EQ
                                -> Text.Parsec.Error.ParseError
                                     ww3
                                     Text.Parsec.Prim.$fMonadReaderrParsecT2 } } }
                          } in
                          Text.Parsec.Prim.$fApplicativeParsecT2
                            @ [GHC.Types.Char]
                            @ GHC.Types.Int
                            @ Data.Functor.Identity.Identity
                            @ ()
                            @ [GHC.Types.Char]
                            (\ @ b
                               (w2 :: Text.Parsec.Prim.State
                                        [GHC.Types.Char] GHC.Types.Int)[OneShot]
                               (w3 :: ()
                                      -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                      -> Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot]
                               (w4 :: Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot]
                               (w5 :: ()
                                      -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                                      -> Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot]
                               (w6 :: Text.Parsec.Error.ParseError
                                      -> Data.Functor.Identity.Identity b)[OneShot] ->
                             Text.Parsec.Prim.$wsetPosition
                               @ Data.Functor.Identity.Identity
                               @ [GHC.Types.Char]
                               @ GHC.Types.Int
                               (case s1 of wild { Text.Parsec.Prim.State ds ds1 ds2 ->
                                Text.Parsec.Pos.SourcePos file 1# 1# })
                               @ b
                               w2
                               w5)
                              `cast`
                            (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                      <[GHC.Types.Char]>_R
                                      <GHC.Types.Int>_R
                                      <Data.Functor.Identity.Identity>_R
                                      <()>_R))
                            Language.Fortran.PreProcess.parseExpr2
                              `cast`
                            (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                      <[GHC.Types.Char]>_R
                                      <GHC.Types.Int>_R
                                      <Data.Functor.Identity.Identity>_R
                                      <[GHC.Types.Char]>_R))
                            @ b1
                            s1
                            cok
                            cerr
                            (\ (x2 :: [GHC.Types.Char])
                               (s3 :: Text.Parsec.Prim.State
                                        [GHC.Types.Char] GHC.Types.Int)[OneShot]
                               (err' :: Text.Parsec.Error.ParseError)[OneShot] ->
                             eok x2 s3 (Text.Parsec.Error.mergeError err err'))
                            (\ (err' :: Text.Parsec.Error.ParseError) ->
                             eerr (Text.Parsec.Error.mergeError err err')))
                           `cast`
                         (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                   <[GHC.Types.Char]>_R
                                   <GHC.Types.Int>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Char]>_R))
                         Language.Fortran.PreProcess.parseExpr1
                         (GHC.Types.[] @ GHC.Types.Char)
                         input)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Data.Either.Either
                              Text.Parsec.Error.ParseError [GHC.Types.Char]>_R) of wild {
                   Data.Either.Left err -> GHC.Types.[] @ GHC.Types.Char
                   Data.Either.Right x2 -> x2 }) -}
b039c1bd069f10688d2d16ecfbf3e976
  parseExpr1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
4db787b915e2bc0e6d64ec1a3f28f86a
  parseExpr2 ::
    Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Unfolding: (Language.Fortran.PreProcess.parseExpr3
                   (GHC.Types.[] @ (GHC.Base.Maybe [GHC.Types.Char]))) -}
b46305da22d3972a055fae4a0d082777
  parseExpr3 ::
    [GHC.Base.Maybe [GHC.Types.Char]]
    -> forall b.
       Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
       -> ([GHC.Types.Char]
           -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([GHC.Types.Char]
           -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (labels :: [GHC.Base.Maybe [GHC.Types.Char]]) ->
                 Language.Fortran.PreProcess.parseExpr6
                   @ GHC.Types.Char
                   @ GHC.Types.Int
                   @ GHC.Types.Char
                   Language.Fortran.PreProcess.parseExpr5
                     `cast`
                   (Sym (Text.Parsec.Prim.N:ParsecT[0]
                             <[GHC.Types.Char]>_R
                             <GHC.Types.Int>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Types.Char>_R))
                   (let {
                      p1 :: Text.Parsec.Prim.ParsecT
                              [GHC.Types.Char]
                              GHC.Types.Int
                              Data.Functor.Identity.Identity
                              [GHC.Types.Char]
                      = case labels of wild {
                          []
                          -> Language.Fortran.PreProcess.parseExpr4
                               `cast`
                             (Sym (Text.Parsec.Prim.N:ParsecT[0]
                                       <[GHC.Types.Char]>_R
                                       <GHC.Types.Int>_R
                                       <Data.Functor.Identity.Identity>_R
                                       <[GHC.Types.Char]>_R))
                          : ds1 ds2
                          -> Language.Fortran.PreProcess.parseExpr_end_or_start_do wild }
                    } in
                    (\ @ b
                       (s1 :: Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int)
                       (cok :: [GHC.Types.Char]
                               -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b)
                       (ds :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b)
                       (eok :: [GHC.Types.Char]
                               -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b)
                       (eerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b) ->
                     p1
                       `cast`
                     (Text.Parsec.Prim.N:ParsecT[0]
                          <[GHC.Types.Char]>_R
                          <GHC.Types.Int>_R
                          <Data.Functor.Identity.Identity>_R
                          <[GHC.Types.Char]>_R)
                       @ b
                       s1
                       cok
                       eerr
                       eok
                       eerr)
                      `cast`
                    (Sym (Text.Parsec.Prim.N:ParsecT[0]
                              <[GHC.Types.Char]>_R
                              <GHC.Types.Int>_R
                              <Data.Functor.Identity.Identity>_R
                              <[GHC.Types.Char]>_R)))) -}
ff7b7e96c33353fa0195f89bacbb7391
  parseExpr4 ::
    Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> ([GHC.Types.Char]
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,C(U)> -}
2fe55c3884dfde2e2807f58e0719b8dd
  parseExpr5 ::
    Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (GHC.Types.Char
        -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
        -> Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> (Text.Parsec.Error.ParseError
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <S(LS(LSS)S),1*U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,A><L,C(U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ b
                   (eta :: Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int)
                   (eta1 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta2 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: GHC.Types.Char
                            -> Text.Parsec.Prim.State [GHC.Types.Char] GHC.Types.Int
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b) ->
                 case eta of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                 case ww2 of ww4 { Text.Parsec.Pos.SourcePos ww5 ww6 ww7 ->
                 Text.Parsec.Char.$wsatisfy
                   @ [GHC.Types.Char]
                   @ Data.Functor.Identity.Identity
                   @ GHC.Types.Int
                   (Language.Fortran.PreProcess.$s$fStream[]mtok @ GHC.Types.Char)
                   Text.Parsec.Char.anyChar2
                   @ b
                   ww1
                   ww5
                   ww6
                   ww7
                   ww3
                   eta1
                   eta4 } }) -}
75a929ce640d6f20de066820c3c64605
  parseExpr6 ::
    Text.Parsec.Prim.ParsecT [tok] u Data.Functor.Identity.Identity a
    -> Text.Parsec.String.GenParser tok u [a]
    -> forall b.
       Text.Parsec.Prim.State [tok] u
       -> ([a]
           -> Text.Parsec.Prim.State [tok] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> ([a]
           -> Text.Parsec.Prim.State [tok] u
           -> Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> (Text.Parsec.Error.ParseError
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(C1(U)))))><C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(U)> -}
7de699d0f54b366862e9d4ec9696c913
  parseExpr_end_or_start_do ::
    [GHC.Base.Maybe [GHC.Types.Char]]
    -> Text.Parsec.String.GenParser
         GHC.Types.Char GHC.Types.Int [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,U> -}
a98cb6172fea7d968e7e26545d7306d5
  pre_process :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (Language.Fortran.PreProcess.parseExpr
                   (GHC.Types.[] @ GHC.Types.Char)) -}
"SPEC/Language.Fortran.PreProcess $fEqMaybe @ [Char]" [orphan] forall (v :: GHC.Classes.Eq
                                                                              [GHC.Types.Char])
  GHC.Base.$fEqMaybe @ [GHC.Types.Char] v
  = Language.Fortran.PreProcess.$s$fEqMaybe
"SPEC/Language.Fortran.PreProcess $fEqMaybe_$c/= @ [Char]" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                      [GHC.Types.Char])
  GHC.Base.$fEqMaybe_$c/= @ [GHC.Types.Char] $dEq
  = Language.Fortran.PreProcess.$s$fEqMaybe_$s$fEqMaybe_$c/=
"SPEC/Language.Fortran.PreProcess $fEqMaybe_$c== @ [Char]" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                      [GHC.Types.Char])
  GHC.Base.$fEqMaybe_$c== @ [GHC.Types.Char] $dEq
  = Language.Fortran.PreProcess.$s$fEqMaybe_$c==
"SPEC/Language.Fortran.PreProcess $fStream[]mtok @ Identity _" [orphan] forall @ tok
                                                                               (v :: GHC.Base.Monad
                                                                                       Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok @ Data.Functor.Identity.Identity
                                  @ tok
                                  v
  = Language.Fortran.PreProcess.$s$fStream[]mtok @ tok
"SPEC/Language.Fortran.PreProcess $fStream[]mtok_$cuncons @ Identity _" [orphan] forall @ tok
                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                      Data.Functor.Identity.Identity)
  Text.Parsec.Prim.$fStream[]mtok_$cuncons @ Data.Functor.Identity.Identity
                                           @ tok
                                           $dMonad
  = Language.Fortran.PreProcess.$s$fStream[]mtok_$s$fStream[]mtok_$cuncons
      @ tok
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

