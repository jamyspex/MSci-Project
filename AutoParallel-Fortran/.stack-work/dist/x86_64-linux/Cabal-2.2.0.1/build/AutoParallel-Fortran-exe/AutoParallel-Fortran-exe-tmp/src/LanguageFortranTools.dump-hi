
==================== FINAL INTERFACE ====================
2018-11-16 12:45:14.575065071 UTC

interface main:LanguageFortranTools 8043
  interface hash: 2b24809311d27c617afca1faab8fecc8
  ABI hash: 737e8abc5de089abcd0ce62660f9d159
  export-list hash: a5a994dcb8ba92c93a8a354a063275b0
  orphan hash: 2356dfc1a1f383fdc961f19998d5705b
  flag hash: 7853c119b27f3f568e863cba4679c19c
  opt_hash: 2c98c95d41c045ae9c2fb565ec8aabc6
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  LanguageFortranTools.addImplicitNone
  LanguageFortranTools.addToValueTable
  LanguageFortranTools.addToValueTable_type
  LanguageFortranTools.appendAnnotation
  LanguageFortranTools.appendAnnotationList
  LanguageFortranTools.appendAnnotationMap
  LanguageFortranTools.appendFortran_recursive
  LanguageFortranTools.appendToMap
  LanguageFortranTools.applyGeneratedSrcSpans
  LanguageFortranTools.applyGlobalSrcSpan
  LanguageFortranTools.applySrcSpan
  LanguageFortranTools.checkSrcLocBefore
  LanguageFortranTools.checkSrcLocEqualLines
  LanguageFortranTools.checkSrcSpanAfter
  LanguageFortranTools.checkSrcSpanBefore
  LanguageFortranTools.checkSrcSpanBefore_line
  LanguageFortranTools.checkSrcSpanContainsSrcSpan
  LanguageFortranTools.combineAnnotations
  LanguageFortranTools.combineMaps
  LanguageFortranTools.commentSeparator
  LanguageFortranTools.commentSeparator'
  LanguageFortranTools.compilerName
  LanguageFortranTools.deleteValueFromTable
  LanguageFortranTools.errorLocationFormatting
  LanguageFortranTools.errorLocationRangeFormatting
  LanguageFortranTools.evaluateExpr
  LanguageFortranTools.evaluateExpr_type
  LanguageFortranTools.evaluateRange
  LanguageFortranTools.extractAllVarNames
  LanguageFortranTools.extractArgName
  LanguageFortranTools.extractAssigneeFromDecl
  LanguageFortranTools.extractAssignments
  LanguageFortranTools.extractBaseType
  LanguageFortranTools.extractBlock
  LanguageFortranTools.extractBufferReads
  LanguageFortranTools.extractBufferReads'
  LanguageFortranTools.extractBufferWrites
  LanguageFortranTools.extractBufferWrites'
  LanguageFortranTools.extractContainedOperands
  LanguageFortranTools.extractContainedVars
  LanguageFortranTools.extractContainedVarsWV
  LanguageFortranTools.extractDecl
  LanguageFortranTools.extractEvaluatedType
  LanguageFortranTools.extractEvaluatedValue
  LanguageFortranTools.extractExpr
  LanguageFortranTools.extractExpr_list
  LanguageFortranTools.extractFirstChildFor
  LanguageFortranTools.extractFirstFortran
  LanguageFortranTools.extractFor
  LanguageFortranTools.extractForWithFollowing
  LanguageFortranTools.extractForWithFollowing_beta
  LanguageFortranTools.extractFortran
  LanguageFortranTools.extractIndent
  LanguageFortranTools.extractKernels
  LanguageFortranTools.extractKernels'
  LanguageFortranTools.extractLineNumber
  LanguageFortranTools.extractLoopIters
  LanguageFortranTools.extractLoopIters'
  LanguageFortranTools.extractLoopVars
  LanguageFortranTools.extractLoopVars'
  LanguageFortranTools.extractLoops
  LanguageFortranTools.extractLoops'
  LanguageFortranTools.extractMaybeVarNames
  LanguageFortranTools.extractOpenCLReduces
  LanguageFortranTools.extractOpenCLReduces'
  LanguageFortranTools.extractOperands
  LanguageFortranTools.extractPrimaryReductionFunction
  LanguageFortranTools.extractPrimaryReductionOp
  LanguageFortranTools.extractPriorToFor
  LanguageFortranTools.extractReductionVarNames
  LanguageFortranTools.extractUsedVarName
  LanguageFortranTools.extractVarNames
  LanguageFortranTools.extractVarNames_loopVars
  LanguageFortranTools.findDeclLine
  LanguageFortranTools.findDeclLineVars
  LanguageFortranTools.generateAdditionExpr
  LanguageFortranTools.generateAndExpr
  LanguageFortranTools.generateAndExprFromList
  LanguageFortranTools.generateArrayVar
  LanguageFortranTools.generateAssgCode
  LanguageFortranTools.generateDivisionExpr
  LanguageFortranTools.generateESeq
  LanguageFortranTools.generateFSeq
  LanguageFortranTools.generateFloatConstant
  LanguageFortranTools.generateIf
  LanguageFortranTools.generateIntConstant
  LanguageFortranTools.generateLTExpr
  LanguageFortranTools.generateProductExpr
  LanguageFortranTools.generateSrcSpan
  LanguageFortranTools.generateSrcSpanMerge
  LanguageFortranTools.generateSubtractionExpr
  LanguageFortranTools.generateVar
  LanguageFortranTools.getEarliestSrcLoc
  LanguageFortranTools.getEarliestSrcSpan
  LanguageFortranTools.getIterLoopVars
  LanguageFortranTools.getLatestSrcSpan
  LanguageFortranTools.getLoopVar
  LanguageFortranTools.getLoopVars
  LanguageFortranTools.getReadArgs
  LanguageFortranTools.getReadArgs'
  LanguageFortranTools.getSrcSpanNonIntersection
  LanguageFortranTools.getSubNames
  LanguageFortranTools.getUnitName
  LanguageFortranTools.getUnitName'
  LanguageFortranTools.getUses
  LanguageFortranTools.getWrittenArgs
  LanguageFortranTools.getWrittenArgs'
  LanguageFortranTools.hasOperand
  LanguageFortranTools.inlineDeclsFromUsedModules
  LanguageFortranTools.isDeclOnly
  LanguageFortranTools.isImplicitNoneDecl
  LanguageFortranTools.isRelevantModuleLine
  LanguageFortranTools.isUseDecl
  LanguageFortranTools.isVar
  LanguageFortranTools.isVarDeclWithMultipleVars
  LanguageFortranTools.listCartesianProduct
  LanguageFortranTools.listConcatUnique
  LanguageFortranTools.listCountAppearances
  LanguageFortranTools.listExtractSingleAppearances
  LanguageFortranTools.listExtractSingleAppearances'
  LanguageFortranTools.listIntersection
  LanguageFortranTools.listRemoveDuplications
  LanguageFortranTools.listSubtract
  LanguageFortranTools.listSubtractWithExemption
  LanguageFortranTools.listUnion
  LanguageFortranTools.lookupValueTable
  LanguageFortranTools.lookupValueTable_type
  LanguageFortranTools.maybeBinOp
  LanguageFortranTools.maybeBinOp_float
  LanguageFortranTools.maybeBinOp_integral
  LanguageFortranTools.maybeNegative
  LanguageFortranTools.normaliseSrcSpan
  LanguageFortranTools.nullAnno
  LanguageFortranTools.nullSrcLoc
  LanguageFortranTools.nullSrcSpan
  LanguageFortranTools.oneVarDeclPerVarDeclLine
  LanguageFortranTools.orElem
  LanguageFortranTools.outputExprFormatting
  LanguageFortranTools.outputTab
  LanguageFortranTools.parseFile
  LanguageFortranTools.preProcessingHelper
  LanguageFortranTools.readUsedModuleDecls
  LanguageFortranTools.removeAllAnnotations
  LanguageFortranTools.removeAnnotations
  LanguageFortranTools.removeLoopConstructs_recursive
  LanguageFortranTools.replaceAllOccurences_varname
  LanguageFortranTools.replaceAllOccurences_varnamePairs
  LanguageFortranTools.replaceFortran
  LanguageFortranTools.replaceFortran'
  LanguageFortranTools.replaceProgUnit
  LanguageFortranTools.replaceProgUnit'
  LanguageFortranTools.replaceSrSpan
  LanguageFortranTools.replaceVarname
  LanguageFortranTools.resolveType
  LanguageFortranTools.runCpp
  LanguageFortranTools.shiftSrcSpan
  LanguageFortranTools.shiftSrcSpanLineGlobal
  LanguageFortranTools.split
  LanguageFortranTools.splitDelim
  LanguageFortranTools.splitOutVarDecls
  LanguageFortranTools.srcSpanInSrcSpan
  LanguageFortranTools.srcSpanInSrcSpanRange
  LanguageFortranTools.srcSpanLineCount
  LanguageFortranTools.standardiseSrcSpan
  LanguageFortranTools.stretchSrc
  LanguageFortranTools.stretchSrcSpanLine
  LanguageFortranTools.tabInc
  LanguageFortranTools.takeLast
  LanguageFortranTools.trimFront
  LanguageFortranTools.usesVarName
  LanguageFortranTools.usesVarName_list
  LanguageFortranTools.varNameListStr
  LanguageFortranTools.varNameStr
  LanguageFortranTools.Anno
  LanguageFortranTools.CodeStash
  LanguageFortranTools.ModuleVarsTable
  LanguageFortranTools.ValueTable
module dependencies: F95IntrinsicFunctions Language.Fortran
                     Language.Fortran.Lexer Language.Fortran.Parser
                     Language.Fortran.PreProcess PreProcessor Warning
package dependencies: array-0.5.2.0 base-4.11.1.0 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.11.0 deepseq-1.4.3.0
                      directory-1.3.1.5 filepath-1.4.2 ghc-prim-0.5.2.0
                      haskell-src-1.0.3.0 integer-gmp-1.0.2.0 mtl-2.2.2 parsec-3.1.13.0
                      process-1.6.3.0 syb-0.7 text-1.2.3.1 time-1.8.0.2
                      transformers-0.5.5.0 unix-2.7.2.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         syb-0.7:Data.Generics.Instances base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
import  -/  base-4.11.1.0:Data.Char 3e89818e2b8ef1a2cc5393163484da72
import  -/  base-4.11.1.0:Data.Data b150502d549600eff3202c16ff6cf22d
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Traversable 7ad4edb9184ea1ae8e73f6b94f115c8c
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:Data.Typeable 9548bf378a98cc2492ab02d9a516a250
import  -/  base-4.11.1.0:Data.Typeable.Internal 0b0201144a992d956fd13a21fc2d4b48
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.Float 99c69d365bb2607725a22530ce1ca4b4
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  base-4.11.1.0:Text.Read 6c02630607b565ffcb34e8127673989b
import  -/  containers-0.5.11.0:Data.Map f51b9cf04edd738eb6d014be576b3403
import  -/  containers-0.5.11.0:Data.Map.Internal e02d23495520de11b8e9f3c9c93a4d11
import  -/  directory-1.3.1.5:System.Directory 3989d404cf62c9bbd5d0a078de68acbe
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  F95IntrinsicFunctions 2a2dc1d4915ed7b9c5e736fba48a3676
  exports: a9e028fabd4d7137fc009fef93c07a09
  f95IntrinsicFunctions 79f039953e6ee977de902fe8df3b89c4
import  -/  Language.Fortran e2add56600673959dbdfe1ac093795c9
  exports: 6ca1e7b188145fc0c602707ea4a1c428
  And 363892c30801fc29b80cea45b0393521
  ArgName 9acaf710a8bc920f63e26e943ae5d9fe
  ArgName 7dbcccb83ec422e5f4dcc4667e1f64fb
  ArrayCon 60bd0c5317f2037fe707fd85c137411d
  ArrayT df8e826bb4708d07e8721be5c8d45d67
  Assg c3a5a5c7c0380c697e6a5cda4cc060bd
  BaseType 4771b9af523aad0f39b02040c5046e99
  BaseType c66c0bcbb42951ba147c66147650e364
  Bin ce8c88108b295f664e1eddaeffc220f4
  BinOp 64bb8ea1ee9f5a8f0460e13355fb6f83
  Block c8f6dc9d55c3b3cbc94e3fb30057f310
  Bound 52caa595feb141e1277ed2bd4771b161
  Con a93b732ad49402af2de80d19cc1ec61c
  Concat b413f6bfbbb9b2bcf8c82bee0a5a95d3
  Decl bf5604fd57dfb9f698111c9b30ee5605
  Decl e30f41d3f2effdd4b4a22fa8cf8c0055
  Div cf4bd6881ccd627392e1e8e1ed049580
  ESeq 6a34050ad6d9661fc16dd8420fa213a1
  Expr 6304956f2901eead56a8fac1e90d4904
  FSeq 779df6dd417159b80814ee837ce7e2c0
  For 5816e0af6d8df16d1771d2006bcf3abf
  Fortran cab0cd6287333175c6b9d87427982518
  If 70f325448a0ac0d3e601c0f9e1e99ec6
  Integer 8082a45204513974002220b5341d5b33
  Minus 83a81930ff6b28393feaec477bd960ce
  Mul d78a38debaadbefa8faf16070429adab
  Not ef9796084aacd0e0568ca31c6c5a182b
  Null 1580fcfff05ff5fc8ac22a76d8ac4e12
  NullExpr adfc15f00ad4bfbe033d167983c94995
  NullStmt ea47243779318c110f98776b706a62f7
  OpenCLBufferRead 9d6facba2ab5a4549c7d415b86d2a12f
  OpenCLBufferWrite fd57e16ab494e9f928a6973a79663ac9
  OpenCLMap e48fa1b14eab97eb69b2edc5f2c10ce8
  OpenCLReduce d14e8e442939b0e4bb37da5a0da04484
  Or e5382b608079e3dd86ef71ac28c83530
  Plus 18a4412d61780e28c85d747ab521c561
  Power f50c6075726b0342163df5e3a6e284dd
  ProgUnit 573fa2fe80c5713ab0c018712ac118d8
  Program 607f4435fb994a8c5b83bd9f7709b3c3
  Real efcfab18e0d8f1dbab722c8ce1c4fbc7
  RelEQ 111eeea484191a1666facdb41159ee35
  RelGE 673bc609ec0049e040c0dcddb45b97ef
  RelGT b744cd2b4251ef3c4f144872ecd35718
  RelLE f99123cc981a176cf81be7799ddce3ee
  RelLT 99f52e83374f4ebfeeb48496c9e98b9d
  RelNE 3ee0465e5f7743bf42dd42c339d808e7
  SrcLoc af6592465c21031ac12547ec948ff586
  SrcLoc 46c6d78d8d8ad90615ee6b6136237ffd
  SrcSpan 667dadf32292a4602702274000a648d8
  SubName 9b06404c654299d20e94c12ba761aaab
  SubName 3c0e7e5e2ace2b7b36167e7f447bc3f1
  Type 6b8210ea10d2538ca4598cfb9584c470
  UMinus cb540ba7408204e48292865b022765e9
  Unary 63556e06c16e9f5656f0a9e0a647971b
  Use 8c26fe492485a1d27d329f8234d19f1d
  Uses 8347678f6676bd3eacaa7f87ac9bd303
  Var 4b8ab01fc12afd12d9f52ad45e3004a1
  VarName a39ab087efdb6eba24247b07097f591c
  VarName 361ec85699986b0b7f4d68a05374d64d
  srcColumn 46c6d78d8d8ad90615ee6b6136237ffd
  srcFilename 46c6d78d8d8ad90615ee6b6136237ffd
  srcLine 46c6d78d8d8ad90615ee6b6136237ffd
  srcSpan c13b4efea655d094fcf2aa6fb6fdfaaf
import  -/  Language.Fortran.Parser 94f87e312918e2e0d84323268977b8af
  exports: 811e5416839040be903a08c9e7bce6b9
  parse 4f47ce38940aeed8d0824347f48e346f
import  -/  PreProcessor 41752a7f7f42cfa80c5ac68418b12326
  exports: 55307c0ab844f5316868ba7013faf129
  preProcess a51f4272d7304e45cccd40bb54b195d2
  removeBlankLines f162be19b405c1cd9d2ea8c494473e19
import  -/  Warning b5ec059e95d91647264308e84d2ed3ea
  exports: d9b5419f40dd7650497f479a7fe0214a
  warning 5c420cdeeb6016db8a4c66534ccbe9c7
import  -/  process-1.6.3.0:System.Process 17a215e760465e01e09a5bb6ca1a6adb
import  -/  syb-0.7:Data.Generics 2ddc257f9ac35414fc37ff4d19b4d388
import  -/  syb-0.7:Data.Generics.Aliases a5097c06261967df51d59247bf1d4958
import  -/  syb-0.7:Data.Generics.Schemes 58bc96c8ed0bed4ad53424f237efe8b8
3a5417a21e1d75c50012d87e077e9043
  $s$fDataExpr ::
    Data.Data.Data
      (Language.Fortran.Expr
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Expr
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ Language.Fortran.Expr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     Language.Fortran.$fDataExpr6
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ (Data.Map.Internal.Map [GHC.Types.Char])
                        @ [GHC.Base.String]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ Data.Map.Internal.Map
                           @ [GHC.Types.Char]
                           Data.Map.Internal.$fDataMap17
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ [GHC.Types.Char]
                           Data.Data.$fData[]3
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Expr
                                                                       (Data.Map.Internal.Map
                                                                          GHC.Base.String
                                                                          [GHC.Base.String])>_N)
                  (Language.Fortran.$fDataExpr_$cgfoldl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgunfold
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$ctoConstr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (\ (ds :: Language.Fortran.Expr
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   Language.Fortran.$tExpr)
                  (Language.Fortran.$fDataExpr_$cdataCast1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.Expr
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))))
                  (Language.Fortran.$fDataExpr1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Expr
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Expr
                               (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                  (Language.Fortran.$fDataExpr_$cgmapQl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgmapQr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgmapQ
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgmapQi
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgmapM
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgmapMp
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataExpr_$cgmapMo
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap) -}
7c781969e5e7be852433faa21e057419
  $s$fDataExpr_$s$fDataMap ::
    Data.Data.Data
      (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ (Data.Map.Internal.Map [GHC.Types.Char])
                     @ [GHC.Base.String]
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ (* -> *)
                        @ Data.Map.Internal.Map
                        @ [GHC.Types.Char]
                        Data.Map.Internal.$fDataMap17
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7))
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ [GHC.Types.Char]
                        Data.Data.$fData[]3
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7)))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Data.Map.Internal.Map
                                                                       [GHC.Types.Char]
                                                                       [GHC.Base.String]>_N)
                  (Data.Map.Internal.$fDataMap_$cgfoldl
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgunfold
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (\ (ds :: Data.Map.Internal.Map
                              [GHC.Types.Char] [GHC.Base.String]) ->
                   Data.Map.Internal.fromListConstr)
                  (\ (ds :: Data.Map.Internal.Map
                              [GHC.Types.Char] [GHC.Base.String]) ->
                   Data.Map.Internal.mapDataType)
                  (\ @ t :: * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d. Data.Data.Data d => c (t d)) ->
                   GHC.Base.Nothing
                     @ (c (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])))
                  (Data.Map.Internal.$fDataMap_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap6
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]>_R)
                  (Data.Map.Internal.$fDataMap_$cgmapQl
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapQr
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapQ
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapQi
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapM
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Internal.$fDataMap_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr_$s$fData[]
                     GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
36cb3fd193a860e4bf9ba84c6b6aba95
  $s$fDataExpr_$s$fData[] :: Data.Data.Data [[GHC.Types.Char]]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [[GHC.Types.Char]]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[[GHC.Types.Char]]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: [[GHC.Types.Char]]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [[GHC.Types.Char]]) -> Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c [[GHC.Types.Char]]))
                  (Data.Data.$fData[]_$cgmapT
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQr
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQ
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQi
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
ee8709015bdef12d38b27e2f7473a104
  $s$fDataFortran ::
    Data.Data.Data
      (Language.Fortran.Fortran
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Fortran
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ Language.Fortran.Fortran
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     Language.Fortran.$fDataFortran6
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ (Data.Map.Internal.Map [GHC.Types.Char])
                        @ [GHC.Base.String]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ Data.Map.Internal.Map
                           @ [GHC.Types.Char]
                           Data.Map.Internal.$fDataMap17
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ [GHC.Types.Char]
                           Data.Data.$fData[]3
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Fortran
                                                                       (Data.Map.Internal.Map
                                                                          GHC.Base.String
                                                                          [GHC.Base.String])>_N)
                  (Language.Fortran.$fDataFortran_$cgfoldl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgunfold
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$ctoConstr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (\ (ds :: Language.Fortran.Fortran
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   Language.Fortran.$tFortran)
                  (Language.Fortran.$fDataFortran_$cdataCast1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.Fortran
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))))
                  (Language.Fortran.$fDataFortran1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Fortran
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Fortran
                               (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                  (Language.Fortran.$fDataFortran_$cgmapQl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgmapQr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgmapQ
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgmapQi
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgmapM
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgmapMp
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataFortran_$cgmapMo
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap) -}
f65d33f790c08120ec2cd9cc527cf7be
  $s$fDataFortran5 ::
    Data.Typeable.Internal.TypeRep
      (Language.Fortran.Fortran
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Fortran
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   Language.Fortran.$fDataFortran6
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ (Data.Map.Internal.Map [GHC.Types.Char])
                      @ [GHC.Base.String]
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ (* -> *)
                         @ Data.Map.Internal.Map
                         @ [GHC.Types.Char]
                         Data.Map.Internal.$fDataMap17
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Types.Char
                            Data.Data.$fData[]3
                            Data.Data.$fDataChar7))
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ *
                         @ []
                         @ [GHC.Types.Char]
                         Data.Data.$fData[]3
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Types.Char
                            Data.Data.$fData[]3
                            Data.Data.$fDataChar7)))) -}
a07e15da308e4f30ef1578feba3a2236
  $s$fDataMap_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe
         (c (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]))
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t :: * -> * -> *
                   @ c :: * -> *
                   (w3 :: Data.Typeable.Internal.Typeable t) ->
                 Data.Map.Internal.$w$cdataCast2
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   Data.Data.$fData[]_$s$fData[]
                   LanguageFortranTools.$s$fDataExpr_$s$fData[]
                   @ t
                   @ c
                   w3) -}
3d6fb47856a73b2f97930b40deea6464
  $s$fDataProgUnit ::
    Data.Data.Data
      (Language.Fortran.ProgUnit
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.ProgUnit
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ Language.Fortran.ProgUnit
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     Language.Fortran.$fDataProgUnit6
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ (Data.Map.Internal.Map [GHC.Types.Char])
                        @ [GHC.Base.String]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ Data.Map.Internal.Map
                           @ [GHC.Types.Char]
                           Data.Map.Internal.$fDataMap17
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ [GHC.Types.Char]
                           Data.Data.$fData[]3
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ProgUnit
                                                                       (Data.Map.Internal.Map
                                                                          GHC.Base.String
                                                                          [GHC.Base.String])>_N)
                  (Language.Fortran.$fDataProgUnit_$cgfoldl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgunfold
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (\ (ds :: Language.Fortran.ProgUnit
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   case ds of wild {
                     Language.Fortran.Main ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cMain
                     Language.Fortran.Sub ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cSub
                     Language.Fortran.Function ds1 ds2 ds3 ds4 ds5 ds6 ds7
                     -> Language.Fortran.$cFunction
                     Language.Fortran.Module ds1 ds2 ds3 ds4 ds5 ds6 ds7
                     -> Language.Fortran.$cModule
                     Language.Fortran.BlockData ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cBlockData
                     Language.Fortran.PSeq ds1 ds2 ds3 ds4 -> Language.Fortran.$cPSeq
                     Language.Fortran.Prog ds1 ds2 ds3 -> Language.Fortran.$cProg
                     Language.Fortran.NullProg ds1 ds2 -> Language.Fortran.$cNullProg
                     Language.Fortran.IncludeProg ds1 ds2 ds3 ds4
                     -> Language.Fortran.$cIncludeProg })
                  (\ (ds :: Language.Fortran.ProgUnit
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                   Language.Fortran.$tProgUnit)
                  (Language.Fortran.$fDataProgUnit_$cdataCast1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.ProgUnit
                             (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))))
                  (Language.Fortran.$fDataProgUnit1
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ProgUnit
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ProgUnit
                               (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                  (Language.Fortran.$fDataProgUnit_$cgmapQl
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapQr
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapQ
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapQi
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapM
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapMp
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap)
                  (Language.Fortran.$fDataProgUnit_$cgmapMo
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr_$s$fDataMap) -}
6e2e1c7134b588c42b624f7967472ea6
  $s$fDataProgUnit5 ::
    Data.Typeable.Internal.TypeRep
      (Language.Fortran.ProgUnit
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ProgUnit
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   Language.Fortran.$fDataProgUnit6
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ (Data.Map.Internal.Map [GHC.Types.Char])
                      @ [GHC.Base.String]
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ (* -> *)
                         @ Data.Map.Internal.Map
                         @ [GHC.Types.Char]
                         Data.Map.Internal.$fDataMap17
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Types.Char
                            Data.Data.$fData[]3
                            Data.Data.$fDataChar7))
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ *
                         @ []
                         @ [GHC.Types.Char]
                         Data.Data.$fData[]3
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Types.Char
                            Data.Data.$fData[]3
                            Data.Data.$fDataChar7)))) -}
d2c57dceb7d6de0636381cad7114c83f
  $s$fData[]7 :: Data.Typeable.Internal.TypeRep [[GHC.Types.Char]]
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]3
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Types.Char
                      Data.Data.$fData[]3
                      Data.Data.$fDataChar7)) -}
e9b5278b23b4cc52ece0f844c4ab30f4
  $s$fEqExpr ::
    GHC.Classes.Eq
      (Language.Fortran.Expr
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Expr
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fEqArgList_$c==
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fEqExpr_$s$fEqMap)
                  LanguageFortranTools.$s$fEqExpr_$s$fEqExpr_$c/= -}
6925beac7ff3340ef0cc10d0d2ed73d0
  $s$fEqExpr_$s$fEqExpr_$c/= ::
    Language.Fortran.Expr
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.Expr
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.Fortran.Expr
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                   (y :: Language.Fortran.Expr
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                 case Language.Fortran.$fEqArgList_$c==
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        LanguageFortranTools.$s$fEqExpr_$s$fEqMap
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
74fa295b26a33b79aa3ca15e82d6f399
  $s$fEqExpr_$s$fEqMap ::
    GHC.Classes.Eq
      (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Map.Internal.$fEqMap_$c==
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]2)
                  LanguageFortranTools.$s$fEqExpr_$s$fEqMap_$c/= -}
496b3cdf1c6691853fe5525ac0eee2bd
  $s$fEqExpr_$s$fEqMap_$c/= ::
    Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                   (y :: Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]) ->
                 case Data.Map.Internal.$fEqMap_$c==
                        @ [GHC.Types.Char]
                        @ [GHC.Base.String]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        GHC.Classes.$fEq[]_$s$fEq[]2
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
99ce50118e0c29da8f48e672c3321266
  $s$fEqVarName ::
    GHC.Classes.Eq
      (Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.VarName
                       (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fEqVarName_$c==
                     @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fEqExpr_$s$fEqMap)
                  LanguageFortranTools.$s$fEqVarName_$s$fEqVarName_$c/= -}
531de9ec549d7a9e0ab1e80fd209ae74
  $s$fEqVarName_$s$fEqVarName_$c/= ::
    Language.Fortran.VarName
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.VarName
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.Fortran.VarName
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
                   (y :: Language.Fortran.VarName
                           (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])) ->
                 case x of wild { Language.Fortran.VarName a1 a2 ->
                 case y of wild1 { Language.Fortran.VarName b1 b2 ->
                 case Data.Map.Internal.$fEqMap_$c==
                        @ [GHC.Types.Char]
                        @ [GHC.Base.String]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        GHC.Classes.$fEq[]_$s$fEq[]2
                        a1
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
a1beb7a7d5f32acb65171ce182bd75c9
  $s$fShowExpr_$cshowsPrec_$s$fShowMap ::
    GHC.Show.Show
      (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Map.Internal.$fShowMap_$cshowsPrec
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Show.$fShow[]_$s$fShow[]2)
                  (\ (x :: Data.Map.Internal.Map
                             [GHC.Types.Char] [GHC.Base.String]) ->
                   Data.Map.Internal.$fShowMap_$cshowsPrec
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     GHC.Show.$fShow[]_$s$fShow[]1
                     GHC.Show.$fShow[]_$s$fShow[]2
                     Data.Map.Internal.$fDataMap3
                     x
                     (GHC.Types.[] @ GHC.Types.Char))
                  (\ (ls :: [Data.Map.Internal.Map
                               [GHC.Types.Char] [GHC.Base.String]])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                     (Data.Map.Internal.$fShowMap_$cshowsPrec
                        @ [GHC.Types.Char]
                        @ [GHC.Base.String]
                        GHC.Show.$fShow[]_$s$fShow[]1
                        GHC.Show.$fShow[]_$s$fShow[]2
                        Data.Map.Internal.$fDataMap3)
                     ls
                     s) -}
e60a415dd0726985f4314df610860ce6
  $s$fShowMap_$cshow ::
    Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Map.Internal.Map
                           [GHC.Types.Char] [GHC.Base.String]) ->
                 Data.Map.Internal.$fShowMap_$cshowsPrec
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   GHC.Show.$fShow[]_$s$fShow[]1
                   GHC.Show.$fShow[]_$s$fShow[]2
                   Data.Map.Internal.$fDataMap3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ca254a5bb77507fa1dc22a7390eedaef
  $s$fShowMap_$cshowList ::
    [Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Data.Map.Internal.Map
                             [GHC.Types.Char] [GHC.Base.String]])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String])
                   (Data.Map.Internal.$fShowMap_$cshowsPrec
                      @ [GHC.Types.Char]
                      @ [GHC.Base.String]
                      GHC.Show.$fShow[]_$s$fShow[]1
                      GHC.Show.$fShow[]_$s$fShow[]2
                      Data.Map.Internal.$fDataMap3)
                   ls
                   s) -}
bc2deca90b12c40a8e7d28c505102cbb
  $s$fShowMap_$cshowsPrec ::
    GHC.Types.Int
    -> Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w2 :: GHC.Types.Int)
                   (w3 :: Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Data.Map.Internal.$w$cshowsPrec
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   GHC.Show.$fShow[]_$s$fShow[]1
                   GHC.Show.$fShow[]_$s$fShow[]2
                   ww1
                   w3 }) -}
671159aeb8b78003fefaa23790f72bbf
  $sdelete_$sgo13 ::
    GHC.Base.String
    -> Data.Map.Internal.Map GHC.Base.String a1
    -> Data.Map.Internal.Map GHC.Base.String a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
b2fb45e895f2c8a2d2d957536af44a96
  $sfindWithDefault1 ::
    a
    -> GHC.Base.String -> Data.Map.Internal.Map GHC.Base.String a -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><S,1*U><S,1*U> -}
af1825defbc9faa993e4df4e91fbd823
  $sfromList ::
    [(GHC.Base.String, a)] -> Data.Map.Internal.Map GHC.Base.String a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(GHC.Base.String, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Internal.Tip @ GHC.Base.String @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Internal.Bin
                             @ GHC.Base.String
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Internal.Tip @ GHC.Base.String @ a)
                             (Data.Map.Internal.Tip @ GHC.Base.String @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                LanguageFortranTools.$sfromList_$spoly_go14
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Internal.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Internal.Tip @ GHC.Base.String @ a)) }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                LanguageFortranTools.$sfromList_$s$wpoly_go13
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Internal.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Internal.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Internal.Tip @ GHC.Base.String @ a))
                                  1# } } } } } }) -}
2815f239be0131b9e5d0cad9fde8661a
  $sfromList_$s$wpoly_go13 ::
    [GHC.Types.Char]
    -> a
    -> [([GHC.Types.Char], a)]
    -> Data.Map.Internal.Map [GHC.Types.Char] a
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map GHC.Base.String a
  {- Arity: 5, Strictness: <S,U><L,U><S,1*U><S,1*U><L,U> -}
43d839bda7fab64bc71868f12e268096
  $sfromList_$spoly_go14 ::
    [GHC.Types.Char]
    -> a
    -> [([GHC.Types.Char], a)]
    -> Data.Map.Internal.Map [GHC.Types.Char] a
    -> Data.Map.Internal.Map GHC.Base.String a
  {- Arity: 4, Strictness: <S,U><L,U><S,1*U><S,1*U> -}
b275305ca36bd5342b2feb585daf87b9
  $sinsert_$sgo13 ::
    GHC.Base.String
    -> GHC.Base.String
    -> a1
    -> Data.Map.Internal.Map GHC.Base.String a1
    -> Data.Map.Internal.Map GHC.Base.String a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
50e83250ddd096b6cb68685f28ddd1a4
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Internal.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
1c7439203adc84e05ca1315fde0bfb71
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   LanguageFortranTools.$trModule3
                   LanguageFortranTools.$trModule1) -}
07f4dd1da5990d5e7a6d15e1b1e6d665
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LanguageFortranTools.$trModule2) -}
3a3392455b2af6406792c5f0430f3141
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LanguageFortranTools"#) -}
978d664c8ff4bda2f02106f77ade2c74
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LanguageFortranTools.$trModule4) -}
41c0b9f842c1a5db3b62c3f8b1270f60
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
4c2d3f0d49de936a030b9595a19d8b2e
  $wcheckSrcLocBefore ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.False 1# -> GHC.Classes.ltInt ww1 ww3 }
                   1# -> GHC.Types.True }) -}
5b75bdb3bfaf71e81c25958f99142887
  $wcheckSrcSpanAfter ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.># ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.False 1# -> GHC.Classes.gtInt ww1 ww3 }
                   1# -> GHC.Types.True }) -}
bea5227123bf7a9cac89ff0c75060f32
  $wcheckSrcSpanContainsSrcSpan ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: GHC.Prim.Int#)
                   (ww5 :: GHC.Types.Int)
                   (ww6 :: GHC.Types.Int)
                   (ww7 :: GHC.Types.Int) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case ww2 of wild { GHC.Types.I# x ->
                     case ww6 of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.># x y of lwild {
                       DEFAULT
                       -> case GHC.Prim.==# x y of lwild1 {
                            DEFAULT -> GHC.Types.False 1# -> GHC.Classes.gtInt ww3 ww7 }
                       1# -> GHC.Types.True } } }
                 } in
                 case GHC.Prim.<# ww ww4 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww4 of lwild1 {
                        DEFAULT -> GHC.Types.False
                        1#
                        -> case ww1 of wild { GHC.Types.I# x ->
                           case ww5 of wild1 { GHC.Types.I# y ->
                           case GHC.Prim.<# x y of lwild2 {
                             DEFAULT -> GHC.Types.False 1# -> $j } } } }
                   1# -> $j }) -}
72b95f5658a037edd0f0d0ab7b128b51
  $werrorLocationFormatting ::
    GHC.Prim.Int#
    -> GHC.Types.Int -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        ww
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 case GHC.Base.++_$s++
                        @ GHC.Types.Char
                        (GHC.CString.unpackAppendCString#
                           LanguageFortranTools.errorLocationFormatting1
                           (case ww1 of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   ww3
                                   (GHC.Types.[] @ GHC.Types.Char) of ww8 { (#,#) ww9 ww10 ->
                            GHC.Types.: @ GHC.Types.Char ww9 ww10 } }))
                        ww5
                        ww6 of ww2 { : ww3 ww7 ->
                 (# ww3, ww7 #) } }) -}
ba015dcde92e79cd4b413e7d0137ada7
  $werrorLocationRangeFormatting ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   LanguageFortranTools.errorLocationRangeFormatting2
                   (case ww of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++_$s++
                      @ GHC.Types.Char
                      (GHC.CString.unpackAppendCString#
                         LanguageFortranTools.errorLocationRangeFormatting1
                         (case ww1 of ww8 { GHC.Types.I# ww9 ->
                          case GHC.Show.$wshowSignedInt
                                 0#
                                 ww9
                                 (GHC.Types.[] @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                          GHC.Types.: @ GHC.Types.Char ww11 ww12 } }))
                      ww5
                      ww6 } })) -}
628cbf664944519a3b61d4918fc2161b
  $wextractAssigneeFromDecl ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Language.Fortran.Decl
                           LanguageFortranTools.Anno) ->
                 case w of wild {
                   DEFAULT
                   -> case LanguageFortranTools.extractAssigneeFromDecl1
                      ret_ty (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
                      of {}
                   Language.Fortran.Decl anno src lst typ
                   -> case lst of wild1 {
                        []
                        -> case GHC.List.badHead
                           ret_ty (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
                           of {}
                        : x ds1
                        -> case x of wild2 { (,,) x1 ds ds2 ->
                           case x1 of wild3 {
                             DEFAULT
                             -> case GHC.List.badHead
                                ret_ty (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
                                of {}
                             Language.Fortran.Var ds3 ds4 lst1
                             -> LanguageFortranTools.extractAssigneeFromDecl_go lst1 } } } }) -}
6d29f7798ee2c7cd7f3b6866d3dc4be5
  $wextractContainedOperands ::
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Expr p) ->
                 case w of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.Expr p)
                   Language.Fortran.Var ds ds1 lst
                   -> LanguageFortranTools.extractContainedOperands1
                        @ p
                        lst
                        (GHC.Types.[] @ (Language.Fortran.Expr p)) }) -}
94c17ef391ec40c0e4cb9a30cb4abaf7
  $wextractContainedVarsWV ::
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Expr p) ->
                 case w of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.Expr p)
                   Language.Fortran.Var ds ds1 lst
                   -> LanguageFortranTools.extractContainedVarsWV1
                        @ p
                        lst
                        (GHC.Types.[] @ (Language.Fortran.Expr p)) }) -}
32817a47c71ccd8e47b1bdde1971fa96
  $wextractOperands ::
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
1c7bf0f92ed673f7040f76b145c8bc20
  $wgo :: [[GHC.Types.Char]] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
2badbecc527ccd5586898ab2d90dbeef
  $wgo1 ::
    [([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))]
    -> (# [[GHC.Base.String]],
          [(GHC.Base.String, [GHC.Base.String])] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
f8f461929883d04963a241a1e8b42d48
  $wgo_up :: GHC.Prim.Int# -> GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U>, Inline: [0] -}
b7a887a02eb6cd8c0af7a56abd8a98a2
  $wlistCountAppearances ::
    GHC.Classes.Eq a => a -> [a] -> GHC.Prim.Int#
  {- Arity: 3, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Classes.Eq a) (w1 :: a) (w2 :: [a]) ->
                 case w2 of wild {
                   []
                   -> case LanguageFortranTools.listCountAppearances1
                      ret_ty GHC.Prim.Int#
                      of {}
                   : x ds
                   -> case ds of wild1 {
                        []
                        -> case GHC.Classes.== @ a w w1 x of wild2 {
                             GHC.Types.False -> 0# GHC.Types.True -> 1# }
                        : ipv ipv1
                        -> case GHC.Classes.== @ a w w1 x of wild2 {
                             GHC.Types.False
                             -> LanguageFortranTools.listCountAppearances_$s$wlistCountAppearances
                                  @ a
                                  ipv
                                  ipv1
                                  w1
                                  w
                             GHC.Types.True
                             -> case LanguageFortranTools.listCountAppearances_$s$wlistCountAppearances
                                       @ a
                                       ipv
                                       ipv1
                                       w1
                                       w of ww { DEFAULT ->
                                GHC.Prim.+# 1# ww } } } }) -}
bbc4c88f65591386be9d842e7ca0b347
  $wpreProcessingHelper ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, LanguageFortranTools.CodeStash,
           LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>, Inline: [0] -}
512ea78c905245aa4e360807a1942bde
  $wreplaceVarname ::
    LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U(U,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: LanguageFortranTools.Anno)
                   (ww1 :: Language.Fortran.Variable)
                   (w :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (ww2 :: LanguageFortranTools.Anno)
                   (ww3 :: Language.Fortran.Variable) ->
                 case LanguageFortranTools.replaceVarname1 ww ww2 of wild {
                   GHC.Types.False
                   -> Language.Fortran.VarName @ LanguageFortranTools.Anno ww2 ww3
                   GHC.Types.True
                   -> case GHC.Base.eqString ww1 ww3 of wild1 {
                        GHC.Types.False
                        -> Language.Fortran.VarName @ LanguageFortranTools.Anno ww2 ww3
                        GHC.Types.True -> w } }) -}
ce041ee40f75f945365327daeaa2fee3
  $wsrcSpanInSrcSpan ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: GHC.Prim.Int#)
                   (ww5 :: GHC.Types.Int)
                   (ww6 :: GHC.Types.Int)
                   (ww7 :: GHC.Types.Int) ->
                 let {
                   $j :: GHC.Types.Bool <join 0>
                   = case ww6 of wild { GHC.Types.I# x ->
                     case ww2 of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.<# x y of lwild {
                       DEFAULT
                       -> case GHC.Prim.==# x y of lwild1 {
                            DEFAULT -> GHC.Types.False 1# -> GHC.Classes.leInt ww7 ww3 }
                       1# -> GHC.Types.True } } }
                 } in
                 case GHC.Prim.># ww4 ww of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww4 ww of lwild1 {
                        DEFAULT -> GHC.Types.False
                        1#
                        -> case ww5 of wild { GHC.Types.I# x ->
                           case ww1 of wild1 { GHC.Types.I# y ->
                           case GHC.Prim.>=# x y of lwild2 {
                             DEFAULT -> GHC.Types.False 1# -> $j } } } }
                   1# -> $j }) -}
59336c2252f0a935e0168e65532082ca
  $wtakeLast :: GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 2, Strictness: <S,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: GHC.Prim.Int#) (w :: [a]) ->
                 case GHC.Prim.<# 0# ww of lwild {
                   DEFAULT -> LanguageFortranTools.takeLast1 @ a
                   1#
                   -> GHC.List.reverse1
                        @ a
                        (GHC.List.$wunsafeTake
                           @ a
                           ww
                           (GHC.List.reverse1 @ a w (GHC.Types.[] @ a)))
                        (GHC.Types.[] @ a) }) -}
1420203ed9c39fcf982d2ff37c01ae68
  type Anno = Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]
1c29ea8ff443013115e90c4ff359e69e
  type CodeStash =
    Data.Map.Internal.Map GHC.Types.Int [GHC.Base.String]
364600a9c3152b88c1d8dd54bf6543e7
  type ModuleVarsTable =
    Data.Map.Internal.Map GHC.Base.String GHC.Base.String
50dc4c0e6bda2c24d460032a03e4911d
  type ValueTable =
    Data.Map.Internal.Map
      GHC.Base.String
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
ebe16abefb71726b98c3ab840251a413
  addImplicitNone :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (contentLines :: [GHC.Base.String]) ->
                 LanguageFortranTools.addImplicitNone_$s$wgo
                   (GHC.Types.[] @ GHC.Base.String)
                   (GHC.Types.[] @ GHC.Base.String)
                   contentLines) -}
ca30ed94fdaae5e4f41c10d97c5b43fe
  addImplicitNone_$s$wgo ::
    [[GHC.Types.Char]]
    -> [[GHC.Types.Char]] -> [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
988d13887971f4a96c87369ec2d95570
  addToValueTable ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> GHC.Types.Float
    -> LanguageFortranTools.ValueTable
    -> LanguageFortranTools.ValueTable
  {- Arity: 3, Strictness: <S(LS),1*U(A,U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (var :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (value :: GHC.Types.Float)
                   (table :: LanguageFortranTools.ValueTable) ->
                 let {
                   kx0 :: GHC.Base.String
                   = case var of wild { Language.Fortran.VarName ds str -> str }
                 } in
                 LanguageFortranTools.$sinsert_$sgo13
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   kx0
                   kx0
                   (value, LanguageFortranTools.addToValueTable1)
                   table) -}
1c556cedfe688d1ec37ecb78727ff8cf
  addToValueTable1 ::
    Language.Fortran.BaseType LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Language.Fortran.Real
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
e8e9923814c648412a3aa91a830906d9
  addToValueTable_type ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> GHC.Types.Float
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
    -> LanguageFortranTools.ValueTable
    -> LanguageFortranTools.ValueTable
  {- Arity: 4, Strictness: <S(LS),1*U(A,U)><L,U><L,U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ (var :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (value :: GHC.Types.Float)
                   (typ :: Language.Fortran.BaseType LanguageFortranTools.Anno)
                   (table :: LanguageFortranTools.ValueTable) ->
                 let {
                   kx0 :: GHC.Base.String
                   = case var of wild { Language.Fortran.VarName ds str -> str }
                 } in
                 LanguageFortranTools.$sinsert_$sgo13
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   kx0
                   kx0
                   (value, typ)
                   table) -}
0cb1dda6325719e67f26de8d69e9d691
  appendAnnotation ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.String
    -> GHC.Base.String
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: (\ (original :: Language.Fortran.Fortran
                                  LanguageFortranTools.Anno)
                   (key :: GHC.Base.String)
                   (appendage :: GHC.Base.String) ->
                 case original of wild {
                   DEFAULT -> wild
                   Language.Fortran.For anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.For
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        (LanguageFortranTools.appendAnnotation_$sappendToMap
                           @ [GHC.Types.Char]
                           key
                           appendage
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLMap anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.OpenCLMap
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        (LanguageFortranTools.appendAnnotation_$sappendToMap
                           @ [GHC.Types.Char]
                           key
                           appendage
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLReduce anno f2 f3 f4 f5 f6 f7 f8
                   -> Language.Fortran.OpenCLReduce
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        (LanguageFortranTools.appendAnnotation_$sappendToMap
                           @ [GHC.Types.Char]
                           key
                           appendage
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                        f8 }) -}
ee537cc463d095f0ff74fab8c4ae637b
  appendAnnotationList ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (original :: Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (key :: GHC.Base.String)
                   (appendage :: [GHC.Base.String]) ->
                 letrec {
                   go9 :: [GHC.Base.String]
                          -> Language.Fortran.Fortran LanguageFortranTools.Anno
                          -> Language.Fortran.Fortran LanguageFortranTools.Anno
                     <join 2> {- Arity: 2 -}
                   = \ (ds :: [GHC.Base.String])
                       (eta :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go9 ys (LanguageFortranTools.appendAnnotation eta key y) }
                 } in
                 go9 appendage original) -}
50267667683b6ec2d29dd181c59a4fea
  appendAnnotationMap ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno)
                   (newMap :: LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT -> LanguageFortranTools.appendAnnotationMap2
                   Language.Fortran.For anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.For
                        @ LanguageFortranTools.Anno
                        (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                           @ [GHC.Types.Char]
                           newMap
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLMap anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.OpenCLMap
                        @ LanguageFortranTools.Anno
                        (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                           @ [GHC.Types.Char]
                           newMap
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLReduce anno f2 f3 f4 f5 f6 f7 f8
                   -> Language.Fortran.OpenCLReduce
                        @ LanguageFortranTools.Anno
                        (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                           @ [GHC.Types.Char]
                           newMap
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                        f8 }) -}
d5f855c53727210edc683c3f42cdc847
  appendAnnotationMap1 ::
    (Data.Map.Internal.Map GHC.Base.String [a]
     -> Data.Map.Internal.Map GHC.Base.String [a])
    -> Data.Map.Internal.Map GHC.Base.String [a]
    -> Data.Map.Internal.Map GHC.Base.String [a]
    -> Data.Map.Internal.Map GHC.Base.String [a]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
8cba0ccb49a9d7d53c12d008bf795463
  appendAnnotationMap2 ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Strictness: x -}
4569d6538a320ad93e286a5c40ce2e80
  appendAnnotationMap_$scombineMaps ::
    Data.Map.Internal.Map GHC.Base.String [a]
    -> Data.Map.Internal.Map GHC.Base.String [a]
    -> Data.Map.Internal.Map GHC.Base.String [a]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   (map1 :: Data.Map.Internal.Map GHC.Base.String [a])
                   (map2 :: Data.Map.Internal.Map GHC.Base.String [a]) ->
                 LanguageFortranTools.appendAnnotationMap1
                   @ a
                   (GHC.Base.id @ (Data.Map.Internal.Map GHC.Base.String [a]))
                   map2
                   map1) -}
8357f2f0057c2f2974d11a9d4d104164
  appendAnnotation_$sappendToMap ::
    GHC.Base.String
    -> a
    -> Data.Map.Internal.Map GHC.Base.String [a]
    -> Data.Map.Internal.Map GHC.Base.String [a]
  {- Arity: 3, Strictness: <S,U><L,U><S,U>,
     Unfolding: (\ @ a
                   (key :: GHC.Base.String)
                   (item :: a)
                   (map :: Data.Map.Internal.Map GHC.Base.String [a]) ->
                 LanguageFortranTools.$sinsert_$sgo13
                   @ [a]
                   key
                   key
                   (GHC.Base.++
                      @ a
                      (LanguageFortranTools.$sfindWithDefault1
                         @ [a]
                         (GHC.Types.[] @ a)
                         key
                         map)
                      (GHC.Types.: @ a item (GHC.Types.[] @ a)))
                   map) -}
a4e0a6baa3b66014183e44ccf0a12047
  appendFortran_recursive ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
77a73b9bc695373ab2fcd5b66619a1a4
  appendToMap ::
    GHC.Classes.Ord k =>
    k
    -> a -> Data.Map.Internal.Map k [a] -> Data.Map.Internal.Map k [a]
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,U><L,U><S,U>,
     Unfolding: (\ @ k
                   @ a
                   ($dOrd :: GHC.Classes.Ord k)
                   (key :: k)
                   (item :: a)
                   (map :: Data.Map.Internal.Map k [a]) ->
                 Data.Map.Internal.insert
                   @ k
                   @ [a]
                   $dOrd
                   key
                   (GHC.Base.++
                      @ a
                      (Data.Map.Internal.findWithDefault
                         @ k
                         @ [a]
                         $dOrd
                         (GHC.Types.[] @ a)
                         key
                         map)
                      (GHC.Types.: @ a item (GHC.Types.[] @ a)))
                   map) -}
c887472fe8f7b8f174b1bbcd7a24b63d
  applyGeneratedSrcSpans ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a :: * -> *
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno)) ->
                 Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans1
                   @ (a LanguageFortranTools.Anno)
                   $dData) -}
cbc3e434615b7b8cc4d5b984225caacf
  applyGeneratedSrcSpans1 :: Data.Data.Data a => a -> a
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) ->
                 case LanguageFortranTools.applyGeneratedSrcSpans2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.id @ a
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.id @ a
                        1#
                        -> LanguageFortranTools.standardiseSrcSpan
                             `cast`
                           (UnsafeCo representational Language.Fortran.SrcSpan a
                            ->_R UnsafeCo representational Language.Fortran.SrcSpan a) } } } }) -}
17b3b47fc07af08a8bab4c23e4192cac
  applyGeneratedSrcSpans2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> * -> *)
                        @ (,)
                        3966139188614386852##
                        2108306554504130472##
                        GHC.Tuple.$trModule
                        GHC.Tuple.$tc(,)1
                        0#
                        GHC.Types.krep$*->*->*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ Language.Fortran.SrcSpan
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ ((,) Language.Fortran.SrcLoc)
                      @ Language.Fortran.SrcLoc
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ (* -> *)
                         @ (,)
                         @ Language.Fortran.SrcLoc
                         (Data.Typeable.Internal.TrTyCon
                            @ (* -> * -> *)
                            @ (,)
                            ww8
                            ww9
                            ww10
                            ww11
                            ww12)
                         LanguageFortranTools.applyGeneratedSrcSpans3)
                      LanguageFortranTools.applyGeneratedSrcSpans3) }) -}
9b1580ea7fa26f13ed87ca509fc073a1
  applyGeneratedSrcSpans3 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.SrcLoc
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ *
                        @ Language.Fortran.SrcLoc
                        3748651587269198497##
                        6830777199461934499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSrcLoc8
                        0#
                        GHC.Types.krep$*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ *
                   @ Language.Fortran.SrcLoc
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
c7571cf37d30d0ff08b830a9b642f4d0
  applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Unfolding: (Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans1
                   @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataExpr) -}
d1c4d7fdabc9d5d154fb6d9b3c9fb4e2
  applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1 ::
    Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
  {- Unfolding: (Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans1
                   @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataProgUnit) -}
236f8d89fb4f5de1f2fdf4c50b5a3b3a
  applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2 ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Unfolding: (Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans1
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran) -}
69c87933226710060b7879a0f4ffe714
  applyGlobalSrcSpan ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    Language.Fortran.SrcSpan
    -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U)><L,U>,
     Unfolding: (\ @ a :: * -> *
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (srcSpan :: Language.Fortran.SrcSpan)
                   (codeSeg :: a LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True)
                                   (\ (current :: Language.Fortran.SrcSpan) -> srcSpan) -}
                   = \ (current :: Language.Fortran.SrcSpan) -> srcSpan
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.applyGeneratedSrcSpans2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ a1
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ a1
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a1
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a1) } } } })
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   codeSeg) -}
a821fb3009dbfbb7d0be440f52bdf5c5
  applySrcSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (src :: Language.Fortran.SrcSpan)
                   (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> LanguageFortranTools.applySrcSpan1
                   Language.Fortran.OpenCLMap anno ds1 read written loopvs iterloopvs fortran
                   -> Language.Fortran.OpenCLMap
                        @ LanguageFortranTools.Anno
                        anno
                        src
                        read
                        written
                        loopvs
                        iterloopvs
                        fortran
                   Language.Fortran.OpenCLReduce anno ds1 read written loopvs iterloopvs rvs fortran
                   -> Language.Fortran.OpenCLReduce
                        @ LanguageFortranTools.Anno
                        anno
                        src
                        read
                        written
                        loopvs
                        iterloopvs
                        rvs
                        fortran }) -}
a09ec1d78572dc1964bac6b220677e2c
  applySrcSpan1 :: Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Strictness: x -}
e60527f39c486756f2c7f90a90e6c660
  checkSrcLocBefore ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)L),1*U(A,1*U(U),1*U(U))><S(LS(S)L),1*U(A,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcLoc)
                   (w1 :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 case ww2 of ww4 { GHC.Types.I# ww5 ->
                 case w1 of ww6 { Language.Fortran.SrcLoc ww7 ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 LanguageFortranTools.$wcheckSrcLocBefore
                   ww5
                   ww3
                   ww11
                   ww9 } } } }) -}
9372d129218dd9bc19618b6b97c610a9
  checkSrcLocEqualLines ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)L),1*U(A,1*U(U),A)><S(LS(S)L),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Language.Fortran.SrcLoc)
                   (ds1 :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds2 l1 ds3 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc ds4 l2 ds5 ->
                 GHC.Classes.eqInt l1 l2 } }) -}
fa8dc93cd7f3d507f6e84c6e36c68aed
  checkSrcSpanAfter ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)><S(LS(LS(S)L)),1*U(A,1*U(A,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case w1 of ww9 { (,) ww10 ww11 ->
                 case ww11 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                 case ww14 of ww16 { GHC.Types.I# ww17 ->
                 LanguageFortranTools.$wcheckSrcSpanAfter
                   ww8
                   ww6
                   ww17
                   ww15 } } } } } }) -}
5147f615e784e745818778fbeb5abdf7
  checkSrcSpanBefore ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LS(S)L)),1*U(A,1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case w1 of ww9 { (,) ww10 ww11 ->
                 case ww10 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                 case ww14 of ww16 { GHC.Types.I# ww17 ->
                 LanguageFortranTools.$wcheckSrcLocBefore
                   ww8
                   ww6
                   ww17
                   ww15 } } } } } }) -}
f92e64a1107f1ea3da20018cf98eb008
  checkSrcSpanBefore_line ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),A),A)><S(S(LS(S)L)L),1*U(1*U(A,1*U(U),A),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                   (ds1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds2 beforeEnd ->
                 case ds2 of wild1 { Language.Fortran.SrcLoc file_before line_before column_before ->
                 case ds1 of wild2 { (,) ds3 afterEnd ->
                 case ds3 of wild3 { Language.Fortran.SrcLoc file_after line_after column_after ->
                 GHC.Classes.ltInt line_before line_after } } } }) -}
b880d4b946ba7a946a3ef7ff54fe2cf3
  checkSrcSpanContainsSrcSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case ww2 of ww9 { Language.Fortran.SrcLoc ww10 ww11 ww12 ->
                 case w1 of ww13 { (,) ww14 ww15 ->
                 case ww14 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                 case ww18 of ww20 { GHC.Types.I# ww21 ->
                 case ww15 of ww22 { Language.Fortran.SrcLoc ww23 ww24 ww25 ->
                 LanguageFortranTools.$wcheckSrcSpanContainsSrcSpan
                   ww8
                   ww6
                   ww11
                   ww12
                   ww21
                   ww19
                   ww24
                   ww25 } } } } } } } }) -}
bd18cf823eef8367746cfe801f0e9d2f
  combineAnnotations ::
    LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno -> LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                   @ [GHC.Types.Char]) -}
7a416190dd312c66ab0c5e1e6c977d9b
  combineMaps ::
    GHC.Classes.Ord k =>
    Data.Map.Internal.Map k [a]
    -> Data.Map.Internal.Map k [a] -> Data.Map.Internal.Map k [a]
  {- Arity: 3, Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U>,
     Unfolding: (\ @ k
                   @ a
                   ($dOrd :: GHC.Classes.Ord k)
                   (map1 :: Data.Map.Internal.Map k [a])
                   (map2 :: Data.Map.Internal.Map k [a]) ->
                 letrec {
                   go13 :: (Data.Map.Internal.Map k [a]
                            -> Data.Map.Internal.Map k [a])
                           -> Data.Map.Internal.Map k [a]
                           -> Data.Map.Internal.Map k [a]
                           -> Data.Map.Internal.Map k [a]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: Data.Map.Internal.Map k [a]
                              -> Data.Map.Internal.Map k [a])
                       (ds :: Data.Map.Internal.Map k [a]) ->
                     case ds of wild {
                       Data.Map.Internal.Bin dt kx x l r
                       -> go13
                            (let {
                               xs :: Data.Map.Internal.Map k [a] -> Data.Map.Internal.Map k [a]
                               = go13 z' r
                             } in
                             \ (eta :: Data.Map.Internal.Map k [a]) ->
                             xs
                               (Data.Map.Internal.insert
                                  @ k
                                  @ [a]
                                  $dOrd
                                  kx
                                  (GHC.Base.++
                                     @ a
                                     (Data.Map.Internal.findWithDefault
                                        @ k
                                        @ [a]
                                        $dOrd
                                        (GHC.Types.[] @ a)
                                        kx
                                        eta)
                                     x)
                                  eta))
                            l
                       Data.Map.Internal.Tip -> z' }
                 } in
                 go13 (GHC.Base.id @ (Data.Map.Internal.Map k [a])) map2 map1) -}
a1809b3eac0161e3eb38096b43673ea6
  commentSeparator :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (str :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   LanguageFortranTools.commentSeparator7
                   (case str of wild {
                      [] -> LanguageFortranTools.commentSeparator6
                      : ipv ipv1
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           (LanguageFortranTools.commentSeparator'
                              (GHC.CString.unpackAppendCString#
                                 LanguageFortranTools.commentSeparator5
                                 (GHC.Base.++_$s++
                                    @ GHC.Types.Char
                                    LanguageFortranTools.commentSeparator4
                                    ipv
                                    ipv1))
                              LanguageFortranTools.commentSeparator3)
                           LanguageFortranTools.commentSeparator1 })) -}
ffcb45ed710f6161c1d47c44f311db0f
  commentSeparator' ::
    GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
9db2994d1314036542e9f0a80505972c
  commentSeparator1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.commentSeparator2) -}
cb37b4ef30d67601f04a954e121edfc7
  commentSeparator2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
3946c95f3ca2b132992f7b1b31a16285
  commentSeparator3 :: [GHC.Types.Char]
  {- Unfolding: (LanguageFortranTools.$wgo_up 45# 122#) -}
cf0714949f0c7eeef3f2452674d7ce87
  commentSeparator4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.commentSeparator5) -}
751045168607c1923041d3920bb432dd
  commentSeparator5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" "#) -}
66f5f0cac728257c544fc4c0d9d0ce71
  commentSeparator6 :: [GHC.Types.Char]
  {- Unfolding: (case LanguageFortranTools.commentSeparator3 of wild {
                   []
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.[] @ GHC.Types.Char)
                        LanguageFortranTools.commentSeparator1
                   : ds seps
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        seps
                        LanguageFortranTools.commentSeparator1 }) -}
f6ac67234b0d05ee0506040efbb58fdd
  commentSeparator7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("! ----"#) -}
716783fc2180cf5d40b0847b268cbee2
  compilerName :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.compilerName1) -}
00f674767c253eca0c866f0ebedb09dc
  compilerName1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ParallelFortran"#) -}
1447a72f813f73fb801851722b963123
  deleteValueFromTable ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> LanguageFortranTools.ValueTable
    -> LanguageFortranTools.ValueTable
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (var :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (table :: LanguageFortranTools.ValueTable) ->
                 case var of wild { Language.Fortran.VarName ds str ->
                 LanguageFortranTools.$sdelete_$sgo13
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   str
                   table }) -}
9c9c0273432833def2860c2509392832
  errorLocationFormatting ::
    Language.Fortran.SrcSpan -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)>m2,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case LanguageFortranTools.$werrorLocationFormatting
                        ww8
                        ww6 of ww9 { (#,#) ww10 ww11 ->
                 GHC.Types.: @ GHC.Types.Char ww10 ww11 } } } }) -}
63905977de809e42e64f59146d7712eb
  errorLocationFormatting1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
14d10c29e040d752f90d6fabf010a1d3
  errorLocationRangeFormatting ::
    Language.Fortran.SrcSpan -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SS),1*U(1*U(A,1*U(U),A),1*U(A,1*U(U),A))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww2 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                 LanguageFortranTools.$werrorLocationRangeFormatting
                   ww5
                   ww9 } } }) -}
c985f6c0324178e3e18cb55b25a5f3c4
  errorLocationRangeFormatting1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" and line "#) -}
f84e1b264cd84c5a1287c8d2aadd5310
  errorLocationRangeFormatting2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("line "#) -}
c54884e87e53218b60fc85f5486fa9d3
  evaluateExpr ::
    LanguageFortranTools.ValueTable
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe GHC.Types.Float
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (vt :: LanguageFortranTools.ValueTable)
                   (expr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.evaluateExpr_type vt expr of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Float
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) val ds1 ->
                      GHC.Base.Just @ GHC.Types.Float val } }) -}
a6597bc9b375b42ce8997c5597e3968a
  evaluateExpr_type ::
    LanguageFortranTools.ValueTable
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
ef0f926a60f9ccf7c9bed0514458aed2
  evaluateRange ::
    LanguageFortranTools.ValueTable
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe [GHC.Types.Float]
  {- Arity: 4, Strictness: <L,U><S,1*U><L,1*U><L,1*U>,
     Unfolding: (\ (vt :: LanguageFortranTools.ValueTable)
                   (startExpr :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (endExpr :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (stepExpr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.evaluateExpr_type vt startExpr of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Float]
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) val ds1 ->
                      case LanguageFortranTools.evaluateExpr_type vt endExpr of wild2 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Float]
                        GHC.Base.Just ds2
                        -> case ds2 of wild3 { (,) val1 ds3 ->
                           case LanguageFortranTools.evaluateExpr_type vt stepExpr of wild4 {
                             GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Float]
                             GHC.Base.Just ds4
                             -> case ds4 of wild5 { (,) val2 ds5 ->
                                GHC.Base.Just
                                  @ [GHC.Types.Float]
                                  (case val of ds6 { GHC.Types.F# ds7 ->
                                   case {__pkg_ccall base-4.11.1.0 GHC.Prim.Float#
                                                                   -> GHC.Prim.State#
                                                                        GHC.Prim.RealWorld
                                                                   -> (# GHC.Prim.State#
                                                                           GHC.Prim.RealWorld,
                                                                         GHC.Prim.Float# #)}
                                          ds7
                                          GHC.Prim.realWorld# of wild6 { (#,#) ds8 ds9 ->
                                   case val2 of ds10 { GHC.Types.F# ds11 ->
                                   case {__pkg_ccall base-4.11.1.0 GHC.Prim.Float#
                                                                   -> GHC.Prim.State#
                                                                        GHC.Prim.RealWorld
                                                                   -> (# GHC.Prim.State#
                                                                           GHC.Prim.RealWorld,
                                                                         GHC.Prim.Float# #)}
                                          ds11
                                          GHC.Prim.realWorld# of wild7 { (#,#) ds12 ds13 ->
                                   case val1 of ds14 { GHC.Types.F# ds15 ->
                                   case {__pkg_ccall base-4.11.1.0 GHC.Prim.Float#
                                                                   -> GHC.Prim.State#
                                                                        GHC.Prim.RealWorld
                                                                   -> (# GHC.Prim.State#
                                                                           GHC.Prim.RealWorld,
                                                                         GHC.Prim.Float# #)}
                                          ds15
                                          GHC.Prim.realWorld# of wild8 { (#,#) ds16 ds17 ->
                                   let {
                                     x1 :: GHC.Prim.Int# = GHC.Prim.float2Int# ds9
                                   } in
                                   let {
                                     x2 :: GHC.Prim.Int#
                                     = GHC.Prim.+#
                                         (GHC.Prim.float2Int# ds9)
                                         (GHC.Prim.float2Int# ds13)
                                   } in
                                   case GHC.Prim.>=# x2 x1 of lwild {
                                     DEFAULT
                                     -> let {
                                          y :: GHC.Prim.Int# = GHC.Prim.float2Int# ds17
                                        } in
                                        case GHC.Prim.># y x2 of lwild1 {
                                          DEFAULT
                                          -> GHC.Types.:
                                               @ GHC.Types.Float
                                               (GHC.Types.F# (GHC.Prim.int2Float# x1))
                                               (let {
                                                  delta :: GHC.Prim.Int# = GHC.Prim.-# x2 x1
                                                } in
                                                let {
                                                  y' :: GHC.Prim.Int# = GHC.Prim.-# y delta
                                                } in
                                                letrec {
                                                  go_dn :: GHC.Prim.Int# -> [GHC.Types.Float]
                                                    {- Arity: 1, Strictness: <S,U> -}
                                                  = \ (x :: GHC.Prim.Int#) ->
                                                    case GHC.Prim.<# x y' of lwild2 {
                                                      DEFAULT
                                                      -> GHC.Types.:
                                                           @ GHC.Types.Float
                                                           (GHC.Types.F# (GHC.Prim.int2Float# x))
                                                           (go_dn (GHC.Prim.+# x delta))
                                                      1#
                                                      -> GHC.Types.:
                                                           @ GHC.Types.Float
                                                           (GHC.Types.F# (GHC.Prim.int2Float# x))
                                                           (GHC.Types.[] @ GHC.Types.Float) }
                                                } in
                                                go_dn x2)
                                          1#
                                          -> case GHC.Prim.># y x1 of lwild2 {
                                               DEFAULT
                                               -> GHC.Types.:
                                                    @ GHC.Types.Float
                                                    (GHC.Types.F# (GHC.Prim.int2Float# x1))
                                                    (GHC.Types.[] @ GHC.Types.Float)
                                               1# -> GHC.Types.[] @ GHC.Types.Float } }
                                     1#
                                     -> let {
                                          y :: GHC.Prim.Int# = GHC.Prim.float2Int# ds17
                                        } in
                                        case GHC.Prim.<# y x2 of lwild1 {
                                          DEFAULT
                                          -> GHC.Types.:
                                               @ GHC.Types.Float
                                               (GHC.Types.F# (GHC.Prim.int2Float# x1))
                                               (let {
                                                  delta :: GHC.Prim.Int# = GHC.Prim.-# x2 x1
                                                } in
                                                let {
                                                  y' :: GHC.Prim.Int# = GHC.Prim.-# y delta
                                                } in
                                                letrec {
                                                  go_up :: GHC.Prim.Int# -> [GHC.Types.Float]
                                                    {- Arity: 1, Strictness: <S,U> -}
                                                  = \ (x :: GHC.Prim.Int#) ->
                                                    case GHC.Prim.># x y' of lwild2 {
                                                      DEFAULT
                                                      -> GHC.Types.:
                                                           @ GHC.Types.Float
                                                           (GHC.Types.F# (GHC.Prim.int2Float# x))
                                                           (go_up (GHC.Prim.+# x delta))
                                                      1#
                                                      -> GHC.Types.:
                                                           @ GHC.Types.Float
                                                           (GHC.Types.F# (GHC.Prim.int2Float# x))
                                                           (GHC.Types.[] @ GHC.Types.Float) }
                                                } in
                                                go_up x2)
                                          1#
                                          -> case GHC.Prim.<# y x1 of lwild2 {
                                               DEFAULT
                                               -> GHC.Types.:
                                                    @ GHC.Types.Float
                                                    (GHC.Types.F# (GHC.Prim.int2Float# x1))
                                                    (GHC.Types.[] @ GHC.Types.Float)
                                               1#
                                               -> GHC.Types.[]
                                                    @ GHC.Types.Float } } } } } } } } }) } } } } } }) -}
ee05f387e04b6558115e3d72c09a12c7
  extractAllVarNames ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    a LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a :: * -> *
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (eta :: a LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno))
                   LanguageFortranTools.extractAllVarNames1
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   eta) -}
00e29d293fdb3e440342069021f78d1a
  extractAllVarNames1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (a1 :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractAllVarNames2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractVarNames
                             a1
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Expr
                                                             LanguageFortranTools.Anno)) } } } }) -}
597c43db976c2e08b967973865637133
  extractAllVarNames2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Expr
                        17869853342830359556##
                        1287957171183349453##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataExpr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.Expr
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.Expr
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      LanguageFortranTools.extractAllVarNames3) }) -}
482a2ec1eb93703b58805e39637c6bb5
  extractAllVarNames3 ::
    Data.Typeable.Internal.TypeRep
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> * -> *)
                        @ Data.Map.Internal.Map
                        11323335571407833487##
                        2177232330301466659##
                        Data.Map.Internal.$trModule
                        Data.Map.Internal.$fDataMap9
                        0#
                        GHC.Types.krep$*->*->*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (Data.Map.Internal.Map GHC.Base.String)
                   @ [GHC.Base.String]
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ (* -> *)
                      @ Data.Map.Internal.Map
                      @ GHC.Base.String
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> * -> *)
                         @ Data.Map.Internal.Map
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      LanguageFortranTools.extractAllVarNames5)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Base.String
                      LanguageFortranTools.extractAllVarNames4
                      LanguageFortranTools.extractAllVarNames5) }) -}
305d5ab217979149eaf564547a77eb32
  extractAllVarNames4 :: Data.Typeable.Internal.TypeRep []
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ []
                        15300440589168157478##
                        15016221815972113379##
                        GHC.Types.$trModule
                        GHC.Types.$tc[]1
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ []
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
e922e51557764d60caabf61955242f66
  extractAllVarNames5 ::
    Data.Typeable.Internal.TypeRep [GHC.Types.Char]
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ *
                        @ GHC.Types.Char
                        8424092006618324671##
                        2724268014499746065##
                        GHC.Types.$trModule
                        GHC.Types.$tcChar1
                        0#
                        GHC.Types.krep$*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ GHC.Types.Char
                   LanguageFortranTools.extractAllVarNames4
                   (Data.Typeable.Internal.TrTyCon
                      @ *
                      @ GHC.Types.Char
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
20910af79192242a6c20a87676f19776
  extractArgName ::
    Language.Fortran.ArgName LanguageFortranTools.Anno
    -> [Language.Fortran.ArgName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.ArgName
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.ArgName LanguageFortranTools.Anno)
                   Language.Fortran.ArgName ds ds1
                   -> GHC.Types.:
                        @ (Language.Fortran.ArgName LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.ArgName LanguageFortranTools.Anno)) }) -}
d4ecaf52b7147befe912a1b31720faf2
  extractAssigneeFromDecl ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.Decl LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.$wextractAssigneeFromDecl
                        w of ww { (#,#) ww1 ww2 ->
                 Language.Fortran.VarName @ LanguageFortranTools.Anno ww1 ww2 }) -}
861cbabc859e92d3d3077bf0ac25751c
  extractAssigneeFromDecl1 ::
    Language.Fortran.VarName LanguageFortranTools.Anno
  {- Strictness: x -}
f54c8a7353aea63ad0c88c951fe98715
  extractAssigneeFromDecl_go ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      [Language.Fortran.Expr LanguageFortranTools.Anno])]
    -> (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
  {- Arity: 1, Strictness: <S,1*U> -}
5a7dc3b6bc5f6c534391606b447516fb
  extractAssignments ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.Assg ds ds1 ds2 ds3
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
9c876ee28a1e0ede2d9dfb4c0dd4f4ab
  extractBaseType ::
    Language.Fortran.Type LanguageFortranTools.Anno
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Type LanguageFortranTools.Anno) ->
                 case ds of wild {
                   Language.Fortran.BaseType ds1 bt ds2 ds3 ds4 -> bt
                   Language.Fortran.ArrayT ds1 ds2 bt ds3 ds4 ds5 -> bt }) -}
812aa2944ed6e4ee80b23cbd8ca0b112
  extractBlock ::
    Language.Fortran.Block LanguageFortranTools.Anno
    -> [Language.Fortran.Block LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (block :: Language.Fortran.Block LanguageFortranTools.Anno) ->
                 GHC.Types.:
                   @ (Language.Fortran.Block LanguageFortranTools.Anno)
                   block
                   (GHC.Types.[]
                      @ (Language.Fortran.Block LanguageFortranTools.Anno))) -}
5c8431efe64da625bcd884a777cf7d00
  extractBufferReads ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractBufferReads1
                   @ a
                   $dData
                   ast) -}
a2e7c42b30c2e679d49a98e81da08413
  extractBufferReads' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLBufferRead ds ds1 ds2
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
7cdf88da272ca0070db4ea4790564b2f
  extractBufferReads1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractBufferReads'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
168497a89615e6907c3b60011669e33f
  extractBufferReads2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        1898037638716600659##
                        3599167482411011499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> * -> *)
                        @ Data.Map.Internal.Map
                        11323335571407833487##
                        2177232330301466659##
                        Data.Map.Internal.$trModule
                        Data.Map.Internal.$fDataMap9
                        0#
                        GHC.Types.krep$*->*->*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww1 { (#,,,,#) ww2 ww3 ww4 ww5 ww6 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.Fortran
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.Fortran
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ *
                         @ (Data.Map.Internal.Map GHC.Base.String)
                         @ [GHC.Base.String]
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ (* -> *)
                            @ Data.Map.Internal.Map
                            @ GHC.Base.String
                            (Data.Typeable.Internal.TrTyCon
                               @ (* -> * -> *)
                               @ Data.Map.Internal.Map
                               ww2
                               ww3
                               ww4
                               ww5
                               ww6)
                            LanguageFortranTools.extractAllVarNames5)
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Base.String
                            LanguageFortranTools.extractAllVarNames4
                            LanguageFortranTools.extractAllVarNames5))) } }) -}
41e6c1201ca2212536e0a9c5c5f69678
  extractBufferWrites ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractBufferWrites1
                   @ a
                   $dData
                   ast) -}
c9e222395c520b876237cb5e3b209096
  extractBufferWrites' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLBufferWrite ds ds1 ds2
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
dfe57aae6286c1377a65cc0e8cb76784
  extractBufferWrites1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractBufferWrites'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
d361b930fecbdcf85fd16030b6f74596
  extractContainedOperands ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractContainedOperands @ p w2) -}
e669f7b6dc3ca87ff684251318afcc54
  extractContainedOperands1 ::
    [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
    -> [Language.Fortran.Expr p] -> [Language.Fortran.Expr p]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
767cae289da3c9031018929f0cd15574
  extractContainedVars ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dTypeable :: Data.Typeable.Internal.Typeable p)
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Expr p) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.Expr p)
                   Language.Fortran.Var ds1 ds2 lst
                   -> letrec {
                        go9 :: [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
                               -> [Language.Fortran.Expr p] -> [Language.Fortran.Expr p]
                          <join 2> {- Arity: 2 -}
                        = \ (ds3 :: [(Language.Fortran.VarName p,
                                      [Language.Fortran.Expr p])])
                            (eta :: [Language.Fortran.Expr p]) ->
                          case ds3 of wild1 {
                            [] -> eta
                            : y ys
                            -> go9
                                 ys
                                 (case y of wild2 { (,) itemVar itemExprs ->
                                  GHC.Base.augment
                                    @ (Language.Fortran.Expr p)
                                    (\ @ b
                                       (c :: Language.Fortran.Expr p -> b -> b)[OneShot]
                                       (n1 :: b)[OneShot] ->
                                     GHC.Base.foldr @ (Language.Fortran.Expr p) @ b c n1 eta)
                                    itemExprs }) }
                      } in
                      go9 lst (GHC.Types.[] @ (Language.Fortran.Expr p)) }) -}
ecd26085b30ac90ec5d1649826bb7f23
  extractContainedVarsWV ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractContainedVarsWV @ p w2) -}
88b8e5c20b629dab3d1de5a7c8051410
  extractContainedVarsWV1 ::
    [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
    -> [Language.Fortran.Expr p] -> [Language.Fortran.Expr p]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U> -}
e53fbef31ddec405bad6a03c3c79fac8
  extractDecl ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> [Language.Fortran.Decl LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (decl :: Language.Fortran.Decl LanguageFortranTools.Anno) ->
                 GHC.Types.:
                   @ (Language.Fortran.Decl LanguageFortranTools.Anno)
                   decl
                   (GHC.Types.[]
                      @ (Language.Fortran.Decl LanguageFortranTools.Anno))) -}
1c139360184950c03c788cd2f3296fe1
  extractEvaluatedType ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: GHC.Base.Maybe
                              (GHC.Types.Float,
                               Language.Fortran.BaseType LanguageFortranTools.Anno)) ->
                 case expr of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) ds1 typ ->
                      GHC.Base.Just
                        @ (Language.Fortran.BaseType LanguageFortranTools.Anno)
                        typ } }) -}
998837ce786d1ecd90c2f98514498106
  extractEvaluatedValue ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: GHC.Base.Maybe
                              (GHC.Types.Float,
                               Language.Fortran.BaseType LanguageFortranTools.Anno)) ->
                 case expr of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Float
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) val ds1 ->
                      GHC.Base.Just @ GHC.Types.Float val } }) -}
a8c78e7bfc32415d9f59def6fd3159c8
  extractExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (expr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 expr) -}
6dab979ee8b8d4ff63fc85e5d8625380
  extractExpr_list ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.:
                        @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[] @ (Language.Fortran.Expr LanguageFortranTools.Anno))
                   Language.Fortran.ESeq ds1 ds2 ds3 ds4
                   -> GHC.Types.[]
                        @ (Language.Fortran.Expr LanguageFortranTools.Anno) }) -}
cb1e1b3f65db98fed1f95106ee8ee930
  extractFirstChildFor ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Fortran
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> LanguageFortranTools.extractFirstChildFor1
                   Language.Fortran.For ds1 ds2 ds3 ds4 ds5 ds6 fortran
                   -> case LanguageFortranTools.extractForWithFollowing_beta
                             fortran of wild1 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Base.Just a
                        -> GHC.Base.Just
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                             (LanguageFortranTools.extractPriorToFor fortran,
                              case a of wild2 { (,) firstFor followingFortran -> firstFor },
                              case a of wild2 { (,) firstFor followingFortran ->
                              followingFortran }) } }) -}
dc5eec4c392338781a1ab97162c964b9
  extractFirstChildFor1 ::
    GHC.Base.Maybe
      (Language.Fortran.Fortran LanguageFortranTools.Anno,
       Language.Fortran.Fortran LanguageFortranTools.Anno,
       Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Strictness: x -}
46fb79c22780fed40c23fd1c2c3d4d82
  extractFirstFortran ::
    Data.Data.Data a =>
    a -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (codeSeg :: a) ->
                 case Data.Generics.Schemes.everything
                        @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                        (GHC.Base.++
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                        LanguageFortranTools.extractFirstFortran1
                        @ a
                        $dData
                        codeSeg of wild {
                   []
                   -> GHC.List.badHead
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   : x ds1 -> x }) -}
58b1f81ff8a38cc75cc3e5c16fcecb7a
  extractFirstFortran1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        1#
                        -> GHC.Types.:
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno))
                             (GHC.Types.[]
                                @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) } } } }) -}
2f4ed9cb98a65a75c23a1f3b7582496e
  extractFor ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
07ce127fe846af91cbe68bd6a5496ec2
  extractForWithFollowing ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [(Language.Fortran.Fortran LanguageFortranTools.Anno,
         Language.Fortran.Fortran LanguageFortranTools.Anno)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                           Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.FSeq ds1 ds2 fortran1 fortran2
                   -> case fortran1 of wild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                        Language.Fortran.For ds3 ds4 ds5 ds6 ds7 ds8 ds9
                        -> GHC.Types.:
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                             (wild1, fortran2)
                             (GHC.Types.[]
                                @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                   Language.Fortran.Fortran LanguageFortranTools.Anno)) } }) -}
82d7e5e534b94ad9a5be660fbeb106b7
  extractForWithFollowing_beta ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 let {
                   recursiveCheck_maybe :: GHC.Base.Maybe
                                             (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                              Language.Fortran.Fortran LanguageFortranTools.Anno)
                     <join 0>
                   = case (LanguageFortranTools.extractForWithFollowing_beta2
                             LanguageFortranTools.extractForWithFollowing_beta1
                               `cast`
                             (forall (d :: <*>_N) (b :: <*>_N).
                              <Data.Data.Data d>_R
                              ->_R <Data.Data.Qr
                                      [GHC.Base.Maybe
                                         (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                          Language.Fortran.Fortran LanguageFortranTools.Anno)]
                                      (d -> b)>_R
                              ->_R <d>_R
                              ->_R Sym (Data.Data.N:Qr[0]
                                            <*>_N
                                            <[GHC.Base.Maybe
                                                (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                                 Language.Fortran.Fortran
                                                   LanguageFortranTools.Anno)]>_R
                                            <b>_P))
                             (Language.Fortran.$fDataArg4
                                @ (GHC.Base.Maybe
                                     (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                      Language.Fortran.Fortran LanguageFortranTools.Anno)))
                               `cast`
                             (forall (g :: <*>_N).
                              <g>_R
                              ->_R Sym (Data.Data.N:Qr[0]
                                            <*>_N
                                            <[GHC.Base.Maybe
                                                (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                                 Language.Fortran.Fortran
                                                   LanguageFortranTools.Anno)]>_R
                                            <g>_P))
                             codeSeg)
                            `cast`
                          (Data.Data.N:Qr[0]
                               <*>_N
                               <[GHC.Base.Maybe
                                   (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                    Language.Fortran.Fortran LanguageFortranTools.Anno)]>_R
                               <Language.Fortran.Fortran
                                  (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_P)
                            (GHC.Types.[]
                               @ (GHC.Base.Maybe
                                    (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                     Language.Fortran.Fortran LanguageFortranTools.Anno))) of wild {
                       []
                       -> GHC.Base.Nothing
                            @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                               Language.Fortran.Fortran LanguageFortranTools.Anno)
                       : ipv ipv1 -> ipv }
                 } in
                 case codeSeg of wild {
                   DEFAULT -> recursiveCheck_maybe
                   Language.Fortran.FSeq ds ds1 fortran1 fortran2
                   -> case fortran1 of wild1 {
                        DEFAULT -> recursiveCheck_maybe
                        Language.Fortran.For ds2 ds3 ds4 ds5 ds6 ds7 ds8
                        -> GHC.Base.Just
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                             (wild1, fortran2) } }) -}
beb35fff95989b21d877d46ce8599d4a
  extractForWithFollowing_beta1 ::
    Data.Data.Data d =>
    Data.Data.Qr
      [GHC.Base.Maybe
         (Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno)]
      (d -> b)
    -> d
    -> [GHC.Base.Maybe
          (Language.Fortran.Fortran LanguageFortranTools.Anno,
           Language.Fortran.Fortran LanguageFortranTools.Anno)]
    -> [GHC.Base.Maybe
          (Language.Fortran.Fortran LanguageFortranTools.Anno,
           Language.Fortran.Fortran LanguageFortranTools.Anno)]
  {- Arity: 4,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><C(S),1*C1(U)><L,U><L,U>,
     Unfolding: (\ @ d
                   @ b
                   ($dData2 :: Data.Data.Data d)
                   (ds1 :: Data.Data.Qr
                             [GHC.Base.Maybe
                                (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                 Language.Fortran.Fortran LanguageFortranTools.Anno)]
                             (d -> b))
                   (x :: d)
                   (r1 :: [GHC.Base.Maybe
                             (Language.Fortran.Fortran LanguageFortranTools.Anno,
                              Language.Fortran.Fortran LanguageFortranTools.Anno)]) ->
                 ds1
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N
                      <[GHC.Base.Maybe
                          (Language.Fortran.Fortran LanguageFortranTools.Anno,
                           Language.Fortran.Fortran LanguageFortranTools.Anno)]>_R
                      <d -> b>_P)
                   (GHC.Types.:
                      @ (GHC.Base.Maybe
                           (Language.Fortran.Fortran LanguageFortranTools.Anno,
                            Language.Fortran.Fortran LanguageFortranTools.Anno))
                      (case Data.Typeable.Internal.typeRepFingerprint
                              @ *
                              @ d
                              (Data.Data.$p1Data @ d $dData2)
                                `cast`
                              (Data.Typeable.Internal.N:Typeable[0] <*>_N <d>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                       case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                       case GHC.Prim.eqWord# dt dt2 of lwild {
                         DEFAULT
                         -> GHC.Base.Nothing
                              @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                 Language.Fortran.Fortran LanguageFortranTools.Anno)
                         1#
                         -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                              DEFAULT
                              -> GHC.Base.Nothing
                                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                      Language.Fortran.Fortran LanguageFortranTools.Anno)
                              1#
                              -> letrec {
                                   lvl169 :: forall d1 b1.
                                             Data.Data.Data d1 =>
                                             Data.Data.Qr
                                               [GHC.Base.Maybe
                                                  (Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno,
                                                   Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno)]
                                               (d1 -> b1)
                                             -> d1
                                             -> [GHC.Base.Maybe
                                                   (Language.Fortran.Fortran
                                                      LanguageFortranTools.Anno,
                                                    Language.Fortran.Fortran
                                                      LanguageFortranTools.Anno)]
                                             -> [GHC.Base.Maybe
                                                   (Language.Fortran.Fortran
                                                      LanguageFortranTools.Anno,
                                                    Language.Fortran.Fortran
                                                      LanguageFortranTools.Anno)]
                                     {- Arity: 4,
                                        Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><C(S),1*C1(U)><L,U><L,U> -}
                                   = \ @ d1
                                       @ b1
                                       ($dData1 :: Data.Data.Data d1)
                                       (ds2 :: Data.Data.Qr
                                                 [GHC.Base.Maybe
                                                    (Language.Fortran.Fortran
                                                       LanguageFortranTools.Anno,
                                                     Language.Fortran.Fortran
                                                       LanguageFortranTools.Anno)]
                                                 (d1 -> b1))
                                       (x1 :: d1)
                                       (r2 :: [GHC.Base.Maybe
                                                 (Language.Fortran.Fortran
                                                    LanguageFortranTools.Anno,
                                                  Language.Fortran.Fortran
                                                    LanguageFortranTools.Anno)]) ->
                                     ds2
                                       `cast`
                                     (Data.Data.N:Qr[0]
                                          <*>_N
                                          <[GHC.Base.Maybe
                                              (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                               Language.Fortran.Fortran
                                                 LanguageFortranTools.Anno)]>_R
                                          <d1 -> b1>_P)
                                       (GHC.Types.:
                                          @ (GHC.Base.Maybe
                                               (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                                Language.Fortran.Fortran LanguageFortranTools.Anno))
                                          (case Data.Typeable.Internal.typeRepFingerprint
                                                  @ *
                                                  @ d1
                                                  (Data.Data.$p1Data @ d1 $dData1)
                                                    `cast`
                                                  (Data.Typeable.Internal.N:Typeable[0] <*>_N <d1>_N) of wild2 { GHC.Fingerprint.Type.Fingerprint dt4 dt5 ->
                                           case GHC.Prim.eqWord# dt4 dt2 of lwild2 {
                                             DEFAULT
                                             -> GHC.Base.Nothing
                                                  @ (Language.Fortran.Fortran
                                                       LanguageFortranTools.Anno,
                                                     Language.Fortran.Fortran
                                                       LanguageFortranTools.Anno)
                                             1#
                                             -> case GHC.Prim.eqWord# dt5 dt3 of lwild3 {
                                                  DEFAULT
                                                  -> GHC.Base.Nothing
                                                       @ (Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno,
                                                          Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno)
                                                  1#
                                                  -> extractForWithFollowing_beta3
                                                       x1
                                                         `cast`
                                                       (UnsafeCo representational d1 (Language.Fortran.Fortran
                                                                                        LanguageFortranTools.Anno)) } } })
                                          r2)
                                   extractForWithFollowing_beta3 :: Language.Fortran.Fortran
                                                                      LanguageFortranTools.Anno
                                                                    -> GHC.Base.Maybe
                                                                         (Language.Fortran.Fortran
                                                                            LanguageFortranTools.Anno,
                                                                          Language.Fortran.Fortran
                                                                            LanguageFortranTools.Anno)
                                     {- Arity: 1, Strictness: <S,U> -}
                                   = \ (codeSeg :: Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno) ->
                                     let {
                                       recursiveCheck_maybe :: GHC.Base.Maybe
                                                                 (Language.Fortran.Fortran
                                                                    LanguageFortranTools.Anno,
                                                                  Language.Fortran.Fortran
                                                                    LanguageFortranTools.Anno)
                                         <join 0>
                                       = case (LanguageFortranTools.extractForWithFollowing_beta2
                                                 lvl169
                                                   `cast`
                                                 (forall (d1 :: <*>_N) (b1 :: <*>_N).
                                                  <Data.Data.Data d1>_R
                                                  ->_R <Data.Data.Qr
                                                          [GHC.Base.Maybe
                                                             (Language.Fortran.Fortran
                                                                LanguageFortranTools.Anno,
                                                              Language.Fortran.Fortran
                                                                LanguageFortranTools.Anno)]
                                                          (d1 -> b1)>_R
                                                  ->_R <d1>_R
                                                  ->_R Sym (Data.Data.N:Qr[0]
                                                                <*>_N
                                                                <[GHC.Base.Maybe
                                                                    (Language.Fortran.Fortran
                                                                       LanguageFortranTools.Anno,
                                                                     Language.Fortran.Fortran
                                                                       LanguageFortranTools.Anno)]>_R
                                                                <b1>_P))
                                                 (Language.Fortran.$fDataArg4
                                                    @ (GHC.Base.Maybe
                                                         (Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno,
                                                          Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno)))
                                                   `cast`
                                                 (forall (g :: <*>_N).
                                                  <g>_R
                                                  ->_R Sym (Data.Data.N:Qr[0]
                                                                <*>_N
                                                                <[GHC.Base.Maybe
                                                                    (Language.Fortran.Fortran
                                                                       LanguageFortranTools.Anno,
                                                                     Language.Fortran.Fortran
                                                                       LanguageFortranTools.Anno)]>_R
                                                                <g>_P))
                                                 codeSeg)
                                                `cast`
                                              (Data.Data.N:Qr[0]
                                                   <*>_N
                                                   <[GHC.Base.Maybe
                                                       (Language.Fortran.Fortran
                                                          LanguageFortranTools.Anno,
                                                        Language.Fortran.Fortran
                                                          LanguageFortranTools.Anno)]>_R
                                                   <Language.Fortran.Fortran
                                                      (Data.Map.Internal.Map
                                                         GHC.Base.String [GHC.Base.String])>_P)
                                                (GHC.Types.[]
                                                   @ (GHC.Base.Maybe
                                                        (Language.Fortran.Fortran
                                                           LanguageFortranTools.Anno,
                                                         Language.Fortran.Fortran
                                                           LanguageFortranTools.Anno))) of wild2 {
                                           []
                                           -> GHC.Base.Nothing
                                                @ (Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno,
                                                   Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno)
                                           : ipv ipv1 -> ipv }
                                     } in
                                     case codeSeg of wild2 {
                                       DEFAULT -> recursiveCheck_maybe
                                       Language.Fortran.FSeq ds ds2 fortran1 fortran2
                                       -> case fortran1 of wild3 {
                                            DEFAULT -> recursiveCheck_maybe
                                            Language.Fortran.For ds3 ds4 ds5 ds6 ds7 ds8 ds9
                                            -> GHC.Base.Just
                                                 @ (Language.Fortran.Fortran
                                                      LanguageFortranTools.Anno,
                                                    Language.Fortran.Fortran
                                                      LanguageFortranTools.Anno)
                                                 (wild3, fortran2) } }
                                 } in
                                 extractForWithFollowing_beta3
                                   x `cast`
                                   (UnsafeCo representational d (Language.Fortran.Fortran
                                                                   LanguageFortranTools.Anno)) } } } })
                      r1)) -}
a0464d5ec7e7a40afc985a6b1909c5c2
  extractForWithFollowing_beta2 ::
    (forall d b.
     Data.Data.Data d =>
     Data.Data.Qr
       [GHC.Base.Maybe
          (Language.Fortran.Fortran LanguageFortranTools.Anno,
           Language.Fortran.Fortran LanguageFortranTools.Anno)]
       (d -> b)
     -> d
     -> Data.Data.Qr
          [GHC.Base.Maybe
             (Language.Fortran.Fortran LanguageFortranTools.Anno,
              Language.Fortran.Fortran LanguageFortranTools.Anno)]
          b)
    -> (forall g.
        g
        -> Data.Data.Qr
             [GHC.Base.Maybe
                (Language.Fortran.Fortran LanguageFortranTools.Anno,
                 Language.Fortran.Fortran LanguageFortranTools.Anno)]
             g)
    -> Language.Fortran.Fortran
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Data.Data.Qr
         [GHC.Base.Maybe
            (Language.Fortran.Fortran LanguageFortranTools.Anno,
             Language.Fortran.Fortran LanguageFortranTools.Anno)]
         (Language.Fortran.Fortran
            (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Unfolding: (Language.Fortran.$fDataFortran_$cgfoldl
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                   @ (Data.Data.Qr
                        [GHC.Base.Maybe
                           (Language.Fortran.Fortran LanguageFortranTools.Anno,
                            Language.Fortran.Fortran LanguageFortranTools.Anno)])) -}
14a2022f178918597fbb8d7180b6621e
  extractFortran ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (fort :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 GHC.Types.:
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   fort
                   (GHC.Types.[]
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))) -}
1772713b50a8871ac6d17dec231b70bb
  extractIndent :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ad07c0817a81bb6887a1071b5ccd2396
  extractKernels ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractKernels1
                   @ a
                   $dData
                   ast) -}
acebf30aab4c23a0375999af8a559c8e
  extractKernels' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLMap ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
938558e41640e233b438095948d0756c
  extractKernels1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractKernels'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
e012ddd2e7791fe1d55452ef96d4b6eb
  extractLineNumber :: Language.Fortran.SrcSpan -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LSL)L),1*U(1*U(A,1*U(U),A),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds1 ds2 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc ds3 line ds4 ->
                 line } }) -}
b9ad8bf674c41efab4819c061d4ad364
  extractLoopIters ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [GHC.Base.String]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ast :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [GHC.Base.String]
                   (GHC.Base.++ @ GHC.Base.String)
                   LanguageFortranTools.extractLoopIters1
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   ast) -}
b0bcfda957b2976c4bfcf6088d0f0df9
  extractLoopIters' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Base.String
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> case ds2 of wild1 { Language.Fortran.VarName ds7 idx ->
                      GHC.Types.:
                        @ GHC.Base.String
                        idx
                        (GHC.Types.[] @ GHC.Base.String) } }) -}
2c65c67c0e1e7617bcee5c2db68df37c
  extractLoopIters1 :: Data.Data.Data a => a -> [GHC.Base.String]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (a1 :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractPriorToFor4 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Types.[] @ GHC.Base.String
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Types.[] @ GHC.Base.String
                        1#
                        -> LanguageFortranTools.extractLoopIters'
                             a1
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
ab5343506b38be9c29b0a8a0873f663b
  extractLoopVars ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno))
                   LanguageFortranTools.extractLoopVars1
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   codeSeg) -}
be4c72c6be46458535d1f9d2eaf44cf1
  extractLoopVars' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.For ds1 ds2 var ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        var
                        (GHC.Types.[]
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno)) }) -}
71dd7a1aaefa115c4e8436a5b5481a07
  extractLoopVars1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (a1 :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractPriorToFor4 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractLoopVars'
                             a1
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
67c33ad65238e9bda712a382484a9ed2
  extractLoops ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractLoops1
                   @ a
                   $dData
                   ast) -}
a227c1220bc74dba01628facac847718
  extractLoops' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
d3b85607437576bf567f64fe1ead2729
  extractLoops1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractFor
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
e0c9195a15f2d56092ef8ae31ebdf94d
  extractMaybeVarNames ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Expr
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Base.Nothing
                        @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   Language.Fortran.Var ds1 ds2 lst
                   -> GHC.Base.Just
                        @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                        (LanguageFortranTools.extractVarNames_go lst) }) -}
fd9b35e80a59167580dd0eec2038c50b
  extractOpenCLReduces ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractOpenCLReduces1
                   @ a
                   $dData
                   ast) -}
7de00b8674b4391711ca5b178bc083a8
  extractOpenCLReduces' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
4f7e6e34c67934107727c1e741a1a610
  extractOpenCLReduces1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (eta :: a)[OneShot] ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        1#
                        -> LanguageFortranTools.extractOpenCLReduces'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
8fb945abeb65fded10e8824b0c525de5
  extractOperands ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractOperands @ p w2) -}
a59e55a7099cfe5aa4ef172dfaf10bcb
  extractOperands_$sextractOperands ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
107a7a029ec017d3ccd919d45a4fe468
  extractPrimaryReductionFunction ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (assignee :: Language.Fortran.Expr
                                  LanguageFortranTools.Anno)
                   (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   Language.Fortran.Var ds1 ds2 list
                   -> let {
                        lvl169 :: Language.Fortran.Expr LanguageFortranTools.Anno
                        = LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans
                            assignee
                      } in
                      letrec {
                        go9 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                 [Language.Fortran.Expr LanguageFortranTools.Anno])]
                               -> GHC.Base.String -> GHC.Base.String
                          <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                        = \ (ds3 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                      [Language.Fortran.Expr LanguageFortranTools.Anno])])
                            (eta :: GHC.Base.String) ->
                          case ds3 of wild1 {
                            [] -> eta
                            : y ys
                            -> go9
                                 ys
                                 (case y of wild2 { (,) var exprList ->
                                  case GHC.List.elem
                                         @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                         LanguageFortranTools.$s$fEqExpr
                                         lvl169
                                         (GHC.Base.map
                                            @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                            @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                            LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans
                                            exprList) of wild3 {
                                    GHC.Types.False -> eta
                                    GHC.Types.True
                                    -> case var of wild4 { Language.Fortran.VarName ds4 str ->
                                       str } } }) }
                      } in
                      go9 list (GHC.Types.[] @ GHC.Types.Char) }) -}
f88551446462666ca9682d051c5513da
  extractPrimaryReductionOp ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (Language.Fortran.BinOp LanguageFortranTools.Anno)
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
eef32fcfeec1e982414572fd698bd000
  extractPriorToFor ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> (LanguageFortranTools.extractPriorToFor3
                         LanguageFortranTools.extractPriorToFor2
                           `cast`
                         (forall (d :: <*>_N) (b :: <*>_N).
                          <Data.Data.Data d>_R
                          ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                          ->_R <d>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                         Language.Fortran.$fDataArg7
                           `cast`
                         (forall (g :: <*>_N).
                          <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                         wild)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.Fortran
                              (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> LanguageFortranTools.extractPriorToFor1
                   Language.Fortran.FSeq ds ds1 ds2 ds3
                   -> case ds2 of wild1 {
                        DEFAULT
                        -> (LanguageFortranTools.extractPriorToFor3
                              LanguageFortranTools.extractPriorToFor2
                                `cast`
                              (forall (d :: <*>_N) (b :: <*>_N).
                               <Data.Data.Data d>_R
                               ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                               ->_R <d>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                              Language.Fortran.$fDataArg7
                                `cast`
                              (forall (g :: <*>_N).
                               <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                              wild)
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fortran
                                   (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_R)
                        Language.Fortran.For ds4 ds5 ds6 ds7 ds8 ds9 ds10
                        -> LanguageFortranTools.extractPriorToFor1 } }) -}
ba65382bb4a286484a1cb6ea65b77d0a
  extractPriorToFor1 ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Strictness: m33,
     Unfolding: (Language.Fortran.NullStmt
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan) -}
be2e77a8fc0e2ac9c51fb723145f63a9
  extractPriorToFor2 ::
    Data.Data.Data d =>
    Data.Functor.Identity.Identity (d -> b) -> d -> b
  {- Arity: 3,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><C(S),1*C1(U)><L,1*U>,
     Unfolding: (\ @ d
                   @ b
                   ($dData2 :: Data.Data.Data d)
                   (ds1 :: Data.Functor.Identity.Identity (d -> b))
                   (x :: d) ->
                 ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                   (case LanguageFortranTools.extractPriorToFor4 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ d
                           (Data.Data.$p1Data @ d $dData2)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <d>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> x
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> x
                           1#
                           -> letrec {
                                lvl169 :: forall d1 b1.
                                          Data.Data.Data d1 =>
                                          Data.Functor.Identity.Identity (d1 -> b1) -> d1 -> b1
                                  {- Arity: 3,
                                     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><C(S),1*C1(U)><L,1*U> -}
                                = \ @ d1
                                    @ b1
                                    ($dData1 :: Data.Data.Data d1)
                                    (ds2 :: Data.Functor.Identity.Identity (d1 -> b1))
                                    (x1 :: d1) ->
                                  ds2 `cast` (Data.Functor.Identity.N:Identity[0] <d1 -> b1>_R)
                                    (case Data.Typeable.Internal.typeRepFingerprint
                                            @ *
                                            @ d1
                                            (Data.Data.$p1Data @ d1 $dData1)
                                              `cast`
                                            (Data.Typeable.Internal.N:Typeable[0] <*>_N <d1>_N) of wild2 { GHC.Fingerprint.Type.Fingerprint dt4 dt5 ->
                                     case GHC.Prim.eqWord# dt dt4 of lwild2 {
                                       DEFAULT -> x1
                                       1#
                                       -> case GHC.Prim.eqWord# dt1 dt5 of lwild3 {
                                            DEFAULT -> x1
                                            1#
                                            -> (extractPriorToFor5
                                                  x1
                                                    `cast`
                                                  (UnsafeCo representational d1 (Language.Fortran.Fortran
                                                                                   LanguageFortranTools.Anno)))
                                                 `cast`
                                               (UnsafeCo representational (Language.Fortran.Fortran
                                                                             LanguageFortranTools.Anno) d1) } } })
                                extractPriorToFor5 :: Language.Fortran.Fortran
                                                        LanguageFortranTools.Anno
                                                      -> Language.Fortran.Fortran
                                                           LanguageFortranTools.Anno
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (codeSeg :: Language.Fortran.Fortran
                                                  LanguageFortranTools.Anno) ->
                                  case codeSeg of wild2 {
                                    DEFAULT
                                    -> (LanguageFortranTools.extractPriorToFor3
                                          lvl169
                                            `cast`
                                          (forall (d1 :: <*>_N) (b1 :: <*>_N).
                                           <Data.Data.Data d1>_R
                                           ->_R <Data.Functor.Identity.Identity (d1 -> b1)>_R
                                           ->_R <d1>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0] <b1>_R))
                                          Language.Fortran.$fDataArg7
                                            `cast`
                                          (forall (g :: <*>_N).
                                           <g>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                                          wild2)
                                         `cast`
                                       (Data.Functor.Identity.N:Identity[0]
                                            <Language.Fortran.Fortran
                                               (Data.Map.Internal.Map
                                                  GHC.Base.String [GHC.Base.String])>_R)
                                    Language.Fortran.For ds ds2 ds3 ds4 ds5 ds6 ds7
                                    -> LanguageFortranTools.extractPriorToFor1
                                    Language.Fortran.FSeq ds ds2 ds3 ds4
                                    -> case ds3 of wild3 {
                                         DEFAULT
                                         -> (LanguageFortranTools.extractPriorToFor3
                                               lvl169
                                                 `cast`
                                               (forall (d1 :: <*>_N) (b1 :: <*>_N).
                                                <Data.Data.Data d1>_R
                                                ->_R <Data.Functor.Identity.Identity (d1 -> b1)>_R
                                                ->_R <d1>_R
                                                ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                              <b1>_R))
                                               Language.Fortran.$fDataArg7
                                                 `cast`
                                               (forall (g :: <*>_N).
                                                <g>_R
                                                ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                              <g>_R))
                                               wild2)
                                              `cast`
                                            (Data.Functor.Identity.N:Identity[0]
                                                 <Language.Fortran.Fortran
                                                    (Data.Map.Internal.Map
                                                       GHC.Base.String [GHC.Base.String])>_R)
                                         Language.Fortran.For ds5 ds6 ds7 ds8 ds9 ds10 ds11
                                         -> LanguageFortranTools.extractPriorToFor1 } }
                              } in
                              (extractPriorToFor5
                                 x `cast`
                                 (UnsafeCo representational d (Language.Fortran.Fortran
                                                                 LanguageFortranTools.Anno)))
                                `cast`
                              (UnsafeCo representational (Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno) d) } } } })) -}
5b5e58568a3c6edddca831c2a3e72ab3
  extractPriorToFor3 ::
    (forall d b.
     Data.Data.Data d =>
     Data.Functor.Identity.Identity (d -> b)
     -> d -> Data.Functor.Identity.Identity b)
    -> (forall g. g -> Data.Functor.Identity.Identity g)
    -> Language.Fortran.Fortran
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Data.Functor.Identity.Identity
         (Language.Fortran.Fortran
            (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Unfolding: (Language.Fortran.$fDataFortran_$cgfoldl
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                   @ Data.Functor.Identity.Identity) -}
97e1ac922ff570b514d52d42af0217cf
  extractPriorToFor4 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        1898037638716600659##
                        3599167482411011499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.Fortran
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.Fortran
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      LanguageFortranTools.extractAllVarNames3) }) -}
f1c370a27378ad56f7061a79135d5ec4
  extractReductionVarNames ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLReduce ds1 ds2 ds3 ds4 ds5 ds6 redVars ds7
                   -> GHC.Base.build
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        (\ @ b1
                           (c :: Language.Fortran.VarName LanguageFortranTools.Anno
                                 -> b1 -> b1)[OneShot]
                           (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                              Language.Fortran.Expr LanguageFortranTools.Anno)
                           @ b1
                           (GHC.Base.mapFB
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                              @ b1
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                                 Language.Fortran.Expr LanguageFortranTools.Anno)
                              c
                              (Data.Tuple.fst
                                 @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                 @ (Language.Fortran.Expr LanguageFortranTools.Anno)))
                           n1
                           redVars) }) -}
6ee6819edd989ddc1822947b80617724
  extractUsedVarName ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.Var ds1 ds2 list
                   -> GHC.Base.build
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        (\ @ b1
                           (c :: Language.Fortran.VarName LanguageFortranTools.Anno
                                 -> b1 -> b1)[OneShot]
                           (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                              [Language.Fortran.Expr LanguageFortranTools.Anno])
                           @ b1
                           (GHC.Base.mapFB
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                              @ b1
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                                 [Language.Fortran.Expr LanguageFortranTools.Anno])
                              c
                              LanguageFortranTools.extractUsedVarName1)
                           n1
                           list) }) -}
e579cc4f12fcaf3798a666b191f121a5
  extractUsedVarName1 ::
    (Language.Fortran.VarName LanguageFortranTools.Anno,
     [Language.Fortran.Expr LanguageFortranTools.Anno])
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.VarName LanguageFortranTools.Anno,
                           [Language.Fortran.Expr LanguageFortranTools.Anno])) ->
                 case ds of wild { (,) varname exprs -> varname }) -}
920113507cf2d36f1a1834c3a88c2c59
  extractVarNames ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Expr
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.Var ds1 ds2 lst
                   -> LanguageFortranTools.extractVarNames_go lst }) -}
33f94d7c859359639ffcb66fd951bd43
  extractVarNames_go ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      [Language.Fortran.Expr LanguageFortranTools.Anno])]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U> -}
d39b077e8b02a9fc2dbc85c3c3f73564
  extractVarNames_loopVars ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno)]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Base.map
                   @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                      Language.Fortran.Expr LanguageFortranTools.Anno,
                      Language.Fortran.Expr LanguageFortranTools.Anno,
                      Language.Fortran.Expr LanguageFortranTools.Anno)
                   @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   LanguageFortranTools.extractVarNames_loopVars1) -}
5a25291416a9dc709c1a1c3d630d6812
  extractVarNames_loopVars1 ::
    (Language.Fortran.VarName LanguageFortranTools.Anno,
     Language.Fortran.Expr LanguageFortranTools.Anno,
     Language.Fortran.Expr LanguageFortranTools.Anno,
     Language.Fortran.Expr LanguageFortranTools.Anno)
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U(U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.VarName LanguageFortranTools.Anno,
                           Language.Fortran.Expr LanguageFortranTools.Anno,
                           Language.Fortran.Expr LanguageFortranTools.Anno,
                           Language.Fortran.Expr LanguageFortranTools.Anno)) ->
                 case ds of wild { (,,,) x ds1 ds2 ds3 -> x }) -}
950eed49da10706f0d7595c6d086e83b
  findDeclLine :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case LanguageFortranTools.findDeclLine_tailsGo line of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> LanguageFortranTools.findDeclLine_go line }) -}
61a7fb98eeef932acf3bfcfc73d93bcc
  findDeclLineVars :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case LanguageFortranTools.findDeclLine_tailsGo line of wild {
                   GHC.Types.False -> GHC.Types.[] @ GHC.Base.String
                   GHC.Types.True
                   -> let {
                        $j :: GHC.Prim.Char# -> [GHC.Base.String]
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (x :: GHC.Prim.Char#)[OneShot] ->
                          case x of wild1 {
                            DEFAULT
                            -> case LanguageFortranTools.splitDelim
                                      LanguageFortranTools.findDeclLineVars9
                                      line of wild2 {
                                 [] -> case GHC.List.badHead ret_ty [GHC.Base.String] of {}
                                 : x1 ds1
                                 -> case LanguageFortranTools.splitDelim
                                           LanguageFortranTools.findDeclLineVars7
                                           (GHC.List.filter
                                              @ GHC.Types.Char
                                              LanguageFortranTools.findDeclLineVars6
                                              x1) of wild3 {
                                      []
                                      -> case LanguageFortranTools.findDeclLineVars5
                                         ret_ty [GHC.Base.String]
                                         of {}
                                      : lhs ds
                                      -> case ds of wild4 {
                                           []
                                           -> case LanguageFortranTools.findDeclLineVars5
                                              ret_ty [GHC.Base.String]
                                              of {}
                                           : rhs ds2
                                           -> case ds2 of wild5 {
                                                []
                                                -> GHC.Base.map
                                                     @ [GHC.Types.Char]
                                                     @ [GHC.Types.Char]
                                                     LanguageFortranTools.findDeclLineVars2
                                                     (LanguageFortranTools.splitDelim
                                                        LanguageFortranTools.findDeclLineVars_needle
                                                        rhs)
                                                : ipv ipv1
                                                -> case LanguageFortranTools.findDeclLineVars5
                                                   ret_ty [GHC.Base.String]
                                                   of {} } } } }
                            '!'# -> GHC.Types.[] @ GHC.Base.String }
                      } in
                      letrec {
                        go9 :: [GHC.Types.Char] -> [GHC.Base.String]
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [GHC.Types.Char]) ->
                          case ds of wild1 {
                            [] -> case GHC.List.badHead ret_ty [GHC.Base.String] of {}
                            : y ys
                            -> case y of wild2 { GHC.Types.C# x ->
                               case x of wild3 { DEFAULT -> $j wild3 ' '# -> go9 ys } } }
                      } in
                      go9 line }) -}
ebe936052e0bf5c9a52f1202b5356063
  findDeclLineVars1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (","#) -}
cd6075d82c9024b93431a520c18bef46
  findDeclLineVars10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
87bc7dbb596dc8fa40556086e0eb941d
  findDeclLineVars2 :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Base.String) ->
                 case LanguageFortranTools.splitDelim
                        LanguageFortranTools.findDeclLineVars3
                        x of wild {
                   [] -> GHC.List.badHead @ GHC.Base.String : x1 ds1 -> x1 }) -}
427bfd0284ccb06a97d19d15a666d327
  findDeclLineVars3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.findDeclLineVars4) -}
21ebebb64f4192d83fa7263b55de7a14
  findDeclLineVars4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("="#) -}
0bf2467bd7536e50cf760f0f77c9561a
  findDeclLineVars5 :: (GHC.Base.String, GHC.Base.String)
  {- Strictness: x -}
5a27e94aeca9f9fbfef1391c04964559
  findDeclLineVars6 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.True ' '# -> GHC.Types.False } }) -}
00da9d2f94b98c95fb6778184742a246
  findDeclLineVars7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.findDeclLineVars8) -}
dba2ba724cad749a4b3e464309f82e4d
  findDeclLineVars8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("::"#) -}
4badae4f97fcbcc0fd60294d3b54b9a6
  findDeclLineVars9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.findDeclLineVars10) -}
9a50421db735ad3c9b624e84859cd0a0
  findDeclLineVars_needle :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.findDeclLineVars1) -}
70dcf9ba22e192e0d78ed856fd80d2c7
  findDeclLine_go :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
f174de8715829fbf75d72c5756d08848
  findDeclLine_tailsGo :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U> -}
ebefe7ed371ea5a025889e090db2effe
  generateAdditionExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateAdditionExpr1
                   expr1
                   expr2) -}
4827c1d8e34b418fe27f535b51c40408
  generateAdditionExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Language.Fortran.Plus
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
0a3b6216f4f18a77afa1be430f8edf6e
  generateAndExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateAndExpr1
                   expr1
                   expr2) -}
773937a0f95cb0553dee717a9bfdb297
  generateAndExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Language.Fortran.And
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
3cf17bbc4ef8f5186be247188ddd53d7
  generateAndExprFromList ::
    [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (list :: [Language.Fortran.Expr LanguageFortranTools.Anno]) ->
                 case list of wild {
                   []
                   -> GHC.List.foldl2
                        @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                   : x xs
                   -> letrec {
                        go9 :: [Language.Fortran.Expr LanguageFortranTools.Anno]
                               -> Language.Fortran.Expr LanguageFortranTools.Anno
                               -> Language.Fortran.Expr LanguageFortranTools.Anno
                          <join 2> {- Arity: 2 -}
                        = \ (ds :: [Language.Fortran.Expr LanguageFortranTools.Anno])
                            (eta :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                          case ds of wild1 {
                            [] -> eta
                            : y ys
                            -> go9
                                 ys
                                 (Language.Fortran.Bin
                                    @ LanguageFortranTools.Anno
                                    (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                                    LanguageFortranTools.nullSrcSpan
                                    LanguageFortranTools.generateAndExpr1
                                    eta
                                    y) }
                      } in
                      go9 xs x }) -}
41f69fa556436cb7a4d3721607926c4e
  generateArrayVar ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (varname :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (exprs :: [Language.Fortran.Expr LanguageFortranTools.Anno]) ->
                 Language.Fortran.Var
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Types.:
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                         [Language.Fortran.Expr LanguageFortranTools.Anno])
                      (varname, exprs)
                      (GHC.Types.[]
                         @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                            [Language.Fortran.Expr LanguageFortranTools.Anno])))) -}
20710a75ff0344432f71c139fc360606
  generateAssgCode ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Assg
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   expr1
                   expr2) -}
93d1e6cd3eb2354ecf60e3f1d019d728
  generateDivisionExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateDivisionExpr1
                   expr1
                   expr2) -}
e91d5ea512ed0b626459dbda0b4559d1
  generateDivisionExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Language.Fortran.Div
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
9fb1ed62bd0a0082ff6bcab51b602e13
  generateESeq ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.VarName
                             LanguageFortranTools.Anno]) ->
                 case ds of wild {
                   [] -> LanguageFortranTools.generateESeq1
                   : var ds1
                   -> case ds1 of wild1 {
                        [] -> LanguageFortranTools.generateVar var
                        : ipv ipv1
                        -> Language.Fortran.ESeq
                             @ LanguageFortranTools.Anno
                             (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                             LanguageFortranTools.nullSrcSpan
                             (LanguageFortranTools.generateESeq_$sgenerateESeq ipv ipv1)
                             (LanguageFortranTools.generateVar var) } }) -}
0a72bfa0a2cf3809c01899eb50b1bd0e
  generateESeq1 :: Language.Fortran.Expr LanguageFortranTools.Anno
  {- Strictness: x -}
275ad2d143fa5a115248dd1c87f8eec8
  generateESeq_$sgenerateESeq ::
    Language.Fortran.VarName
      (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])
    -> [Language.Fortran.VarName
          (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
5dcba2026db65bc794f7f492a806bcd7
  generateFSeq ::
    [Language.Fortran.Fortran LanguageFortranTools.Anno]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.Fortran
                             LanguageFortranTools.Anno]) ->
                 case ds of wild {
                   [] -> LanguageFortranTools.extractPriorToFor1
                   : statement ds1
                   -> case ds1 of wild1 {
                        [] -> statement
                        : ipv ipv1
                        -> Language.Fortran.FSeq
                             @ LanguageFortranTools.Anno
                             (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                             LanguageFortranTools.nullSrcSpan
                             statement
                             (LanguageFortranTools.generateFSeq_$sgenerateFSeq ipv ipv1) } }) -}
eb14247e0afa6c755fbac8f5227da219
  generateFSeq_$sgenerateFSeq ::
    Language.Fortran.Fortran
      (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])
    -> [Language.Fortran.Fortran
          (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
8328eb5a24ca03c6663765c1f882e9d3
  generateFloatConstant ::
    GHC.Types.Float -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,1*U(U)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (value :: GHC.Types.Float) ->
                 Language.Fortran.Con
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Float.$fShowFloat_$cshow value)) -}
e9ac66b594d47f4b1fc9da873f6ce778
  generateIf ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (fortran :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 Language.Fortran.If
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   expr
                   fortran
                   (GHC.Types.[]
                      @ (Language.Fortran.Expr LanguageFortranTools.Anno,
                         Language.Fortran.Fortran LanguageFortranTools.Anno))
                   (GHC.Base.Nothing
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))) -}
6662a08fe79ba459b5e48087464e69d4
  generateIntConstant ::
    GHC.Types.Int -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,1*U(U)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (value :: GHC.Types.Int) ->
                 Language.Fortran.Con
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Show.$fShowInt_$cshow value)) -}
e83c0a2e02d3a190d6db72ef29392553
  generateLTExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateLTExpr1
                   expr1
                   expr2) -}
07e4efb453005f9ad3b6d3c79493bfa1
  generateLTExpr1 :: Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m11,
     Unfolding: (Language.Fortran.RelLT
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
a907e73ddd0bd196a78de8c20b92f95f
  generateProductExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateProductExpr1
                   expr1
                   expr2) -}
8f1347eb34e1dd6d2cd7d1d4daa4ed7e
  generateProductExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Language.Fortran.Mul
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
14c58888c86ebb60674149bdcf574778
  generateSrcSpan ::
    GHC.Base.String
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2,
     Strictness: <S,1*U><S(SS),1*U(1*U(A,U,U),1*U(A,U,U))>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: Language.Fortran.SrcSpan) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww2 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                 case w of wild {
                   []
                   -> (Language.Fortran.SrcLoc
                         LanguageFortranTools.nullSrcLoc2
                         ww5
                         ww6,
                       Language.Fortran.SrcLoc LanguageFortranTools.nullSrcLoc2 ww9 ww10)
                   : ipv ipv1
                   -> (Language.Fortran.SrcLoc wild ww5 ww6,
                       Language.Fortran.SrcLoc wild ww9 ww10) } } } }) -}
9351529b83def99d6b69f6e3a8dee095
  generateSrcSpanMerge ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U,A)><L,1*U(A,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (src1 :: Language.Fortran.SrcSpan)
                   (src2 :: Language.Fortran.SrcSpan) ->
                 (case src1 of wild { (,) src1_s src1_e -> src1_s },
                  case src2 of wild { (,) src2_s src2_e -> src2_e })) -}
5bd05c27c551cc874ced7ab020963e53
  generateSubtractionExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateSubtractionExpr1
                   expr1
                   expr2) -}
a0dc77ce7bd5d648ea66c5d02ef417fc
  generateSubtractionExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Language.Fortran.Minus
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
15f2fb62881f8fb31d49eabe4798345c
  generateVar ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (varname :: Language.Fortran.VarName
                                 LanguageFortranTools.Anno) ->
                 Language.Fortran.Var
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Types.:
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                         [Language.Fortran.Expr LanguageFortranTools.Anno])
                      (varname,
                       GHC.Types.[] @ (Language.Fortran.Expr LanguageFortranTools.Anno))
                      (GHC.Types.[]
                         @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                            [Language.Fortran.Expr LanguageFortranTools.Anno])))) -}
520069fdc5dbddc2e3e8297e885d8f7a
  getEarliestSrcLoc ::
    [Language.Fortran.SrcLoc] -> GHC.Base.Maybe Language.Fortran.SrcLoc
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.SrcLoc]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Language.Fortran.SrcLoc
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Language.Fortran.SrcLoc
                        (case GHC.List.$w!!
                                @ Language.Fortran.SrcLoc
                                wild
                                0# of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                         case ipv of wild1 { Language.Fortran.SrcLoc file_before line_before column_before ->
                         case line_before of wild2 { GHC.Types.I# x ->
                         case ww2 of wild3 { GHC.Types.I# y ->
                         case GHC.Prim.<# x y of lwild {
                           DEFAULT
                           -> case GHC.Prim.==# x y of lwild1 {
                                DEFAULT
                                -> LanguageFortranTools.getEarliestSrcLoc_$s$wgo1 ww3 y ww1 ipv1
                                1#
                                -> case column_before of wild4 { GHC.Types.I# x1 ->
                                   case ww3 of wild5 { GHC.Types.I# y1 ->
                                   case GHC.Prim.<# x1 y1 of lwild2 {
                                     DEFAULT
                                     -> LanguageFortranTools.getEarliestSrcLoc_$s$wgo y1 y ww1 ipv1
                                     1#
                                     -> LanguageFortranTools.getEarliestSrcLoc_$s$wgo
                                          x1
                                          x
                                          file_before
                                          ipv1 } } } }
                           1#
                           -> LanguageFortranTools.getEarliestSrcLoc_$s$wgo1
                                column_before
                                x
                                file_before
                                ipv1 } } } } }) }) -}
2be8ecbcdfc262b1fa090fd7db0088d5
  getEarliestSrcLoc_$s$wgo ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> [Language.Fortran.SrcLoc]
    -> Language.Fortran.SrcLoc
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>m -}
a48f422b7a51f22d00c54821403e6c8a
  getEarliestSrcLoc_$s$wgo1 ::
    GHC.Types.Int
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> [Language.Fortran.SrcLoc]
    -> Language.Fortran.SrcLoc
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U)><L,U><L,U><S,1*U>m -}
7f2f1226a255a2e3e291f9b34ce0c8e9
  getEarliestSrcSpan ::
    [Language.Fortran.SrcSpan]
    -> GHC.Base.Maybe Language.Fortran.SrcSpan
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.SrcSpan]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Language.Fortran.SrcSpan
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Language.Fortran.SrcSpan
                        (case GHC.List.$w!!
                                @ Language.Fortran.SrcSpan
                                wild
                                0# of ww { (,) ww1 ww2 ->
                         LanguageFortranTools.getEarliestSrcSpan_$s$wgo
                           ww2
                           ww1
                           ipv
                           ipv1 }) }) -}
945c5967bce8055cb2330926600226c3
  getEarliestSrcSpan_$s$wgo ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> Language.Fortran.SrcSpan
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(S)L),1*U(U,1*U(U),U(U))><S(LS(LS(S)L)),1*U(U(U,U(U),U(U)),1*U(U,U(U),U(U)))><S,1*U>m -}
d8cfb9da0f97af7781450e7f9c7dd953
  getIterLoopVars ::
    Language.Fortran.Fortran p -> [Language.Fortran.VarName p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p (ds :: Language.Fortran.Fortran p) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                   Language.Fortran.OpenCLMap ds1 ds2 vrs vws lvars ilvars stmt1
                   -> ilvars
                   Language.Fortran.OpenCLReduce ds1 ds2 vrs vws lvars ilvars rvarexprs stmt1
                   -> ilvars }) -}
7fb6d3f5dbb2f4b696576735aaf465bb
  getLatestSrcSpan ::
    [Language.Fortran.SrcSpan]
    -> GHC.Base.Maybe Language.Fortran.SrcSpan
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.SrcSpan]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Language.Fortran.SrcSpan
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Language.Fortran.SrcSpan
                        (case GHC.List.$w!!
                                @ Language.Fortran.SrcSpan
                                wild
                                0# of ww { (,) ww1 ww2 ->
                         LanguageFortranTools.getLatestSrcSpan_$s$wgo
                           ww2
                           ww1
                           ipv
                           ipv1 }) }) -}
08a7515f443fd4b520f008ab1a7fce60
  getLatestSrcSpan_$s$wgo ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> Language.Fortran.SrcSpan
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(S)L),1*U(U,1*U(U),U(U))><S(LS(LS(S)L)),1*U(U(U,U(U),U(U)),1*U(U,U(U),U(U)))><S,1*U>m -}
995e5eb39ecbdc26753715677fd95021
  getLoopVar ::
    Language.Fortran.Fortran p
    -> GHC.Base.Maybe (Language.Fortran.VarName p)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p (ds :: Language.Fortran.Fortran p) ->
                 case ds of wild {
                   DEFAULT -> GHC.Base.Nothing @ (Language.Fortran.VarName p)
                   Language.Fortran.For ds1 ds2 var ds3 ds4 ds5 ds6
                   -> GHC.Base.Just @ (Language.Fortran.VarName p) var }) -}
56d05664396f319d962054d4d9204453
  getLoopVars ::
    Language.Fortran.Fortran p -> [Language.Fortran.VarName p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ p (ds :: Language.Fortran.Fortran p) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                   Language.Fortran.OpenCLMap ds1 ds2 vrs vws lvars ilvars stmt1
                   -> GHC.Base.map
                        @ (Language.Fortran.VarName p, Language.Fortran.Expr p,
                           Language.Fortran.Expr p, Language.Fortran.Expr p)
                        @ (Language.Fortran.VarName p)
                        (LanguageFortranTools.getLoopVars1 @ p)
                        lvars
                   Language.Fortran.OpenCLReduce ds1 ds2 vrs vws lvars ilvars rvarexprs stmt1
                   -> GHC.Base.map
                        @ (Language.Fortran.VarName p, Language.Fortran.Expr p,
                           Language.Fortran.Expr p, Language.Fortran.Expr p)
                        @ (Language.Fortran.VarName p)
                        (LanguageFortranTools.getLoopVars1 @ p)
                        lvars }) -}
26aab009a3a70c9074e673adcdf92255
  getLoopVars1 ::
    (Language.Fortran.VarName p, Language.Fortran.Expr p,
     Language.Fortran.Expr p, Language.Fortran.Expr p)
    -> Language.Fortran.VarName p
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U(U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ p
                   (ds :: (Language.Fortran.VarName p, Language.Fortran.Expr p,
                           Language.Fortran.Expr p, Language.Fortran.Expr p)) ->
                 case ds of wild { (,,,) v ds1 ds2 ds3 -> v }) -}
1dbb5f688d9abe3940c6a8dbc34776a9
  getReadArgs ::
    (Data.Data.Data a, Data.Typeable.Internal.Typeable p) =>
    a -> [Language.Fortran.VarName p]
  {- Arity: 3,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ a
                   @ p
                   ($dData :: Data.Data.Data a)
                   ($dTypeable :: Data.Typeable.Internal.Typeable p)
                   (ast :: a) ->
                 let {
                   lvl169 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ *
                       @ (Language.Fortran.Fortran p)
                       (Data.Typeable.Internal.mkTrApp
                          @ *
                          @ *
                          @ Language.Fortran.Fortran
                          @ p
                          LanguageFortranTools.getReadArgs1
                          $dTypeable
                            `cast`
                          (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N))
                 } in
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName p]
                   (GHC.Base.++ @ (Language.Fortran.VarName p))
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) (a2 :: a1)[OneShot] ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case lvl169 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                           1#
                           -> LanguageFortranTools.getReadArgs'
                                @ p
                                a2
                                  `cast`
                                (UnsafeCo representational a1 (Language.Fortran.Fortran
                                                                 p)) } } } })
                   @ a
                   $dData
                   ast) -}
cdc8ab2228c9ed4597a98ab429cf17e2
  getReadArgs' ::
    Language.Fortran.Fortran p -> [Language.Fortran.VarName p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p (codeSeg :: Language.Fortran.Fortran p) ->
                 case codeSeg of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                   Language.Fortran.OpenCLMap ds ds1 vrs vws ds2 ds3 ds4 -> vrs
                   Language.Fortran.OpenCLReduce ds ds1 vrs vws ds2 ds3 ds4 ds5
                   -> vrs }) -}
28f4d23ceff759a6eddad8cadf574597
  getReadArgs1 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Fortran
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        1898037638716600659##
                        3599167482411011499##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Fortran
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
888ca4734f39f6a84076707dd127b382
  getSrcSpanNonIntersection ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> (Language.Fortran.SrcSpan, Language.Fortran.SrcSpan)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,1*U)><L,U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (src1 :: Language.Fortran.SrcSpan)
                   (src2 :: Language.Fortran.SrcSpan) ->
                 ((case src1 of wild { (,) src1_s src1_e -> src1_s },
                   case src2 of wild { (,) src2_s src2_e -> src2_s }),
                  (case src2 of wild { (,) src2_s src2_e -> src2_e },
                   case src1 of wild { (,) src1_s src1_e -> src1_e }))) -}
336426aad7da74b5bebc39b13f5e654a
  getSubNames ::
    Language.Fortran.SubName LanguageFortranTools.Anno
    -> [Language.Fortran.SubName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (sub :: Language.Fortran.SubName LanguageFortranTools.Anno) ->
                 case sub of wild {
                   Language.Fortran.SubName ds ds1
                   -> GHC.Types.:
                        @ (Language.Fortran.SubName LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.SubName LanguageFortranTools.Anno))
                   Language.Fortran.NullSubName ipv
                   -> GHC.Types.[]
                        @ (Language.Fortran.SubName LanguageFortranTools.Anno) }) -}
a99f3d2245811fd8db9db35928672d24
  getUnitName ::
    Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (progunit :: Language.Fortran.ProgUnit
                                  LanguageFortranTools.Anno) ->
                 LanguageFortranTools.getUnitName_go
                   ((LanguageFortranTools.getUnitName3
                       LanguageFortranTools.getUnitName1
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.Qr [[GHC.Types.Char]] (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:Qr[0] <*>_N <[[GHC.Types.Char]]>_R <b>_P))
                       (Language.Fortran.$fDataArg4 @ [GHC.Types.Char])
                         `cast`
                       (forall (g :: <*>_N).
                        <g>_R
                        ->_R Sym (Data.Data.N:Qr[0] <*>_N <[[GHC.Types.Char]]>_R <g>_P))
                       progunit)
                      `cast`
                    (Data.Data.N:Qr[0]
                         <*>_N
                         <[[GHC.Types.Char]]>_R
                         <Language.Fortran.ProgUnit
                            (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])>_P)
                      (GHC.Types.[] @ [GHC.Types.Char]))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
eb5d7107a2ee2fb5f48e15caa7470476
  getUnitName' ::
    Language.Fortran.SubName LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SubName LanguageFortranTools.Anno) ->
                 case ds of wild {
                   Language.Fortran.SubName ds1 str -> str
                   Language.Fortran.NullSubName ipv
                   -> GHC.Types.[] @ GHC.Types.Char }) -}
f1e020f08a3da63c8e797d75026fb9b9
  getUnitName1 ::
    Data.Data.Data d =>
    Data.Data.Qr [[GHC.Types.Char]] (d -> b)
    -> d -> [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 4,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><C(S),1*C1(U)><L,1*U><L,U>,
     Unfolding: (\ @ d
                   @ b
                   ($dData2 :: Data.Data.Data d)
                   (ds1 :: Data.Data.Qr [[GHC.Types.Char]] (d -> b))
                   (x :: d)
                   (r1 :: [[GHC.Types.Char]]) ->
                 ds1
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[[GHC.Types.Char]]>_R <d -> b>_P)
                   (GHC.Types.:
                      @ [GHC.Types.Char]
                      (case Data.Typeable.Internal.typeRepFingerprint
                              @ *
                              @ d
                              (Data.Data.$p1Data @ d $dData2)
                                `cast`
                              (Data.Typeable.Internal.N:Typeable[0] <*>_N <d>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                       case LanguageFortranTools.getUnitName2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                       case GHC.Prim.eqWord# dt dt2 of lwild {
                         DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                         1#
                         -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                              DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                              1#
                              -> case x `cast`
                                      (UnsafeCo representational d (Language.Fortran.SubName
                                                                      LanguageFortranTools.Anno)) of wild2 {
                                   Language.Fortran.SubName ds str -> str
                                   Language.Fortran.NullSubName ipv
                                   -> GHC.Types.[] @ GHC.Types.Char } } } } })
                      r1)) -}
d7ef6640b53762d1759a06d392f2f36f
  getUnitName2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.SubName
                        984225159571365899##
                        8068956749520935535##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSubName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.SubName LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.SubName
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.SubName
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      LanguageFortranTools.extractAllVarNames3) }) -}
f3016e29139bb2535f77fa9b45823434
  getUnitName3 ::
    (forall d b.
     Data.Data.Data d =>
     Data.Data.Qr [[GHC.Types.Char]] (d -> b)
     -> d -> Data.Data.Qr [[GHC.Types.Char]] b)
    -> (forall g. g -> Data.Data.Qr [[GHC.Types.Char]] g)
    -> Language.Fortran.ProgUnit
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Data.Data.Qr
         [[GHC.Types.Char]]
         (Language.Fortran.ProgUnit
            (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String]))
  {- Unfolding: (Language.Fortran.$fDataProgUnit_$cgfoldl
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                   @ (Data.Data.Qr [[GHC.Types.Char]])) -}
d9cf486951cad1c506ab25afee2217b0
  getUnitName_go ::
    [[GHC.Types.Char]] -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
546711d9aa71da48ce05b7658ca41089
  getUses ::
    Language.Fortran.Uses LanguageFortranTools.Anno
    -> [Language.Fortran.Uses LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (uses :: Language.Fortran.Uses LanguageFortranTools.Anno) ->
                 case uses of wild {
                   Language.Fortran.Use ds ds1 ds2 ds3
                   -> GHC.Types.:
                        @ (Language.Fortran.Uses LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[] @ (Language.Fortran.Uses LanguageFortranTools.Anno))
                   Language.Fortran.UseNil ipv
                   -> GHC.Types.[]
                        @ (Language.Fortran.Uses LanguageFortranTools.Anno) }) -}
725b27eecc2eb6b2ad02250bf2de5653
  getWrittenArgs ::
    (Data.Data.Data a, Data.Typeable.Internal.Typeable p) =>
    a -> [Language.Fortran.VarName p]
  {- Arity: 3,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ a
                   @ p
                   ($dData :: Data.Data.Data a)
                   ($dTypeable :: Data.Typeable.Internal.Typeable p)
                   (ast :: a) ->
                 let {
                   lvl169 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ *
                       @ (Language.Fortran.Fortran p)
                       (Data.Typeable.Internal.mkTrApp
                          @ *
                          @ *
                          @ Language.Fortran.Fortran
                          @ p
                          LanguageFortranTools.getReadArgs1
                          $dTypeable
                            `cast`
                          (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N))
                 } in
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName p]
                   (GHC.Base.++ @ (Language.Fortran.VarName p))
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) (a2 :: a1)[OneShot] ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case lvl169 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                           1#
                           -> LanguageFortranTools.getWrittenArgs'
                                @ p
                                a2
                                  `cast`
                                (UnsafeCo representational a1 (Language.Fortran.Fortran
                                                                 p)) } } } })
                   @ a
                   $dData
                   ast) -}
2db20b564a84f8de76d2ca31e14d52ed
  getWrittenArgs' ::
    Language.Fortran.Fortran p -> [Language.Fortran.VarName p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p (codeSeg :: Language.Fortran.Fortran p) ->
                 case codeSeg of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName p)
                   Language.Fortran.OpenCLMap ds ds1 ds2 vws ds3 ds4 ds5 -> vws
                   Language.Fortran.OpenCLReduce ds ds1 ds2 vws ds3 ds4 ds5 ds6
                   -> vws }) -}
59b9a0f4ba8529cd3f2c57589290752d
  hasOperand ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.hasOperand1
                  `cast`
                (<Language.Fortran.Expr LanguageFortranTools.Anno>_R
                 ->_R <Language.Fortran.Expr LanguageFortranTools.Anno>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
a1d6708754506f0cddaf4194551b85a7
  hasOperand1 ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Data.Semigroup.Internal.All
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (container :: Language.Fortran.Expr
                                   LanguageFortranTools.Anno)
                   (contains :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: [Language.Fortran.Expr LanguageFortranTools.Anno]
                   = LanguageFortranTools.extractOperands_$sextractOperands
                       (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans
                          container)
                 } in
                 letrec {
                   go9 :: [Language.Fortran.Expr LanguageFortranTools.Anno]
                          -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Language.Fortran.Expr LanguageFortranTools.Anno]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> case GHC.List.elem
                                 @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                 LanguageFortranTools.$s$fEqExpr
                                 y
                                 lvl169 of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                            GHC.Types.True -> go9 ys } }
                 } in
                 go9
                   (LanguageFortranTools.extractOperands_$sextractOperands
                      (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans
                         contains))) -}
787d9f434329b0e8da93606ca5c5c7ed
  inlineDeclsFromUsedModules ::
    GHC.Types.Bool
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.IO
         ([GHC.Base.String], LanguageFortranTools.ModuleVarsTable)
  {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.inlineDeclsFromUsedModules1
                  `cast`
                (<GHC.Types.Bool>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <([GHC.Base.String], LanguageFortranTools.ModuleVarsTable)>_R)) -}
5fc67aa5bece7a3fb1edd03dd51f7b04
  inlineDeclsFromUsedModules1 ::
    GHC.Types.Bool
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Base.String], LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><S,U>,
     Unfolding: (\ (ds :: GHC.Types.Bool)
                   (contentLines :: [GHC.Base.String])
                   (ds1 :: [GHC.Base.String])
                   (ds2 :: [GHC.Base.String])
                   (ds3 :: GHC.Types.Bool)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ds of wild {
                   GHC.Types.False
                   -> (# eta,
                         (contentLines,
                          Data.Map.Internal.Tip @ GHC.Base.String @ GHC.Base.String) #)
                   GHC.Types.True
                   -> letrec {
                        go9 :: [[GHC.Types.Char]]
                               -> GHC.Prim.State# GHC.Prim.RealWorld
                               -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     [([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))] #)
                          {- Arity: 2, Strictness: <S,1*U><S,U> -}
                        = \ (ds4 :: [[GHC.Types.Char]])
                            (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case ds4 of wild1 {
                            []
                            -> (# eta1,
                                  GHC.Types.[]
                                    @ ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String])) #)
                            : y ys
                            -> case LanguageFortranTools.inlineDeclsFromUsedModules_tailsGo
                                      y of wild2 {
                                 GHC.Types.False
                                 -> case LanguageFortranTools.inlineDeclsFromUsedModules_go3
                                           y of wild3 {
                                      []
                                      -> case go9 ys eta1 of ds5 { (#,#) ipv2 ipv3 ->
                                         (# ipv2,
                                            GHC.Types.:
                                              @ ([GHC.Base.String],
                                                 (GHC.Base.String, [GHC.Base.String]))
                                              (GHC.Types.:
                                                 @ GHC.Base.String
                                                 y
                                                 (GHC.Types.[] @ GHC.Base.String),
                                               LanguageFortranTools.inlineDeclsFromUsedModules5)
                                              ipv3 #) }
                                      : ds5 ds6
                                      -> case GHC.Base.eqString
                                                ds5
                                                LanguageFortranTools.inlineDeclsFromUsedModules3 of wild4 {
                                           GHC.Types.False
                                           -> case go9 ys eta1 of ds7 { (#,#) ipv2 ipv3 ->
                                              (# ipv2,
                                                 GHC.Types.:
                                                   @ ([GHC.Base.String],
                                                      (GHC.Base.String, [GHC.Base.String]))
                                                   (GHC.Types.:
                                                      @ GHC.Base.String
                                                      y
                                                      (GHC.Types.[] @ GHC.Base.String),
                                                    LanguageFortranTools.inlineDeclsFromUsedModules5)
                                                   ipv3 #) }
                                           GHC.Types.True
                                           -> case LanguageFortranTools.inlineDeclsFromUsedModules2
                                                     y
                                                     ds1
                                                     ds2
                                                     ds3
                                                     eta1 of ds7 { (#,#) ipv ipv1 ->
                                              case go9 ys ipv of ds8 { (#,#) ipv2 ipv3 ->
                                              (# ipv2,
                                                 GHC.Types.:
                                                   @ ([GHC.Base.String],
                                                      (GHC.Base.String, [GHC.Base.String]))
                                                   ipv1
                                                   ipv3 #) } } } }
                                 GHC.Types.True -> go9 ys eta1 } }
                      } in
                      case go9 contentLines eta of ds4 { (#,#) ipv ipv1 ->
                      let {
                        ds5 :: ([[GHC.Base.String]],
                                [(GHC.Base.String, [GHC.Base.String])])
                        = case LanguageFortranTools.$wgo1 ipv1 of ww { (#,#) ww1 ww2 ->
                          (ww1, ww2) }
                      } in
                      (# ipv,
                         (case LanguageFortranTools.$wgo contentLines 0# of ww { DEFAULT ->
                          case GHC.Prim.># ww 0# of lwild {
                            DEFAULT
                            -> case ds5 of wild1 { (,) expandedContentLines moduleVarTupleList ->
                               LanguageFortranTools.inlineDeclsFromUsedModules_go2
                                 expandedContentLines
                                 (GHC.Types.[] @ GHC.Base.String) }
                            1#
                            -> case ds5 of wild1 { (,) expandedContentLines moduleVarTupleList ->
                               LanguageFortranTools.inlineDeclsFromUsedModules_go1
                                 expandedContentLines
                                 (GHC.Types.[] @ GHC.Base.String) } } },
                          case ds5 of wild1 { (,) expandedContentLines moduleVarTupleList ->
                          LanguageFortranTools.inlineDeclsFromUsedModules_go
                            moduleVarTupleList
                            (GHC.Types.[] @ (GHC.Base.String, GHC.Base.String)) }) #) } }) -}
1e69c22b3ef6ea3e66214cef61bcfa77
  inlineDeclsFromUsedModules2 ::
    GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String])) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U> -}
9b5f20829fe057b0f6490821f5c91e19
  inlineDeclsFromUsedModules3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.inlineDeclsFromUsedModules4) -}
c875886af976ac48a28472c928746a36
  inlineDeclsFromUsedModules4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("use"#) -}
3c811ec6b1904b614907c2f6d6c19945
  inlineDeclsFromUsedModules5 ::
    ([GHC.Types.Char], [GHC.Base.String])
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Types.[] @ GHC.Types.Char,
                  GHC.Types.[] @ GHC.Base.String)) -}
5404cd7ffece4e923336148e63c2d2b0
  inlineDeclsFromUsedModules_$sinlineDeclsFromUsedModules ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> GHC.Types.Bool
    -> [[GHC.Types.Char]]
    -> [[GHC.Types.Char]]
    -> [[GHC.Types.Char]]
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Base.String], LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 5, Strictness: <S,U><L,U><L,U><L,U><S,U>,
     Unfolding: (\ (sc :: GHC.Prim.State# GHC.Prim.RealWorld)
                   (sc1 :: GHC.Types.Bool)
                   (sc2 :: [[GHC.Types.Char]])
                   (sc3 :: [[GHC.Types.Char]])
                   (sc4 :: [[GHC.Types.Char]]) ->
                 letrec {
                   go9 :: [[GHC.Types.Char]]
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                [([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))] #)
                     {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [[GHC.Types.Char]])
                       (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       []
                       -> (# eta,
                             GHC.Types.[]
                               @ ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String])) #)
                       : y ys
                       -> case LanguageFortranTools.inlineDeclsFromUsedModules_tailsGo
                                 y of wild1 {
                            GHC.Types.False
                            -> case LanguageFortranTools.inlineDeclsFromUsedModules_go3
                                      y of wild2 {
                                 []
                                 -> case go9 ys eta of ds1 { (#,#) ipv2 ipv3 ->
                                    (# ipv2,
                                       GHC.Types.:
                                         @ ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))
                                         (GHC.Types.:
                                            @ GHC.Base.String
                                            y
                                            (GHC.Types.[] @ GHC.Base.String),
                                          LanguageFortranTools.inlineDeclsFromUsedModules5)
                                         ipv3 #) }
                                 : ds1 ds2
                                 -> case GHC.Base.eqString
                                           ds1
                                           LanguageFortranTools.inlineDeclsFromUsedModules3 of wild3 {
                                      GHC.Types.False
                                      -> case go9 ys eta of ds4 { (#,#) ipv2 ipv3 ->
                                         (# ipv2,
                                            GHC.Types.:
                                              @ ([GHC.Base.String],
                                                 (GHC.Base.String, [GHC.Base.String]))
                                              (GHC.Types.:
                                                 @ GHC.Base.String
                                                 y
                                                 (GHC.Types.[] @ GHC.Base.String),
                                               LanguageFortranTools.inlineDeclsFromUsedModules5)
                                              ipv3 #) }
                                      GHC.Types.True
                                      -> case LanguageFortranTools.inlineDeclsFromUsedModules2
                                                y
                                                sc3
                                                sc2
                                                sc1
                                                eta of ds4 { (#,#) ipv ipv1 ->
                                         case go9 ys ipv of ds5 { (#,#) ipv2 ipv3 ->
                                         (# ipv2,
                                            GHC.Types.:
                                              @ ([GHC.Base.String],
                                                 (GHC.Base.String, [GHC.Base.String]))
                                              ipv1
                                              ipv3 #) } } } }
                            GHC.Types.True -> go9 ys eta } }
                 } in
                 case go9 sc4 sc of ds1 { (#,#) ipv ipv1 ->
                 let {
                   ds :: ([[GHC.Base.String]], [(GHC.Base.String, [GHC.Base.String])])
                   = case LanguageFortranTools.$wgo1 ipv1 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 (# ipv,
                    (case LanguageFortranTools.$wgo sc4 0# of ww { DEFAULT ->
                     case GHC.Prim.># ww 0# of lwild {
                       DEFAULT
                       -> case ds of wild { (,) expandedContentLines moduleVarTupleList ->
                          LanguageFortranTools.inlineDeclsFromUsedModules_go2
                            expandedContentLines
                            (GHC.Types.[] @ GHC.Base.String) }
                       1#
                       -> case ds of wild { (,) expandedContentLines moduleVarTupleList ->
                          LanguageFortranTools.inlineDeclsFromUsedModules_go1
                            expandedContentLines
                            (GHC.Types.[] @ GHC.Base.String) } } },
                     case ds of wild { (,) expandedContentLines moduleVarTupleList ->
                     LanguageFortranTools.inlineDeclsFromUsedModules_go
                       moduleVarTupleList
                       (GHC.Types.[] @ (GHC.Base.String, GHC.Base.String)) }) #) }) -}
7a5cb6043a4ead7a1d22069b70fbfc97
  inlineDeclsFromUsedModules_go ::
    [(GHC.Base.String, [GHC.Base.String])]
    -> [(GHC.Base.String, GHC.Base.String)]
    -> Data.Map.Internal.Map GHC.Base.String GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
68fe5e4202bae95a6b6576bca28dda96
  inlineDeclsFromUsedModules_go1 ::
    [[GHC.Base.String]] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
d2b45c136ba339f378692666fd6ad4a1
  inlineDeclsFromUsedModules_go2 ::
    [[GHC.Base.String]] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
a77738279639cc4bfc766cf61b79cedb
  inlineDeclsFromUsedModules_go3 ::
    [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
2182f13e3a8461648bdd7d36ca0cda7e
  inlineDeclsFromUsedModules_tailsGo ::
    [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U> -}
c74ee8cee36b139b4b054fa5e1670086
  isDeclOnly :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (module_content_str :: GHC.Base.String) ->
                 case LanguageFortranTools.isDeclOnly_go
                        (Data.OldList.lines module_content_str) of wild {
                   [] -> GHC.Types.True : ds1 ds2 -> GHC.Types.False }) -}
a35bd222e81f9f99c653701efde93913
  isDeclOnly_go :: [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
fd913831c2f6d5e014bf84fb8b9ab5c1
  isImplicitNoneDecl :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, True)
                (\ (line :: [GHC.Types.Char]) ->
                 LanguageFortranTools.inlineDeclsFromUsedModules_tailsGo line) -}
7821ee59324bc65a99b1dbbb882e9df0
  isRelevantModuleLine :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case Data.OldList.words line of wild {
                   [] -> GHC.Types.False
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        [] -> case GHC.List.badHead ret_ty GHC.Types.Bool of {}
                        : x ds4
                        -> case x of wild2 { GHC.Types.C# x1 ->
                           case x1 of wild3 {
                             DEFAULT
                             -> case GHC.List.elem
                                       @ GHC.Base.String
                                       GHC.Classes.$fEq[]_$s$fEq[]1
                                       wild1
                                       LanguageFortranTools.isRelevantModuleLine6 of wild4 {
                                  GHC.Types.False
                                  -> case GHC.Base.eqString
                                            wild1
                                            LanguageFortranTools.isRelevantModuleLine4 of wild5 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True
                                       -> case GHC.List.elem
                                                 @ GHC.Base.String
                                                 GHC.Classes.$fEq[]_$s$fEq[]1
                                                 (case GHC.List.$wlenAcc
                                                         @ [GHC.Types.Char]
                                                         wild
                                                         0# of ww2 { DEFAULT ->
                                                  case GHC.Prim.># ww2 1# of lwild {
                                                    DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                                                    1#
                                                    -> GHC.List.$w!! @ GHC.Base.String wild 1# } })
                                                 LanguageFortranTools.isRelevantModuleLine1 of wild6 {
                                            GHC.Types.False -> GHC.Types.True
                                            GHC.Types.True -> GHC.Types.False } }
                                  GHC.Types.True -> GHC.Types.False }
                             '!'# -> GHC.Types.False } } } }) -}
8927f6615272fa16da4483739fb2791f
  isRelevantModuleLine1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine2
                   (GHC.Types.[] @ GHC.Base.String)) -}
2357c0a3d21abc6822c9b5225c433c52
  isRelevantModuleLine10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.isRelevantModuleLine11) -}
367386eb2536be4d71b4934c24d6e76f
  isRelevantModuleLine11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("implicit"#) -}
9798ab2b7c3e37f2000b0726a551c1f6
  isRelevantModuleLine12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.isRelevantModuleLine13) -}
c363d3d8b96c131249ee25f1a5d6dd24
  isRelevantModuleLine13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("contains"#) -}
0ea9279fa09e22e915f561399c4bdc0b
  isRelevantModuleLine2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.isRelevantModuleLine3) -}
a3a6db8511581423894567424e33219b
  isRelevantModuleLine3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("module"#) -}
a345b62c02b96c597ee982c1aa1e463a
  isRelevantModuleLine4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.isRelevantModuleLine5) -}
9564c56e66e7c3544d83c4fd5908bc6e
  isRelevantModuleLine5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("end"#) -}
01c5644e7c4010dd677e9fffcbad1de4
  isRelevantModuleLine6 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine2
                   LanguageFortranTools.isRelevantModuleLine7) -}
cb9a31c05a1f2f19454e9ba2cc75af84
  isRelevantModuleLine7 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine12
                   LanguageFortranTools.isRelevantModuleLine8) -}
fad99a9dd9e54832dc19d775a5add5c4
  isRelevantModuleLine8 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.inlineDeclsFromUsedModules3
                   LanguageFortranTools.isRelevantModuleLine9) -}
422fa65dde65e7deaf2da16e5ad4c7f5
  isRelevantModuleLine9 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine10
                   (GHC.Types.[] @ GHC.Base.String)) -}
52ee046225d513485ed89239d0a294e2
  isUseDecl :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case LanguageFortranTools.inlineDeclsFromUsedModules_go3
                        line of wild {
                   [] -> GHC.Types.False
                   : ds1 ds2
                   -> GHC.Base.eqString
                        ds1
                        LanguageFortranTools.inlineDeclsFromUsedModules3 }) -}
f8582da483272aa2ba7beff35cdca0d2
  isVar ::
    Language.Fortran.Expr LanguageFortranTools.Anno -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Language.Fortran.Var ds1 ds2 ds3 -> GHC.Types.True }) -}
f2b856cc1744d1711caeca55a59d6843
  isVarDeclWithMultipleVars :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 let {
                   line_no_comments :: GHC.Base.String
                   = case LanguageFortranTools.splitDelim
                            LanguageFortranTools.findDeclLineVars9
                            line of wild {
                       [] -> GHC.List.badHead @ GHC.Base.String : x ds1 -> x }
                 } in
                 case LanguageFortranTools.findDeclLine_tailsGo
                        line_no_comments of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> let {
                        $j :: GHC.Prim.Char# -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (x :: GHC.Prim.Char#)[OneShot] ->
                          case x of wild1 {
                            DEFAULT
                            -> let {
                                 chunks :: [GHC.Base.String]
                                 = LanguageFortranTools.splitDelim
                                     LanguageFortranTools.findDeclLineVars7
                                     line_no_comments
                               } in
                               case GHC.List.$wlenAcc @ [GHC.Types.Char] chunks 0# of ww2 {
                                 DEFAULT -> GHC.Types.False
                                 2#
                                 -> LanguageFortranTools.isVarDeclWithMultipleVars_tailsGo
                                      (GHC.List.$w!! @ GHC.Base.String chunks 1#) }
                            '!'# -> GHC.Types.False }
                      } in
                      letrec {
                        go9 :: [GHC.Types.Char] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [GHC.Types.Char]) ->
                          case ds of wild1 {
                            [] -> case GHC.List.badHead ret_ty GHC.Types.Bool of {}
                            : y ys
                            -> case y of wild2 { GHC.Types.C# x ->
                               case x of wild3 { DEFAULT -> $j wild3 ' '# -> go9 ys } } }
                      } in
                      go9 line_no_comments }) -}
aad27c39c0351f224829f5a49a37f54e
  isVarDeclWithMultipleVars_tailsGo ::
    [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U> -}
0f1fd6fd70ad4274f1caf34ae8244774
  listCartesianProduct :: [a] -> [a] -> [(a, a)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ a (xs :: [a]) (ys :: [a]) ->
                 letrec {
                   go9 :: [a] -> [(a, a)] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (a, a)
                       : y ys1
                       -> let {
                            z :: [(a, a)] = go9 ys1
                          } in
                          letrec {
                            go10 :: [a] -> [(a, a)] {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [a]) ->
                              case ds1 of wild1 {
                                [] -> z : y1 ys2 -> GHC.Types.: @ (a, a) (y, y1) (go10 ys2) }
                          } in
                          go10 ys }
                 } in
                 go9 xs) -}
28a5be85845b4739b6b5219484213c70
  listConcatUnique :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: [a])
                   (b :: [a]) ->
                 letrec {
                   go9 :: [a] -> [a] -> [a]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [a]) (eta :: [a]) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case GHC.List.elem @ a $dEq y eta of wild1 {
                            GHC.Types.False
                            -> go9
                                 ys
                                 (GHC.Base.++ @ a eta (GHC.Types.: @ a y (GHC.Types.[] @ a)))
                            GHC.Types.True -> go9 ys eta } }
                 } in
                 go9 a1 b) -}
e528245444f56c895c332f8c669a282d
  listCountAppearances ::
    GHC.Classes.Eq a => a -> [a] -> GHC.Types.Int
  {- Arity: 3, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><S,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Classes.Eq a) (w1 :: a) (w2 :: [a]) ->
                 case LanguageFortranTools.$wlistCountAppearances
                        @ a
                        w
                        w1
                        w2 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
d9cf2d486697a4770988b2e5a8d255f7
  listCountAppearances1 :: GHC.Types.Int
  {- Strictness: x -}
0841898cf5fde8de68f832d84d7e11ed
  listCountAppearances_$s$wlistCountAppearances ::
    a -> [a] -> a -> GHC.Classes.Eq a => GHC.Prim.Int#
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S,1*U><L,U><S(C(C(S))L),U(C(C1(U)),A)> -}
de57f61448288543306ceaa1bf4628ed
  listExtractSingleAppearances :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (list :: [a]) ->
                 LanguageFortranTools.listExtractSingleAppearances'
                   @ a
                   $dEq
                   list
                   list) -}
e8532db25b659c4bc6ff4ef374d81465
  listExtractSingleAppearances' ::
    GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U><S,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: [a])
                   (wholeList :: [a]) ->
                 case ds of wild {
                   [] -> LanguageFortranTools.listExtractSingleAppearances'1 @ a
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case LanguageFortranTools.$wlistCountAppearances
                                  @ a
                                  $dEq
                                  x
                                  wholeList of ww {
                             DEFAULT -> GHC.Types.[] @ a
                             1# -> GHC.Types.: @ a x (GHC.Types.[] @ a) }
                        : ipv ipv1
                        -> case LanguageFortranTools.$wlistCountAppearances
                                  @ a
                                  $dEq
                                  x
                                  wholeList of ww {
                             DEFAULT
                             -> LanguageFortranTools.listExtractSingleAppearances'_$slistExtractSingleAppearances'
                                  @ a
                                  wholeList
                                  ipv
                                  ipv1
                                  $dEq
                             1#
                             -> GHC.Types.:
                                  @ a
                                  x
                                  (LanguageFortranTools.listExtractSingleAppearances'_$slistExtractSingleAppearances'
                                     @ a
                                     wholeList
                                     ipv
                                     ipv1
                                     $dEq) } } }) -}
ab25d8593508a50e48208e7c32303ab9
  listExtractSingleAppearances'1 :: [a]
  {- Strictness: x -}
2763022026de90ed32ee5cc8b49bdb03
  listExtractSingleAppearances'_$slistExtractSingleAppearances' ::
    [a] -> a -> [a] -> GHC.Classes.Eq a => [a]
  {- Arity: 4,
     Strictness: <S,U><L,U><S,1*U><S(C(C(S))L),U(C(C1(U)),A)> -}
a852f434f0160ba789329974e5d10cb7
  listIntersection :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) (b :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.List.filterFB
                         @ a
                         @ b1
                         c
                         (\ (x :: a) -> GHC.List.elem @ a $dEq x b))
                      n1
                      a1)) -}
cc90c431c334b3429c5de18c32c0abd0
  listRemoveDuplications :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) ->
                 letrec {
                   go9 :: [a] -> [a] -> [a]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [a]) (eta :: [a]) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case GHC.List.elem @ a $dEq y eta of wild1 {
                            GHC.Types.False
                            -> go9
                                 ys
                                 (GHC.Base.++ @ a eta (GHC.Types.: @ a y (GHC.Types.[] @ a)))
                            GHC.Types.True -> go9 ys eta } }
                 } in
                 go9 a1 (GHC.Types.[] @ a)) -}
40ed5a52f1d2f2210a51ecab157379fd
  listSubtract :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) (b :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.List.filterFB
                         @ a
                         @ b1
                         c
                         (\ (x :: a) ->
                          case GHC.List.elem @ a $dEq x b of wild {
                            GHC.Types.False -> GHC.Types.True
                            GHC.Types.True -> GHC.Types.False }))
                      n1
                      a1)) -}
c9f4877af5f81809f72d91c922065715
  listSubtractWithExemption ::
    GHC.Classes.Eq a => [a] -> [a] -> [a] -> [a]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (exempt :: [a])
                   (a1 :: [a])
                   (b :: [a]) ->
                 GHC.List.filter
                   @ a
                   (\ (x :: a) ->
                    case GHC.List.elem @ a $dEq x exempt of wild {
                      GHC.Types.False
                      -> case GHC.List.elem @ a $dEq x b of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False }
                      GHC.Types.True -> GHC.Types.True })
                   a1) -}
0741894ac59e24a25fdb6bf898d028dd
  listUnion :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C(C1(U)),A)><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) (b :: [a]) ->
                 Data.OldList.nubBy
                   @ a
                   (GHC.Classes.== @ a $dEq)
                   (GHC.Base.augment
                      @ a
                      (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                       GHC.Base.foldr @ a @ b1 c n1 a1)
                      b)) -}
7f34069e25122faca67e824cfc2b6096
  lookupValueTable ::
    GHC.Base.String
    -> LanguageFortranTools.ValueTable
    -> GHC.Base.Maybe GHC.Types.Float
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (str :: GHC.Base.String)
                   (table :: LanguageFortranTools.ValueTable) ->
                 case LanguageFortranTools.$slookup1
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                        str
                        table of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Float
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) v t ->
                      GHC.Base.Just @ GHC.Types.Float v } }) -}
26d251d75c2c6bd0ddddd93b9397df03
  lookupValueTable_type ::
    GHC.Base.String
    -> LanguageFortranTools.ValueTable
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ (str :: GHC.Base.String)
                   (table :: LanguageFortranTools.ValueTable) ->
                 LanguageFortranTools.$slookup1
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   str
                   table) -}
947bb694d1143d6fbfde73cf39462be2
  maybeBinOp ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> (GHC.Types.Float -> GHC.Types.Float -> GHC.Types.Float)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: (\ (maybeFloat1 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (maybeFloat2 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (op :: GHC.Types.Float -> GHC.Types.Float -> GHC.Types.Float) ->
                 case maybeFloat1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) float1 typ1 ->
                      case maybeFloat2 of wild2 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                        GHC.Base.Just ds1
                        -> case ds1 of wild3 { (,) float2 typ2 ->
                           GHC.Base.Just
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                             (op float1 float2,
                              LanguageFortranTools.resolveType typ1 typ2) } } } }) -}
106928ef7ed48420fcaad0b1c03c2fef
  maybeBinOp_float ::
    GHC.Base.Maybe (t1, b1)
    -> GHC.Base.Maybe (t2, b2)
    -> (t1 -> t2 -> a)
    -> GHC.Base.Maybe
         (a, Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: (\ @ t
                   @ b
                   @ t1
                   @ b1
                   @ a
                   (maybeFloat1 :: GHC.Base.Maybe (t, b))
                   (maybeFloat2 :: GHC.Base.Maybe (t1, b1))
                   (op :: t -> t1 -> a) ->
                 case maybeFloat1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (a, Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) float1 typ1 ->
                      case maybeFloat2 of wild2 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (a, Language.Fortran.BaseType LanguageFortranTools.Anno)
                        GHC.Base.Just ds1
                        -> case ds1 of wild3 { (,) float2 typ2 ->
                           GHC.Base.Just
                             @ (a, Language.Fortran.BaseType LanguageFortranTools.Anno)
                             (op float1 float2,
                              LanguageFortranTools.maybeBinOp_float1) } } } }) -}
b0983f4a560a9b4c3ee5600ac6691bd3
  maybeBinOp_float1 ::
    Language.Fortran.BaseType LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Language.Fortran.Integer
                   @ LanguageFortranTools.Anno
                   (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
1301cac882ee2f9f7b89dc70444a71fb
  maybeBinOp_integral ::
    GHC.Real.Integral a =>
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> (a -> a -> a)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 4,
     Strictness: <L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: (\ @ a
                   ($dIntegral :: GHC.Real.Integral a)
                   (maybeFloat1 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (maybeFloat2 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (op :: a -> a -> a) ->
                 case maybeFloat1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) float1 typ1 ->
                      case maybeFloat2 of wild2 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                        GHC.Base.Just ds1
                        -> case ds1 of wild3 { (,) float2 typ2 ->
                           GHC.Base.Just
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                             (case GHC.Integer.Type.doubleFromInteger
                                     (GHC.Real.toInteger
                                        @ a
                                        $dIntegral
                                        (op
                                           (case float1 of ww { GHC.Types.F# ww1 ->
                                            GHC.Float.$w$cround1 @ a $dIntegral ww1 })
                                           (case float2 of ww { GHC.Types.F# ww1 ->
                                            GHC.Float.$w$cround1
                                              @ a
                                              $dIntegral
                                              ww1 }))) of wild4 { DEFAULT ->
                              GHC.Types.F# (GHC.Prim.double2Float# wild4) },
                              LanguageFortranTools.maybeBinOp_float1) } } } }) -}
82963c98282ee475f287e9377f9390a0
  maybeNegative ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe
                            (GHC.Types.Float,
                             Language.Fortran.BaseType LanguageFortranTools.Anno)) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 { (,) int typ ->
                      GHC.Base.Just
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                        (GHC.Float.negateFloat int, typ) } }) -}
2dcebbb0cfcad53e100f94b37235c3ce
  normaliseSrcSpan ::
    (Data.Data.Data (a LanguageFortranTools.Anno),
     Language.Fortran.Span (a LanguageFortranTools.Anno),
     Language.Fortran.Span t) =>
    t -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(U(1*U(A,1*U(U),A),A))><L,1*C1(U(1*U(A,1*U(U),A),A))><L,U><L,U>,
     Unfolding: (\ @ a :: * -> *
                   @ t
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   ($dSpan :: Language.Fortran.Span (a LanguageFortranTools.Anno))
                   ($dSpan1 :: Language.Fortran.Span t)
                   (correctSpanned :: t)
                   (badSpanned :: a LanguageFortranTools.Anno) ->
                 LanguageFortranTools.shiftSrcSpanLineGlobal
                   @ a
                   $dData
                   (case $dSpan1 `cast` (Language.Fortran.N:Span[0] <t>_N)
                           correctSpanned of wild { (,) ds ds1 ->
                    case ds of wild1 { Language.Fortran.SrcLoc ds2 correctLine ds3 ->
                    case correctLine of wild2 { GHC.Types.I# x ->
                    case $dSpan
                           `cast`
                         (Language.Fortran.N:Span[0] <a LanguageFortranTools.Anno>_N)
                           badSpanned of wild3 { (,) ds4 ds5 ->
                    case ds4 of wild4 { Language.Fortran.SrcLoc ds6 badLine ds7 ->
                    case badLine of wild5 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.-# x y) } } } } } })
                   badSpanned) -}
b5ec3f8914fec256ad2e53b761b9bd52
  nullAnno :: LanguageFortranTools.Anno
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String]) -}
70048daf19804e152496d0171ca45658
  nullSrcLoc :: Language.Fortran.SrcLoc
  {- Strictness: m,
     Unfolding: (Language.Fortran.SrcLoc
                   LanguageFortranTools.nullSrcLoc2
                   LanguageFortranTools.nullSrcLoc1
                   LanguageFortranTools.nullSrcLoc1) -}
ae8e4b58a9db7f9eb96a1eb1d13b67a9
  nullSrcLoc1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# -1#) -}
188419c0284aa844a5b3d2928f8acdd5
  nullSrcLoc2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.nullSrcLoc3) -}
db11cda4a9f31304e5b996d703cbc592
  nullSrcLoc3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("generated"#) -}
d9f6701836bf1a31425d57566b44db7b
  nullSrcSpan :: Language.Fortran.SrcSpan
  {- Strictness: m,
     Unfolding: ((LanguageFortranTools.nullSrcLoc,
                  LanguageFortranTools.nullSrcLoc)) -}
04a765aff7dc7295fa9835422f5a2ecb
  oneVarDeclPerVarDeclLine :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (contentLines :: [GHC.Base.String]) ->
                 LanguageFortranTools.oneVarDeclPerVarDeclLine_go
                   contentLines
                   (GHC.Types.[] @ GHC.Base.String)) -}
c8010c5056990eea394deba3b892010f
  oneVarDeclPerVarDeclLine_go ::
    [[GHC.Types.Char]] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
d4123f41824a146046d5f091a0757039
  orElem :: GHC.Classes.Eq a => a -> [[a]] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U> -}
071110acbe7f8df82378c3e15acadb0d
  outputExprFormatting ::
    Language.Fortran.Expr LanguageFortranTools.Anno -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
e52db0602fff64fd09a0948045bb72a5
  outputTab :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.outputTab1) -}
28181d35ea37f3d3813c321b20a8bebe
  outputTab1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("  "#) -}
7f0e0ed770467ef59fd723f4841e3190
  parseFile ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Types.IO
         ((Language.Fortran.Program LanguageFortranTools.Anno,
           [GHC.Base.String]),
          (GHC.Base.String, LanguageFortranTools.CodeStash),
          LanguageFortranTools.ModuleVarsTable)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.parseFile1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <((Language.Fortran.Program LanguageFortranTools.Anno,
                                  [GHC.Base.String]),
                                 (GHC.Base.String, LanguageFortranTools.CodeStash),
                                 LanguageFortranTools.ModuleVarsTable)>_R)) -}
3f9473e31776ea3d3804ac108f143cc6
  parseFile1 ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ((Language.Fortran.Program LanguageFortranTools.Anno,
            [GHC.Base.String]),
           (GHC.Base.String, LanguageFortranTools.CodeStash),
           LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: (\ (cppDArgs :: [GHC.Base.String])
                   (cppXArgs :: [GHC.Base.String])
                   (fixedForm :: GHC.Types.Bool)
                   (filename :: GHC.Base.String)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case LanguageFortranTools.$wpreProcessingHelper
                        cppDArgs
                        cppXArgs
                        fixedForm
                        filename
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,) preproc_inp stash moduleVarTable ->
                 (# ipv,
                    ((case GHC.Magic.runRW#
                             @ ('GHC.Types.TupleRep
                                  '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                             @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                  Language.Fortran.Program Language.Fortran.Parser.A0 #)
                             (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case GHC.Prim.noDuplicate#
                                     @ GHC.Prim.RealWorld
                                     s1 of s' { DEFAULT ->
                              case GHC.IO.Handle.Text.hPutStr2
                                     GHC.IO.Handle.FD.stdout
                                     (GHC.CString.unpackAppendCString#
                                        LanguageFortranTools.parseFile2
                                        filename)
                                     GHC.Types.True
                                     s' of ds2 { (#,#) ipv2 ipv3 ->
                              (# ipv2,
                                 Language.Fortran.Parser.parse
                                   preproc_inp #) } }) of ds { (#,#) ipv2 ipv3 ->
                      ipv3 },
                      Data.OldList.lines preproc_inp),
                     (filename, stash), moduleVarTable) #) } }) -}
73b829f2bc06e600d6832849bf8ba273
  parseFile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Parsing "#) -}
7a8b3c2fa40f95d6df5e9b0681e721d4
  preProcessingHelper ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Types.IO
         (GHC.Base.String, LanguageFortranTools.CodeStash,
          LanguageFortranTools.ModuleVarsTable)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,A><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.preProcessingHelper1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <(GHC.Base.String, LanguageFortranTools.CodeStash,
                                 LanguageFortranTools.ModuleVarsTable)>_R)) -}
6842fbee19caa7af4079453eb736aed5
  preProcessingHelper1 ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, LanguageFortranTools.CodeStash,
           LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,A><L,U><S,U>,
     Inline: [0],
     Unfolding: InlineRule (6, True, True)
                (\ (w :: [GHC.Base.String])
                   (w1 :: [GHC.Base.String])
                   (w2 :: GHC.Types.Bool)
                   (w3 :: GHC.Types.Bool)
                   (w4 :: GHC.Base.String)
                   (w5 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 LanguageFortranTools.$wpreProcessingHelper w w1 w2 w4 w5) -}
a1a63664642046780a00433226c69842
  readUsedModuleDecls ::
    GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.IO
         ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.inlineDeclsFromUsedModules2
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))>_R)) -}
88271269b0a76b96d931a508ee3978d3
  removeAllAnnotations :: Data.Data.Data a => a -> a
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (original :: a) ->
                 Data.Generics.Schemes.everywhere
                   LanguageFortranTools.removeAllAnnotations1
                   @ a
                   $dData
                   original) -}
603e321dbf13c655cea1e20e78db52cf
  removeAllAnnotations1 :: Data.Data.Data a => a -> a
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) ->
                 case LanguageFortranTools.extractBufferReads2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Data.Typeable.Internal.typeRepFingerprint
                        @ *
                        @ a
                        (Data.Data.$p1Data @ a $dData)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.id @ a
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.id @ a
                        1#
                        -> LanguageFortranTools.removeAnnotations
                             `cast`
                           (UnsafeCo representational (Language.Fortran.Fortran
                                                         LanguageFortranTools.Anno) a
                            ->_R UnsafeCo representational (Language.Fortran.Fortran
                                                              LanguageFortranTools.Anno) a) } } } }) -}
a70426fee671985e1016fb13bfd13555
  removeAnnotations ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (original :: Language.Fortran.Fortran
                                  LanguageFortranTools.Anno) ->
                 case original of wild {
                   DEFAULT -> wild
                   Language.Fortran.For anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.For
                        @ LanguageFortranTools.Anno
                        (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLMap anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.OpenCLMap
                        @ LanguageFortranTools.Anno
                        (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLReduce anno f2 f3 f4 f5 f6 f7 f8
                   -> Language.Fortran.OpenCLReduce
                        @ LanguageFortranTools.Anno
                        (Data.Map.Internal.Tip @ GHC.Base.String @ [GHC.Base.String])
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                        f8 }) -}
34f5362b635daa521636f09aab132d56
  removeLoopConstructs_recursive ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U> -}
cff8581a492a2237821e0a1c44d1e722
  replaceAllOccurences_varname ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    a LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> a LanguageFortranTools.Anno
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U(U,U)><L,U(U,U)>,
     Unfolding: (\ @ a :: * -> *
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (codeSeg :: a LanguageFortranTools.Anno)
                   (original :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (replacement :: Language.Fortran.VarName
                                     LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.VarName LanguageFortranTools.Anno
                             -> Language.Fortran.VarName LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceVarname original replacement
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.replaceAllOccurences_varname1 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT
                      -> (GHC.Base.id @ a1)
                           `cast`
                         (Sym (Data.Generics.Aliases.N:T[0] <a1>_R))
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT
                           -> (GHC.Base.id @ a1)
                                `cast`
                              (Sym (Data.Generics.Aliases.N:T[0] <a1>_R))
                           1#
                           -> lvl169
                                `cast`
                              (Sym (Data.Generics.Aliases.N:T[0]
                                        (UnsafeCo representational a1 (Language.Fortran.VarName
                                                                         LanguageFortranTools.Anno)))) } } } })
                     `cast`
                   (forall (a1 :: <*>_N).
                    <Data.Data.Data a1>_R ->_R Data.Generics.Aliases.N:T[0] <a1>_R)
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   codeSeg) -}
01027f84537c2672baa0bf9ae20fdcaf
  replaceAllOccurences_varname1 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.VarName
                        758275414034097677##
                        18215223083819119344##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataVarName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.VarName
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.VarName
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      LanguageFortranTools.extractAllVarNames3) }) -}
ed241b9e5508b14981874e4cbdda5859
  replaceAllOccurences_varnamePairs ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (originals :: [Language.Fortran.VarName LanguageFortranTools.Anno])
                   (replacements :: [Language.Fortran.VarName
                                       LanguageFortranTools.Anno]) ->
                 letrec {
                   go9 :: [Language.Fortran.VarName LanguageFortranTools.Anno]
                          -> [Language.Fortran.VarName LanguageFortranTools.Anno]
                          -> Language.Fortran.Fortran LanguageFortranTools.Anno
                          -> Language.Fortran.Fortran LanguageFortranTools.Anno
                     <join 3> {- Arity: 3 -}
                   = \ (ds :: [Language.Fortran.VarName LanguageFortranTools.Anno])
                       (_ys :: [Language.Fortran.VarName LanguageFortranTools.Anno])
                       (eta :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                     case ds of wild {
                       [] -> eta
                       : ipv ipv1
                       -> case _ys of wild1 {
                            [] -> eta
                            : ipv2 ipv3
                            -> go9
                                 ipv1
                                 ipv3
                                 (LanguageFortranTools.replaceAllOccurences_varname_$sreplaceAllOccurences_varname
                                    eta
                                    ipv
                                    ipv2) } }
                 } in
                 go9 originals replacements codeSeg) -}
c6a681401819f588d92511a9e307bbf1
  replaceAllOccurences_varname_$sreplaceAllOccurences_varname ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><L,U(U,U)><L,U(U,U)>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno)
                   (original :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (replacement :: Language.Fortran.VarName
                                     LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.VarName LanguageFortranTools.Anno
                             -> Language.Fortran.VarName LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceVarname original replacement
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a ($dData :: Data.Data.Data a) ->
                    case LanguageFortranTools.replaceAllOccurences_varname1 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a
                           (Data.Data.$p1Data @ a $dData)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT
                      -> (GHC.Base.id @ a)
                           `cast`
                         (Sym (Data.Generics.Aliases.N:T[0] <a>_R))
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT
                           -> (GHC.Base.id @ a)
                                `cast`
                              (Sym (Data.Generics.Aliases.N:T[0] <a>_R))
                           1#
                           -> lvl169
                                `cast`
                              (Sym (Data.Generics.Aliases.N:T[0]
                                        (UnsafeCo representational a (Language.Fortran.VarName
                                                                        LanguageFortranTools.Anno)))) } } } })
                     `cast`
                   (forall (a :: <*>_N).
                    <Data.Data.Data a>_R ->_R Data.Generics.Aliases.N:T[0] <a>_R)
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   codeSeg) -}
97e3729215fcdf4e3ef68d08ede68a9d
  replaceFortran ::
    Data.Data.Data a =>
    a
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> a
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (progAst :: a)
                   (oldFortran :: Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (newFortran :: Language.Fortran.Fortran
                                    LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.Fortran LanguageFortranTools.Anno
                             -> Language.Fortran.Fortran LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceFortran' oldFortran newFortran
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.extractBufferReads2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ a1
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ a1
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational (Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno) a1
                               ->_R UnsafeCo representational (Language.Fortran.Fortran
                                                                 LanguageFortranTools.Anno) a1) } } } })
                   @ a
                   $dData
                   progAst) -}
1795982e85b5107770fce84ba832019e
  replaceFortran' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Unfolding: (\ (oldFortran :: Language.Fortran.Fortran
                                    LanguageFortranTools.Anno)
                   (newFortran :: Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (currentFortran :: Language.Fortran.Fortran
                                        LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.replaceFortran'1
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2
                           oldFortran)
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2
                           currentFortran) of wild {
                   GHC.Types.False -> currentFortran
                   GHC.Types.True
                   -> LanguageFortranTools.shiftSrcSpanLineGlobal_$sshiftSrcSpanLineGlobal1
                        (case Language.Fortran.$fSpanFortran_$csrcSpan
                                @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                                currentFortran of wild1 { (,) ds ds1 ->
                         case ds of wild2 { Language.Fortran.SrcLoc ds2 correctLine ds3 ->
                         case correctLine of wild3 { GHC.Types.I# x ->
                         case Language.Fortran.$fSpanFortran_$csrcSpan
                                @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                                newFortran of wild4 { (,) ds4 ds5 ->
                         case ds4 of wild5 { Language.Fortran.SrcLoc ds6 badLine ds7 ->
                         case badLine of wild6 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.-# x y) } } } } } })
                        newFortran }) -}
d06196894807d5fb2719415282462a6f
  replaceFortran'1 ::
    Language.Fortran.Fortran
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.Fortran
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Unfolding: (Language.Fortran.$fEqBlock_$c==1
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fEqExpr_$s$fEqMap) -}
4fa848391826bd600764e54ed13813e9
  replaceProgUnit ::
    Data.Data.Data a =>
    a
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> a
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (ast :: a)
                   (oldProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno)
                   (newProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.ProgUnit LanguageFortranTools.Anno
                             -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceProgUnit' oldProgUnit newProgUnit
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.replaceProgUnit1 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ a1
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ a1
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational (Language.Fortran.ProgUnit
                                                            LanguageFortranTools.Anno) a1
                               ->_R UnsafeCo representational (Language.Fortran.ProgUnit
                                                                 LanguageFortranTools.Anno) a1) } } } })
                   @ a
                   $dData
                   ast) -}
7aa169531e3949d444feeb39d7e45a73
  replaceProgUnit' ::
    Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Unfolding: (\ (oldProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno)
                   (newProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno)
                   (currentProgUnit :: Language.Fortran.ProgUnit
                                         LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.replaceProgUnit'1
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1
                           oldProgUnit)
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1
                           currentProgUnit) of wild {
                   GHC.Types.False -> currentProgUnit
                   GHC.Types.True
                   -> LanguageFortranTools.shiftSrcSpanLineGlobal_$sshiftSrcSpanLineGlobal
                        (case Language.Fortran.$fSpanProgUnit_$csrcSpan
                                @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                                currentProgUnit of wild1 { (,) ds ds1 ->
                         case ds of wild2 { Language.Fortran.SrcLoc ds2 correctLine ds3 ->
                         case correctLine of wild3 { GHC.Types.I# x ->
                         case Language.Fortran.$fSpanProgUnit_$csrcSpan
                                @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                                newProgUnit of wild4 { (,) ds4 ds5 ->
                         case ds4 of wild5 { Language.Fortran.SrcLoc ds6 badLine ds7 ->
                         case badLine of wild6 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.-# x y) } } } } } })
                        newProgUnit }) -}
4e9aad0ec664c4ee679e639ee79c93f1
  replaceProgUnit'1 ::
    Language.Fortran.ProgUnit
      (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.ProgUnit
         (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Unfolding: (Language.Fortran.$fEqProgUnit_$c==
                   @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fEqExpr_$s$fEqMap) -}
d3b961b730fe96866180fd56a38bcdfb
  replaceProgUnit1 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ProgUnit
                        6479780727992239168##
                        17397259944912469841##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataProgUnit3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> * -> *)
                        @ Data.Map.Internal.Map
                        11323335571407833487##
                        2177232330301466659##
                        Data.Map.Internal.$trModule
                        Data.Map.Internal.$fDataMap9
                        0#
                        GHC.Types.krep$*->*->*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww1 { (#,,,,#) ww2 ww3 ww4 ww5 ww6 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ *
                   @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ Language.Fortran.ProgUnit
                      @ LanguageFortranTools.Anno
                      (Data.Typeable.Internal.TrTyCon
                         @ (* -> *)
                         @ Language.Fortran.ProgUnit
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12)
                      (Data.Typeable.Internal.mkTrApp
                         @ *
                         @ *
                         @ (Data.Map.Internal.Map GHC.Base.String)
                         @ [GHC.Base.String]
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ (* -> *)
                            @ Data.Map.Internal.Map
                            @ GHC.Base.String
                            (Data.Typeable.Internal.TrTyCon
                               @ (* -> * -> *)
                               @ Data.Map.Internal.Map
                               ww2
                               ww3
                               ww4
                               ww5
                               ww6)
                            LanguageFortranTools.extractAllVarNames5)
                         (Data.Typeable.Internal.mkTrApp
                            @ *
                            @ *
                            @ []
                            @ GHC.Base.String
                            LanguageFortranTools.extractAllVarNames4
                            LanguageFortranTools.extractAllVarNames5))) } }) -}
feb0e83ef142257cbe1629e0ab26aa89
  replaceSrSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ (input :: Language.Fortran.SrcSpan)
                   (current :: Language.Fortran.SrcSpan) ->
                 input) -}
736491a1380da448b9a30410f7b0b13b
  replaceVarname ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U(U,1*U)><L,1*U(U,U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.VarName LanguageFortranTools.Anno) ->
                 case w of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 LanguageFortranTools.$wreplaceVarname ww1 ww2 w1 ww4 ww5 } }) -}
8c20be8bd6579289a3eff9b4f4a486c4
  replaceVarname1 ::
    Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Map.Internal.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Types.Bool
  {- Unfolding: (Data.Map.Internal.$fEqMap_$c==
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   GHC.Classes.$fEq[]_$s$fEq[]2) -}
c5496ae2aeeae3a572fbb8430ba29b48
  resolveType ::
    Language.Fortran.BaseType LanguageFortranTools.Anno
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (type1 :: Language.Fortran.BaseType LanguageFortranTools.Anno)
                   (type2 :: Language.Fortran.BaseType LanguageFortranTools.Anno) ->
                 case Language.Fortran.$fEqBaseType_$c==
                        @ (Data.Map.Internal.Map GHC.Base.String [GHC.Base.String])
                        LanguageFortranTools.$s$fEqExpr_$s$fEqMap
                        type1
                        type2 of wild {
                   GHC.Types.False -> LanguageFortranTools.addToValueTable1
                   GHC.Types.True -> type1 }) -}
8eb1c63d1865e2844971cfc264b7ab2c
  runCpp ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Types.IO GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.runCpp1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
45fd73f713016d53d1a3c35d07afc34f
  runCpp1 ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (5, True, False)
                (\ (cppDArgs :: [GHC.Base.String])
                   (cppXArgs :: [GHC.Base.String])
                   (fixedForm :: GHC.Types.Bool)
                   (filename :: GHC.Base.String)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case LanguageFortranTools.preProcessingHelper1
                        cppDArgs
                        cppXArgs
                        fixedForm
                        GHC.Types.False
                        filename
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,) preproc_inp ds ds2 ->
                 (# ipv, preproc_inp #) } }) -}
af8b05453971f373a387bb79739b942d
  shiftSrcSpan ::
    GHC.Types.Int
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U)><S(SS),1*U(1*U(U,1*U(U),U),1*U(U,1*U(U),U))>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Language.Fortran.SrcSpan) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww2 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                 (Language.Fortran.SrcLoc ww4 (GHC.Num.$fNumInt_$c+ ww5 w) ww6,
                  Language.Fortran.SrcLoc
                    ww8
                    (GHC.Num.$fNumInt_$c+ ww9 w)
                    ww10) } } }) -}
f3d28e30b31f810fb766dd805a0cbf9b
  shiftSrcSpanLineGlobal ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    GHC.Types.Int
    -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,U>,
     Unfolding: (\ @ a :: * -> *
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (inc :: GHC.Types.Int)
                   (codeSeg :: a LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.shiftSrcSpan inc
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.applyGeneratedSrcSpans2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a1
                           (Data.Data.$p1Data @ a1 $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ a1
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ a1
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a1
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a1) } } } })
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   codeSeg) -}
be65136ca3de85ef684c307293f20ee9
  shiftSrcSpanLineGlobal_$sshiftSrcSpanLineGlobal ::
    GHC.Types.Int
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U(U)><L,U>,
     Unfolding: (\ (inc :: GHC.Types.Int)
                   (codeSeg :: Language.Fortran.ProgUnit LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.shiftSrcSpan inc
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a ($dData :: Data.Data.Data a) ->
                    case LanguageFortranTools.applyGeneratedSrcSpans2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a
                           (Data.Data.$p1Data @ a $dData)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ a
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ a
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a) } } } })
                   @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataProgUnit
                   codeSeg) -}
4bf665050de77372d5c7fe660d840e78
  shiftSrcSpanLineGlobal_$sshiftSrcSpanLineGlobal1 ::
    GHC.Types.Int
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U(U)><L,U>,
     Unfolding: (\ (inc :: GHC.Types.Int)
                   (codeSeg :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.shiftSrcSpan inc
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a ($dData :: Data.Data.Data a) ->
                    case LanguageFortranTools.applyGeneratedSrcSpans2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ a
                           (Data.Data.$p1Data @ a $dData)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ a
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ a
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a) } } } })
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   codeSeg) -}
0b04a17d804ef793673f1d8e5862fa5d
  split :: GHC.Types.Char -> [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ (delim :: GHC.Types.Char)
                   (str :: [GHC.Types.Char]) ->
                 let {
                   lvl169 :: GHC.Types.Char -> GHC.Types.Char
                     {- Arity: 1, Strictness: <S(S),1*U(U)>m,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (c :: GHC.Types.Char) ->
                                    case c of wild { GHC.Types.C# x ->
                                    case delim of wild1 { GHC.Types.C# y ->
                                    case GHC.Prim.eqChar# x y of lwild {
                                      DEFAULT -> wild 1# -> LanguageFortranTools.split1 } } }) -}
                   = \ (c :: GHC.Types.Char) ->
                     case c of wild { GHC.Types.C# x ->
                     case delim of wild1 { GHC.Types.C# y ->
                     case GHC.Prim.eqChar# x y of lwild {
                       DEFAULT -> wild 1# -> LanguageFortranTools.split1 } } }
                 } in
                 letrec {
                   go9 :: [GHC.Types.Char] -> [[GHC.Types.Char]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (s :: [GHC.Types.Char]) ->
                     case GHC.List.dropWhile
                            @ GHC.Types.Char
                            GHC.Unicode.isSpace
                            s of wild {
                       [] -> GHC.Types.[] @ [GHC.Types.Char]
                       : ipv ipv1
                       -> let {
                            ds :: ([GHC.Types.Char], [GHC.Types.Char])
                            = case GHC.List.$wbreak
                                     @ GHC.Types.Char
                                     GHC.Unicode.isSpace
                                     wild of ww { (#,#) ww1 ww2 ->
                              (ww1, ww2) }
                          } in
                          GHC.Types.:
                            @ [GHC.Types.Char]
                            (case ds of wild1 { (,) w s'' ->
                             GHC.Base.map @ GHC.Types.Char @ GHC.Types.Char lvl169 w })
                            (case ds of wild1 { (,) w s'' -> go9 s'' }) }
                 } in
                 go9
                   (GHC.Base.map
                      @ GHC.Types.Char
                      @ GHC.Types.Char
                      (\ (c :: GHC.Types.Char) ->
                       case delim of wild { GHC.Types.C# x ->
                       case c of wild1 { GHC.Types.C# y ->
                       case GHC.Prim.eqChar# x y of lwild {
                         DEFAULT -> case y of wild2 { DEFAULT -> wild1 ' '# -> wild }
                         1# -> LanguageFortranTools.split1 } } })
                      str)) -}
90d4f9b3ec25d09b256c572fefff3dba
  split1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
a4066e960bd0dd9493c31b303b022300
  splitDelim ::
    GHC.Base.String -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (patt :: GHC.Base.String)
                   (line :: GHC.Base.String) ->
                 letrec {
                   $wgo5 :: [GHC.Types.Char]
                            -> [[GHC.Types.Char]]
                            -> [GHC.Types.Char]
                            -> [GHC.Types.Char]
                            -> [[GHC.Types.Char]]
                     <join 4> {- Arity: 4, Strictness: <S,1*U><S,1*U><L,U><L,U>,
                                 Inline: [0] -}
                   = \ (w :: [GHC.Types.Char])
                       (ww :: [[GHC.Types.Char]])
                       (ww1 :: [GHC.Types.Char])
                       (ww2 :: [GHC.Types.Char]) ->
                     case w of wild {
                       []
                       -> GHC.Base.++
                            @ [GHC.Types.Char]
                            ww
                            (GHC.Types.:
                               @ [GHC.Types.Char]
                               ww1
                               (GHC.Types.[] @ [GHC.Types.Char]))
                       : y ys
                       -> case Data.OldList.isPrefixOf
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 patt
                                 ww2 of wild1 {
                            GHC.Types.False
                            -> case GHC.List.$wlenAcc
                                      @ GHC.Types.Char
                                      ww2
                                      0# of ww3 { DEFAULT ->
                               case GHC.Prim.># ww3 0# of lwild {
                                 DEFAULT -> $wgo5 ys ww ww1 ww2
                                 1#
                                 -> let {
                                      ds :: (GHC.Types.Char, [GHC.Types.Char])
                                      = case ww2 of wild2 {
                                          [] -> LanguageFortranTools.splitDelim1
                                          : ch' rest_of_line' -> (ch', rest_of_line') }
                                    } in
                                    $wgo5
                                      ys
                                      ww
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         ww1
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            (case ds of ds1 { (,) ch' rest_of_line' -> ch' })
                                            (GHC.Types.[] @ GHC.Types.Char)))
                                      (case ds of ds1 { (,) ch' rest_of_line' ->
                                       rest_of_line' }) } }
                            GHC.Types.True
                            -> $wgo5
                                 ys
                                 (GHC.Base.++
                                    @ [GHC.Types.Char]
                                    ww
                                    (GHC.Types.:
                                       @ [GHC.Types.Char]
                                       ww1
                                       (GHC.Types.[] @ [GHC.Types.Char])))
                                 (GHC.Types.[] @ GHC.Types.Char)
                                 (case Data.OldList.stripPrefix
                                         @ GHC.Types.Char
                                         GHC.Classes.$fEqChar
                                         patt
                                         ww2 of wild2 {
                                    GHC.Base.Nothing -> ww2 GHC.Base.Just r -> r }) } }
                 } in
                 $wgo5
                   line
                   (GHC.Types.[] @ [GHC.Types.Char])
                   (GHC.Types.[] @ GHC.Types.Char)
                   line) -}
c2c00fda1ed911db8882368eca57d955
  splitDelim1 :: (GHC.Types.Char, [GHC.Types.Char])
  {- Strictness: x -}
7d4d106c007bf5233a361deb20f5a487
  splitOutVarDecls :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case LanguageFortranTools.splitDelim
                        LanguageFortranTools.findDeclLineVars9
                        line of wild {
                   [] -> case GHC.List.badHead ret_ty [[GHC.Types.Char]] of {}
                   : x ds1
                   -> case LanguageFortranTools.splitDelim
                             LanguageFortranTools.findDeclLineVars7
                             x of wild1 {
                        []
                        -> case LanguageFortranTools.splitOutVarDecls2
                           ret_ty [[GHC.Types.Char]]
                           of {}
                        : lhs ds
                        -> case ds of wild2 {
                             []
                             -> case LanguageFortranTools.splitOutVarDecls2
                                ret_ty [[GHC.Types.Char]]
                                of {}
                             : rhs ds2
                             -> case ds2 of wild3 {
                                  []
                                  -> GHC.Base.map
                                       @ [GHC.Types.Char]
                                       @ [GHC.Types.Char]
                                       (\ (var :: [GHC.Types.Char]) ->
                                        GHC.Base.++
                                          @ GHC.Types.Char
                                          lhs
                                          (GHC.CString.unpackAppendCString#
                                             LanguageFortranTools.splitOutVarDecls1
                                             var))
                                       (LanguageFortranTools.splitDelim
                                          LanguageFortranTools.findDeclLineVars_needle
                                          rhs)
                                  : ipv ipv1
                                  -> case LanguageFortranTools.splitOutVarDecls2
                                     ret_ty [[GHC.Types.Char]]
                                     of {} } } } }) -}
c77909909c6be6f1552ab0ffcadafae2
  splitOutVarDecls1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" :: "#) -}
ecb160f3f370b0b15fe4085347cfd89c
  splitOutVarDecls2 :: (GHC.Base.String, GHC.Base.String)
  {- Strictness: x -}
c04e1c706b70ba96c1b0cba68a25e122
  srcSpanInSrcSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case ww2 of ww9 { Language.Fortran.SrcLoc ww10 ww11 ww12 ->
                 case w1 of ww13 { (,) ww14 ww15 ->
                 case ww14 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                 case ww18 of ww20 { GHC.Types.I# ww21 ->
                 case ww15 of ww22 { Language.Fortran.SrcLoc ww23 ww24 ww25 ->
                 LanguageFortranTools.$wsrcSpanInSrcSpan
                   ww8
                   ww6
                   ww11
                   ww12
                   ww21
                   ww19
                   ww24
                   ww25 } } } } } } } }) -}
917a5e7f7d210cd5760ff4f66fe41e44
  srcSpanInSrcSpanRange ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)><S(LS),1*U(A,1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))>,
     Unfolding: InlineRule (3, True, False)
                (\ (start :: Language.Fortran.SrcSpan)
                   (finish :: Language.Fortran.SrcSpan)
                   (inside :: Language.Fortran.SrcSpan) ->
                 LanguageFortranTools.srcSpanInSrcSpan
                   (Data.Tuple.fst
                      @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      start,
                    Data.Tuple.snd
                      @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      finish)
                   inside) -}
29a782e9565b2396d9ce12cfe4caa533
  srcSpanLineCount :: Language.Fortran.SrcSpan -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)S(LS(S)L)),1*U(1*U(A,1*U(U),A),1*U(A,1*U(U),A))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds1 ds2 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc fs ls cs ->
                 case ds2 of wild2 { Language.Fortran.SrcLoc fe le ce ->
                 GHC.Num.$fNumInt_$c- le ls } } }) -}
86113634805728e5513a4ae4d8033f83
  standardiseSrcSpan ::
    Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (src :: Language.Fortran.SrcSpan) ->
                 LanguageFortranTools.nullSrcSpan) -}
fd06d75e63e15ff29f83d90605d1dbd1
  stretchSrc ::
    GHC.Types.Int
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(U)><S(LS),1*U(U,1*U(U,1*U(U),U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (inc :: GHC.Types.Int)
                   (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) srcLoc ds1 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc fe le ce ->
                 (srcLoc,
                  Language.Fortran.SrcLoc
                    fe
                    (GHC.Num.$fNumInt_$c+ le inc)
                    ce) } }) -}
2cc0bd9c661134c6b2a3551060e3faa5
  stretchSrcSpanLine ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    GHC.Types.Int
    -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <S(LLLLLLLC(C(S))LLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A)><L,U(U)><L,U>,
     Unfolding: (\ @ a :: * -> *
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (inc :: GHC.Types.Int)
                   (codeSeg :: a LanguageFortranTools.Anno) ->
                 let {
                   lvl169 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.stretchSrc inc
                 } in
                 Data.Data.gmapT
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   (\ @ b ($dData1 :: Data.Data.Data b) ->
                    case LanguageFortranTools.applyGeneratedSrcSpans2 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                    case Data.Typeable.Internal.typeRepFingerprint
                           @ *
                           @ b
                           (Data.Data.$p1Data @ b $dData1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <b>_N) of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                    case GHC.Prim.eqWord# dt dt2 of lwild {
                      DEFAULT -> GHC.Base.id @ b
                      1#
                      -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                           DEFAULT -> GHC.Base.id @ b
                           1#
                           -> lvl169
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan b
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan b) } } } })
                   codeSeg) -}
ff394e4c2d3b4f4a9436013fcb176452
  tabInc :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   LanguageFortranTools.tabInc1) -}
7e79b0f0a26063606f533db4e704e4e0
  tabInc1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("    "#) -}
00ff0b26bb5d63341741ba46ff41bec3
  takeLast :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: [a]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 LanguageFortranTools.$wtakeLast @ a ww1 w1 }) -}
7d2c218fc10d46bb84c0283ce865c490
  takeLast1 :: [a]
  {- Unfolding: (\ @ a ->
                 GHC.List.reverse1 @ a (GHC.Types.[] @ a) (GHC.Types.[] @ a)) -}
6d0ef74e46680a3ecc3cdcc8b1661ac0
  trimFront :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (inp :: GHC.Base.String) ->
                 GHC.Base.build
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n1 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      (GHC.List.filterFB
                         @ GHC.Types.Char
                         @ b
                         c
                         LanguageFortranTools.trimFront1)
                      n1
                      inp)) -}
9a784744d49a656f7d9c88f16f3f8358
  trimFront1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Char) ->
                 case x of wild { GHC.Types.C# x1 ->
                 case x1 of wild1 {
                   DEFAULT -> GHC.Types.True
                   '\t'# -> GHC.Types.False
                   ' '# -> GHC.Types.False } }) -}
e85d7745c8134a728fde9310ab248c87
  usesVarName ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U(U,U)><S,1*U>,
     Unfolding: (\ (varnameInp :: Language.Fortran.VarName
                                    LanguageFortranTools.Anno)
                   (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> LanguageFortranTools.usesVarName1
                   Language.Fortran.Var ds1 ds2 list
                   -> case list of wild1 {
                        [] -> GHC.Types.False
                        : y ys
                        -> case y of wild2 { (,) varname exprs ->
                           case varname of ww { Language.Fortran.VarName ww1 ww2 ->
                           case varnameInp of ww3 { Language.Fortran.VarName ww4 ww5 ->
                           case LanguageFortranTools.replaceVarname1 ww1 ww4 of wild3 {
                             GHC.Types.False
                             -> letrec {
                                  $sgo :: [(Language.Fortran.VarName
                                              (Data.Map.Internal.Map
                                                 [GHC.Types.Char] [[GHC.Types.Char]]),
                                            [Language.Fortran.Expr
                                               (Data.Map.Internal.Map
                                                  [GHC.Types.Char] [[GHC.Types.Char]])])]
                                          -> GHC.Types.Bool
                                    <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                  = \ (sc :: [(Language.Fortran.VarName
                                                 (Data.Map.Internal.Map
                                                    [GHC.Types.Char] [[GHC.Types.Char]]),
                                               [Language.Fortran.Expr
                                                  (Data.Map.Internal.Map
                                                     [GHC.Types.Char] [[GHC.Types.Char]])])]) ->
                                    case sc of wild4 {
                                      [] -> GHC.Types.False
                                      : y1 ys1
                                      -> case y1 of wild5 { (,) varname1 exprs1 ->
                                         case varname1 of ww7 { Language.Fortran.VarName ww8 ww9 ->
                                         case LanguageFortranTools.replaceVarname1
                                                ww8
                                                ww4 of wild6 {
                                           GHC.Types.False -> $sgo ys1
                                           GHC.Types.True
                                           -> go9 ys1 (GHC.Base.eqString ww9 ww5) } } } }
                                  go9 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                           [Language.Fortran.Expr LanguageFortranTools.Anno])]
                                         -> GHC.Types.Bool -> GHC.Types.Bool
                                    <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                                  = \ (ds3 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                                [Language.Fortran.Expr LanguageFortranTools.Anno])])
                                      (eta :: GHC.Types.Bool) ->
                                    case ds3 of wild4 {
                                      [] -> eta
                                      : y1 ys1
                                      -> case eta of wild5 {
                                           GHC.Types.False
                                           -> case y1 of wild6 { (,) varname1 exprs1 ->
                                              case varname1 of ww7 { Language.Fortran.VarName ww8 ww9 ->
                                              case LanguageFortranTools.replaceVarname1
                                                     ww8
                                                     ww4 of wild7 {
                                                GHC.Types.False -> $sgo ys1
                                                GHC.Types.True
                                                -> go9 ys1 (GHC.Base.eqString ww9 ww5) } } }
                                           GHC.Types.True -> go9 ys1 GHC.Types.True } }
                                } in
                                $sgo ys
                             GHC.Types.True
                             -> letrec {
                                  $sgo :: [(Language.Fortran.VarName
                                              (Data.Map.Internal.Map
                                                 [GHC.Types.Char] [[GHC.Types.Char]]),
                                            [Language.Fortran.Expr
                                               (Data.Map.Internal.Map
                                                  [GHC.Types.Char] [[GHC.Types.Char]])])]
                                          -> GHC.Types.Bool
                                    <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                  = \ (sc :: [(Language.Fortran.VarName
                                                 (Data.Map.Internal.Map
                                                    [GHC.Types.Char] [[GHC.Types.Char]]),
                                               [Language.Fortran.Expr
                                                  (Data.Map.Internal.Map
                                                     [GHC.Types.Char] [[GHC.Types.Char]])])]) ->
                                    case sc of wild4 {
                                      [] -> GHC.Types.False
                                      : y1 ys1
                                      -> case y1 of wild5 { (,) varname1 exprs1 ->
                                         case varname1 of ww7 { Language.Fortran.VarName ww8 ww9 ->
                                         case LanguageFortranTools.replaceVarname1
                                                ww8
                                                ww4 of wild6 {
                                           GHC.Types.False -> $sgo ys1
                                           GHC.Types.True
                                           -> go9 ys1 (GHC.Base.eqString ww9 ww5) } } } }
                                  go9 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                           [Language.Fortran.Expr LanguageFortranTools.Anno])]
                                         -> GHC.Types.Bool -> GHC.Types.Bool
                                    <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                                  = \ (ds3 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                                [Language.Fortran.Expr LanguageFortranTools.Anno])])
                                      (eta :: GHC.Types.Bool) ->
                                    case ds3 of wild4 {
                                      [] -> eta
                                      : y1 ys1
                                      -> case eta of wild5 {
                                           GHC.Types.False
                                           -> case y1 of wild6 { (,) varname1 exprs1 ->
                                              case varname1 of ww7 { Language.Fortran.VarName ww8 ww9 ->
                                              case LanguageFortranTools.replaceVarname1
                                                     ww8
                                                     ww4 of wild7 {
                                                GHC.Types.False -> $sgo ys1
                                                GHC.Types.True
                                                -> go9 ys1 (GHC.Base.eqString ww9 ww5) } } }
                                           GHC.Types.True -> go9 ys1 GHC.Types.True } }
                                } in
                                go9 ys (GHC.Base.eqString ww2 ww5) } } } } } }) -}
38183138115f52af5d0f3e3626884e3d
  usesVarName1 :: GHC.Types.Bool
  {- Strictness: x -}
7c75ad65f572a2cb7160776fea4e5c98
  usesVarName_list ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
c813920057088e9cc99c19be5a935d27
  varNameListStr ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.VarName
                             LanguageFortranTools.Anno]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : var ds1
                   -> case ds1 of wild1 {
                        [] -> case var of wild2 { Language.Fortran.VarName ds2 str -> str }
                        : ipv ipv1
                        -> case var of wild2 { Language.Fortran.VarName ds2 str ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             str
                             (GHC.CString.unpackAppendCString#
                                LanguageFortranTools.findDeclLineVars1
                                (LanguageFortranTools.varNameListStr_$svarNameListStr
                                   ipv
                                   ipv1)) } } }) -}
799c60dc2be4dd4c65823ea5fdf0844e
  varNameListStr_$svarNameListStr ::
    Language.Fortran.VarName
      (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])
    -> [Language.Fortran.VarName
          (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])]
    -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)><S,1*U> -}
4f55193896441ff99d96346c5aacd560
  varNameStr ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.VarName LanguageFortranTools.Anno) ->
                 case ds of wild { Language.Fortran.VarName ds1 str -> str }) -}
"SC:$wlistCountAppearances0" [0] forall @ a
                                        (sc :: a)
                                        (sc1 :: [a])
                                        (sc2 :: a)
                                        (sc3 :: GHC.Classes.Eq a)
  LanguageFortranTools.$wlistCountAppearances @ a
                                              sc3
                                              sc2
                                              (GHC.Types.: @ a sc sc1)
  = LanguageFortranTools.listCountAppearances_$s$wlistCountAppearances
      @ a
      sc
      sc1
      sc2
      sc3
"SC:generateESeq0" forall (sc :: Language.Fortran.VarName
                                   (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]]))
                          (sc1 :: [Language.Fortran.VarName
                                     (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])])
  LanguageFortranTools.generateESeq (GHC.Types.:
                                       @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                       sc
                                       sc1)
  = LanguageFortranTools.generateESeq_$sgenerateESeq sc sc1
"SC:generateFSeq0" forall (sc :: Language.Fortran.Fortran
                                   (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]]))
                          (sc1 :: [Language.Fortran.Fortran
                                     (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])])
  LanguageFortranTools.generateFSeq (GHC.Types.:
                                       @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                                       sc
                                       sc1)
  = LanguageFortranTools.generateFSeq_$sgenerateFSeq sc sc1
"SC:inlineDeclsFromUsedModules0" forall (sc :: GHC.Prim.State#
                                                 GHC.Prim.RealWorld)
                                        (sc1 :: GHC.Types.Bool)
                                        (sc2 :: [[GHC.Types.Char]])
                                        (sc3 :: [[GHC.Types.Char]])
                                        (sc4 :: [[GHC.Types.Char]])
  LanguageFortranTools.inlineDeclsFromUsedModules1 GHC.Types.True
                                                   sc4
                                                   sc3
                                                   sc2
                                                   sc1
                                                   sc
  = LanguageFortranTools.inlineDeclsFromUsedModules_$sinlineDeclsFromUsedModules
      sc
      sc1
      sc2
      sc3
      sc4
"SC:listExtractSingleAppearances'0" forall @ a
                                           (sc :: [a])
                                           (sc1 :: a)
                                           (sc2 :: [a])
                                           (sc3 :: GHC.Classes.Eq a)
  LanguageFortranTools.listExtractSingleAppearances' @ a
                                                     sc3
                                                     (GHC.Types.: @ a sc1 sc2)
                                                     sc
  = LanguageFortranTools.listExtractSingleAppearances'_$slistExtractSingleAppearances'
      @ a
      sc
      sc1
      sc2
      sc3
"SC:varNameListStr0" forall (sc :: Language.Fortran.VarName
                                     (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]]))
                            (sc1 :: [Language.Fortran.VarName
                                       (Data.Map.Internal.Map [GHC.Types.Char] [[GHC.Types.Char]])])
  LanguageFortranTools.varNameListStr (GHC.Types.:
                                         @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                         sc
                                         sc1)
  = LanguageFortranTools.varNameListStr_$svarNameListStr sc sc1
"SPEC appendToMap @ String _" forall @ a
                                     ($dOrd :: GHC.Classes.Ord GHC.Base.String)
  LanguageFortranTools.appendToMap @ [GHC.Types.Char] @ a $dOrd
  = LanguageFortranTools.appendAnnotation_$sappendToMap @ a
"SPEC applyGeneratedSrcSpans @ Expr" forall ($dData :: Data.Data.Data
                                                         (Language.Fortran.Expr
                                                            LanguageFortranTools.Anno))
  LanguageFortranTools.applyGeneratedSrcSpans @ Language.Fortran.Expr
                                              $dData
  = LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans
"SPEC applyGeneratedSrcSpans @ Fortran" forall ($dData :: Data.Data.Data
                                                            (Language.Fortran.Fortran
                                                               LanguageFortranTools.Anno))
  LanguageFortranTools.applyGeneratedSrcSpans @ Language.Fortran.Fortran
                                              $dData
  = LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2
"SPEC applyGeneratedSrcSpans @ ProgUnit" forall ($dData :: Data.Data.Data
                                                             (Language.Fortran.ProgUnit
                                                                LanguageFortranTools.Anno))
  LanguageFortranTools.applyGeneratedSrcSpans @ Language.Fortran.ProgUnit
                                              $dData
  = LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1
"SPEC combineMaps @ String _" forall @ a
                                     ($dOrd :: GHC.Classes.Ord GHC.Base.String)
  LanguageFortranTools.combineMaps @ [GHC.Types.Char] @ a $dOrd
  = LanguageFortranTools.appendAnnotationMap_$scombineMaps @ a
"SPEC extractOperands @ Anno" forall ($dData :: Data.Data.Data
                                                  LanguageFortranTools.Anno)
                                     ($dTypeable :: Data.Typeable.Internal.Typeable
                                                      LanguageFortranTools.Anno)
  LanguageFortranTools.extractOperands @ (Data.Map.Internal.Map
                                            GHC.Base.String [GHC.Base.String])
                                       $dTypeable
                                       $dData
  = LanguageFortranTools.extractOperands_$sextractOperands
"SPEC replaceAllOccurences_varname @ Fortran" forall ($dData :: Data.Data.Data
                                                                  (Language.Fortran.Fortran
                                                                     LanguageFortranTools.Anno))
  LanguageFortranTools.replaceAllOccurences_varname @ Language.Fortran.Fortran
                                                    $dData
  = LanguageFortranTools.replaceAllOccurences_varname_$sreplaceAllOccurences_varname
"SPEC shiftSrcSpanLineGlobal @ Fortran" forall ($dData :: Data.Data.Data
                                                            (Language.Fortran.Fortran
                                                               LanguageFortranTools.Anno))
  LanguageFortranTools.shiftSrcSpanLineGlobal @ Language.Fortran.Fortran
                                              $dData
  = LanguageFortranTools.shiftSrcSpanLineGlobal_$sshiftSrcSpanLineGlobal1
"SPEC shiftSrcSpanLineGlobal @ ProgUnit" forall ($dData :: Data.Data.Data
                                                             (Language.Fortran.ProgUnit
                                                                LanguageFortranTools.Anno))
  LanguageFortranTools.shiftSrcSpanLineGlobal @ Language.Fortran.ProgUnit
                                              $dData
  = LanguageFortranTools.shiftSrcSpanLineGlobal_$sshiftSrcSpanLineGlobal
"SPEC/LanguageFortranTools $fDataExpr @ (Map String [String])" [orphan] forall (v :: Data.Data.Data
                                                                                       (Data.Map.Internal.Map
                                                                                          GHC.Base.String
                                                                                          [GHC.Base.String]))
  Language.Fortran.$fDataExpr @ (Data.Map.Internal.Map
                                   GHC.Base.String [GHC.Base.String])
                              v
  = LanguageFortranTools.$s$fDataExpr
"SPEC/LanguageFortranTools $fDataFortran @ (Map String [String])" [orphan] forall (v :: Data.Data.Data
                                                                                          (Data.Map.Internal.Map
                                                                                             GHC.Base.String
                                                                                             [GHC.Base.String]))
  Language.Fortran.$fDataFortran @ (Data.Map.Internal.Map
                                      GHC.Base.String [GHC.Base.String])
                                 v
  = LanguageFortranTools.$s$fDataFortran
"SPEC/LanguageFortranTools $fDataFortran5 @ (Map String [String])" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                                 (Data.Map.Internal.Map
                                                                                                    GHC.Base.String
                                                                                                    [GHC.Base.String]))
  Language.Fortran.$fDataFortran5 @ (Data.Map.Internal.Map
                                       GHC.Base.String [GHC.Base.String])
                                  $dData1
  = LanguageFortranTools.$s$fDataFortran5
"SPEC/LanguageFortranTools $fDataMap @ [Char] @ [String]" [orphan] forall (v2 :: GHC.Classes.Ord
                                                                                   [GHC.Types.Char])
                                                                          (v1 :: Data.Data.Data
                                                                                   [GHC.Base.String])
                                                                          (v :: Data.Data.Data
                                                                                  [GHC.Types.Char])
  Data.Map.Internal.$fDataMap @ [GHC.Types.Char]
                              @ [GHC.Base.String]
                              v
                              v1
                              v2
  = LanguageFortranTools.$s$fDataExpr_$s$fDataMap
"SPEC/LanguageFortranTools $fDataMap_$cdataCast2 @ [Char] @ [String]" [orphan] [0] forall (w2 :: GHC.Classes.Ord
                                                                                                   [GHC.Types.Char])
                                                                                          (w1 :: Data.Data.Data
                                                                                                   [GHC.Base.String])
                                                                                          (w :: Data.Data.Data
                                                                                                  [GHC.Types.Char])
  Data.Map.Internal.$fDataMap_$cdataCast2 @ [GHC.Types.Char]
                                          @ [GHC.Base.String]
                                          w
                                          w1
                                          w2
  = LanguageFortranTools.$s$fDataMap_$cdataCast2
"SPEC/LanguageFortranTools $fDataProgUnit @ (Map String [String])" [orphan] forall (v :: Data.Data.Data
                                                                                           (Data.Map.Internal.Map
                                                                                              GHC.Base.String
                                                                                              [GHC.Base.String]))
  Language.Fortran.$fDataProgUnit @ (Data.Map.Internal.Map
                                       GHC.Base.String [GHC.Base.String])
                                  v
  = LanguageFortranTools.$s$fDataProgUnit
"SPEC/LanguageFortranTools $fDataProgUnit5 @ (Map String [String])" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                                  (Data.Map.Internal.Map
                                                                                                     GHC.Base.String
                                                                                                     [GHC.Base.String]))
  Language.Fortran.$fDataProgUnit5 @ (Data.Map.Internal.Map
                                        GHC.Base.String [GHC.Base.String])
                                   $dData1
  = LanguageFortranTools.$s$fDataProgUnit5
"SPEC/LanguageFortranTools $fData[] @ [Char]" [orphan] forall (v :: Data.Data.Data
                                                                      [GHC.Types.Char])
  Data.Data.$fData[] @ [GHC.Types.Char] v
  = LanguageFortranTools.$s$fDataExpr_$s$fData[]
"SPEC/LanguageFortranTools $fData[]7 @ [Char]" [orphan] forall ($dData :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fData[]7 @ [GHC.Types.Char] $dData
  = LanguageFortranTools.$s$fData[]7
"SPEC/LanguageFortranTools $fEqExpr @ (Map String [String])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                     (Data.Map.Internal.Map
                                                                                        GHC.Base.String
                                                                                        [GHC.Base.String]))
  Language.Fortran.$fEqExpr @ (Data.Map.Internal.Map
                                 GHC.Base.String [GHC.Base.String])
                            v
  = LanguageFortranTools.$s$fEqExpr
"SPEC/LanguageFortranTools $fEqExpr_$c/= @ (Map String [String])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                             (Data.Map.Internal.Map
                                                                                                GHC.Base.String
                                                                                                [GHC.Base.String]))
  Language.Fortran.$fEqExpr_$c/= @ (Data.Map.Internal.Map
                                      GHC.Base.String [GHC.Base.String])
                                 $dEq
  = LanguageFortranTools.$s$fEqExpr_$s$fEqExpr_$c/=
"SPEC/LanguageFortranTools $fEqMap @ [Char] @ [String]" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                                 [GHC.Base.String])
                                                                        (v :: GHC.Classes.Eq
                                                                                [GHC.Types.Char])
  Data.Map.Internal.$fEqMap @ [GHC.Types.Char]
                            @ [GHC.Base.String]
                            v
                            v1
  = LanguageFortranTools.$s$fEqExpr_$s$fEqMap
"SPEC/LanguageFortranTools $fEqMap_$c/= @ [Char] @ [String]" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                                         [GHC.Base.String])
                                                                             ($dEq :: GHC.Classes.Eq
                                                                                        [GHC.Types.Char])
  Data.Map.Internal.$fEqMap_$c/= @ [GHC.Types.Char]
                                 @ [GHC.Base.String]
                                 $dEq
                                 $dEq1
  = LanguageFortranTools.$s$fEqExpr_$s$fEqMap_$c/=
"SPEC/LanguageFortranTools $fEqVarName @ (Map String [String])" [orphan] forall (v :: GHC.Classes.Eq
                                                                                        (Data.Map.Internal.Map
                                                                                           GHC.Base.String
                                                                                           [GHC.Base.String]))
  Language.Fortran.$fEqVarName @ (Data.Map.Internal.Map
                                    GHC.Base.String [GHC.Base.String])
                               v
  = LanguageFortranTools.$s$fEqVarName
"SPEC/LanguageFortranTools $fEqVarName_$c/= @ (Map String [String])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                                                (Data.Map.Internal.Map
                                                                                                   GHC.Base.String
                                                                                                   [GHC.Base.String]))
  Language.Fortran.$fEqVarName_$c/= @ (Data.Map.Internal.Map
                                         GHC.Base.String [GHC.Base.String])
                                    $dEq
  = LanguageFortranTools.$s$fEqVarName_$s$fEqVarName_$c/=
"SPEC/LanguageFortranTools $fShowMap @ [Char] @ [String]" [orphan] forall (v1 :: GHC.Show.Show
                                                                                   [GHC.Base.String])
                                                                          (v :: GHC.Show.Show
                                                                                  [GHC.Types.Char])
  Data.Map.Internal.$fShowMap @ [GHC.Types.Char]
                              @ [GHC.Base.String]
                              v
                              v1
  = LanguageFortranTools.$s$fShowExpr_$cshowsPrec_$s$fShowMap
"SPEC/LanguageFortranTools $fShowMap_$cshow @ [Char] @ [String]" [orphan] forall ($dShow1 :: GHC.Show.Show
                                                                                               [GHC.Base.String])
                                                                                 ($dShow :: GHC.Show.Show
                                                                                              [GHC.Types.Char])
  Data.Map.Internal.$fShowMap_$cshow @ [GHC.Types.Char]
                                     @ [GHC.Base.String]
                                     $dShow
                                     $dShow1
  = LanguageFortranTools.$s$fShowMap_$cshow
"SPEC/LanguageFortranTools $fShowMap_$cshowList @ [Char] @ [String]" [orphan] forall ($dShow1 :: GHC.Show.Show
                                                                                                   [GHC.Base.String])
                                                                                     ($dShow :: GHC.Show.Show
                                                                                                  [GHC.Types.Char])
  Data.Map.Internal.$fShowMap_$cshowList @ [GHC.Types.Char]
                                         @ [GHC.Base.String]
                                         $dShow
                                         $dShow1
  = LanguageFortranTools.$s$fShowMap_$cshowList
"SPEC/LanguageFortranTools $fShowMap_$cshowsPrec @ [Char] @ [String]" [orphan] [0] forall (w1 :: GHC.Show.Show
                                                                                                   [GHC.Base.String])
                                                                                          (w :: GHC.Show.Show
                                                                                                  [GHC.Types.Char])
  Data.Map.Internal.$fShowMap_$cshowsPrec @ [GHC.Types.Char]
                                          @ [GHC.Base.String]
                                          w
                                          w1
  = LanguageFortranTools.$s$fShowMap_$cshowsPrec
"SPEC/LanguageFortranTools fromList @ String _" [orphan] forall @ a
                                                                ($dOrd :: GHC.Classes.Ord
                                                                            GHC.Base.String)
  Data.Map.Internal.fromList @ [GHC.Types.Char] @ a $dOrd
  = LanguageFortranTools.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

