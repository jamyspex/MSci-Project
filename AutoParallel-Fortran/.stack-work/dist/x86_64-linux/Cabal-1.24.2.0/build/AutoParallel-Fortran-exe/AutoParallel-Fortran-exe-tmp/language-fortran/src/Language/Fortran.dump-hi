
==================== FINAL INTERFACE ====================
2018-12-03 15:54:53.180121 UTC

interface main@main:Language.Fortran 8002
  interface hash: 9e1188588dda47a4ba659a2d5f966cc0
  ABI hash: c957d8f93581b3ce2cc521df25110d11
  export-list hash: cb4e2f808f933bd0493dcd95204741d0
  orphan hash: c0bbef0a3bf623bc649c9eb1ffccc44f
  flag hash: afdec844352392eb035c92d85775fb4a
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.Fortran.Arg{Language.Fortran.Arg}
  Language.Fortran.ArgList{Language.Fortran.ArgList}
  Language.Fortran.ArgName{Language.Fortran.ASeq Language.Fortran.ArgName Language.Fortran.NullArg}
  Language.Fortran.Attr{Language.Fortran.Allocatable Language.Fortran.Dimension Language.Fortran.External Language.Fortran.Intent Language.Fortran.Intrinsic Language.Fortran.MeasureUnit Language.Fortran.Optional Language.Fortran.Parameter Language.Fortran.Pointer Language.Fortran.Private Language.Fortran.Public Language.Fortran.Save Language.Fortran.Sequence Language.Fortran.Target Language.Fortran.Volatile}
  Language.Fortran.BaseType{Language.Fortran.Character Language.Fortran.Complex Language.Fortran.DerivedType Language.Fortran.Elemental Language.Fortran.Integer Language.Fortran.Logical Language.Fortran.Pure Language.Fortran.Real Language.Fortran.Recursive Language.Fortran.SomeType}
  Language.Fortran.BinOp{Language.Fortran.And Language.Fortran.Concat Language.Fortran.Div Language.Fortran.Minus Language.Fortran.Mul Language.Fortran.Or Language.Fortran.Plus Language.Fortran.Power Language.Fortran.RelEQ Language.Fortran.RelGE Language.Fortran.RelGT Language.Fortran.RelLE Language.Fortran.RelLT Language.Fortran.RelNE}
  Language.Fortran.Block{Language.Fortran.Block}
  Language.Fortran.DataForm{Language.Fortran.Data}
  Language.Fortran.Decl{Language.Fortran.AccessStmt Language.Fortran.AttrStmt Language.Fortran.Common Language.Fortran.DSeq Language.Fortran.DataDecl Language.Fortran.Decl Language.Fortran.DerivedTypeDef Language.Fortran.Equivalence Language.Fortran.ExternalStmt Language.Fortran.Include Language.Fortran.Interface Language.Fortran.MeasureUnitDef Language.Fortran.Namelist Language.Fortran.NullDecl Language.Fortran.TextDecl}
  Language.Fortran.Expr{Language.Fortran.ArrayCon Language.Fortran.AssgExpr Language.Fortran.Bin Language.Fortran.Bound Language.Fortran.CallExpr Language.Fortran.Con Language.Fortran.ConL Language.Fortran.ConS Language.Fortran.ESeq Language.Fortran.Null Language.Fortran.NullExpr Language.Fortran.ParenthesizedExpr Language.Fortran.Sqrt Language.Fortran.Unary Language.Fortran.Var}
  Language.Fortran.Fortran{Language.Fortran.Allocate Language.Fortran.Assg Language.Fortran.Backspace Language.Fortran.Call Language.Fortran.Close Language.Fortran.Continue Language.Fortran.Cycle Language.Fortran.DataStmt Language.Fortran.Deallocate Language.Fortran.DoWhile Language.Fortran.Endfile Language.Fortran.Exit Language.Fortran.FSeq Language.Fortran.For Language.Fortran.Forall Language.Fortran.Format Language.Fortran.Goto Language.Fortran.If Language.Fortran.Inquire Language.Fortran.Label Language.Fortran.NullStmt Language.Fortran.Nullify Language.Fortran.Open Language.Fortran.OpenCLBufferRead Language.Fortran.OpenCLBufferWrite Language.Fortran.OpenCLMap Language.Fortran.OpenCLReduce Language.Fortran.OpenCLSeq Language.Fortran.Pause Language.Fortran.PointerAssg Language.Fortran.Print Language.Fortran.ReadS Language.Fortran.Return Language.Fortran.Rewind Language.Fortran.SelectStmt Language.Fortran.Stop Language.Fortran.TextStmt Language.Fortran.Where Language.Fortran.Write}
  Language.Fortran.Fraction{Language.Fortran.FractionConst Language.Fortran.IntegerConst Language.Fortran.NullFraction}
  Language.Fortran.GSpec{Language.Fortran.GAssg Language.Fortran.GName Language.Fortran.GOper}
  Language.Fortran.Implicit{Language.Fortran.ImplicitNone Language.Fortran.ImplicitNull}
  Language.Fortran.IntentAttr{Language.Fortran.In Language.Fortran.InOut Language.Fortran.Out}
  Language.Fortran.InterfaceSpec{Language.Fortran.FunctionInterface Language.Fortran.ModuleProcedure Language.Fortran.SubroutineInterface}
  Language.Fortran.MeasureUnit
  Language.Fortran.MeasureUnitSpec{Language.Fortran.UnitNone Language.Fortran.UnitProduct Language.Fortran.UnitQuotient}
  Language.Fortran.ProgName
  Language.Fortran.ProgUnit{Language.Fortran.BlockData Language.Fortran.Function Language.Fortran.IncludeProg Language.Fortran.Main Language.Fortran.Module Language.Fortran.NullProg Language.Fortran.PSeq Language.Fortran.Prog Language.Fortran.Sub}
  Language.Fortran.Program
  Language.Fortran.Renames
  Language.Fortran.Span{Language.Fortran.srcSpan}
  Language.Fortran.Spec{Language.Fortran.Access Language.Fortran.Action Language.Fortran.Advance Language.Fortran.Blank Language.Fortran.Delim Language.Fortran.Delimiter Language.Fortran.Direct Language.Fortran.End Language.Fortran.Eor Language.Fortran.Err Language.Fortran.ExFile Language.Fortran.Exist Language.Fortran.FMT Language.Fortran.File Language.Fortran.Floating Language.Fortran.Form Language.Fortran.Formatted Language.Fortran.IOLength Language.Fortran.IOStat Language.Fortran.NML Language.Fortran.Name Language.Fortran.Named Language.Fortran.NextRec Language.Fortran.NoSpec Language.Fortran.Number Language.Fortran.Opened Language.Fortran.Pad Language.Fortran.Position Language.Fortran.Read Language.Fortran.ReadWrite Language.Fortran.Rec Language.Fortran.Recl Language.Fortran.Sequential Language.Fortran.Size Language.Fortran.Status Language.Fortran.StringLit Language.Fortran.Unformatted Language.Fortran.Unit Language.Fortran.WriteSp}
  Language.Fortran.SrcLoc{Language.Fortran.SrcLoc srcColumn srcFilename srcLine}
  Language.Fortran.SrcSpan
  Language.Fortran.SubName{Language.Fortran.NullSubName Language.Fortran.SubName}
  Language.Fortran.Tagged{Language.Fortran.tag}
  Language.Fortran.Type{Language.Fortran.ArrayT Language.Fortran.BaseType}
  Language.Fortran.UnaryOp{Language.Fortran.Not Language.Fortran.UMinus}
  Language.Fortran.UseBlock{Language.Fortran.UseBlock}
  Language.Fortran.Uses{Language.Fortran.Use Language.Fortran.UseNil}
  Language.Fortran.VarName{Language.Fortran.VarName}
  Language.Fortran.Variable
module dependencies:
package dependencies: base-4.9.1.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS:Data.Generics.Instances
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Data da440c60016500822a3d4307ca5dea66
import  -/  base-4.9.1.0:Data.Typeable 9257e47d10882145c67c5b489965cfb7
import  -/  base-4.9.1.0:Data.Typeable.Internal 0e9bdefa4325a0112d8e73b5e1e1f85d
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.Read b6821365d2d5fa2155c9e910160e7f57
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:Text.ParserCombinators.ReadPrec 5a182a8d6deb0f7d67aed5fab08a5cc0
import  -/  base-4.9.1.0:Text.Read.Lex 16199fac3c6c2d64cc7c268f3c0d2269
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS:Data.Generics ea99a8062a9608312218ffd7309b5391
a54956ed8bf9b1d4a1b634f70d6f587c
  $c12Sm1gxWcOn3cUJRtBlJgB :: Data.Data.Constr
8f0fb3d9dbe9b40142abfd537fb794fb
  $c153RCtDJMOyJaz55P4WRZA :: Data.Data.Constr
6eaa30d33644f55067fda7f3159de5f8
  $c18YkNDG5QMhL8iPWXWrllf :: Data.Data.Constr
2a08784b8fff84be62edb1f4631e6608
  $c18aqH9BmJhgHld6kuetHv6 :: Data.Data.Constr
c683e60f8121838cd7c1d1d84b9636a7
  $c1CQ0luLqwKE0fss1qXQrBR :: Data.Data.Constr
96b9df53a51b3f43d46b14993bdf499e
  $c1IznUHFLi46FHd3grEUQfU :: Data.Data.Constr
d2043130274344c373e768cbbdd884ff
  $c1MhfwF7Y9jS0tsFMiHDDeD :: Data.Data.Constr
e5c7d3b91c7fa6493704e86a094d9cf7
  $c1Wz6iPX2W8tHU6q9f5HuxM :: Data.Data.Constr
46f174b73ad1b31798cdd30d3fb4025f
  $c1bIlWY0B7An9HoCGDZAyX6 :: Data.Data.Constr
07e42402a229a43081a4a65532487341
  $c1fQMqkMbKQTLcoqlmJAEse :: Data.Data.Constr
af7b80ac4130f39fc311eca02f6aa949
  $c1kxrjM0ubOr2AKqDtvXYpv :: Data.Data.Constr
ca8d7f5d63b754c0a6ad9176ca1b3955
  $c1punZIYcQoU5BRBrTkMOur :: Data.Data.Constr
2c5b95efde8211ca18cd633bd9a762ce
  $c1qcO2l0Dlc4HmQDSBM7P6x :: Data.Data.Constr
aab111557f2753bcd2989fe1accee849
  $c1qnG2e03wKqFUA1PtIEn7e :: Data.Data.Constr
d926635e5ef8e31af84d648407576476
  $c20exh3Nv2bF91fBcfHsSli :: Data.Data.Constr
6cd04502bc69cb1ad2b23ec042be9682
  $c22KnKYxEP4y33Osr94L5dt :: Data.Data.Constr
bc29028cef3e72f2961364e00a954663
  $c2AYhPPmEPMTJeQTk3WUMe2 :: Data.Data.Constr
82787a2240ca6b30473b08c3b642a197
  $c2DhuP2n5J9jK7fCzidnavw :: Data.Data.Constr
36da7bfd9be0dc8e6cded6776510064a
  $c2bis2A5kzul0VB1cVHCnO4 :: Data.Data.Constr
a151a9a85a4bbbe01b6eeb9e4d52d47b
  $c2i44pp7L9VbEUZLmsRmH3u :: Data.Data.Constr
cc59719374bbec48472f4539898f7b89
  $c2m43nNsGDGRBTaeiwQgc31 :: Data.Data.Constr
530baf02bbdce82bec2a51873981bca1
  $c2mK1s9VxLdt4GGXKi4786u :: Data.Data.Constr
727582bf497931e6de9dd308da44d2d8
  $c2zM3Wvd2OSTKQWpzDfGPs3 :: Data.Data.Constr
1b40cc77559575cc47be936aacce7cf4
  $c383qGoi97p81OtjiyaourQ :: Data.Data.Constr
86d4306223b1cb28217e12c04fac845b
  $c38rK9vmzDD4E6uZr2fvSTl :: Data.Data.Constr
afce38c7522c417563afdb7ad0ecfeae
  $c3YEyxCulpF32LgLHGSyebX :: Data.Data.Constr
3e4dc4287025aaa66b5a79e97caff67f
  $c3arFYhpAYyHAt36aWemnjU :: Data.Data.Constr
0383594ec31d1bc34da8df6efaf7f9d2
  $c3mMEKtaZYQL3iBM6k8DhAO :: Data.Data.Constr
77cc47df1a7aef56d2b3a73483f855ed
  $c3qv8lWLr4xn6EqXsj3zYHw :: Data.Data.Constr
85c6693487ddbb23f1a7abd9c6efa455
  $c4ANqVaXyL4yIdeOK79e62B :: Data.Data.Constr
0568b6c8a8b2822430b177db05fdbb2b
  $c4IpgnqT1fRXLxfwDHaby2z :: Data.Data.Constr
20509f5583899c20aa3d0cf4bf2374f6
  $c4SKEEpjEDeOD124ZRzk6QM :: Data.Data.Constr
9baffda6b6c07a9196edca73d7c7a599
  $c4SQpifNfQuGHtJQ44yIpuU :: Data.Data.Constr
31c0fc764770f2e824d95ae70e9dd594
  $c4YtPC6DHZWXAfR4LZG1kUS :: Data.Data.Constr
c974510462fff8b00f51436f73f8c13a
  $c4h74CzRNc1XLVWLIn3H4X2 :: Data.Data.Constr
468fa0aab05377240a6d8e4dac069045
  $c4xrtyfBJfgG9CdmZCyXplY :: Data.Data.Constr
4333a763c254214dcfea4cb99175688c
  $c57WXxHeFdMP6uTlDFEoR2e :: Data.Data.Constr
ed0264bc645d08fde08d5ae551b84130
  $c5IBBfvIJazmGZ0AUBImoCA :: Data.Data.Constr
f51dba4bbaee5f7b63a961ae5c74c77d
  $c5PpNSQeZhEd6mfzscovZzk :: Data.Data.Constr
7ff01bd3e2a3331a342721229e0bb2dd
  $c5SQPygD1Ty89qjjuuJHaUt :: Data.Data.Constr
dd1bed02e205be5fd005ee118d5b7ed8
  $c5UkOpWTdNZeHmddgiPGy4V :: Data.Data.Constr
3f70659e487e85fe937c2d07bb6d0040
  $c5e5NrY6v35hIG0HGZ9sZX6 :: Data.Data.Constr
1b400dbb5204f82ec288672b8c4dab9b
  $c5gqDvaOFUnJ5QtGWu4MTYJ :: Data.Data.Constr
8b171b59d02ff0336dca83868acffa6f
  $c5koiIUnlOzUKTeNbDqPNFO :: Data.Data.Constr
5277f969aef5c10129ace8ea2d0d4226
  $c5p5tLEohJso2vKXnu75TMm :: Data.Data.Constr
e63ba8e10a563895f659a541eae682e7
  $c5sCdJIX6mGtF7T4I5o5IXH :: Data.Data.Constr
f3971ed8c0b4e9af785f8c41b9853ff0
  $c5uLIP5eW38kBLuMWdEWDVA :: Data.Data.Constr
523c404b5c353c742786647c8b180d31
  $c5wamPn3Wrx17qM0d44RERP :: Data.Data.Constr
d24d3bd53db2eb6e274e98e74c2eb003
  $c60GMhfP1qJqKHS0iBvnyL8 :: Data.Data.Constr
cd8b4c485df0f5b9d8f1aba47cbfff56
  $c61GRAacu9E7KjUErp8I6wr :: Data.Data.Constr
d33090ae6f36a380c23e95a8c6f83c05
  $c64mCk8Ne1Wa90P1TKqd60d :: Data.Data.Constr
8e79f488f65e50443c5dc37af9020c40
  $c6VZm4EXLGcl6lxcJFA1Hbq :: Data.Data.Constr
3dc245fbf2d04f562a57b1b275affb10
  $c77NRxilTXqq793JqKDeH3Z :: Data.Data.Constr
fb0e5f76cddd8e517dec2f13c5779d4a
  $c78tQ8qZxOZr324tkfj0IRz :: Data.Data.Constr
ceebe0ad5d7533853c3fa360e6c0544a
  $c7B7CwvLXlI65LliAKSg6fB :: Data.Data.Constr
bcb4ab7fbab5cee08a53010fdd69bac6
  $c7DRQkmBPZA34szLkne8yRT :: Data.Data.Constr
597248d8f2588c0caac5c3f1c2413de8
  $c7Gl0pQ9Y43l2rL5R2ucb0T :: Data.Data.Constr
0026bf65061267be5245c845896c76c0
  $c7OcYfPjTVfVKWmGVGvQDuT :: Data.Data.Constr
1b0ddcf8bb67e0f603191508117cae14
  $c7ZgxpdN9n7XBLTHFJWmMgw :: Data.Data.Constr
a59590968825f8235f3eaf02f82fb50d
  $c7d8OlwqiJau34WHIostq8f :: Data.Data.Constr
9dfa1e728f9ce000f4a47c88002454c5
  $c7l8qyLFruibGotK7S3TC2C :: Data.Data.Constr
eadb34dbee3cf76361fe50e2e9fdc698
  $c7lfNiGPDM2tJsjHmBnjtvF :: Data.Data.Constr
602be187dfa74a996627818c2450ffae
  $c7zjF0LiJYf2AdH4exyJgTk :: Data.Data.Constr
2a548747116868a0ef5474cd4dfc6771
  $c85seZPcVf6L6w9soyXu5VI :: Data.Data.Constr
125a0c74c4e614279a744c2b3ad7e911
  $c8EqkxogGSaf38UCer6UE7V :: Data.Data.Constr
b29366ded3e2791cef3c185a7960e3f3
  $c8KKprhwZTDWIjt2XeaMi66 :: Data.Data.Constr
0e37dcd963a11b4f79dfa3f2d993aaba
  $c8V4DuEbkPAEIfcWhxCrJ2n :: Data.Data.Constr
61654996bd63db6b52d9165ed184e112
  $c8a2uDwF9ZA71XaRMXFjhlN :: Data.Data.Constr
a2d16317e8777b61771071101489d2d0
  $c8alWOQnlY8j5XvDy7ZLFeQ :: Data.Data.Constr
cc0e2bb1cd065bb7594a28b33bed5960
  $c8g6LBR4Z66Q9zl9ZbnAs01 :: Data.Data.Constr
87acf636f836a98ce3c618580f3879d3
  $c8mencuMehIDCmyd4I42Hz1 :: Data.Data.Constr
e9313baa592caa2c9904141716bf260e
  $c8oI8VcsgCvA41cZKrFA3aS :: Data.Data.Constr
1b8a64a2de3d965eeeeb4e308788c913
  $c8tHUVs27NcXHKX7Nm6RrSS :: Data.Data.Constr
65d94c9c331b757da463669164c25b7a
  $c8uxH7NWw8crDcRrppV58Jw :: Data.Data.Constr
24c90ea70c47502920245abc0987eafa
  $c8x2pi9QDrqRCm6uWv2rvPl :: Data.Data.Constr
0c43ddc548b17a00bd809ef0573fbbae
  $c9jJakhk2EHs3dQvW2C6t8f :: Data.Data.Constr
c6b3d68e55cd0fdd7f3fc34056cb9b04
  $c9oM7r2u0wZ0FXo9rh1iD7p :: Data.Data.Constr
4b8665ba7a28acdc74d4a81465f2a32a
  $c9omskyfFg9qBfOGsHHyRnk :: Data.Data.Constr
dde5462254b5120e3763f0ec90953b1c
  $c9wUW5raBQcVDAKDv14uNEd :: Data.Data.Constr
3c517b3f491be777e6decde892ba0420
  $cA3gtOKVvfj24du9egUU4pL :: Data.Data.Constr
dad3f240d4ce590137a94fcf11177613
  $cA4QSI58ZfFkLxGkxSbd69y :: Data.Data.Constr
aa14746ea511dee615f4caa3f9b062a8
  $cA6zFekJaEKo1Ig9n9uLZdR :: Data.Data.Constr
425dd1ccd532b79b667fbd19e384ad31
  $cAA5FnhjZgxtHvdjJc3iDfO :: Data.Data.Constr
e321e487b5a4db4595f7f668d3f6a578
  $cAF3epF9VjKiAWOEkFMvaa4 :: Data.Data.Constr
dc640b4fad26a56e4755b2bf00a0dadb
  $cAYXgtZzgYPd88xyJVp9FSm :: Data.Data.Constr
b53e18cb37d7d82a522a192a92dd0622
  $cAbMSwCXSfl8LUbBeST0WD9 :: Data.Data.Constr
66aedb55dd0d60cd669009e80cd21325
  $cAhS1i9Auu0J7VmXnhCTnJG :: Data.Data.Constr
5d9b9dd59344e649e20f4eb57c9deea2
  $cAzhApblMBHHJU8C7xBa9fJ :: Data.Data.Constr
899a065aad868775258084e31299ebce
  $cB2ZtwXqHF8L4PRGLDqv8gI :: Data.Data.Constr
e67c96fca2a879c6eceb6b59723d0323
  $cB6QEzUjKqweCeNxLtCZnTj :: Data.Data.Constr
dd4f27213bd93f7604db63e183e103fb
  $cB89Tp5UcFJY5zWyNR39ve9 :: Data.Data.Constr
d05eed0628b8752f74dd8595c264f747
  $cBDdjphmfhN46M2lJ4KqkC5 :: Data.Data.Constr
cc0c7d57646149ddb8e81b5e70181501
  $cBHObfxlHoGgA4QTTVq6oi4 :: Data.Data.Constr
05fd604d51a3cd599c53bcd339458957
  $cBOqujp4qXetGp5vwKhj7Tb :: Data.Data.Constr
b5e89d8368954948bae890b0334b08ec
  $cBSwpqhq0QE6EPH9yiaMC9K :: Data.Data.Constr
878064eafa23bfd2c2d9b62750cc740a
  $cBUetck2MQOs1Upzg5eNaup :: Data.Data.Constr
89d2b76ebf4007b1eefd5168d17bf363
  $cBaIe6LD43DmBcCQvn2FSto :: Data.Data.Constr
ba135bbfa0630266c741a8cd27866c0f
  $cBhco6aZ1tyeC07hEtbJOeV :: Data.Data.Constr
e4739a77a71de2d75bf74611f6d7fd4d
  $cBjUNnw5gxKeGq6ZKrPavlh :: Data.Data.Constr
915d0e3cb72a6f050fd172c3f51856a3
  $cBkX4OAQJ9orEBepae4Ozqm :: Data.Data.Constr
1e1673501c4c5c9cdc9cddf3099b3920
  $cBnoJ3Fz73Zm4yWidz7liRC :: Data.Data.Constr
6d9bc3fe55054ed54a5f2188931594d6
  $cBxm7TsMN2Uv3pnUvfizH4a :: Data.Data.Constr
8813056b7f2af08445fc93f23a1a8db3
  $cBxpvXAA12XjHuly5nuTiE8 :: Data.Data.Constr
6a094dccf965e1dfe4317257f584bf36
  $cC0nxMGD6gUKFvIpMtayQcB :: Data.Data.Constr
9e0275dc23dce17b41fed7693467faca
  $cCGFBodCaxL10tlXfi5MSfH :: Data.Data.Constr
cdc44ea0dd684ae455215c8ae5a4aa71
  $cCHtw2VnCYTERZ4xHeWpE4 :: Data.Data.Constr
60d41203ece6add3e21cf64e49f3f25f
  $cCJsE0jKA293JmiK7bwItsB :: Data.Data.Constr
bac8145632dea95245a6ceccc0286678
  $cCLEx3Oi2MB55JzB9GYZf6v :: Data.Data.Constr
6e8bea67badb90b87555248475d06eb9
  $cCR6r44wooKB4ahO4Z7xi2 :: Data.Data.Constr
607fd6083128f04bde9768735ef6d082
  $cCh7W1cTHWOrHcDXoX6md4V :: Data.Data.Constr
a98bb5cecb3667c1ee1b10ed48979277
  $cCnG8eZj9IrVCmtlLEFwUGg :: Data.Data.Constr
022d54d9840cb23539c82597386557ab
  $cD23qQhICPJIAlRuFWUrWTG :: Data.Data.Constr
12fca2c97d3454d0504b4fd2123b6203
  $cD3qrJPFo7TpKgBpACeEzmz :: Data.Data.Constr
f046ccbabd1614fa116e9d1486112d27
  $cD3uCaXvvn8S1Kmgoi15Hal :: Data.Data.Constr
63f6e60d25bb6d246643eb85a2fe7d7a
  $cD3uxCVrcHH32NBssdQhe1C :: Data.Data.Constr
c106b43ca2b10fb71b4d0b721beacddb
  $cD3wcgyNZlXWFJGnEiXeZLk :: Data.Data.Constr
e99467ce3bddd5784edfd287223e056a
  $cDAbIZOfZUoyKNINb6T8jr3 :: Data.Data.Constr
67ff3010c18108a0eda9800c4b671bae
  $cDRxAjenayYj94ZvPWP7a56 :: Data.Data.Constr
d225893b5a5ce8045bf5eb9a2272a05d
  $cDUwJELfr3Fz4arRtKikbg0 :: Data.Data.Constr
ebec228818869f30abd442f0e6823c61
  $cDdcoueG3JQzDl7jqyfcnZb :: Data.Data.Constr
09deb3267c2b0ac81fc15be0cad09832
  $cDjBpcn6xMzsHPN22w1wI82 :: Data.Data.Constr
e27cb20f650c8234eca4765d558c8972
  $cDjimyCQcrglDvnGq9cCHps :: Data.Data.Constr
31017d2627c04ca72f4f70ddf7989bc7
  $cDs23a8nWism1nJTKHlEXTj :: Data.Data.Constr
c55c255d105fb322416ad3be6040816a
  $cDsG5sYerBcHB9v8lVsfVY5 :: Data.Data.Constr
b387b4e9a3be910572825991cd76160b
  $cEErEL27lDw1B0N3YvXaWET :: Data.Data.Constr
58a4a1e8d8437feb075eb0cffb7021b0
  $cEJEHRNo6HpQ0IZ7fc5UH2m :: Data.Data.Constr
39892310388b8ec4baa0f732e755e4cb
  $cERfpYlJLt2r1ym8wgeAxzB :: Data.Data.Constr
22213e2316843c8d64200777138b8a3a
  $cETFTR8syJoXGSa4EBKNf90 :: Data.Data.Constr
df9699c197564137ecdada81665747c2
  $cEWJ0Auj1ARaDjMLQKis4KM :: Data.Data.Constr
37ba092fba767be8533b00ca5b6724b6
  $cEYy6jWMRHxp5HZSgP2Q9ZK :: Data.Data.Constr
ccdad3dbaf980c18bc4251b857fa435a
  $cElP7vJxaWuY2h5QpZwARwX :: Data.Data.Constr
8cb1ba91288fddde9604d65f21410b09
  $cEr4sZrx2wgp4CcX0qpsSpf :: Data.Data.Constr
9d2253acf3b4d83362aeca805ef3e827
  $cF1IKYwsRetP0SeNkioe6Y7 :: Data.Data.Constr
b9bf879485188224245b4e7a2eb99082
  $cFGQSZussvkOFNnRO51hGKa :: Data.Data.Constr
8f8d22566fcb9687c654224e5dfb8566
  $cFQ6NHQIThDN3fFSD7smHNn :: Data.Data.Constr
f5a6dbb0b8275d204c2074365f926b74
  $cFXzcZuUPSalBxcWakFNiwk :: Data.Data.Constr
34b7c98d0ea095578442fb63621cb640
  $cFviLcdSWCkzJxWsC2hkVmg :: Data.Data.Constr
48c7a8be1f27cd820181163fb65d192e
  $cG04j4Fj75pWA5WN2R3sstL :: Data.Data.Constr
d7517682e382d52ebeb71bd278a5a7be
  $cG9ZNuwcTtgaIpzhpWIwrk0 :: Data.Data.Constr
9f3c89f74d13677208a88a89323bee76
  $cGP3vwUNcJksADq43fmNFtK :: Data.Data.Constr
01fbf75d63cbc8a662b6795620a86e29
  $cGTpusTKqFxJ22IdjCosmhu :: Data.Data.Constr
afe1326478da7a74fbf2fd295815183b
  $cGaZokv3vKoyKQJRX4rtnkj :: Data.Data.Constr
b4f10fdf1ad55ac6fdcc53af2a9a43fa
  $cGbXUKdZa5O7Btl967GFUlU :: Data.Data.Constr
3e390d3fd434f12f12eb61ede344e63f
  $cGkmznj2VlO42PYwprZUrCU :: Data.Data.Constr
c1bf649740144591571b8109b56367e3
  $cGmWj83OUQ795Ps0R1oraOm :: Data.Data.Constr
8782aec811936f24939abb2275a29d9f
  $cGoaQjPIFzFlK8YmKo4dBNa :: Data.Data.Constr
35541c2ba33322e9cfa029a8a484fc01
  $cGqxaLgq7GgOGlWGdzVm1TD :: Data.Data.Constr
6a0faa68580347c30abc8c61869b689f
  $cGxIc2mtUiNe1Nyz5GUgXvl :: Data.Data.Constr
14d6c2c03923ca812fba7457806061f7
  $cHEASYRzErmJGPCyxQpLXIW :: Data.Data.Constr
556332edef772070f161fe344be30948
  $cHWt0CBnUqw77wKA6I45BBj :: Data.Data.Constr
77426a12a6a0f9cf101d69f13cc5eed4
  $cHXnvV5ahnQ2LFa0mdMe6uA :: Data.Data.Constr
060f55f5da1fbaa24199266dfe311e71
  $cHZ7uyMpPcEEEcwapdnRQaU :: Data.Data.Constr
e67e6918dcc3edbbbf5730fbbe99e217
  $cHuyzJGnP4eNEshO9nUNJvc :: Data.Data.Constr
9bed3a67d6f08d31f0328a4411dbf679
  $cHz24H293oUm0OxUULdlqBb :: Data.Data.Constr
486252bff68b44a01030f5849852c8fc
  $cI4PF9mC7gG22viZwqmXmQI :: Data.Data.Constr
f29b0a5ed546297153a94324aee05e4e
  $cIAevgWXYHzwLRUFBHwuUZ8 :: Data.Data.Constr
817bed02421f62603488abb0a9dd77de
  $cIM0ypPVSiloC4bjtwrXHRp :: Data.Data.Constr
3c6602696711df051d165bc88904f85a
  $cIMGNvWbJdnq9xozMAhQSu2 :: Data.Data.Constr
597967919f7a6c4ef8bef65629cf6b4e
  $cIcMUtRli3Fb6z5cNjlPbsf :: Data.Data.Constr
60dd77830715066ff4b2ba2cb67df8a1
  $cIe4io6ptRQTBZkPPhPd59J :: Data.Data.Constr
ba7637cef432571fa2b953008265405b
  $cInvqrPypDap7KpUF8KbmzY :: Data.Data.Constr
cddb7fb4108b71a1a955e00d1a1b0364
  $cIuB4iIZQb1w9cGdjsxMCsc :: Data.Data.Constr
d233fd4012e1fa215f72ecde34f5b01b
  $cIyLi8J1OHq723JJNc4oM1a :: Data.Data.Constr
4458548b737c7d484a2a7e164b19c223
  $cJ89XmQl4LdA2XZ14ZkwIS3 :: Data.Data.Constr
f64ea1bd5f479a13d4e97d9034e9de04
  $cJF7ERNq7h76LqRZ36w7OdI :: Data.Data.Constr
55da202bdf41278279e7cb7da64cd77f
  $cJGg760wRwEQJEY2f8Sd1Z7 :: Data.Data.Constr
f9bd24cff586de3f1305c68c9bcd42ec
  $cJIuXgcJUNEdIDk2n1uvBTZ :: Data.Data.Constr
c3f8d830a1c4f3e63b39c0a0b098126b
  $cJK1JTGWnd4sK8HL1FrCJ9G :: Data.Data.Constr
4d1fb7bcbc38469386f9b1676ccb3e38
  $cJLXsf9lxOoaFiQSAQ8W4hd :: Data.Data.Constr
e55109ac8d021497a401d7323803d5b7
  $cJMYppX9bYODKKluMTnLSGS :: Data.Data.Constr
d4f810e6577e8482239424d42af59a8f
  $cJUigIhd9rkN7twKvBnXy7l :: Data.Data.Constr
dda14ae7a7f6a01d6ca9a2ddd596ba99
  $cJfL0DGYlphOFBne7T622o2 :: Data.Data.Constr
c85fb5ef57bddaf1793a46e7b669e094
  $cJl4i34RdGTBBkJR6CNDRk6 :: Data.Data.Constr
5d0c9a3d3d3ed0e02825cc240eddef1d
  $cJycyi77aaqH3o3UgNEeNZw :: Data.Data.Constr
64f5b4eeeed4f8238bf89bfbd3e055f0
  $cKJgysgXd4XrCpbjDx61YPu :: Data.Data.Constr
e3af9e473db38ac205d0185bfecd8b05
  $cKaQG7L5fPygCJMfpz2UOZd :: Data.Data.Constr
91d968f374b2ffd69625913ff3a75d2b
  $cKcegaxJX2G4G3MxjzGOVFy :: Data.Data.Constr
6e6c4833473fb9aaf85ba2612edd620a
  $cKixEZNPGwILIKGvB325tuX :: Data.Data.Constr
ce5954144d700b15b5cdf8f7b737a872
  $cKshv8guM6KWBTLkG9LdK8Q :: Data.Data.Constr
09f9d53ab2cb5c661e307602965f5c0d
  $cKvdQh7V79Kp1D1pJcVfiuV :: Data.Data.Constr
6d3b61071d50b7c725c5371f1ebba291
  $cLBPxZUMv6542zJYgjft5l3 :: Data.Data.Constr
1b7cbafc6f7cd41f61a90c0825134ea1
  $cLMTGSzJsZ7M2WWbZRwXJIc :: Data.Data.Constr
cc3b9b463589ab9f6abbbeb2fcf1f0a9
  $cLMazxJn46665m8Yj6dJ4f2 :: Data.Data.Constr
7b59a4fb7bef704f348e236ea6446974
  $cLTiyBcAAGRR1kehXcN8BdU :: Data.Data.Constr
ae052324f251f9249f5abb66dce5609e
  $cLUk6nnNjD0l6PtfmFqmXuq :: Data.Data.Constr
4874328f3a6e512e81c7af90ea21cf2e
  $cLYSRIS5IXhsKtPBuLbJhSN :: Data.Data.Constr
0e1ee4be744ac2bd7e0a4ab5562b24ce
  $cLvbK0pIELosBhNJL5acEyk :: Data.Data.Constr
c40dd63f45065fe42445df3df485b2d6
  $ca2TTLH2iFC1qRliXzNZGA :: Data.Data.Constr
cfb27ae9f6afec74639ea6a5cefe122c
  $cbejFFDHCLXEwDZCBT24qk :: Data.Data.Constr
54bb72e6e53deb10e2dc33213c427ed6
  $ccuN7R8hpA70mFie3N0Ynq :: Data.Data.Constr
02a811ce0bc4b301bdf39a89b94876d5
  $cu5gtSoLHcOBiRcc4Ziped :: Data.Data.Constr
6a578be33391db91b5fea0db543565f7
  $fDataArg ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fDataArg_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataArg_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataArg_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataArg_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataArg_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataArg_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataArg_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataArg_$cgmapMo @ p $dData) -}
8da5ae3eefdd9eeaa258811a7d49ec9d
  $fDataArg1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe
         (c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing
                   @ (c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))) -}
25ada2acb643a7a12e371931e8df42aa
  $fDataArg10 :: g -> g
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ g (tpl :: g)[OneShot] -> tpl) -}
76190d3710f292e7a89ec2cb2d5b1cb5
  $fDataArg11 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataArg12
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcArg
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
f0a12a74acfadee20a6195695e37d707
  $fDataArg12 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   11297984408639489004##
                   15999878566552054401##) -}
8e88fa5183de3de1020479038f4a2c5f
  $fDataArg13 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArg14) -}
5d669ba8bc5a3b1ec1e734bd0067ed6d
  $fDataArg14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1qnG2e03wKqFUA1PtIEn7e
                   (GHC.Types.[] @ Data.Data.Constr)) -}
b33652a7312d9b4eb3b015320003ddc1
  $fDataArg15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Arg"#) -}
3abd3b5610d6f3bcf9efd7eb25692a1c
  $fDataArg2 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 Data.Data.tuple2DataType) -}
033d49625ba7e5545ce4748f6a152c0a
  $fDataArg3 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds1 ds2 -> Data.Data.tuple2Constr }) -}
743550781308cf3ccf15e240dd4f62c9
  $fDataArg4 :: g -> Data.Data.Qi u g
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ u @ g (ds :: g) ->
                 Language.Fortran.$fDataArg5 @ g @ u) -}
3bd16dfa47a1f570f7a4554513c1405d
  $fDataArg5 :: Data.Data.Qi u g
  {- HasNoCafRefs,
     Unfolding: (\ @ g @ u ->
                 Data.Data.Qi
                   @ *
                   @ u
                   @ g
                   Language.Fortran.$fDataArg6
                   (GHC.Base.Nothing @ u)) -}
fcb071134ef996ce3e939fa75b7e1980
  $fDataArg6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
66b75cb43cc2eb2360e3fac93c8aeb4b
  $fDataArg7 :: g -> [u] -> [u]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ @ u @ g (ds :: g)[OneShot] (eta :: [u]) -> eta) -}
52ff8dd8d7c3fadeb2480e31e1afe8c9
  $fDataArg8 :: g -> r -> r
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ @ r @ g (ds :: g)[OneShot] (eta :: r) -> eta) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg9 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Arg p -> Data.Data.ID (Language.Fortran.Arg p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Arg p) ->
                 Language.Fortran.$fDataArg_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fDataArgList_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataArgList_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataArgList_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataArgList_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataArgList_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataArgList_$cgmapMo @ p $dData) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgList p
    -> Data.Data.ID (Language.Fortran.ArgList p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.ArgList p) ->
                 case eta of wild { Language.Fortran.ArgList a1 a2 ->
                 (Language.Fortran.ArgList
                    @ p
                    (ds @ p $dData a1)
                    (ds
                       @ (Language.Fortran.Expr p)
                       (Language.Fortran.$fDataExpr @ p $dData)
                       a2))
                   `cast`
                 (Sym (Data.Data.N:ID[0] <Language.Fortran.ArgList p>_R)) }) -}
28192afd74c852e5676c7c9cc72c8b98
  $fDataArgList2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataArgList3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcArgList
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
c2a8db19b7fefae03ebdd5a75a6bf9a5
  $fDataArgList3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17085691833968039316##
                   4384770729493771167##) -}
0b71d66fe25191aa330225f2216f863d
  $fDataArgList4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArgList5) -}
67c5dbe96fb5292164699d09f05c4f92
  $fDataArgList5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$ca2TTLH2iFC1qRliXzNZGA
                   (GHC.Types.[] @ Data.Data.Constr)) -}
6cead87d228ae3d2146b24b6f9132057
  $fDataArgList6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ArgList"#) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgList p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataArgList2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ArgList p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ArgList <p>_N)) } } } }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgList p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.ArgList p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.ArgList p) ->
                 Language.Fortran.$ta2TTLH2iFC1qRliXzNZGA) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ArgList p
    -> c (Language.Fortran.ArgList p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgList p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.ArgList p) ->
                 case w2 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 GHC.Types.:
                   @ u
                   (w1 @ p w ww1)
                   (GHC.Types.:
                      @ u
                      (w1
                         @ (Language.Fortran.Expr p)
                         (Language.Fortran.$fDataExpr @ p w)
                         ww2)
                      (GHC.Types.[] @ u)) }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgList p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.ArgList p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { Language.Fortran.ArgList ww3 ww4 ->
                 Language.Fortran.$w$cgmapQi1 @ p w @ u ww1 w2 ww3 ww4 } }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgList p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgList p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r' -> r -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (w4 :: Language.Fortran.ArgList p) ->
                 case w4 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr1 @ p w @ r @ r' w1 w2 w3 ww1 ww2 }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgList p -> Language.Fortran.ArgList p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataArgList1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.ArgList p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.ArgList p>_R) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ArgList p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.ArgList p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataArgList2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.ArgList p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.ArgList p>_N))) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataArgList_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.ArgList p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.ArgList p) ->
                 case ds of wild { Language.Fortran.ArgList ds1 ds2 ->
                 Language.Fortran.$ca2TTLH2iFC1qRliXzNZGA }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fDataArgName_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataArgName_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataArgName_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataArgName_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataArgName_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataArgName_$cgmapMo @ p $dData) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgName p
    -> Data.Data.ID (Language.Fortran.ArgName p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
b03cc8ef9b56272e12e1d7f9b60e3d54
  $fDataArgName2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataArgName3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcArgName
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
9de2509a3f3f4e58101fe6b2fc306d97
  $fDataArgName3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   9242974714316311215##
                   9957090134460514018##) -}
7d2bdff20cb8ec84b9351ee4bb81be05
  $fDataArgName4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArgName5) -}
57e72a23be4b58a2c7fb9f6b3b903bfd
  $fDataArgName5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGoaQjPIFzFlK8YmKo4dBNa
                   Language.Fortran.$fDataArgName6) -}
70e2c373184ac35d27a79e2d9159e68b
  $fDataArgName6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDAbIZOfZUoyKNINb6T8jr3
                   Language.Fortran.$fDataArgName7) -}
5818de7f115809ea67260526c032b7f6
  $fDataArgName7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIuB4iIZQb1w9cGdjsxMCsc
                   (GHC.Types.[] @ Data.Data.Constr)) -}
a81d91df4effc4d2f34e3c85f86b8560
  $fDataArgName8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ArgName"#) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgName p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataArgName2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ArgName p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ArgName <p>_N)) } } } }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgName p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.ArgName p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.ArgName p) ->
                 Language.Fortran.$tGoaQjPIFzFlK8YmKo4dBNa) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ArgName p
    -> c (Language.Fortran.ArgName p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgName p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgName p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgName p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgName p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgName p -> Language.Fortran.ArgName p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataArgName1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.ArgName p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.ArgName p>_R) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ArgName p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.ArgName p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataArgName2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.ArgName p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.ArgName p>_N))) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fDataArgName_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.ArgName p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.ArgName p) ->
                 case ds of wild {
                   Language.Fortran.ArgName ds1 ds2
                   -> Language.Fortran.$cGoaQjPIFzFlK8YmKo4dBNa
                   Language.Fortran.ASeq ds1 ds2 ds3
                   -> Language.Fortran.$cDAbIZOfZUoyKNINb6T8jr3
                   Language.Fortran.NullArg ds1
                   -> Language.Fortran.$cIuB4iIZQb1w9cGdjsxMCsc }) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Arg p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataArg11 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Arg p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Arg p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Arg p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Arg <p>_N)) } } } }) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Arg p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Arg p))) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Arg p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Arg p) ->
                 Language.Fortran.$t1qnG2e03wKqFUA1PtIEn7e) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Arg p
    -> c (Language.Fortran.Arg p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.ArgName p)
                   = Language.Fortran.$fDataArgName @ p $dData
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Arg p) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 k @ Language.Fortran.SrcSpan
                   @ (Language.Fortran.Arg p)
                   Language.Fortran.$fDataArg_$s$fData(,)
                   (k @ (Language.Fortran.ArgName p)
                      @ (Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                      $dData1
                      (k @ p
                         @ (Language.Fortran.ArgName p
                            -> Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                         $dData
                         (z @ (p
                               -> Language.Fortran.ArgName p
                               -> Language.Fortran.SrcSpan
                               -> Language.Fortran.Arg p)
                            (Language.Fortran.Arg @ p))
                         a1)
                      a2)
                   a3 }) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataArg_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Arg p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Arg p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Arg p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Arg p, GHC.Types.Bool)
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fDataArg_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Arg p>_N)
                   (\ (ds1 :: (Language.Fortran.Arg p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Arg p)
                           x' } })) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Arg p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Arg p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Arg p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Arg p, GHC.Types.Bool)
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fDataArg_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Arg p>_N)
                   (\ (ds1 :: (Language.Fortran.Arg p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Arg p)
                           x' } })) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Arg p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Arg p) ->
                 (Language.Fortran.$fDataArg_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Arg p>_P)
                   (GHC.Types.[] @ u)) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Arg p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Arg p) ->
                 case Language.Fortran.$fDataArg_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Arg p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Arg p
                        -> Data.Data.CONST r (Language.Fortran.Arg p)
                   = Language.Fortran.$fDataArg_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Arg p) -> g x)
                   `cast`
                 (<Language.Fortran.Arg p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.Arg p>_P)) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Arg p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Arg p) ->
                 (Language.Fortran.$fDataArg_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Arg p>_P)
                   ds1) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Arg p -> Language.Fortran.Arg p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataArg9
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Arg p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Arg p>_R) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Arg p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.ArgName p)
                   = Language.Fortran.$fDataArgName @ p $dData
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcSpan
                   @ (Language.Fortran.Arg p)
                   Language.Fortran.$fDataArg_$s$fData(,)
                   (k @ (Language.Fortran.ArgName p)
                      @ (Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                      $dData1
                      (k @ p
                         @ (Language.Fortran.ArgName p
                            -> Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                         $dData
                         (z @ (p
                               -> Language.Fortran.ArgName p
                               -> Language.Fortran.SrcSpan
                               -> Language.Fortran.Arg p)
                            (Language.Fortran.Arg @ p))))) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Arg p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataArg11 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Arg p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Arg p>_N))) -}
6a578be33391db91b5fea0db543565f7
  $fDataArg_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Arg p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Arg p) ->
                 case ds of wild { Language.Fortran.Arg ds1 ds2 ds3 ->
                 Language.Fortran.$c1qnG2e03wKqFUA1PtIEn7e }) -}
3ee283849f3b7431d2528c4224df7826
  $fDataArg_$s$fData(,) ::
    Data.Data.Data (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                  (Data.Data.$fData(,)_$cp1Data
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  Language.Fortran.$fDataArg_$s$fData(,)_$cgfoldl
                  (Data.Data.$fData(,)_$cgunfold
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  Language.Fortran.$fDataArg3
                  Language.Fortran.$fDataArg2
                  Language.Fortran.$fDataArg1
                  (Data.Data.$fData(,)_$cdataCast2
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  Language.Fortran.$fDataArg_$s$fData(,)_$cgmapT
                  Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQl
                  Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQr
                  Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQ
                  Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQi
                  (Data.Data.$fData(,)_$cgmapM
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (Data.Data.$fData(,)_$cgmapMp
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (Data.Data.$fData(,)_$cgmapMo
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc) -}
6842a6ea2ede71eecf9f4c31695c2fbf
  $fDataArg_$s$fData(,)_$cgfoldl ::
    (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
    -> (forall g. g -> c g)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 3,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (c :: * -> *)
                   (f :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                   (z :: forall g. g -> c g)
                   (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) a1 b1 ->
                 f @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                   Language.Fortran.$fDataSrcLoc
                   (f @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.SrcLoc
                         -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                      Language.Fortran.$fDataSrcLoc
                      (z @ (Language.Fortran.SrcLoc
                            -> Language.Fortran.SrcLoc
                            -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                         (GHC.Tuple.(,)
                            @ Language.Fortran.SrcLoc
                            @ Language.Fortran.SrcLoc))
                      a1)
                   b1 }) -}
428c857147d08604a23618e76603c258
  $fDataArg_$s$fData(,)_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc) -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 b1 ->
                 GHC.Types.:
                   @ u
                   (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                   (GHC.Types.:
                      @ u
                      (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc b1)
                      (GHC.Types.[] @ u)) }) -}
8886cc282c4df3756f5ab7d87777a428
  $fDataArg_$s$fData(,)_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x of wild { (,) a1 b1 ->
                 case ds of wild1 { GHC.Types.I# x1 ->
                 case x1 of wild2 {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0#
                   -> ds1 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1
                   1#
                   -> ds1
                        @ Language.Fortran.SrcLoc
                        Language.Fortran.$fDataSrcLoc
                        b1 } } }) -}
29294115246cdc79c8bb01e49a4b3e32
  $fDataArg_$s$fData(,)_$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case eta of wild { (,) a1 b1 ->
                 ds
                   (ds
                      ds1
                      (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1))
                   (ds2
                      @ Language.Fortran.SrcLoc
                      Language.Fortran.$fDataSrcLoc
                      b1) }) -}
b253cd857ed5a052e13c04088cd44a5d
  $fDataArg_$s$fData(,)_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 b1 ->
                 ds
                   (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                   (ds
                      (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc b1)
                      ds1) }) -}
be711d7c4f5f0e58ad6df492e530235d
  $fDataArg_$s$fData(,)_$cgmapT ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 b1 ->
                 (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1,
                  ds
                    @ Language.Fortran.SrcLoc
                    Language.Fortran.$fDataSrcLoc
                    b1) }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fDataAttr_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataAttr_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataAttr_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataAttr_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataAttr_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataAttr_$cgmapMo @ p $dData) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Attr p
    -> Data.Data.ID (Language.Fortran.Attr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Attr p) ->
                 Language.Fortran.$fDataAttr_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
9856d667ac5a34d3d00edef33c198430
  $fDataAttr10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGTpusTKqFxJ22IdjCosmhu
                   Language.Fortran.$fDataAttr11) -}
557f377646c2023d9063a21ec3e30edb
  $fDataAttr11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1kxrjM0ubOr2AKqDtvXYpv
                   Language.Fortran.$fDataAttr12) -}
d15e81f2ba644e77122614a7f9fc3b9f
  $fDataAttr12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cHEASYRzErmJGPCyxQpLXIW
                   Language.Fortran.$fDataAttr13) -}
33fb0d1d68c474ea2bd142e74e2b3b1b
  $fDataAttr13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDdcoueG3JQzDl7jqyfcnZb
                   Language.Fortran.$fDataAttr14) -}
fe6f7d0932a9fdf14d1e214d6e798ba5
  $fDataAttr14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cbejFFDHCLXEwDZCBT24qk
                   Language.Fortran.$fDataAttr15) -}
554f75fcad93b396700fa6c45ed99c78
  $fDataAttr15 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7lfNiGPDM2tJsjHmBnjtvF
                   Language.Fortran.$fDataAttr16) -}
17593d22d80cc974ce151119f78ad31e
  $fDataAttr16 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cAbMSwCXSfl8LUbBeST0WD9
                   Language.Fortran.$fDataAttr17) -}
5481d91d286972f8b29e4db1e3046f3d
  $fDataAttr17 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cHuyzJGnP4eNEshO9nUNJvc
                   Language.Fortran.$fDataAttr18) -}
f947578f50f85b30e6a997b331c97499
  $fDataAttr18 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8tHUVs27NcXHKX7Nm6RrSS
                   Language.Fortran.$fDataAttr19) -}
e669b0049fca5fe887096d12184dffa2
  $fDataAttr19 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2DhuP2n5J9jK7fCzidnavw
                   (GHC.Types.[] @ Data.Data.Constr)) -}
f16a3fb41d0e1a7261013b964e5d09e8
  $fDataAttr2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataAttr3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcAttr
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
0a5a736db8a7dc4e74428fe8a9901dcf
  $fDataAttr20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Attr"#) -}
400859ab98323a4d5009f21bdf6efc47
  $fDataAttr3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   9037790331881822576##
                   12484905115659523528##) -}
2068626933234330f5447a4713a5e171
  $fDataAttr4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataAttr5) -}
7f654365a2c706aca8fa8155e4ccdd02
  $fDataAttr5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7B7CwvLXlI65LliAKSg6fB
                   Language.Fortran.$fDataAttr6) -}
c9d65ea7b960d491d857bd9c2882e862
  $fDataAttr6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cElP7vJxaWuY2h5QpZwARwX
                   Language.Fortran.$fDataAttr7) -}
f3874c54a5d08c43cf3cc98dae45e368
  $fDataAttr7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGP3vwUNcJksADq43fmNFtK
                   Language.Fortran.$fDataAttr8) -}
eb6e1801b34ab54425b4f86a2dcf9911
  $fDataAttr8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c9jJakhk2EHs3dQvW2C6t8f
                   Language.Fortran.$fDataAttr9) -}
00b0d975b40aa1f63f4294854b460cfe
  $fDataAttr9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIyLi8J1OHq723JJNc4oM1a
                   Language.Fortran.$fDataAttr10) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Attr p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataAttr2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Attr p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Attr p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Attr p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Attr <p>_N)) } } } }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Attr p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Attr p))) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Attr p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Attr p) ->
                 Language.Fortran.$tIkp3PU8lbwe5Ja5bwBrN6O) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Attr p
    -> c (Language.Fortran.Attr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataAttr_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Attr p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Attr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Attr p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Attr p, GHC.Types.Bool)
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fDataAttr_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Attr p>_N)
                   (\ (ds1 :: (Language.Fortran.Attr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Attr p)
                           x' } })) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Attr p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Attr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Attr p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Attr p, GHC.Types.Bool)
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fDataAttr_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Attr p>_N)
                   (\ (ds1 :: (Language.Fortran.Attr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Attr p)
                           x' } })) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Attr p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Attr p) ->
                 (Language.Fortran.$fDataAttr_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Attr p>_P)
                   (GHC.Types.[] @ u)) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Attr p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Attr p) ->
                 case Language.Fortran.$fDataAttr_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Attr p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Attr p
                        -> Data.Data.CONST r (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Attr p) -> g x)
                   `cast`
                 (<Language.Fortran.Attr p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.Attr p>_P)) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Attr p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Attr p) ->
                 (Language.Fortran.$fDataAttr_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Attr p>_P)
                   ds1) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Attr p -> Language.Fortran.Attr p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataAttr1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Attr p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Attr p>_R) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Attr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Attr p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataAttr2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Attr p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Attr p>_N))) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fDataAttr_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Attr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p (w :: Data.Data.Data p) (w1 :: Language.Fortran.Attr p) ->
                 Language.Fortran.$w$ctoConstr1 @ p w1) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fDataBaseType_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataBaseType_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataBaseType_$cgmapMo @ p $dData) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BaseType p
    -> Data.Data.ID (Language.Fortran.BaseType p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$fDataBaseType_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
050142dc8605cd75ea664b5638865b9f
  $fDataBaseType10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLvbK0pIELosBhNJL5acEyk
                   Language.Fortran.$fDataBaseType11) -}
9576bca1c87389f30816c27d271c65e9
  $fDataBaseType11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5PpNSQeZhEd6mfzscovZzk
                   Language.Fortran.$fDataBaseType12) -}
2347db4428a153fead19742196c8f538
  $fDataBaseType12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5SQPygD1Ty89qjjuuJHaUt
                   Language.Fortran.$fDataBaseType13) -}
dfe3827fc66bc0a6d87395f1b1c097f3
  $fDataBaseType13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c153RCtDJMOyJaz55P4WRZA
                   Language.Fortran.$fDataBaseType14) -}
8614c34f537af007252d7cb61c81f1d5
  $fDataBaseType14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4YtPC6DHZWXAfR4LZG1kUS
                   (GHC.Types.[] @ Data.Data.Constr)) -}
d07d4f36949b3c3d5d7b24415cfd0a5b
  $fDataBaseType15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BaseType"#) -}
220b775c59ba8690f3dd452a3f5a2f32
  $fDataBaseType2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataBaseType3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcBaseType
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
3e921a4e508ddce24bcc337d0948a041
  $fDataBaseType3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1260076333345940747##
                   10788170460963483881##) -}
92661e84944abcf827225c9b7992517b
  $fDataBaseType4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataBaseType5) -}
b8f7e0e4c14ee30c7e6f29059347b4b1
  $fDataBaseType5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2zM3Wvd2OSTKQWpzDfGPs3
                   Language.Fortran.$fDataBaseType6) -}
725af202e8fa1b6ae42f0f115d8db989
  $fDataBaseType6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c57WXxHeFdMP6uTlDFEoR2e
                   Language.Fortran.$fDataBaseType7) -}
4076f100890feac8d85d31d2a882f6f6
  $fDataBaseType7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7OcYfPjTVfVKWmGVGvQDuT
                   Language.Fortran.$fDataBaseType8) -}
8f4d94cda2f7075742825a04e02062a8
  $fDataBaseType8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cKvdQh7V79Kp1D1pJcVfiuV
                   Language.Fortran.$fDataBaseType9) -}
9eafca9e00aa3d208566437ed19eb7ad
  $fDataBaseType9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBOqujp4qXetGp5vwKhj7Tb
                   Language.Fortran.$fDataBaseType10) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.BaseType p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataBaseType2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.BaseType p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.BaseType <p>_N)) } } } }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.BaseType p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.BaseType p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$tCLEx3Oi2MB55JzB9GYZf6v) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.BaseType p
    -> c (Language.Fortran.BaseType p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.BaseType p) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Integer @ p))
                        a1
                   Language.Fortran.Real a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Real @ p))
                        a1
                   Language.Fortran.Character a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Character @ p))
                        a1
                   Language.Fortran.SomeType a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.SomeType @ p))
                        a1
                   Language.Fortran.DerivedType a1 a2
                   -> k @ (Language.Fortran.SubName p)
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (k @ p
                           @ (Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                           $dData
                           (z @ (p
                                 -> Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                              (Language.Fortran.DerivedType @ p))
                           a1)
                        a2
                   Language.Fortran.Recursive a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Recursive @ p))
                        a1
                   Language.Fortran.Pure a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Pure @ p))
                        a1
                   Language.Fortran.Elemental a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Elemental @ p))
                        a1
                   Language.Fortran.Logical a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Logical @ p))
                        a1
                   Language.Fortran.Complex a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Complex @ p))
                        a1 }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataBaseType_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BaseType p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.BaseType p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BaseType p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BaseType p, GHC.Types.Bool)
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fDataBaseType_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BaseType p>_N)
                   (\ (ds1 :: (Language.Fortran.BaseType p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BaseType p)
                           x' } })) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BaseType p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.BaseType p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BaseType p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BaseType p, GHC.Types.Bool)
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fDataBaseType_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BaseType p>_N)
                   (\ (ds1 :: (Language.Fortran.BaseType p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BaseType p)
                           x' } })) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BaseType p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.BaseType p) ->
                 (Language.Fortran.$fDataBaseType_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.BaseType p>_P)
                   (GHC.Types.[] @ u)) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BaseType p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.BaseType p) ->
                 case Language.Fortran.$fDataBaseType_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BaseType p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.BaseType p
                        -> Data.Data.CONST r (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.BaseType p) -> g x)
                   `cast`
                 (<Language.Fortran.BaseType p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.BaseType p>_P)) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BaseType p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.BaseType p) ->
                 (Language.Fortran.$fDataBaseType_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.BaseType p>_P)
                   ds1) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BaseType p -> Language.Fortran.BaseType p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataBaseType1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.BaseType p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.BaseType p>_R) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.BaseType p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 case ww1 of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww5
                      ret_ty (c (Language.Fortran.BaseType p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Complex @ p))
                        1#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Integer @ p))
                        2#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Real @ p))
                        3#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Character @ p))
                        4#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.SomeType @ p))
                        5#
                        -> k @ (Language.Fortran.SubName p)
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (k @ p
                                @ (Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                                $dData
                                (z @ (p
                                      -> Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                                   (Language.Fortran.DerivedType @ p)))
                        6#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Recursive @ p))
                        7#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Pure @ p))
                        8#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Elemental @ p))
                        9#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Logical @ p)) } } } }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.BaseType p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataBaseType2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.BaseType p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.BaseType p>_N))) -}
6b45e4637f33ab3df335753afdb59e8d
  $fDataBaseType_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.BaseType p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w1 :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$w$ctoConstr2 @ p w1) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fDataBinOp_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataBinOp_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataBinOp_$cgmapMo @ p $dData) -}
442301693b0fe827820319b4047cea82
  $fDataBinOp1 :: g -> Data.Data.Qi u g
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ u @ g (ds :: g)[OneShot] ->
                 Data.Data.Qi
                   @ *
                   @ u
                   @ g
                   Language.Fortran.$fDataArg6
                   (GHC.Base.Nothing @ u)) -}
01e594998481689a205faf676b493f96
  $fDataBinOp10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBxm7TsMN2Uv3pnUvfizH4a
                   Language.Fortran.$fDataBinOp11) -}
e2a3bc5375f46e61baf8708d7bd0d32c
  $fDataBinOp11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBSwpqhq0QE6EPH9yiaMC9K
                   Language.Fortran.$fDataBinOp12) -}
d62b6bc751452783f9556a2a1aa5bfa1
  $fDataBinOp12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cKshv8guM6KWBTLkG9LdK8Q
                   Language.Fortran.$fDataBinOp13) -}
a5459e9e60d6ee1f8be024b94860c8da
  $fDataBinOp13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8oI8VcsgCvA41cZKrFA3aS
                   Language.Fortran.$fDataBinOp14) -}
5612ccbf2a946badb71b6f0746f23efc
  $fDataBinOp14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c85seZPcVf6L6w9soyXu5VI
                   Language.Fortran.$fDataBinOp15) -}
4be2be4d2aef7c9edbfe88036742c765
  $fDataBinOp15 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cHXnvV5ahnQ2LFa0mdMe6uA
                   Language.Fortran.$fDataBinOp16) -}
92628d7cdf8374a00e2d1d1829a61b71
  $fDataBinOp16 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c38rK9vmzDD4E6uZr2fvSTl
                   Language.Fortran.$fDataBinOp17) -}
3ea272ae36ef68ca34be370674cb0ca8
  $fDataBinOp17 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cKaQG7L5fPygCJMfpz2UOZd
                   Language.Fortran.$fDataBinOp18) -}
2cd1f4a26cac0fcb773d6c5a18d91b6e
  $fDataBinOp18 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBkX4OAQJ9orEBepae4Ozqm
                   Language.Fortran.$fDataBinOp19) -}
b48fdd95559068a2ec3062be1533ad90
  $fDataBinOp19 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c12Sm1gxWcOn3cUJRtBlJgB
                   Language.Fortran.$fDataBinOp20) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp2 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> Data.Data.CONST r (Language.Fortran.BinOp p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData
                   @ (Data.Data.CONST r)
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)[OneShot]
                      (c :: Data.Data.CONST r (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    ds
                      c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                      (ds2 @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.CONST r (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                   (\ @ g1 (ds3 :: g1)[OneShot] -> ds1)
                     `cast`
                   (forall (g1 :: <*>_N).
                    <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                   eta) -}
1e310d8c5ae6cdd49e03fc87aad408bc
  $fDataBinOp20 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c3qv8lWLr4xn6EqXsj3zYHw
                   (GHC.Types.[] @ Data.Data.Constr)) -}
fa5db53318e792458719fc949a68929f
  $fDataBinOp21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BinOp"#) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp3 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BinOp p
    -> Data.Data.ID (Language.Fortran.BinOp p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)[OneShot]
                      (ds1 :: Data.Data.ID (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
f9f1384c27153df1f2b3d1f135d3258b
  $fDataBinOp4 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataBinOp5
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcBinOp
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
14ccb496e003cc615b23804c9076d3c0
  $fDataBinOp5 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1845785492847154914##
                   6631801608391496845##) -}
200a28fc1dda885cd72e2816da7b68b9
  $fDataBinOp6 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataBinOp7) -}
d3669501a6416bdea08bd14961a65a59
  $fDataBinOp7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLMazxJn46665m8Yj6dJ4f2
                   Language.Fortran.$fDataBinOp8) -}
5af049a397eaebf1b57026cb0770451b
  $fDataBinOp8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCR6r44wooKB4ahO4Z7xi2
                   Language.Fortran.$fDataBinOp9) -}
e22c0227e963405a51c829dbc4588432
  $fDataBinOp9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cKcegaxJX2G4G3MxjzGOVFy
                   Language.Fortran.$fDataBinOp10) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.BinOp p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataBinOp4 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.BinOp p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.BinOp <p>_N)) } } } }) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.BinOp p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.BinOp p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$t1Mltq98siWa3rruNi69Dt1) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.BinOp p
    -> c (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U> -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)[OneShot]
                      (c :: m (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)
                   eta) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.BinOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BinOp p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BinOp p, GHC.Types.Bool)
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fDataBinOp_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)[OneShot]
                         (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                         (y :: d)[OneShot] ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g)[OneShot] ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BinOp p>_N)
                   (\ (ds1 :: (Language.Fortran.BinOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BinOp p)
                           x' } })) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.BinOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BinOp p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BinOp p, GHC.Types.Bool)
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fDataBinOp_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)[OneShot]
                         (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                         (y :: d)[OneShot] ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g)[OneShot] ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BinOp p>_N)
                   (\ (ds1 :: (Language.Fortran.BinOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BinOp p)
                           x' } })) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BinOp p -> [u]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.BinOp p) ->
                 (Language.Fortran.$fDataBinOp_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)[OneShot]
                       (ds1 :: Data.Data.Qr [u] (d -> b))[OneShot]
                       (x :: d)[OneShot]
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.BinOp p>_P)
                   (GHC.Types.[] @ u)) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BinOp p
    -> u
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.BinOp p) ->
                 case Language.Fortran.$fDataBinOp_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)[OneShot]
                           (ds2 :: Data.Data.Qi u (d -> b))[OneShot]
                           (a1 :: d)[OneShot] ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataBinOp1 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataBinOp2
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R forall (r :: <*>_N) (r' :: <*>_N).
                      <r -> r' -> r>_R
                      ->_R <r>_R
                      ->_R <forall d. Data.Data.Data d => d -> r'>_R
                      ->_R <Language.Fortran.BinOp p>_R
                      ->_R Data.Data.N:CONST[0]
                               <*>_N <r>_R <Language.Fortran.BinOp p>_P) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.BinOp p) ->
                 (Language.Fortran.$fDataBinOp_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)[OneShot]
                       (ds3 :: Data.Data.Qr r (d -> b))[OneShot]
                       (x :: d)[OneShot]
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.BinOp p>_P)
                   ds1) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BinOp p -> Language.Fortran.BinOp p
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataBinOp3
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.BinOp p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.BinOp p>_R) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.BinOp p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (w3 :: Data.Data.Constr) ->
                 case w3 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold2 @ p w @ c w1 w2 ww1 ww5 }) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.BinOp p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataBinOp4 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.BinOp p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.BinOp p>_N))) -}
e17095ab710540e6e45e7763d42db35f
  $fDataBinOp_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.BinOp p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p (w :: Data.Data.Data p) (w1 :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$w$ctoConstr3 @ p w1) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fDataBlock_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataBlock_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataBlock_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataBlock_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataBlock_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataBlock_$cgmapMo @ p $dData) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Block p
    -> Data.Data.ID (Language.Fortran.Block p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Block p) ->
                 Language.Fortran.$fDataBlock_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
62dd7f53443032d9a82afbaf4ebfdcc2
  $fDataBlock2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataBlock3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcBlock
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
d1e3f9dfb2bf788305ab981005aaf1bc
  $fDataBlock3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   8622183916436018781##
                   7917166659374511045##) -}
5636fb89d84d3b59c8cc6276873ac3b1
  $fDataBlock4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataBlock5) -}
97fae2cb66af95d480373b46fe072c2c
  $fDataBlock5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGkmznj2VlO42PYwprZUrCU
                   (GHC.Types.[] @ Data.Data.Constr)) -}
430877fb24090936d9df75e7d1fff15d
  $fDataBlock6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Block"#) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Block p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataBlock2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.Block p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.Block p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Block p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Block <p>_N)) } } } }) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Block p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Block p))) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Block p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Block p) ->
                 Language.Fortran.$tGkmznj2VlO42PYwprZUrCU) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Block p
    -> c (Language.Fortran.Block p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.UseBlock p)
                   = Language.Fortran.$fDataUseBlock @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran @ p $dData
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Block p) ->
                 case ds of wild { Language.Fortran.Block a1 a2 a3 a4 a5 a6 ->
                 k @ (Language.Fortran.Fortran p)
                   @ (Language.Fortran.Block p)
                   $dData4
                   (k @ (Language.Fortran.Decl p)
                      @ (Language.Fortran.Fortran p -> Language.Fortran.Block p)
                      $dData3
                      (k @ Language.Fortran.SrcSpan
                         @ (Language.Fortran.Decl p
                            -> Language.Fortran.Fortran p -> Language.Fortran.Block p)
                         Language.Fortran.$fDataArg_$s$fData(,)
                         (k @ (Language.Fortran.Implicit p)
                            @ (Language.Fortran.SrcSpan
                               -> Language.Fortran.Decl p
                               -> Language.Fortran.Fortran p
                               -> Language.Fortran.Block p)
                            $dData2
                            (k @ (Language.Fortran.UseBlock p)
                               @ (Language.Fortran.Implicit p
                                  -> Language.Fortran.SrcSpan
                                  -> Language.Fortran.Decl p
                                  -> Language.Fortran.Fortran p
                                  -> Language.Fortran.Block p)
                               $dData1
                               (k @ p
                                  @ (Language.Fortran.UseBlock p
                                     -> Language.Fortran.Implicit p
                                     -> Language.Fortran.SrcSpan
                                     -> Language.Fortran.Decl p
                                     -> Language.Fortran.Fortran p
                                     -> Language.Fortran.Block p)
                                  $dData
                                  (z @ (p
                                        -> Language.Fortran.UseBlock p
                                        -> Language.Fortran.Implicit p
                                        -> Language.Fortran.SrcSpan
                                        -> Language.Fortran.Decl p
                                        -> Language.Fortran.Fortran p
                                        -> Language.Fortran.Block p)
                                     (Language.Fortran.Block @ p))
                                  a1)
                               a2)
                            a3)
                         a4)
                      a5)
                   a6 }) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataBlock_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Block p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Block p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Block p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Block p, GHC.Types.Bool)
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fDataBlock_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Block p>_N)
                   (\ (ds1 :: (Language.Fortran.Block p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Block p)
                           x' } })) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Block p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Block p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Block p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Block p, GHC.Types.Bool)
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fDataBlock_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Block p>_N)
                   (\ (ds1 :: (Language.Fortran.Block p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Block p)
                           x' } })) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Block p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Block p) ->
                 (Language.Fortran.$fDataBlock_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Block p>_P)
                   (GHC.Types.[] @ u)) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Block p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Block p) ->
                 case Language.Fortran.$fDataBlock_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Block p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Block p
                        -> Data.Data.CONST r (Language.Fortran.Block p)
                   = Language.Fortran.$fDataBlock_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Block p) -> g x)
                   `cast`
                 (<Language.Fortran.Block p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.Block p>_P)) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Block p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Block p) ->
                 (Language.Fortran.$fDataBlock_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Block p>_P)
                   ds1) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Block p -> Language.Fortran.Block p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataBlock1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Block p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Block p>_R) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Block p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.UseBlock p)
                   = Language.Fortran.$fDataUseBlock @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran @ p $dData
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ (Language.Fortran.Fortran p)
                   @ (Language.Fortran.Block p)
                   $dData4
                   (k @ (Language.Fortran.Decl p)
                      @ (Language.Fortran.Fortran p -> Language.Fortran.Block p)
                      $dData3
                      (k @ Language.Fortran.SrcSpan
                         @ (Language.Fortran.Decl p
                            -> Language.Fortran.Fortran p -> Language.Fortran.Block p)
                         Language.Fortran.$fDataArg_$s$fData(,)
                         (k @ (Language.Fortran.Implicit p)
                            @ (Language.Fortran.SrcSpan
                               -> Language.Fortran.Decl p
                               -> Language.Fortran.Fortran p
                               -> Language.Fortran.Block p)
                            $dData2
                            (k @ (Language.Fortran.UseBlock p)
                               @ (Language.Fortran.Implicit p
                                  -> Language.Fortran.SrcSpan
                                  -> Language.Fortran.Decl p
                                  -> Language.Fortran.Fortran p
                                  -> Language.Fortran.Block p)
                               $dData1
                               (k @ p
                                  @ (Language.Fortran.UseBlock p
                                     -> Language.Fortran.Implicit p
                                     -> Language.Fortran.SrcSpan
                                     -> Language.Fortran.Decl p
                                     -> Language.Fortran.Fortran p
                                     -> Language.Fortran.Block p)
                                  $dData
                                  (z @ (p
                                        -> Language.Fortran.UseBlock p
                                        -> Language.Fortran.Implicit p
                                        -> Language.Fortran.SrcSpan
                                        -> Language.Fortran.Decl p
                                        -> Language.Fortran.Fortran p
                                        -> Language.Fortran.Block p)
                                     (Language.Fortran.Block @ p)))))))) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Block p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataBlock2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Block p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Block p>_N))) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fDataBlock_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Block p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Block p) ->
                 case ds of wild { Language.Fortran.Block ds1 ds2 ds3 ds4 ds5 ds6 ->
                 Language.Fortran.$cGkmznj2VlO42PYwprZUrCU }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fDataDataForm_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataDataForm_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataDataForm_$cgmapMo @ p $dData) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.DataForm p
    -> Data.Data.ID (Language.Fortran.DataForm p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$fDataDataForm_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
3ba3db95190826e528d1c361f4b4aa80
  $fDataDataForm2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataDataForm3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcDataForm
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
73d22d2922b75339b70dcc7471032383
  $fDataDataForm3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   9284199641136566210##
                   5278240442727744153##) -}
07099148669cf0b6248226fefcffc2df
  $fDataDataForm4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataDataForm5) -}
2c6723e27f4f27f5ad3dd3e0f15ab57f
  $fDataDataForm5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c9omskyfFg9qBfOGsHHyRnk
                   (GHC.Types.[] @ Data.Data.Constr)) -}
c4781f3fa20d0e06b723c4075674b878
  $fDataDataForm6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DataForm"#) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.DataForm p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataDataForm2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.DataForm p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.DataForm <p>_N)) } } } }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.DataForm p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.DataForm p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$tAYWq9LlwbwV5ZuB247N72k) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.DataForm p
    -> c (Language.Fortran.DataForm p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData1
                       $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData2
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data a1 a2 ->
                 k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   @ (Language.Fortran.DataForm p)
                   $dData3
                   (k @ p
                      @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                         -> Language.Fortran.DataForm p)
                      $dData
                      (z @ (p
                            -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                            -> Language.Fortran.DataForm p)
                         (Language.Fortran.Data @ p))
                      a1)
                   a2 }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataDataForm_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.DataForm p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.DataForm p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.DataForm p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.DataForm p, GHC.Types.Bool)
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fDataDataForm_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.DataForm p>_N)
                   (\ (ds1 :: (Language.Fortran.DataForm p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.DataForm p)
                           x' } })) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.DataForm p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.DataForm p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.DataForm p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.DataForm p, GHC.Types.Bool)
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fDataDataForm_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.DataForm p>_N)
                   (\ (ds1 :: (Language.Fortran.DataForm p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.DataForm p)
                           x' } })) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.DataForm p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.DataForm p) ->
                 (Language.Fortran.$fDataDataForm_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.DataForm p>_P)
                   (GHC.Types.[] @ u)) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.DataForm p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.DataForm p) ->
                 case Language.Fortran.$fDataDataForm_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.DataForm p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.DataForm p
                        -> Data.Data.CONST r (Language.Fortran.DataForm p)
                   = Language.Fortran.$fDataDataForm_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.DataForm p) -> g x)
                   `cast`
                 (<Language.Fortran.DataForm p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.DataForm p>_P)) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.DataForm p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.DataForm p) ->
                 (Language.Fortran.$fDataDataForm_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.DataForm p>_P)
                   ds1) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.DataForm p -> Language.Fortran.DataForm p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataDataForm1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.DataForm p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.DataForm p>_R) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.DataForm p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData1
                       $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData2
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   @ (Language.Fortran.DataForm p)
                   $dData3
                   (k @ p
                      @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                         -> Language.Fortran.DataForm p)
                      $dData
                      (z @ (p
                            -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                            -> Language.Fortran.DataForm p)
                         (Language.Fortran.Data @ p)))) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.DataForm p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataDataForm2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.DataForm p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.DataForm p>_N))) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fDataDataForm_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.DataForm p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data ds1 ds2 ->
                 Language.Fortran.$c9omskyfFg9qBfOGsHHyRnk }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fDataDecl_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataDecl_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataDecl_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataDecl_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataDecl_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataDecl_$cgmapMo @ p $dData) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Decl p
    -> Data.Data.ID (Language.Fortran.Decl p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
86be74ebe364923762d41d436e0695ec
  $fDataDecl10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBUetck2MQOs1Upzg5eNaup
                   Language.Fortran.$fDataDecl11) -}
a8595c42dbd4b1b9e4b91e61ffb1337b
  $fDataDecl11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJLXsf9lxOoaFiQSAQ8W4hd
                   Language.Fortran.$fDataDecl12) -}
e9e8bd1a17e66c19012e1ba6a6495176
  $fDataDecl12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4SKEEpjEDeOD124ZRzk6QM
                   Language.Fortran.$fDataDecl13) -}
52f4a0b7092a084c0b1c59efefc1c0db
  $fDataDecl13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c18YkNDG5QMhL8iPWXWrllf
                   Language.Fortran.$fDataDecl14) -}
361f8d6c750981a26d73c001932c602f
  $fDataDecl14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2AYhPPmEPMTJeQTk3WUMe2
                   Language.Fortran.$fDataDecl15) -}
42851348a07954074f28c10b5d43618f
  $fDataDecl15 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1qcO2l0Dlc4HmQDSBM7P6x
                   Language.Fortran.$fDataDecl16) -}
3c521fba6dcaba7a505ddf1645953138
  $fDataDecl16 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIe4io6ptRQTBZkPPhPd59J
                   Language.Fortran.$fDataDecl17) -}
035c7859704816427dac509da5fb8c2d
  $fDataDecl17 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5wamPn3Wrx17qM0d44RERP
                   Language.Fortran.$fDataDecl18) -}
18b8c9c3d38b90ce4ab6b7c495792977
  $fDataDecl18 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c6VZm4EXLGcl6lxcJFA1Hbq
                   Language.Fortran.$fDataDecl19) -}
a1734fabe066ccdad6ae523d523777a6
  $fDataDecl19 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4h74CzRNc1XLVWLIn3H4X2
                   (GHC.Types.[] @ Data.Data.Constr)) -}
48ca3fcb42ac2f26f181d106e4901b49
  $fDataDecl2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataDecl3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcDecl
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
ab669e2cf6d3f2975301291264505802
  $fDataDecl20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Decl"#) -}
256d2c64d20d560d2562ffd4c5671d43
  $fDataDecl3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1333565254055508066##
                   2348454038217729491##) -}
99a5f077b838c79660f706ff035a4a63
  $fDataDecl4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataDecl5) -}
509f0a3efb77209006247a07b5d4ac9b
  $fDataDecl5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5IBBfvIJazmGZ0AUBImoCA
                   Language.Fortran.$fDataDecl6) -}
d20e440218a75513d2bc2772b59f7fdd
  $fDataDecl6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDsG5sYerBcHB9v8lVsfVY5
                   Language.Fortran.$fDataDecl7) -}
57e256e3d15eed75ea8ab1c67923b673
  $fDataDecl7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIcMUtRli3Fb6z5cNjlPbsf
                   Language.Fortran.$fDataDecl8) -}
d4c0e6562e98132589ea9e82578cc0f5
  $fDataDecl8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8uxH7NWw8crDcRrppV58Jw
                   Language.Fortran.$fDataDecl9) -}
713e0a0e49a397ca59cb7289cf7a39ce
  $fDataDecl9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$ccuN7R8hpA70mFie3N0Ynq
                   Language.Fortran.$fDataDecl10) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Decl p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataDecl2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Decl p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Decl p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Decl p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Decl <p>_N)) } } } }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Decl p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Decl p))) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Decl p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Decl p) ->
                 Language.Fortran.$t5IBBfvIJazmGZ0AUBImoCA) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Decl p
    -> c (Language.Fortran.Decl p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Decl p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Decl p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Decl p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Decl p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Decl p -> Language.Fortran.Decl p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataDecl1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Decl p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Decl p>_R) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Decl p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Decl p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataDecl2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Decl p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Decl p>_N))) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataDecl_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Decl p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p (w :: Data.Data.Data p) (w1 :: Language.Fortran.Decl p) ->
                 Language.Fortran.$w$ctoConstr5 @ p w1) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fDataExpr_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataExpr_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataExpr_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataExpr_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataExpr_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataExpr_$cgmapMo @ p $dData) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Expr p
    -> Data.Data.ID (Language.Fortran.Expr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
5d65814a20c365b846aa38da66bea539
  $fDataExpr10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c22KnKYxEP4y33Osr94L5dt
                   Language.Fortran.$fDataExpr11) -}
6f1fca242b66ca7fb0225220a186ff8b
  $fDataExpr11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c78tQ8qZxOZr324tkfj0IRz
                   Language.Fortran.$fDataExpr12) -}
6830271f33802b9e55a882c0a4ad52bc
  $fDataExpr12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLYSRIS5IXhsKtPBuLbJhSN
                   Language.Fortran.$fDataExpr13) -}
19ab44b509906effa322467105861f1b
  $fDataExpr13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cETFTR8syJoXGSa4EBKNf90
                   Language.Fortran.$fDataExpr14) -}
9319d3d627b78ab9b87bdbf0d2b51721
  $fDataExpr14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cD3qrJPFo7TpKgBpACeEzmz
                   Language.Fortran.$fDataExpr15) -}
3f19c718a4ec9e749414df85c6c14f63
  $fDataExpr15 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1bIlWY0B7An9HoCGDZAyX6
                   Language.Fortran.$fDataExpr16) -}
ec72df2c14b1b90eab8684f1d38c91e0
  $fDataExpr16 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLBPxZUMv6542zJYgjft5l3
                   Language.Fortran.$fDataExpr17) -}
a29ec5555873c799f644a632263292b4
  $fDataExpr17 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cD23qQhICPJIAlRuFWUrWTG
                   Language.Fortran.$fDataExpr18) -}
5b16279286124ec94c2d13c166b1bf1a
  $fDataExpr18 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cFXzcZuUPSalBxcWakFNiwk
                   Language.Fortran.$fDataExpr19) -}
ee03dd0fa67d5ea30f92858caf096acf
  $fDataExpr19 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1IznUHFLi46FHd3grEUQfU
                   (GHC.Types.[] @ Data.Data.Constr)) -}
de057b1abcad34fa16a6a9723410245f
  $fDataExpr2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataExpr3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcExpr
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
7d63e83fa608970722f224e28248c0a2
  $fDataExpr20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Expr"#) -}
8b933222c4220b37379796ed08d7799f
  $fDataExpr3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   13621902738272893592##
                   4484539928315244892##) -}
fa62dfb968ac66e1be839fbb5f454fc4
  $fDataExpr4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataExpr5) -}
87892e20d6c4ac0cbf6d9ffd37568f58
  $fDataExpr5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBnoJ3Fz73Zm4yWidz7liRC
                   Language.Fortran.$fDataExpr6) -}
062e2bebffb9c6e077ebd89778d2f873
  $fDataExpr6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cKixEZNPGwILIKGvB325tuX
                   Language.Fortran.$fDataExpr7) -}
a39eca5621d3f578810fab81d9ae4abc
  $fDataExpr7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJycyi77aaqH3o3UgNEeNZw
                   Language.Fortran.$fDataExpr8) -}
3318672ab0aaf7f8c40d86556ba549af
  $fDataExpr8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4ANqVaXyL4yIdeOK79e62B
                   Language.Fortran.$fDataExpr9) -}
0ffb2c9c6a77ca819730e305d89b1cf8
  $fDataExpr9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCh7W1cTHWOrHcDXoX6md4V
                   Language.Fortran.$fDataExpr10) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Expr p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataExpr2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Expr p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Expr p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Expr p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Expr <p>_N)) } } } }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Expr p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Expr p))) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Expr p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Expr p) ->
                 Language.Fortran.$t8ooBCVvkUu0CFtmgl1DgHc) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Expr p
    -> c (Language.Fortran.Expr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Expr p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Expr p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Expr p -> Language.Fortran.Expr p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataExpr1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Expr p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Expr p>_R) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Expr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Expr p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataExpr2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Expr p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Expr p>_N))) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fDataExpr_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Expr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p (w :: Data.Data.Data p) (w1 :: Language.Fortran.Expr p) ->
                 Language.Fortran.$w$ctoConstr @ p w1) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fDataFortran_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataFortran_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataFortran_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataFortran_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataFortran_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataFortran_$cgmapMo @ p $dData) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fortran p
    -> Data.Data.ID (Language.Fortran.Fortran p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
491e677b469b32b6f442005794a9a526
  $fDataFortran10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c3YEyxCulpF32LgLHGSyebX
                   Language.Fortran.$fDataFortran11) -}
59b06e93212f1fd656dc35eecf6c09f2
  $fDataFortran11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cI4PF9mC7gG22viZwqmXmQI
                   Language.Fortran.$fDataFortran12) -}
2900c872e685ccf464b61432137126ee
  $fDataFortran12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c18aqH9BmJhgHld6kuetHv6
                   Language.Fortran.$fDataFortran13) -}
c2e16ec38ffc6d1af7e477e8bf7d035d
  $fDataFortran13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCHtw2VnCYTERZ4xHeWpE4
                   Language.Fortran.$fDataFortran14) -}
d852a1f4b1347ccd8cffe65015da25d4
  $fDataFortran14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cAzhApblMBHHJU8C7xBa9fJ
                   Language.Fortran.$fDataFortran15) -}
2075ea74dab9bc232657c05848e015cc
  $fDataFortran15 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cC0nxMGD6gUKFvIpMtayQcB
                   Language.Fortran.$fDataFortran16) -}
70938e2623fa44ac6a7c043a34c54e12
  $fDataFortran16 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c3mMEKtaZYQL3iBM6k8DhAO
                   Language.Fortran.$fDataFortran17) -}
c13bb705ac2610b06df4f15fc46f7207
  $fDataFortran17 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7Gl0pQ9Y43l2rL5R2ucb0T
                   Language.Fortran.$fDataFortran18) -}
bd408771efffa7559293fb87ef55f835
  $fDataFortran18 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLTiyBcAAGRR1kehXcN8BdU
                   Language.Fortran.$fDataFortran19) -}
f21a0e772801756a2ac571241ef5a6f2
  $fDataFortran19 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5p5tLEohJso2vKXnu75TMm
                   Language.Fortran.$fDataFortran20) -}
c0cf30ad52cb55c70d2ac9652e0a9f9a
  $fDataFortran2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataFortran3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
ac91b488e0c0a482738a09d08f01d870
  $fDataFortran20 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBHObfxlHoGgA4QTTVq6oi4
                   Language.Fortran.$fDataFortran21) -}
f33af41e60799e0877fe67fd1a1315d5
  $fDataFortran21 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDjimyCQcrglDvnGq9cCHps
                   Language.Fortran.$fDataFortran22) -}
8ee706efd5e006821d5899d420922cbf
  $fDataFortran22 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c60GMhfP1qJqKHS0iBvnyL8
                   Language.Fortran.$fDataFortran23) -}
6e9ef5260613cbd0ac03de1ae1f3ef35
  $fDataFortran23 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1Wz6iPX2W8tHU6q9f5HuxM
                   Language.Fortran.$fDataFortran24) -}
2ca9e240c8133057dc361982f2ae5c4e
  $fDataFortran24 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c9oM7r2u0wZ0FXo9rh1iD7p
                   Language.Fortran.$fDataFortran25) -}
3a02e63c56e0fe7eddf3ca3f5906120b
  $fDataFortran25 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8a2uDwF9ZA71XaRMXFjhlN
                   Language.Fortran.$fDataFortran26) -}
796ff5b9d6e35f26f5993ee20cc9ff31
  $fDataFortran26 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1fQMqkMbKQTLcoqlmJAEse
                   Language.Fortran.$fDataFortran27) -}
67bb2ee6017a06c03c082ed2a929d5cb
  $fDataFortran27 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7DRQkmBPZA34szLkne8yRT
                   Language.Fortran.$fDataFortran28) -}
97935da3f6fbe1beb53d92f78d27d801
  $fDataFortran28 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5sCdJIX6mGtF7T4I5o5IXH
                   Language.Fortran.$fDataFortran29) -}
cbf434966a1e3103ffcdc1526902a848
  $fDataFortran29 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cF1IKYwsRetP0SeNkioe6Y7
                   Language.Fortran.$fDataFortran30) -}
40f743089f7b1c60cb6a3ba49a9fc6e1
  $fDataFortran3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   6882220124880764793##
                   15271875958298145102##) -}
2e8a2029158f392266852d0a159bcdfb
  $fDataFortran30 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8x2pi9QDrqRCm6uWv2rvPl
                   Language.Fortran.$fDataFortran31) -}
22b708a8e952590e20b253be7cd48908
  $fDataFortran31 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIM0ypPVSiloC4bjtwrXHRp
                   Language.Fortran.$fDataFortran32) -}
a501fea9d33b08ed630de2eb91bc4386
  $fDataFortran32 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJK1JTGWnd4sK8HL1FrCJ9G
                   Language.Fortran.$fDataFortran33) -}
35570487f60f99a8b8ac18a3ce683596
  $fDataFortran33 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5gqDvaOFUnJ5QtGWu4MTYJ
                   Language.Fortran.$fDataFortran34) -}
9eed87761b15263fa19f03e10912a719
  $fDataFortran34 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cEYy6jWMRHxp5HZSgP2Q9ZK
                   Language.Fortran.$fDataFortran35) -}
8e67897dc7a7fe5ffac4f4a4aa2873b9
  $fDataFortran35 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1MhfwF7Y9jS0tsFMiHDDeD
                   Language.Fortran.$fDataFortran36) -}
bb7e5a6e172433fec68f1198187574fe
  $fDataFortran36 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cA4QSI58ZfFkLxGkxSbd69y
                   Language.Fortran.$fDataFortran37) -}
e897d022deefd494c2f9299bf060b6bd
  $fDataFortran37 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBjUNnw5gxKeGq6ZKrPavlh
                   Language.Fortran.$fDataFortran38) -}
775b4625a34beb36eece36753723aaaa
  $fDataFortran38 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8alWOQnlY8j5XvDy7ZLFeQ
                   Language.Fortran.$fDataFortran39) -}
ce7eec4b581f04affc13d21e431ff549
  $fDataFortran39 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cFGQSZussvkOFNnRO51hGKa
                   Language.Fortran.$fDataFortran40) -}
a7c8b69f01fd52c3cf740020df1a826c
  $fDataFortran4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataFortran5) -}
3be4e5c6053a3986df83aef78526ca4d
  $fDataFortran40 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cB89Tp5UcFJY5zWyNR39ve9
                   Language.Fortran.$fDataFortran41) -}
5a14daa43b6c578db18a199dd47abfb4
  $fDataFortran41 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8KKprhwZTDWIjt2XeaMi66
                   Language.Fortran.$fDataFortran42) -}
7490aedfaa39bfafb76bb85e7f35eedd
  $fDataFortran42 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGmWj83OUQ795Ps0R1oraOm
                   Language.Fortran.$fDataFortran43) -}
171064420a0e179a1b5cc94dda70f55b
  $fDataFortran43 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJ89XmQl4LdA2XZ14ZkwIS3
                   (GHC.Types.[] @ Data.Data.Constr)) -}
9e5bd9c1635f621d9be39beb965745ff
  $fDataFortran44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Fortran"#) -}
8938b63e9dd14262323e6dc86762c21a
  $fDataFortran5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJIuXgcJUNEdIDk2n1uvBTZ
                   Language.Fortran.$fDataFortran6) -}
176fb843ed2cd55d78f3ff7d0bc1616b
  $fDataFortran6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8mencuMehIDCmyd4I42Hz1
                   Language.Fortran.$fDataFortran7) -}
84732941a54ebfae6205b3c69ec00b5f
  $fDataFortran7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7d8OlwqiJau34WHIostq8f
                   Language.Fortran.$fDataFortran8) -}
24ffa6562325dc91b8a113693b40950f
  $fDataFortran8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cA6zFekJaEKo1Ig9n9uLZdR
                   Language.Fortran.$fDataFortran9) -}
20ac5eba6eb1bf8c86a1a0d1d8c110b7
  $fDataFortran9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDUwJELfr3Fz4arRtKikbg0
                   Language.Fortran.$fDataFortran10) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Fortran p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataFortran2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Fortran p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Fortran <p>_N)) } } } }) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Fortran p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.Fortran p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$tD9QMegU2padFswPGA4PbPq) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Fortran p
    -> c (Language.Fortran.Fortran p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fortran p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fortran p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fortran p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fortran p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fortran p -> Language.Fortran.Fortran p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataFortran1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Fortran p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Fortran p>_R) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Fortran p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Fortran p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataFortran2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Fortran p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Fortran p>_N))) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fDataFortran_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Fortran p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w1 :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$w$ctoConstr4 @ p w1) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fDataFraction_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataFraction_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataFraction_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataFraction_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataFraction_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataFraction_$cgmapMo @ p $dData) -}
e150d0a8393be9871bef5ae54dfa9cc8
  $fDataFraction1 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataFraction2
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcFraction
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
16cbd676f139f846bff1202e725d8d75
  $fDataFraction2 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17714422405102536858##
                   17389403018657959412##) -}
bd80377cc970effaaf1c2c1266aac3b6
  $fDataFraction3 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataFraction4) -}
6d8b5b81123db06ca0004b3eefaeb758
  $fDataFraction4 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5e5NrY6v35hIG0HGZ9sZX6
                   Language.Fortran.$fDataFraction5) -}
b13e12382a897d1ce4c5f46e01d70bdb
  $fDataFraction5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7l8qyLFruibGotK7S3TC2C
                   Language.Fortran.$fDataFraction6) -}
1772b84b0e4236bc863566d6208560a3
  $fDataFraction6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2i44pp7L9VbEUZLmsRmH3u
                   (GHC.Types.[] @ Data.Data.Constr)) -}
c7f3cf9153554f8a3bd55fc429f241d0
  $fDataFraction7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Fraction"#) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Fraction p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataFraction1 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Fraction p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Fraction <p>_N)) } } } }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Fraction p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.Fraction p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Fraction p) ->
                 Language.Fortran.$tI9xo0NVFjIgHN2GbtIenwT) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Fraction p
    -> c (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           $dData
                           (z @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                              (Language.Fortran.IntegerConst @ p))
                           a1)
                        a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ GHC.Base.String
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           Data.Data.$fData[]_$s$fData[]
                           (k @ p
                              @ (GHC.Base.String
                                 -> GHC.Base.String -> Language.Fortran.Fraction p)
                              $dData
                              (z @ (p
                                    -> GHC.Base.String
                                    -> GHC.Base.String
                                    -> Language.Fortran.Fraction p)
                                 (Language.Fortran.FractionConst @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.NullFraction a1
                   -> k @ p
                        @ (Language.Fortran.Fraction p)
                        $dData
                        (z @ (p -> Language.Fortran.Fraction p)
                           (Language.Fortran.NullFraction @ p))
                        a1 }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Fraction p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = ds @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                              (Language.Fortran.IntegerConst @ p))
                           a1)
                        a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ GHC.Base.String
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           Data.Data.$fData[]_$s$fData[]
                           (k @ p
                              @ (GHC.Base.String
                                 -> GHC.Base.String -> Language.Fortran.Fraction p)
                              $dData
                              (GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (p
                                    -> GHC.Base.String
                                    -> GHC.Base.String
                                    -> Language.Fortran.Fraction p)
                                 (Language.Fortran.FractionConst @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.NullFraction a1
                   -> k @ p
                        @ (Language.Fortran.Fraction p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Fraction p)
                           (Language.Fortran.NullFraction @ p))
                        a1 }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Fraction p) ->
                 Language.Fortran.$fDataFraction_$cgmapQr
                   @ p
                   $dData
                   @ [u]
                   @ u
                   (GHC.Types.: @ u)
                   (GHC.Types.[] @ u)
                   ds
                   eta) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.Fraction p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi5 @ p w @ u ww1 w2 w3 }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fraction p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Fraction p) ->
                 case eta of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> ds
                        (ds ds1 (ds2 @ p $dData a1))
                        (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                   Language.Fortran.FractionConst a1 a2 a3
                   -> ds
                        (ds
                           (ds ds1 (ds2 @ p $dData a1))
                           (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3)
                   Language.Fortran.NullFraction a1
                   -> ds ds1 (ds2 @ p $dData a1) }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fraction p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Fraction p) ->
                 case eta of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> ds
                        (ds2 @ p $dData a1)
                        (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2) ds1)
                   Language.Fortran.FractionConst a1 a2 a3
                   -> ds
                        (ds2 @ p $dData a1)
                        (ds
                           (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                           (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3) ds1))
                   Language.Fortran.NullFraction a1
                   -> ds (ds2 @ p $dData a1) ds1 }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fraction p -> Language.Fortran.Fraction p
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Fraction p) ->
                 case eta of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst
                        @ p
                        (ds @ p $dData a1)
                        (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst
                        @ p
                        (ds @ p $dData a1)
                        (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                        (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3)
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ p (ds @ p $dData a1) }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (w3 :: Data.Data.Constr) ->
                 case w3 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold4 @ p w @ c w1 w2 ww1 ww5 }) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Fraction p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataFraction1 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Fraction p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Fraction p>_N))) -}
53046a0aa1c261e776a228d9d40263ca
  $fDataFraction_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Fraction p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst ds1 ds2
                   -> Language.Fortran.$c5e5NrY6v35hIG0HGZ9sZX6
                   Language.Fortran.FractionConst ds1 ds2 ds3
                   -> Language.Fortran.$c7l8qyLFruibGotK7S3TC2C
                   Language.Fortran.NullFraction ds1
                   -> Language.Fortran.$c2i44pp7L9VbEUZLmsRmH3u }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fDataGSpec_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataGSpec_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataGSpec_$cgmapMo @ p $dData) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.GSpec p
    -> Data.Data.ID (Language.Fortran.GSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$fDataGSpec_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
79a63e19b5b418a8ebaff6482531afb2
  $fDataGSpec2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataGSpec3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcGSpec
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
11411cb734c92c80f6ce3eefacfeda1c
  $fDataGSpec3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   9862831229811979126##
                   9644970275925022743##) -}
8d2912fbdf21bfa033fa9bd4c6187900
  $fDataGSpec4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataGSpec5) -}
416940431bd2611edf3bd413db602be1
  $fDataGSpec5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBDdjphmfhN46M2lJ4KqkC5
                   Language.Fortran.$fDataGSpec6) -}
554441f8bce33622d4f023ebc56e730d
  $fDataGSpec6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGqxaLgq7GgOGlWGdzVm1TD
                   Language.Fortran.$fDataGSpec7) -}
1aeb954370101f71560b3ffe2a683067
  $fDataGSpec7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLMTGSzJsZ7M2WWbZRwXJIc
                   (GHC.Types.[] @ Data.Data.Constr)) -}
40eb4bf3458ef4b9be09b38e851177a0
  $fDataGSpec8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GSpec"#) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.GSpec p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataGSpec2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.GSpec p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.GSpec <p>_N)) } } } }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.GSpec p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.GSpec p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$tGrPxyCsDdGxJ0qjZk7a7Iw) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.GSpec p
    -> c (Language.Fortran.GSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.BinOp p)
                   = Language.Fortran.$fDataBinOp @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.GSpec p)
                        $dData2
                        (k @ p
                           @ (Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                           $dData
                           (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                              (Language.Fortran.GName @ p))
                           a1)
                        a2
                   Language.Fortran.GOper a1 a2
                   -> k @ (Language.Fortran.BinOp p)
                        @ (Language.Fortran.GSpec p)
                        $dData1
                        (k @ p
                           @ (Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                           $dData
                           (z @ (p -> Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                              (Language.Fortran.GOper @ p))
                           a1)
                        a2
                   Language.Fortran.GAssg a1
                   -> k @ p
                        @ (Language.Fortran.GSpec p)
                        $dData
                        (z @ (p -> Language.Fortran.GSpec p) (Language.Fortran.GAssg @ p))
                        a1 }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataGSpec_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.GSpec p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.GSpec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.GSpec p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.GSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fDataGSpec_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.GSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.GSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.GSpec p)
                           x' } })) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.GSpec p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.GSpec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.GSpec p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.GSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fDataGSpec_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.GSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.GSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.GSpec p)
                           x' } })) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.GSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.GSpec p) ->
                 (Language.Fortran.$fDataGSpec_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.GSpec p>_P)
                   (GHC.Types.[] @ u)) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.GSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.GSpec p) ->
                 case Language.Fortran.$fDataGSpec_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.GSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.GSpec p
                        -> Data.Data.CONST r (Language.Fortran.GSpec p)
                   = Language.Fortran.$fDataGSpec_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.GSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.GSpec p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.GSpec p>_P)) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.GSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.GSpec p) ->
                 (Language.Fortran.$fDataGSpec_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.GSpec p>_P)
                   ds1) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.GSpec p -> Language.Fortran.GSpec p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataGSpec1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.GSpec p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.GSpec p>_R) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.GSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.BinOp p)
                   = Language.Fortran.$fDataBinOp @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 case ww1 of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww5
                      ret_ty (c (Language.Fortran.GSpec p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.GSpec p)
                             $dData
                             (z @ (p -> Language.Fortran.GSpec p) (Language.Fortran.GAssg @ p))
                        1#
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.GSpec p)
                             $dData2
                             (k @ p
                                @ (Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                                $dData
                                (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                                   (Language.Fortran.GName @ p)))
                        2#
                        -> k @ (Language.Fortran.BinOp p)
                             @ (Language.Fortran.GSpec p)
                             $dData1
                             (k @ p
                                @ (Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                                $dData
                                (z @ (p -> Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                                   (Language.Fortran.GOper @ p))) } } } }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.GSpec p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataGSpec2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.GSpec p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.GSpec p>_N))) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fDataGSpec_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.GSpec p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName ds1 ds2
                   -> Language.Fortran.$cBDdjphmfhN46M2lJ4KqkC5
                   Language.Fortran.GOper ds1 ds2
                   -> Language.Fortran.$cGqxaLgq7GgOGlWGdzVm1TD
                   Language.Fortran.GAssg ds1
                   -> Language.Fortran.$cLMTGSzJsZ7M2WWbZRwXJIc }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fDataImplicit_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataImplicit_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataImplicit_$cgmapMo @ p $dData) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit1 ::
    (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.ImplicitNull @ p, GHC.Types.False)) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit2 ::
    (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.ImplicitNone @ p, GHC.Types.False)) -}
9d2e496f693813aa84169a99aa931bad
  $fDataImplicit3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataImplicit4
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcImplicit
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
00c7f5e567ee605d39932f2ef67363d5
  $fDataImplicit4 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   798838976179940601##
                   18248231120233087656##) -}
60bab0c7a81fa26ab3e4973be3c1e063
  $fDataImplicit5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataImplicit6) -}
320f7384c72d21866efb1b6edf7cfe8f
  $fDataImplicit6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cFviLcdSWCkzJxWsC2hkVmg
                   Language.Fortran.$fDataImplicit7) -}
c7244a94d2a01edf0c0a0b83a9a71415
  $fDataImplicit7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cAA5FnhjZgxtHvdjJc3iDfO
                   (GHC.Types.[] @ Data.Data.Constr)) -}
7be3acd87c0a7b17f73a643d7ec95caa
  $fDataImplicit8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Implicit"#) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Implicit p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataImplicit3 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Implicit p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Implicit <p>_N)) } } } }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Implicit p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.Implicit p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Implicit p) ->
                 Language.Fortran.$t9z7I6Har3E7EI0Bm9Hcn1M) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Implicit p
    -> c (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData
                        (z @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNone @ p))
                        a1
                   Language.Fortran.ImplicitNull a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData
                        (z @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNull @ p))
                        a1 }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Implicit p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = ds @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNone @ p))
                        a1
                   Language.Fortran.ImplicitNull a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNull @ p))
                        a1 }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Implicit p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Implicit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Implicit p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Implicit p, GHC.Types.Bool)
                   @ (Language.Fortran.Implicit p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)[OneShot]
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl530
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.ImplicitNone a1
                      -> k @ p
                           @ (Language.Fortran.Implicit p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
                              (Language.Fortran.$fDataImplicit2 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <p -> Language.Fortran.Implicit p>_N))
                           a1
                      Language.Fortran.ImplicitNull a1
                      -> k @ p
                           @ (Language.Fortran.Implicit p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
                              (Language.Fortran.$fDataImplicit1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <p -> Language.Fortran.Implicit p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.Implicit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Implicit p)
                           x' } })) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p -> [u]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Implicit p) ->
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> GHC.Types.: @ u (ds @ p $dData a1) (GHC.Types.[] @ u)
                   Language.Fortran.ImplicitNull a1
                   -> GHC.Types.: @ u (ds @ p $dData a1) (GHC.Types.[] @ u) }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.Implicit p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi3 @ p w @ u ww1 w2 w3 }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Implicit p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Implicit p) ->
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1 -> ds ds1 (ds2 @ p $dData a1)
                   Language.Fortran.ImplicitNull a1
                   -> ds ds1 (ds2 @ p $dData a1) }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Implicit p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Implicit p) ->
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1 -> ds (ds2 @ p $dData a1) ds1
                   Language.Fortran.ImplicitNull a1
                   -> ds (ds2 @ p $dData a1) ds1 }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Implicit p -> Language.Fortran.Implicit p
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Implicit p) ->
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ p (ds @ p $dData a1)
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ p (ds @ p $dData a1) }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Implicit p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (w3 :: Data.Data.Constr) ->
                 case w3 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold3 @ p w @ c w1 w2 ww1 ww5 }) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Implicit p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataImplicit3 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Implicit p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Implicit p>_N))) -}
ed3a262a18b570752c320c116efb88d0
  $fDataImplicit_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Implicit p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone ds1
                   -> Language.Fortran.$cFviLcdSWCkzJxWsC2hkVmg
                   Language.Fortran.ImplicitNull ds1
                   -> Language.Fortran.$cAA5FnhjZgxtHvdjJc3iDfO }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fDataIntentAttr_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataIntentAttr_$cgmapMo @ p $dData) -}
d19c29ed472f6abb149da67256acb9ba
  $fDataIntentAttr1 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataIntentAttr2
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcIntentAttr
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
17e25f9455c498f823cf43417117ffbb
  $fDataIntentAttr2 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   7948506444303774333##
                   4885414271858797651##) -}
86a7f9daad6824143eb3f8f45a3f65f9
  $fDataIntentAttr3 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataIntentAttr4) -}
60fc35f99b53d561bbe57202b2677b54
  $fDataIntentAttr4 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBaIe6LD43DmBcCQvn2FSto
                   Language.Fortran.$fDataIntentAttr5) -}
4bd849b172debe35d42fd212fa063646
  $fDataIntentAttr5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c383qGoi97p81OtjiyaourQ
                   Language.Fortran.$fDataIntentAttr6) -}
a3e1b839a554b3a7da1b4b464548486d
  $fDataIntentAttr6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cB2ZtwXqHF8L4PRGLDqv8gI
                   (GHC.Types.[] @ Data.Data.Constr)) -}
7f6d5310a02eeb6455de118040c7f610
  $fDataIntentAttr7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IntentAttr"#) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.IntentAttr p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataIntentAttr1 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.IntentAttr p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.IntentAttr <p>_N)) } } } }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.IntentAttr p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.IntentAttr p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.IntentAttr p) ->
                 Language.Fortran.$t8o5Js3295nS1yK5fWYpNml) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.IntentAttr p
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.In @ p))
                        a1
                   Language.Fortran.Out a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.Out @ p))
                        a1
                   Language.Fortran.InOut a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.InOut @ p))
                        a1 }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.IntentAttr p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = ds @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.In a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.In @ p))
                        a1
                   Language.Fortran.Out a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.Out @ p))
                        a1
                   Language.Fortran.InOut a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.InOut @ p))
                        a1 }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p -> [u]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.IntentAttr p) ->
                 Language.Fortran.$fDataIntentAttr_$cgmapQr
                   @ p
                   $dData
                   @ [u]
                   @ u
                   (GHC.Types.: @ u)
                   (GHC.Types.[] @ u)
                   ds
                   eta) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.IntentAttr p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi6 @ p w @ u ww1 w2 w3 }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.IntentAttr p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.IntentAttr p) ->
                 case eta of wild {
                   Language.Fortran.In a1 -> ds ds1 (ds2 @ p $dData a1)
                   Language.Fortran.Out a1 -> ds ds1 (ds2 @ p $dData a1)
                   Language.Fortran.InOut a1 -> ds ds1 (ds2 @ p $dData a1) }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.IntentAttr p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.IntentAttr p) ->
                 case eta of wild {
                   Language.Fortran.In a1 -> ds (ds2 @ p $dData a1) ds1
                   Language.Fortran.Out a1 -> ds (ds2 @ p $dData a1) ds1
                   Language.Fortran.InOut a1 -> ds (ds2 @ p $dData a1) ds1 }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.IntentAttr p -> Language.Fortran.IntentAttr p
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.IntentAttr p) ->
                 case eta of wild {
                   Language.Fortran.In a1
                   -> Language.Fortran.In @ p (ds @ p $dData a1)
                   Language.Fortran.Out a1
                   -> Language.Fortran.Out @ p (ds @ p $dData a1)
                   Language.Fortran.InOut a1
                   -> Language.Fortran.InOut @ p (ds @ p $dData a1) }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (w3 :: Data.Data.Constr) ->
                 case w3 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold5 @ p w @ c w1 w2 ww1 ww5 }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.IntentAttr p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataIntentAttr1 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.IntentAttr p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.IntentAttr p>_N))) -}
2e224cb3ca4fa18503a4d24170747dce
  $fDataIntentAttr_$ctoConstr ::
    Data.Data.Data p =>
    Language.Fortran.IntentAttr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In ds1
                   -> Language.Fortran.$cBaIe6LD43DmBcCQvn2FSto
                   Language.Fortran.Out ds1
                   -> Language.Fortran.$c383qGoi97p81OtjiyaourQ
                   Language.Fortran.InOut ds1
                   -> Language.Fortran.$cB2ZtwXqHF8L4PRGLDqv8gI }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec ::
    Data.Data.Data p =>
    Data.Data.Data (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fDataInterfaceSpec_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapMo @ p $dData) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.InterfaceSpec p
    -> Data.Data.ID (Language.Fortran.InterfaceSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
04d89cc3dbc3db771dc2d3dad5d20752
  $fDataInterfaceSpec2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataInterfaceSpec3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcInterfaceSpec
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
e1710623f6225b59745786fcfdcbbef2
  $fDataInterfaceSpec3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   12927311303432418960##
                   10842732309658907923##) -}
bdb921f37b870bfddad9712e6df8dbfe
  $fDataInterfaceSpec4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep
                   Language.Fortran.$fDataInterfaceSpec5) -}
ce4543c2e9f1df11be62f70ed240d298
  $fDataInterfaceSpec5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJfL0DGYlphOFBne7T622o2
                   Language.Fortran.$fDataInterfaceSpec6) -}
7482f993dbb07d72562f9f88d6c5ca84
  $fDataInterfaceSpec6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDs23a8nWism1nJTKHlEXTj
                   Language.Fortran.$fDataInterfaceSpec7) -}
76171ac77d179d7485b90c8158b1c7fe
  $fDataInterfaceSpec7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cG04j4Fj75pWA5WN2R3sstL
                   (GHC.Types.[] @ Data.Data.Constr)) -}
0cfe81e60c1920cca964df33ceb64e80
  $fDataInterfaceSpec8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "InterfaceSpec"#) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.InterfaceSpec p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataInterfaceSpec2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.InterfaceSpec p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.InterfaceSpec <p>_N)) } } } }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.InterfaceSpec p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.InterfaceSpec p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.InterfaceSpec p) ->
                 Language.Fortran.$tLKbbOeOd5coIUvDeDrohlQ) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.InterfaceSpec p
    -> c (Language.Fortran.InterfaceSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.InterfaceSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.InterfaceSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.InterfaceSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.InterfaceSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataInterfaceSpec1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.InterfaceSpec p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.InterfaceSpec p>_R) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.InterfaceSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.InterfaceSpec p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataInterfaceSpec2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.InterfaceSpec p)) ->
                  ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.InterfaceSpec p>_N))) -}
c4465a5758b20b0d6387c4cda8774a94
  $fDataInterfaceSpec_$ctoConstr ::
    Data.Data.Data p =>
    Language.Fortran.InterfaceSpec p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.InterfaceSpec p) ->
                 case ds of wild {
                   Language.Fortran.FunctionInterface ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cJfL0DGYlphOFBne7T622o2
                   Language.Fortran.SubroutineInterface ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cDs23a8nWism1nJTKHlEXTj
                   Language.Fortran.ModuleProcedure ds1 ds2
                   -> Language.Fortran.$cG04j4Fj75pWA5WN2R3sstL }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec ::
    Data.Data.Data p =>
    Data.Data.Data (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapMo @ p $dData) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.MeasureUnitSpec p
    -> Data.Data.ID (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
0f3eef813df2b847ad53bd6b3cd03a32
  $fDataMeasureUnitSpec2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataMeasureUnitSpec3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcMeasureUnitSpec
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
05c041a5b44446a2f9f87212e6e50caa
  $fDataMeasureUnitSpec3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   12909754064354899##
                   16261568203038643638##) -}
c79718a9450d38a9521b287ce71f06d3
  $fDataMeasureUnitSpec4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep
                   Language.Fortran.$fDataMeasureUnitSpec5) -}
db6f1b1b88033e31560112c1505b01b7
  $fDataMeasureUnitSpec5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2m43nNsGDGRBTaeiwQgc31
                   Language.Fortran.$fDataMeasureUnitSpec6) -}
42ec04184ed8f0c8d37f31bb92c57720
  $fDataMeasureUnitSpec6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGaZokv3vKoyKQJRX4rtnkj
                   Language.Fortran.$fDataMeasureUnitSpec7) -}
84c2473a9ddc6be9c6a56880c158ade8
  $fDataMeasureUnitSpec7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cKJgysgXd4XrCpbjDx61YPu
                   (GHC.Types.[] @ Data.Data.Constr)) -}
257d1e536f9d6304cf179b7db4a0bb17
  $fDataMeasureUnitSpec8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MeasureUnitSpec"#) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.MeasureUnitSpec p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataMeasureUnitSpec2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.MeasureUnitSpec p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.MeasureUnitSpec <p>_N)) } } } }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.MeasureUnitSpec p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.MeasureUnitSpec p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$t3oO1tQaUZl83FvQJ4u6x1P) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.MeasureUnitSpec p
    -> c (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Fraction p)
                   = Language.Fortran.$fDataFraction @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data
                                (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = Data.Data.$fData(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       Data.Data.$fData[]_$s$fData[]
                       $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                       $dData2
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> k @ [(Language.Fortran.MeasureUnit,
                            Language.Fortran.Fraction p)]
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData3
                        (k @ p
                           @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                              -> Language.Fortran.MeasureUnitSpec p)
                           $dData
                           (z @ (p
                                 -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> Language.Fortran.MeasureUnitSpec p)
                              (Language.Fortran.UnitProduct @ p))
                           a1)
                        a2
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> k @ [(Language.Fortran.MeasureUnit,
                            Language.Fortran.Fraction p)]
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData3
                        (k @ [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                           @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                              -> Language.Fortran.MeasureUnitSpec p)
                           $dData3
                           (k @ p
                              @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> Language.Fortran.MeasureUnitSpec p)
                              $dData
                              (z @ (p
                                    -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                    -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                    -> Language.Fortran.MeasureUnitSpec p)
                                 (Language.Fortran.UnitQuotient @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.UnitNone a1
                   -> k @ p
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData
                        (z @ (p -> Language.Fortran.MeasureUnitSpec p)
                           (Language.Fortran.UnitNone @ p))
                        a1 }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.MeasureUnitSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.MeasureUnitSpec p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.MeasureUnitSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.MeasureUnitSpec p)
                           x' } })) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.MeasureUnitSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.MeasureUnitSpec p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.MeasureUnitSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.MeasureUnitSpec p)
                           x' } })) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.MeasureUnitSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <[u]>_R <Language.Fortran.MeasureUnitSpec p>_P)
                   (GHC.Types.[] @ u)) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.MeasureUnitSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 case Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.MeasureUnitSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.MeasureUnitSpec p
                        -> Data.Data.CONST r (Language.Fortran.MeasureUnitSpec p)
                   = Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.MeasureUnitSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.MeasureUnitSpec p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.MeasureUnitSpec p>_P)) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.MeasureUnitSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <r>_R <Language.Fortran.MeasureUnitSpec p>_P)
                   ds1) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataMeasureUnitSpec1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.MeasureUnitSpec p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.MeasureUnitSpec p>_R) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Fraction p)
                   = Language.Fortran.$fDataFraction @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data
                                (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = Data.Data.$fData(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       Data.Data.$fData[]_$s$fData[]
                       $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                       $dData2
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 case ww1 of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww5
                      ret_ty (c (Language.Fortran.MeasureUnitSpec p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData
                             (z @ (p -> Language.Fortran.MeasureUnitSpec p)
                                (Language.Fortran.UnitNone @ p))
                        1#
                        -> k @ [(Language.Fortran.MeasureUnit,
                                 Language.Fortran.Fraction p)]
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData3
                             (k @ p
                                @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                   -> Language.Fortran.MeasureUnitSpec p)
                                $dData
                                (z @ (p
                                      -> [(Language.Fortran.MeasureUnit,
                                           Language.Fortran.Fraction p)]
                                      -> Language.Fortran.MeasureUnitSpec p)
                                   (Language.Fortran.UnitProduct @ p)))
                        2#
                        -> k @ [(Language.Fortran.MeasureUnit,
                                 Language.Fortran.Fraction p)]
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData3
                             (k @ [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                   -> Language.Fortran.MeasureUnitSpec p)
                                $dData3
                                (k @ p
                                   @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                      -> [(Language.Fortran.MeasureUnit,
                                           Language.Fortran.Fraction p)]
                                      -> Language.Fortran.MeasureUnitSpec p)
                                   $dData
                                   (z @ (p
                                         -> [(Language.Fortran.MeasureUnit,
                                              Language.Fortran.Fraction p)]
                                         -> [(Language.Fortran.MeasureUnit,
                                              Language.Fortran.Fraction p)]
                                         -> Language.Fortran.MeasureUnitSpec p)
                                      (Language.Fortran.UnitQuotient @ p)))) } } } }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable
      (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataMeasureUnitSpec2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy#
                               (Language.Fortran.MeasureUnitSpec p)) ->
                  ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.MeasureUnitSpec p>_N))) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fDataMeasureUnitSpec_$ctoConstr ::
    Data.Data.Data p =>
    Language.Fortran.MeasureUnitSpec p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct ds1 ds2
                   -> Language.Fortran.$c2m43nNsGDGRBTaeiwQgc31
                   Language.Fortran.UnitQuotient ds1 ds2 ds3
                   -> Language.Fortran.$cGaZokv3vKoyKQJRX4rtnkj
                   Language.Fortran.UnitNone ds1
                   -> Language.Fortran.$cKJgysgXd4XrCpbjDx61YPu }) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fDataProgUnit_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataProgUnit_$cgmapMo @ p $dData) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ProgUnit p
    -> Data.Data.ID (Language.Fortran.ProgUnit p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
c8e7a67db600636faff67f0965109dd6
  $fDataProgUnit10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBhco6aZ1tyeC07hEtbJOeV
                   Language.Fortran.$fDataProgUnit11) -}
39d05f4d2db0454cef35c5eb85e88393
  $fDataProgUnit11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1punZIYcQoU5BRBrTkMOur
                   Language.Fortran.$fDataProgUnit12) -}
d21faf518dab90cd4f87cb61be809171
  $fDataProgUnit12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4IpgnqT1fRXLxfwDHaby2z
                   Language.Fortran.$fDataProgUnit13) -}
a021358a0eb7e056a3cd1021991e0d01
  $fDataProgUnit13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCGFBodCaxL10tlXfi5MSfH
                   (GHC.Types.[] @ Data.Data.Constr)) -}
fcf5798dfa4df23f732aa3af39c1263b
  $fDataProgUnit14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ProgUnit"#) -}
7db8362d7c1b88a08c9fff085f4ee046
  $fDataProgUnit2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataProgUnit3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcProgUnit
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
c291e739d14ff4af2d5a2283addac5ed
  $fDataProgUnit3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   10056753431434216976##
                   6055604396548152995##) -}
5d5b5bbe0f61e7de31209cf02d0df61f
  $fDataProgUnit4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataProgUnit5) -}
bdb770a129005d805a70091e03f9ad0b
  $fDataProgUnit5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4xrtyfBJfgG9CdmZCyXplY
                   Language.Fortran.$fDataProgUnit6) -}
5dfbc85c7414de1b84e9cf7c3030c703
  $fDataProgUnit6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7zjF0LiJYf2AdH4exyJgTk
                   Language.Fortran.$fDataProgUnit7) -}
52f54608f4243222f0b80900ceaf0c70
  $fDataProgUnit7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cHz24H293oUm0OxUULdlqBb
                   Language.Fortran.$fDataProgUnit8) -}
438be32190b28c47f312dc4dce4a9cb6
  $fDataProgUnit8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJF7ERNq7h76LqRZ36w7OdI
                   Language.Fortran.$fDataProgUnit9) -}
6d72f2f46ef6567a6e14f8c2e8b81fbc
  $fDataProgUnit9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJMYppX9bYODKKluMTnLSGS
                   Language.Fortran.$fDataProgUnit10) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ProgUnit p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataProgUnit2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ProgUnit p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ProgUnit <p>_N)) } } } }) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.ProgUnit p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.ProgUnit p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.ProgUnit p) ->
                 Language.Fortran.$t7VQWdGSfPYu9Iisks7pSs4) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ProgUnit p
    -> c (Language.Fortran.ProgUnit p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ProgUnit p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ProgUnit p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ProgUnit p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ProgUnit p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ProgUnit p -> Language.Fortran.ProgUnit p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataProgUnit1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.ProgUnit p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.ProgUnit p>_R) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ProgUnit p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.ProgUnit p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataProgUnit2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.ProgUnit p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.ProgUnit p>_N))) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fDataProgUnit_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.ProgUnit p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.ProgUnit p) ->
                 case ds of wild {
                   Language.Fortran.Main ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$c4xrtyfBJfgG9CdmZCyXplY
                   Language.Fortran.Sub ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$c7zjF0LiJYf2AdH4exyJgTk
                   Language.Fortran.Function ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cHz24H293oUm0OxUULdlqBb
                   Language.Fortran.Module ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cJF7ERNq7h76LqRZ36w7OdI
                   Language.Fortran.BlockData ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cJMYppX9bYODKKluMTnLSGS
                   Language.Fortran.PSeq ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cBhco6aZ1tyeC07hEtbJOeV
                   Language.Fortran.Prog ds1 ds2 ds3
                   -> Language.Fortran.$c1punZIYcQoU5BRBrTkMOur
                   Language.Fortran.NullProg ds1 ds2
                   -> Language.Fortran.$c4IpgnqT1fRXLxfwDHaby2z
                   Language.Fortran.IncludeProg ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cCGFBodCaxL10tlXfi5MSfH }) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fDataSpec_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataSpec_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataSpec_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataSpec_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataSpec_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataSpec_$cgmapMo @ p $dData) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Spec p
    -> Data.Data.ID (Language.Fortran.Spec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Spec p) ->
                 Language.Fortran.$fDataSpec_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
c9222aec51f23012d331879e672d787c
  $fDataSpec10 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cEWJ0Auj1ARaDjMLQKis4KM
                   Language.Fortran.$fDataSpec11) -}
6148132b998e0bddc74d593dc88c04f9
  $fDataSpec11 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cAYXgtZzgYPd88xyJVp9FSm
                   Language.Fortran.$fDataSpec12) -}
f12a707a41e161d70c6750381f001899
  $fDataSpec12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIAevgWXYHzwLRUFBHwuUZ8
                   Language.Fortran.$fDataSpec13) -}
9cd5cbf44096c71954b6f795cb5a9ee8
  $fDataSpec13 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2mK1s9VxLdt4GGXKi4786u
                   Language.Fortran.$fDataSpec14) -}
cb93d0722e4a14727dca956ffade29e6
  $fDataSpec14 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5UkOpWTdNZeHmddgiPGy4V
                   Language.Fortran.$fDataSpec15) -}
11c8b84328b48a1b4dd3958a2b907d77
  $fDataSpec15 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDjBpcn6xMzsHPN22w1wI82
                   Language.Fortran.$fDataSpec16) -}
5a84fe8cc9cf6507b6331762963b607f
  $fDataSpec16 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cu5gtSoLHcOBiRcc4Ziped
                   Language.Fortran.$fDataSpec17) -}
f0ccd1025869d2300df1853c846371df
  $fDataSpec17 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cFQ6NHQIThDN3fFSD7smHNn
                   Language.Fortran.$fDataSpec18) -}
924265d86a7dbddffb52147988fa12cd
  $fDataSpec18 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c64mCk8Ne1Wa90P1TKqd60d
                   Language.Fortran.$fDataSpec19) -}
884bc4d51f08c8ec1803ce36553dbbfa
  $fDataSpec19 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5uLIP5eW38kBLuMWdEWDVA
                   Language.Fortran.$fDataSpec20) -}
7a4b8e811de047abcbb8e1e89378615e
  $fDataSpec2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataSpec3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcSpec
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
ed25113f3c3aa5a406775460a3829166
  $fDataSpec20 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cA3gtOKVvfj24du9egUU4pL
                   Language.Fortran.$fDataSpec21) -}
4c58326a6e1043dba7fd6687960f5129
  $fDataSpec21 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGxIc2mtUiNe1Nyz5GUgXvl
                   Language.Fortran.$fDataSpec22) -}
801d401e752cc97bea45df62fd944992
  $fDataSpec22 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJGg760wRwEQJEY2f8Sd1Z7
                   Language.Fortran.$fDataSpec23) -}
c02dbcb98697d14bcea736ceb7d42756
  $fDataSpec23 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c20exh3Nv2bF91fBcfHsSli
                   Language.Fortran.$fDataSpec24) -}
cb457afee9ce3e189f34a7a72d5901c9
  $fDataSpec24 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cEJEHRNo6HpQ0IZ7fc5UH2m
                   Language.Fortran.$fDataSpec25) -}
d4bf583397f764b8b3863b9df471e80f
  $fDataSpec25 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cInvqrPypDap7KpUF8KbmzY
                   Language.Fortran.$fDataSpec26) -}
c7b1d81d384de4a9a937105a7e78ca67
  $fDataSpec26 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c77NRxilTXqq793JqKDeH3Z
                   Language.Fortran.$fDataSpec27) -}
7efc5b1640e8dd14ba1e68c419985d97
  $fDataSpec27 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c1CQ0luLqwKE0fss1qXQrBR
                   Language.Fortran.$fDataSpec28) -}
a451d341bc1fafc247a010ea561d8149
  $fDataSpec28 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8V4DuEbkPAEIfcWhxCrJ2n
                   Language.Fortran.$fDataSpec29) -}
afd3062e93d7af30f9cebb5bdac418d7
  $fDataSpec29 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cAF3epF9VjKiAWOEkFMvaa4
                   Language.Fortran.$fDataSpec30) -}
43338944239f3d8618eafa2f643261ac
  $fDataSpec3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   9675708239615344341##
                   9600527172562018424##) -}
ca3103d48d20910847b27f447807ab5f
  $fDataSpec30 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cEErEL27lDw1B0N3YvXaWET
                   Language.Fortran.$fDataSpec31) -}
1ee3820c3b099e51e947fad2e681c13d
  $fDataSpec31 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCJsE0jKA293JmiK7bwItsB
                   Language.Fortran.$fDataSpec32) -}
51cb7d20820c75f17e4a91bb2c773c17
  $fDataSpec32 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBxpvXAA12XjHuly5nuTiE8
                   Language.Fortran.$fDataSpec33) -}
312232ad826b333892a5c59a61a3df27
  $fDataSpec33 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c5koiIUnlOzUKTeNbDqPNFO
                   Language.Fortran.$fDataSpec34) -}
996c94f6e9b414705e31729b4a4f87c8
  $fDataSpec34 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c4SQpifNfQuGHtJQ44yIpuU
                   Language.Fortran.$fDataSpec35) -}
08e961cf793184bf55489d18570834ec
  $fDataSpec35 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c3arFYhpAYyHAt36aWemnjU
                   Language.Fortran.$fDataSpec36) -}
fd1a398cd7fd080788f69c7798c71db7
  $fDataSpec36 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cHZ7uyMpPcEEEcwapdnRQaU
                   Language.Fortran.$fDataSpec37) -}
1c2cc71617cdb784349f16f69ca9dbe5
  $fDataSpec37 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCnG8eZj9IrVCmtlLEFwUGg
                   Language.Fortran.$fDataSpec38) -}
04ccbe0f96905e28c5801432b5ba2de9
  $fDataSpec38 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cDRxAjenayYj94ZvPWP7a56
                   Language.Fortran.$fDataSpec39) -}
aa9e4e03573c30dbdf9e6b02c1b51327
  $fDataSpec39 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cD3uCaXvvn8S1Kmgoi15Hal
                   Language.Fortran.$fDataSpec40) -}
4549f17c1aae470978b3c14bef486af5
  $fDataSpec4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataSpec5) -}
712c11dcc79cd680ef14165a872140d4
  $fDataSpec40 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cG9ZNuwcTtgaIpzhpWIwrk0
                   Language.Fortran.$fDataSpec41) -}
0a73e209b4d97da3a4cd4d176b6cd4af
  $fDataSpec41 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8EqkxogGSaf38UCer6UE7V
                   Language.Fortran.$fDataSpec42) -}
7b208579354f0658bb0ae54b4b50c0a5
  $fDataSpec42 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c7ZgxpdN9n7XBLTHFJWmMgw
                   Language.Fortran.$fDataSpec43) -}
b172ac74ea42ff88433a9dc66971112c
  $fDataSpec43 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c8g6LBR4Z66Q9zl9ZbnAs01
                   (GHC.Types.[] @ Data.Data.Constr)) -}
358cc2bc2841d5dcba45da77f68978c9
  $fDataSpec44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Spec"#) -}
e755e437904cf346fe94f0b90b9a75e8
  $fDataSpec5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c61GRAacu9E7KjUErp8I6wr
                   Language.Fortran.$fDataSpec6) -}
3d79b6d5b9f9811db1671accaf1ff701
  $fDataSpec6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cERfpYlJLt2r1ym8wgeAxzB
                   Language.Fortran.$fDataSpec7) -}
df68da313e239589fe20e2b3a5dfbdd8
  $fDataSpec7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJUigIhd9rkN7twKvBnXy7l
                   Language.Fortran.$fDataSpec8) -}
b53edb0e2c1360f7eb79b79ddc6a1df0
  $fDataSpec8 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cIMGNvWbJdnq9xozMAhQSu2
                   Language.Fortran.$fDataSpec9) -}
31d939b7f362e24baadefaeb1b7ea2d8
  $fDataSpec9 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cHWt0CBnUqw77wKA6I45BBj
                   Language.Fortran.$fDataSpec10) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Spec p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataSpec2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Spec p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Spec p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Spec p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Spec <p>_N)) } } } }) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Spec p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Spec p))) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Spec p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Spec p) ->
                 Language.Fortran.$tAu5XAGgwqIJFgAQgfVhFZd) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Spec p
    -> c (Language.Fortran.Spec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataSpec_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Spec p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Spec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Spec p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Spec p, GHC.Types.Bool)
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fDataSpec_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Spec p>_N)
                   (\ (ds1 :: (Language.Fortran.Spec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Spec p)
                           x' } })) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Spec p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Spec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Spec p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Spec p, GHC.Types.Bool)
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fDataSpec_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Spec p>_N)
                   (\ (ds1 :: (Language.Fortran.Spec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Spec p)
                           x' } })) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Spec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Spec p) ->
                 (Language.Fortran.$fDataSpec_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Spec p>_P)
                   (GHC.Types.[] @ u)) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Spec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Spec p) ->
                 case Language.Fortran.$fDataSpec_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Spec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Spec p
                        -> Data.Data.CONST r (Language.Fortran.Spec p)
                   = Language.Fortran.$fDataSpec_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Spec p) -> g x)
                   `cast`
                 (<Language.Fortran.Spec p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.Spec p>_P)) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Spec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Spec p) ->
                 (Language.Fortran.$fDataSpec_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Spec p>_P)
                   ds1) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Spec p -> Language.Fortran.Spec p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataSpec1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Spec p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Spec p>_R) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Spec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Spec p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataSpec2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Spec p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Spec p>_N))) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fDataSpec_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Spec p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ p (w :: Data.Data.Data p) (w1 :: Language.Fortran.Spec p) ->
                 Language.Fortran.$w$ctoConstr6 @ p w1) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc :: Data.Data.Data Language.Fortran.SrcLoc
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fDataSrcLoc_$cp1Data
                  Language.Fortran.$fDataSrcLoc_$cgfoldl
                  Language.Fortran.$fDataSrcLoc_$cgunfold
                  Language.Fortran.$fDataSrcLoc_$ctoConstr
                  Language.Fortran.$fDataSrcLoc_$cdataTypeOf
                  Language.Fortran.$fDataSrcLoc_$cdataCast1
                  Language.Fortran.$fDataSrcLoc_$cdataCast2
                  Language.Fortran.$fDataSrcLoc_$cgmapT
                  Language.Fortran.$fDataSrcLoc_$cgmapQl
                  Language.Fortran.$fDataSrcLoc_$cgmapQr
                  Language.Fortran.$fDataSrcLoc_$cgmapQ
                  Language.Fortran.$fDataSrcLoc_$cgmapQi
                  Language.Fortran.$fDataSrcLoc_$cgmapM
                  Language.Fortran.$fDataSrcLoc_$cgmapMp
                  Language.Fortran.$fDataSrcLoc_$cgmapMo -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc1 ::
    (GHC.Base.String
     -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc,
     GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: ((Language.Fortran.SrcLoc, GHC.Types.False)) -}
fa14fd49fe847587b654e52d9477e060
  $fDataSrcLoc2 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataSrcLoc3) -}
59d7b2ae5a603908efdd48251312eb2b
  $fDataSrcLoc3 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cD3uxCVrcHH32NBssdQhe1C
                   (GHC.Types.[] @ Data.Data.Constr)) -}
adb4f47d06fda4fe9565f1deab7914e4
  $fDataSrcLoc4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SrcLoc"#) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc5 ::
    GHC.Prim.Proxy# Language.Fortran.SrcLoc
    -> Data.Typeable.Internal.TypeRep
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (wild :: GHC.Prim.Proxy# Language.Fortran.SrcLoc) ->
                 Language.Fortran.$fDataSrcLoc6) -}
d2171c9c7e36bb99abd1df5403641b99
  $fDataSrcLoc6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataSrcLoc7
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcSrcLoc
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
6fe115a03f9aa5fd3f7bb9de3b237b8e
  $fDataSrcLoc7 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   3080101248344241265##
                   5859815666103468669##) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cdataCast1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c Language.Fortran.SrcLoc)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing @ (c Language.Fortran.SrcLoc)) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c Language.Fortran.SrcLoc)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c Language.Fortran.SrcLoc)) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cdataTypeOf ::
    Language.Fortran.SrcLoc -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 Language.Fortran.$tD3uxCVrcHH32NBssdQhe1C) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.SrcLoc
    -> c Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (c :: * -> *)
                   (w :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (w1 :: forall g. g -> c g)
                   (w2 :: Language.Fortran.SrcLoc) ->
                 case w2 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgfoldl @ c w w1 ww1 ww2 ww3 }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   (w :: GHC.Base.Monad m)
                   (w1 :: forall d. Data.Data.Data d => d -> m d)
                   (w2 :: Language.Fortran.SrcLoc) ->
                 case w2 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapM @ m w w1 ww1 ww2 ww3 }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapMo ::
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)> -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapMp ::
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)>,
     Unfolding: (\ @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta1 :: Language.Fortran.SrcLoc) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m Language.Fortran.SrcLoc
                   = GHC.Base.mzero @ m $dMonadPlus @ Language.Fortran.SrcLoc
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.SrcLoc, GHC.Types.Bool)
                   @ Language.Fortran.SrcLoc
                   (case eta1 of wild { Language.Fortran.SrcLoc a1 a2 a3 ->
                    let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild1 { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl530
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    k @ GHC.Types.Int
                      @ Language.Fortran.SrcLoc
                      Data.Data.$fDataInt
                      (k @ GHC.Types.Int
                         @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fDataInt
                         (k @ GHC.Base.String
                            @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Data.Data.$fData[]_$s$fData[]
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (GHC.Base.String
                                  -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc,
                                  GHC.Types.Bool)
                               Language.Fortran.$fDataSrcLoc1)
                              `cast`
                            (Sym (Data.Data.N:Mp[0]
                                      <m>_R
                                      <GHC.Base.String
                                       -> GHC.Types.Int
                                       -> GHC.Types.Int
                                       -> Language.Fortran.SrcLoc>_N))
                            a1)
                           `cast`
                         (Sym (Data.Data.N:Mp[0]
                                   <m>_R
                                   <GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc>_N))
                         a2)
                        `cast`
                      (Sym (Data.Data.N:Mp[0]
                                <m>_R <GHC.Types.Int -> Language.Fortran.SrcLoc>_N))
                      a3 })
                   (\ (ds1 :: (Language.Fortran.SrcLoc, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ Language.Fortran.SrcLoc
                           x' } })) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SrcLoc -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U,U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (w :: forall d. Data.Data.Data d => d -> u)
                   (w1 :: Language.Fortran.SrcLoc) ->
                 case w1 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 GHC.Types.:
                   @ u
                   (w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1)
                   (GHC.Types.:
                      @ u
                      (w @ GHC.Types.Int Data.Data.$fDataInt ww2)
                      (GHC.Types.:
                         @ u
                         (w @ GHC.Types.Int Data.Data.$fDataInt ww3)
                         (GHC.Types.[] @ u))) }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SrcLoc
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (w :: GHC.Types.Int)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.SrcLoc) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.SrcLoc ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgmapQi @ u ww1 w1 ww3 ww4 ww5 } }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (w :: r -> r' -> r)
                   (w1 :: r)
                   (w2 :: forall d. Data.Data.Data d => d -> r')
                   (w3 :: Language.Fortran.SrcLoc) ->
                 case w3 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapQl @ r @ r' w w1 w2 ww1 ww2 ww3 }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (w :: r' -> r -> r)
                   (w1 :: r)
                   (w2 :: forall d. Data.Data.Data d => d -> r')
                   (w3 :: Language.Fortran.SrcLoc) ->
                 case w3 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapQr @ r @ r' w w1 w2 ww1 ww2 ww3 }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgmapT ::
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.SrcLoc -> Language.Fortran.SrcLoc
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: forall b. Data.Data.Data b => b -> b)
                   (w1 :: Language.Fortran.SrcLoc) ->
                 case w1 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.SrcLoc
                   (w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1)
                   (w @ GHC.Types.Int Data.Data.$fDataInt ww2)
                   (w @ GHC.Types.Int Data.Data.$fDataInt ww3) }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c Language.Fortran.SrcLoc
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ (c :: * -> *)
                   (w :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w1 :: forall r. r -> c r)
                   (w2 :: Data.Data.Constr) ->
                 Language.Fortran.$w$cgunfold @ c w w1) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$cp1Data ::
    Data.Typeable.Internal.Typeable Language.Fortran.SrcLoc
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataSrcLoc5
                  `cast`
                (Sym (Data.Typeable.Internal.N:Typeable[0]
                          <*>_N <Language.Fortran.SrcLoc>_N)) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fDataSrcLoc_$ctoConstr ::
    Language.Fortran.SrcLoc -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 ->
                 Language.Fortran.$cD3uxCVrcHH32NBssdQhe1C }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fDataSubName_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataSubName_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataSubName_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataSubName_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataSubName_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataSubName_$cgmapMo @ p $dData) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName1 :: (p -> Language.Fortran.SubName p, GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.NullSubName @ p, GHC.Types.False)) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName2 ::
    (p -> GHC.Base.String -> Language.Fortran.SubName p,
     GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.SubName @ p, GHC.Types.False)) -}
93d1be80016f7003a91b8ebcbbcf1b80
  $fDataSubName3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataSubName4
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcSubName
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
66020e712a1717668be9fa3c8c5ff729
  $fDataSubName4 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1824721943276726566##
                   8805268855664748890##) -}
0b0d22b701250e3625bbcea26b1b254e
  $fDataSubName5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataSubName6) -}
27c653e23425dbe7268e0089ff145948
  $fDataSubName6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c9wUW5raBQcVDAKDv14uNEd
                   Language.Fortran.$fDataSubName7) -}
7adee503257f6727db34c2c9bd8e73dc
  $fDataSubName7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cD3wcgyNZlXWFJGnEiXeZLk
                   (GHC.Types.[] @ Data.Data.Constr)) -}
fe2c31a43cb10dba0c61cd7cd3f102a3
  $fDataSubName8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SubName"#) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.SubName p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataSubName3 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.SubName p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.SubName p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.SubName p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.SubName <p>_N)) } } } }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.SubName p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.SubName p))) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.SubName p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.SubName p) ->
                 Language.Fortran.$t9wUW5raBQcVDAKDv14uNEd) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.SubName p
    -> c (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.SubName p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.SubName p)
                           $dData
                           (z @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                              (Language.Fortran.SubName @ p))
                           a1)
                        a2
                   Language.Fortran.NullSubName a1
                   -> k @ p
                        @ (Language.Fortran.SubName p)
                        $dData
                        (z @ (p -> Language.Fortran.SubName p)
                           (Language.Fortran.NullSubName @ p))
                        a1 }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.SubName p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = ds @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.SubName p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.SubName p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                              (Language.Fortran.SubName @ p))
                           a1)
                        a2
                   Language.Fortran.NullSubName a1
                   -> k @ p
                        @ (Language.Fortran.SubName p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.SubName p)
                           (Language.Fortran.NullSubName @ p))
                        a1 }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.SubName p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.SubName p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.SubName p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.SubName p, GHC.Types.Bool)
                   @ (Language.Fortran.SubName p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl530
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.SubName a1 a2
                      -> k @ GHC.Base.String
                           @ (Language.Fortran.SubName p)
                           Data.Data.$fData[]_$s$fData[]
                           (k @ p
                              @ (GHC.Base.String -> Language.Fortran.SubName p)
                              $dData
                              (GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (p -> GHC.Base.String -> Language.Fortran.SubName p,
                                    GHC.Types.Bool)
                                 (Language.Fortran.$fDataSubName2 @ p))
                                `cast`
                              (Sym (Data.Data.N:Mp[0]
                                        <m>_R
                                        <p -> GHC.Base.String -> Language.Fortran.SubName p>_N))
                              a1)
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <GHC.Base.String -> Language.Fortran.SubName p>_N))
                           a2
                      Language.Fortran.NullSubName a1
                      -> k @ p
                           @ (Language.Fortran.SubName p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.SubName p, GHC.Types.Bool)
                              (Language.Fortran.$fDataSubName1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.SubName p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.SubName p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.SubName p)
                           x' } })) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.SubName p) ->
                 case w2 of wild {
                   Language.Fortran.SubName a1 a2
                   -> GHC.Types.:
                        @ u
                        (w1 @ p w a1)
                        (GHC.Types.:
                           @ u
                           (w1 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                           (GHC.Types.[] @ u))
                   Language.Fortran.NullSubName a1
                   -> GHC.Types.: @ u (w1 @ p w a1) (GHC.Types.[] @ u) }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.SubName p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi2 @ p w @ u ww1 w2 w3 }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SubName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.SubName p) ->
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> ds
                        (ds ds1 (ds2 @ p $dData a1))
                        (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                   Language.Fortran.NullSubName a1 -> ds ds1 (ds2 @ p $dData a1) }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SubName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.SubName p) ->
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> ds
                        (ds2 @ p $dData a1)
                        (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2) ds1)
                   Language.Fortran.NullSubName a1 -> ds (ds2 @ p $dData a1) ds1 }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.SubName p -> Language.Fortran.SubName p
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.SubName p) ->
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> Language.Fortran.SubName
                        @ p
                        (ds @ p $dData a1)
                        (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ p (ds @ p $dData a1) }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (w3 :: Data.Data.Constr) ->
                 case w3 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold1 @ p w @ c w1 w2 ww1 ww5 }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.SubName p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataSubName3 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.SubName p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.SubName p>_N))) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fDataSubName_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.SubName p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName ds1 ds2
                   -> Language.Fortran.$c9wUW5raBQcVDAKDv14uNEd
                   Language.Fortran.NullSubName ds1
                   -> Language.Fortran.$cD3wcgyNZlXWFJGnEiXeZLk }) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fDataType_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataType_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataType_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataType_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataType_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataType_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataType_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataType_$cgmapMo @ p $dData) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Type p
    -> Data.Data.ID (Language.Fortran.Type p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.Type p) ->
                 Language.Fortran.$fDataType_$cgfoldl
                   @ p
                   $dData
                   @ Data.Data.ID
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (ds1 :: Data.Data.ID (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Data.N:ID[0] <d -> b>_R) (ds @ d $dData1 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Data.ID (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Data.N:ID[0] <b>_R))
                   Language.Fortran.$fDataArg10
                     `cast`
                   (forall (g :: <*>_N). <g>_R ->_R Sym (Data.Data.N:ID[0] <g>_R))
                   eta) -}
c96609fb267c7cc5cf7f776216da9f82
  $fDataType2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataType3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcType
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
b847c329ca73136d8a32460daa3ef1d2
  $fDataType3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1220767263731147235##
                   9614101381113798831##) -}
5fab984af5aa9af4751c913d99a1568c
  $fDataType4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataType5) -}
25fd6c20fe7fa5013ce812dc3d64627e
  $fDataType5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cCLEx3Oi2MB55JzB9GYZf6v
                   Language.Fortran.$fDataType6) -}
94b50d9ede98086a3e06e31891f8bcec
  $fDataType6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cB6QEzUjKqweCeNxLtCZnTj
                   (GHC.Types.[] @ Data.Data.Constr)) -}
4fbdd1822c8ec4668663945c3dcc8c16
  $fDataType7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Type"#) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Type p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataType2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Type p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Type p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Type p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Type <p>_N)) } } } }) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Type p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Type p))) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Type p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Type p) ->
                 Language.Fortran.$t9zwlS1ZPD8rGUQKFJ0pOs1) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Type p
    -> c (Language.Fortran.Type p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr @ p $dData
                 } in
                 let {
                   $dData3 :: Data.Data.Data [Language.Fortran.Attr p]
                   = Data.Data.$fData[] @ (Language.Fortran.Attr p) $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData
                 } in
                 let {
                   $dData5 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData4
                       $dData4
                 } in
                 let {
                   $dData6 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData5
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.Type p)
                        $dData4
                        (k @ (Language.Fortran.Expr p)
                           @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                           $dData4
                           (k @ [Language.Fortran.Attr p]
                              @ (Language.Fortran.Expr p
                                 -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                              $dData3
                              (k @ (Language.Fortran.BaseType p)
                                 @ ([Language.Fortran.Attr p]
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Type p)
                                 $dData1
                                 (k @ p
                                    @ (Language.Fortran.BaseType p
                                       -> [Language.Fortran.Attr p]
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Type p)
                                    $dData
                                    (z @ (p
                                          -> Language.Fortran.BaseType p
                                          -> [Language.Fortran.Attr p]
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Type p)
                                       (Language.Fortran.BaseType @ p))
                                    a1)
                                 a2)
                              a3)
                           a4)
                        a5
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.Type p)
                        $dData4
                        (k @ (Language.Fortran.Expr p)
                           @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                           $dData4
                           (k @ [Language.Fortran.Attr p]
                              @ (Language.Fortran.Expr p
                                 -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                              $dData3
                              (k @ (Language.Fortran.BaseType p)
                                 @ ([Language.Fortran.Attr p]
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Type p)
                                 $dData1
                                 (k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                    @ (Language.Fortran.BaseType p
                                       -> [Language.Fortran.Attr p]
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Type p)
                                    $dData6
                                    (k @ p
                                       @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                          -> Language.Fortran.BaseType p
                                          -> [Language.Fortran.Attr p]
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Type p)
                                       $dData
                                       (z @ (p
                                             -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                             -> Language.Fortran.BaseType p
                                             -> [Language.Fortran.Attr p]
                                             -> Language.Fortran.Expr p
                                             -> Language.Fortran.Expr p
                                             -> Language.Fortran.Type p)
                                          (Language.Fortran.ArrayT @ p))
                                       a1)
                                    a2)
                                 a3)
                              a4)
                           a5)
                        a6 }) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataType_$cgfoldl
                   @ p
                   $dData
                   @ m
                   (\ @ d
                      @ b
                      ($dData1 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl529 :: m d = ds @ d $dData1 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl529
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Type p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Type p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Type p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Type p, GHC.Types.Bool)
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fDataType_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl530
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Type p>_N)
                   (\ (ds1 :: (Language.Fortran.Type p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Type p)
                           x' } })) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Type p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Type p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Type p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Type p, GHC.Types.Bool)
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fDataType_$cgfoldl
                      @ p
                      $dData
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData1 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl530 :: m d = ds @ d $dData1 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl530
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Type p>_N)
                   (\ (ds1 :: (Language.Fortran.Type p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Type p)
                           x' } })) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Type p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Type p) ->
                 (Language.Fortran.$fDataType_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg7 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Type p>_P)
                   (GHC.Types.[] @ u)) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Type p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.Type p) ->
                 case Language.Fortran.$fDataType_$cgfoldl
                        @ p
                        $dData
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData1 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x ->
                            GHC.Types.I# (GHC.Prim.+# x 1#) })
                           (case ds of wild1 { GHC.Types.I# x ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# x y) of wild3 {
                              GHC.Types.False -> q
                              GHC.Types.True -> GHC.Base.Just @ u (ds1 @ d $dData1 a1) } } }) })
                        (Language.Fortran.$fDataArg4 @ u)
                        eta of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Type p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Type p
                        -> Data.Data.CONST r (Language.Fortran.Type p)
                   = Language.Fortran.$fDataType_$cgfoldl
                       @ p
                       $dData
                       @ (Data.Data.CONST r)
                       (\ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (c :: Data.Data.CONST r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Data.N:CONST[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData1 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Data.CONST r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Data.N:CONST[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Type p) -> g x)
                   `cast`
                 (<Language.Fortran.Type p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.Type p>_P)) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Type p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Type p) ->
                 (Language.Fortran.$fDataType_$cgfoldl
                    @ p
                    $dData
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData1 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg8 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    eta)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Type p>_P)
                   ds1) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Type p -> Language.Fortran.Type p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataType1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Type p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Type p>_R) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Type p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType @ p $dData
                 } in
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr @ p $dData
                 } in
                 let {
                   $dData3 :: Data.Data.Data [Language.Fortran.Attr p]
                   = Data.Data.$fData[] @ (Language.Fortran.Attr p) $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData
                 } in
                 let {
                   $dData5 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData4
                       $dData4
                 } in
                 let {
                   $dData6 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData5
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 case ww1 of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww5
                      ret_ty (c (Language.Fortran.Type p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.Type p)
                             $dData4
                             (k @ (Language.Fortran.Expr p)
                                @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                                $dData4
                                (k @ [Language.Fortran.Attr p]
                                   @ (Language.Fortran.Expr p
                                      -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                                   $dData3
                                   (k @ (Language.Fortran.BaseType p)
                                      @ ([Language.Fortran.Attr p]
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Type p)
                                      $dData1
                                      (k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                         @ (Language.Fortran.BaseType p
                                            -> [Language.Fortran.Attr p]
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Type p)
                                         $dData6
                                         (k @ p
                                            @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                               -> Language.Fortran.BaseType p
                                               -> [Language.Fortran.Attr p]
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Type p)
                                            $dData
                                            (z @ (p
                                                  -> [(Language.Fortran.Expr p,
                                                       Language.Fortran.Expr p)]
                                                  -> Language.Fortran.BaseType p
                                                  -> [Language.Fortran.Attr p]
                                                  -> Language.Fortran.Expr p
                                                  -> Language.Fortran.Expr p
                                                  -> Language.Fortran.Type p)
                                               (Language.Fortran.ArrayT @ p)))))))
                        1#
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.Type p)
                             $dData4
                             (k @ (Language.Fortran.Expr p)
                                @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                                $dData4
                                (k @ [Language.Fortran.Attr p]
                                   @ (Language.Fortran.Expr p
                                      -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                                   $dData3
                                   (k @ (Language.Fortran.BaseType p)
                                      @ ([Language.Fortran.Attr p]
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Type p)
                                      $dData1
                                      (k @ p
                                         @ (Language.Fortran.BaseType p
                                            -> [Language.Fortran.Attr p]
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Type p)
                                         $dData
                                         (z @ (p
                                               -> Language.Fortran.BaseType p
                                               -> [Language.Fortran.Attr p]
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Type p)
                                            (Language.Fortran.BaseType @ p)))))) } } } }) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Type p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataType2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Type p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Type p>_N))) -}
cac90f1d6845827f0c2780e86e10c606
  $fDataType_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Type p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType ds1 ds2 ds3 ds4 ds5
                   -> Language.Fortran.$cCLEx3Oi2MB55JzB9GYZf6v
                   Language.Fortran.ArrayT ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cB6QEzUjKqweCeNxLtCZnTj }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fDataUnaryOp_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataUnaryOp_$cgmapMo @ p $dData) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp1 :: (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.Not @ p, GHC.Types.False)) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp2 :: (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.UMinus @ p, GHC.Types.False)) -}
bf3858165acabac913f361c4ab63cf88
  $fDataUnaryOp3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataUnaryOp4
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcUnaryOp
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
2cb3d96aa7790b779ed1e438a45d64f6
  $fDataUnaryOp4 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   6152895793842022613##
                   3913372895388833325##) -}
e7e30b02340c5e9d62787b486dbb3395
  $fDataUnaryOp5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataUnaryOp6) -}
be4de2f76e694504311c933308c25ca0
  $fDataUnaryOp6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cJl4i34RdGTBBkJR6CNDRk6
                   Language.Fortran.$fDataUnaryOp7) -}
4eaa65d3dd7ab624a26965186aa8b4c4
  $fDataUnaryOp7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cGbXUKdZa5O7Btl967GFUlU
                   (GHC.Types.[] @ Data.Data.Constr)) -}
c2a09e4f4709d13ae86a0b86a82ea857
  $fDataUnaryOp8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UnaryOp"#) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.UnaryOp p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataUnaryOp3 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.UnaryOp p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.UnaryOp <p>_N)) } } } }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.UnaryOp p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.UnaryOp p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.UnaryOp p) ->
                 Language.Fortran.$tHcv3IdLRyWt6uBs4pZDsWx) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.UnaryOp p
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData
                        (z @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.UMinus @ p))
                        a1
                   Language.Fortran.Not a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData
                        (z @ (p -> Language.Fortran.UnaryOp p) (Language.Fortran.Not @ p))
                        a1 }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = ds @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.UMinus @ p))
                        a1
                   Language.Fortran.Not a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.Not @ p))
                        a1 }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.UnaryOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.UnaryOp p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.UnaryOp p, GHC.Types.Bool)
                   @ (Language.Fortran.UnaryOp p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)[OneShot]
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl530
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.UMinus a1
                      -> k @ p
                           @ (Language.Fortran.UnaryOp p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
                              (Language.Fortran.$fDataUnaryOp2 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.UnaryOp p>_N))
                           a1
                      Language.Fortran.Not a1
                      -> k @ p
                           @ (Language.Fortran.UnaryOp p)
                           $dData
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
                              (Language.Fortran.$fDataUnaryOp1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.UnaryOp p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.UnaryOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.UnaryOp p)
                           x' } })) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p -> [u]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> GHC.Types.: @ u (ds @ p $dData a1) (GHC.Types.[] @ u)
                   Language.Fortran.Not a1
                   -> GHC.Types.: @ u (ds @ p $dData a1) (GHC.Types.[] @ u) }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.UnaryOp p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi7 @ p w @ u ww1 w2 w3 }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UnaryOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.UnaryOp p) ->
                 case eta of wild {
                   Language.Fortran.UMinus a1 -> ds ds1 (ds2 @ p $dData a1)
                   Language.Fortran.Not a1 -> ds ds1 (ds2 @ p $dData a1) }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UnaryOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.UnaryOp p) ->
                 case eta of wild {
                   Language.Fortran.UMinus a1 -> ds (ds2 @ p $dData a1) ds1
                   Language.Fortran.Not a1 -> ds (ds2 @ p $dData a1) ds1 }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.UnaryOp p -> Language.Fortran.UnaryOp p
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> Language.Fortran.UMinus @ p (ds @ p $dData a1)
                   Language.Fortran.Not a1
                   -> Language.Fortran.Not @ p (ds @ p $dData a1) }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (w3 :: Data.Data.Constr) ->
                 case w3 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold6 @ p w @ c w1 w2 ww1 ww5 }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.UnaryOp p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataUnaryOp3 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.UnaryOp p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.UnaryOp p>_N))) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fDataUnaryOp_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.UnaryOp p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus ds1
                   -> Language.Fortran.$cJl4i34RdGTBBkJR6CNDRk6
                   Language.Fortran.Not ds1
                   -> Language.Fortran.$cGbXUKdZa5O7Btl967GFUlU }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fDataUseBlock_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataUseBlock_$cgmapMo @ p $dData) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock1 ::
    (Language.Fortran.Uses p
     -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p,
     GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.UseBlock @ p, GHC.Types.False)) -}
016f731134f51e7cc1e1437ea478cafc
  $fDataUseBlock2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataUseBlock3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcUseBlock
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
66d7423213d7aa80940d782b83b5cf65
  $fDataUseBlock3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   9533103736263371791##
                   3422293205816457763##) -}
513122ed3fe361a8a712537a95a2b188
  $fDataUseBlock4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataUseBlock5) -}
a01d5543d73d62accd3a5fa77d727298
  $fDataUseBlock5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$c2bis2A5kzul0VB1cVHCnO4
                   (GHC.Types.[] @ Data.Data.Constr)) -}
f244ac759f47215c9216fc896ff3e861
  $fDataUseBlock6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UseBlock"#) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.UseBlock p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataUseBlock2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.UseBlock p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.UseBlock <p>_N)) } } } }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.UseBlock p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.UseBlock p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.UseBlock p) ->
                 Language.Fortran.$t2bis2A5kzul0VB1cVHCnO4) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.UseBlock p
    -> c (Language.Fortran.UseBlock p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.UseBlock p) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData1
                      (z @ (Language.Fortran.Uses p
                            -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.UseBlock @ p))
                      a1)
                   a2 }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData
                 } in
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.Uses p
                                -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                   = GHC.Base.return
                       @ m
                       $dMonad
                       @ (Language.Fortran.Uses p
                          -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                       (Language.Fortran.UseBlock @ p)
                 } in
                 \ (ds1 :: Language.Fortran.UseBlock p) ->
                 case ds1 of wild { Language.Fortran.UseBlock a1 a2 ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData1
                      lvl529
                      a1)
                   a2 }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UseBlock p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.UseBlock p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.UseBlock p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.UseBlock p, GHC.Types.Bool)
                   @ (Language.Fortran.UseBlock p)
                   (case eta of wild { Language.Fortran.UseBlock a1 a2 ->
                    let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild1 { (,) h b1 ->
                           case b1 of wild2 {
                             GHC.Types.False
                             -> GHC.Base.mplus
                                  @ m
                                  $dMonadPlus
                                  @ (b, GHC.Types.Bool)
                                  (GHC.Base.>>=
                                     @ m
                                     $dMonad
                                     @ d
                                     @ (b, GHC.Types.Bool)
                                     lvl530
                                     (\ (y' :: d) ->
                                      GHC.Base.return
                                        @ m
                                        $dMonad
                                        @ (b, GHC.Types.Bool)
                                        (h y', GHC.Types.True)))
                                  (GHC.Base.return
                                     @ m
                                     $dMonad
                                     @ (b, GHC.Types.Bool)
                                     (h y, GHC.Types.False))
                             GHC.Types.True
                             -> GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y, GHC.Types.True) } })
                    } in
                    k @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.UseBlock p)
                      Language.Fortran.$fDataSrcLoc
                      (k @ (Language.Fortran.Uses p)
                         @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.$fDataUses @ p $dData)
                         (GHC.Base.return
                            @ m
                            $dMonad
                            @ (Language.Fortran.Uses p
                               -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p,
                               GHC.Types.Bool)
                            (Language.Fortran.$fDataUseBlock1 @ p))
                           `cast`
                         (Sym (Data.Data.N:Mp[0]
                                   <m>_R
                                   <Language.Fortran.Uses p
                                    -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p>_N))
                         a1)
                        `cast`
                      (Sym (Data.Data.N:Mp[0]
                                <m>_R <Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p>_N))
                      a2 })
                   (\ (ds1 :: (Language.Fortran.UseBlock p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.UseBlock p)
                           x' } })) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UseBlock p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.UseBlock p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.UseBlock p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.UseBlock p, GHC.Types.Bool)
                   @ (Language.Fortran.UseBlock p)
                   (case eta of wild { Language.Fortran.UseBlock a1 a2 ->
                    let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild1 { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl530
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    k @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.UseBlock p)
                      Language.Fortran.$fDataSrcLoc
                      (k @ (Language.Fortran.Uses p)
                         @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.$fDataUses @ p $dData)
                         (GHC.Base.return
                            @ m
                            $dMonad
                            @ (Language.Fortran.Uses p
                               -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p,
                               GHC.Types.Bool)
                            (Language.Fortran.$fDataUseBlock1 @ p))
                           `cast`
                         (Sym (Data.Data.N:Mp[0]
                                   <m>_R
                                   <Language.Fortran.Uses p
                                    -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p>_N))
                         a1)
                        `cast`
                      (Sym (Data.Data.N:Mp[0]
                                <m>_R <Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p>_N))
                      a2 })
                   (\ (ds1 :: (Language.Fortran.UseBlock p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.UseBlock p)
                           x' } })) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UseBlock p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.UseBlock p) ->
                 case w2 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 GHC.Types.:
                   @ u
                   (w1
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p w)
                      ww1)
                   (GHC.Types.:
                      @ u
                      (w1 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc ww2)
                      (GHC.Types.[] @ u)) }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UseBlock p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w1 :: GHC.Types.Int)
                   (w2 :: forall d. Data.Data.Data d => d -> u)
                   (w3 :: Language.Fortran.UseBlock p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { Language.Fortran.UseBlock ww3 ww4 ->
                 Language.Fortran.$w$cgmapQi4 @ p w @ u ww1 w2 ww3 ww4 } }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UseBlock p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData
                 } in
                 (\ (ds3 :: Language.Fortran.UseBlock p) ->
                  case ds3 of wild { Language.Fortran.UseBlock a1 a2 ->
                  (ds
                     (ds ds1 (ds2 @ (Language.Fortran.Uses p) $dData1 a1))
                     (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                    `cast`
                  (Sym (Data.Data.N:CONST[0]
                            <*>_N <r>_R <Language.Fortran.UseBlock p>_P)) })
                   `cast`
                 (<Language.Fortran.UseBlock p>_R
                  ->_R Data.Data.N:CONST[0]
                           <*>_N <r>_R <Language.Fortran.UseBlock p>_P)) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UseBlock p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r' -> r -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (w4 :: Language.Fortran.UseBlock p) ->
                 case w4 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr2 @ p w @ r @ r' w1 w2 w3 ww1 ww2 }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.UseBlock p -> Language.Fortran.UseBlock p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.UseBlock p) ->
                 case eta of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ p
                   (ds
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p $dData)
                      a1)
                   (ds
                      @ Language.Fortran.SrcLoc
                      Language.Fortran.$fDataSrcLoc
                      a2) }) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.UseBlock p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) @ (c :: * -> *) ->
                 let {
                   $dData1 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData1
                      (z @ (Language.Fortran.Uses p
                            -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.UseBlock @ p)))) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.UseBlock p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataUseBlock2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.UseBlock p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.UseBlock p>_N))) -}
d59de0314bb55c907d315303e8c78677
  $fDataUseBlock_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.UseBlock p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.UseBlock p) ->
                 case ds of wild { Language.Fortran.UseBlock ds1 ds2 ->
                 Language.Fortran.$c2bis2A5kzul0VB1cVHCnO4 }) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fDataUses_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataUses_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataUses_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataUses_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataUses_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataUses_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataUses_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataUses_$cgmapMo @ p $dData) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Uses p
    -> Data.Data.ID (Language.Fortran.Uses p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
6d50d6661d1cfd58c388349e85efeae6
  $fDataUses2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataUses3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcUses
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
e859a202eca63fef117f3145d127d594
  $fDataUses3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   4363150290659116846##
                   4164391352706304496##) -}
d53c1b6a83a2d86b07e192f0a2fc4649
  $fDataUses4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataUses5) -}
b9b601447d0115422c2b94bf906e58c4
  $fDataUses5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cAhS1i9Auu0J7VmXnhCTnJG
                   Language.Fortran.$fDataUses6) -}
60e68208e4d33a84cd1882ba8d0916b9
  $fDataUses6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cEr4sZrx2wgp4CcX0qpsSpf
                   (GHC.Types.[] @ Data.Data.Constr)) -}
a5956fba355706ac93504555014829db
  $fDataUses7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Uses"#) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Uses p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataUses2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Uses p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Base.Nothing @ (c (Language.Fortran.Uses p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Uses p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Uses <p>_N)) } } } }) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.Uses p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.Uses p))) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cdataTypeOf ::
    Data.Data.Data p => Language.Fortran.Uses p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Uses p) ->
                 Language.Fortran.$tH4ixff6wOjR83m2qXz10ep) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Uses p
    -> c (Language.Fortran.Uses p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,U> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Uses p -> Language.Fortran.Uses p
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fDataUses1
                  `cast`
                (forall (p :: <*>_N).
                 <Data.Data.Data p>_R
                 ->_R <forall b. Data.Data.Data b => b -> b>_R
                 ->_R <Language.Fortran.Uses p>_R
                 ->_R Data.Data.N:ID[0] <Language.Fortran.Uses p>_R) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Uses p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.Uses p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataUses2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.Uses p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.Uses p>_N))) -}
22a7293c3f9ba679ea60d591f21568e8
  $fDataUses_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Uses p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.Uses p) ->
                 case ds of wild {
                   Language.Fortran.Use ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cAhS1i9Auu0J7VmXnhCTnJG
                   Language.Fortran.UseNil ds1
                   -> Language.Fortran.$cEr4sZrx2wgp4CcX0qpsSpf }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dData :: Data.Data.Data p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fDataVarName_$cp1Data @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgfoldl @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgunfold @ p $dData)
                  (Language.Fortran.$fDataVarName_$ctoConstr @ p $dData)
                  (Language.Fortran.$fDataVarName_$cdataTypeOf @ p $dData)
                  (Language.Fortran.$fDataVarName_$cdataCast1 @ p $dData)
                  (Language.Fortran.$fDataVarName_$cdataCast2 @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapT @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapQl @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapQr @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapQ @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapQi @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapM @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapMp @ p $dData)
                  (Language.Fortran.$fDataVarName_$cgmapMo @ p $dData) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName1 ::
    (p -> Language.Fortran.Variable -> Language.Fortran.VarName p,
     GHC.Types.Bool)
  {- HasNoCafRefs,
     Unfolding: (\ @ p ->
                 (Language.Fortran.VarName @ p, GHC.Types.False)) -}
f03ffce00fbfabb21009b6278083e732
  $fDataVarName2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           Language.Fortran.$fDataVarName3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcVarName
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
b1c7bee0ab80b8f3f18451af78eba1a6
  $fDataVarName3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1672502290831751764##
                   46662296866082288##) -}
d8880a8f12560766843440b97226bf7f
  $fDataVarName4 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataVarName5) -}
57b621aeefe634ea2b9998563a80bdc0
  $fDataVarName5 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cLUk6nnNjD0l6PtfmFqmXuq
                   (GHC.Types.[] @ Data.Data.Constr)) -}
615f2eb1b203e4f600542edd5cb0007b
  $fDataVarName6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VarName"#) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.VarName p))
  {- Arity: 3,
     Strictness: <L,U><C(S(SLLLL)),1*C1(U(U,U,A,A,A))><L,1*C1(U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (f :: forall d. Data.Data.Data d => c (t d)) ->
                 case $dTypeable
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                        (GHC.Prim.proxy#
                           @ (* -> *)
                           @ t) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case Language.Fortran.$fDataVarName2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing @ (c (Language.Fortran.VarName p))
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (c (Language.Fortran.VarName p))
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.VarName p))
                             (f @ p $dData)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.VarName <p>_N)) } } } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cdataCast2 ::
    Data.Data.Data p =>
    forall (t :: * -> * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (Language.Fortran.VarName p))
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (Language.Fortran.VarName p))) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cdataTypeOf ::
    Data.Data.Data p =>
    Language.Fortran.VarName p -> Data.Data.DataType
  {- Arity: 2, Strictness: <L,A><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.VarName p) ->
                 Language.Fortran.$tLUk6nnNjD0l6PtfmFqmXuq) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.VarName p
    -> c (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.VarName p) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      $dData
                      (z @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p))
                      a1)
                   a2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ (m :: * -> *)
                   (w1 :: GHC.Base.Monad m)
                   (w2 :: forall d. Data.Data.Data d => d -> m d)
                   (w3 :: Language.Fortran.VarName p) ->
                 case w3 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapM1 @ p w @ m w1 w2 ww1 ww2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.VarName p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.VarName p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.VarName p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.VarName p, GHC.Types.Bool)
                   @ (Language.Fortran.VarName p)
                   (case eta of wild { Language.Fortran.VarName a1 a2 ->
                    let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild1 { (,) h b1 ->
                           case b1 of wild2 {
                             GHC.Types.False
                             -> GHC.Base.mplus
                                  @ m
                                  $dMonadPlus
                                  @ (b, GHC.Types.Bool)
                                  (GHC.Base.>>=
                                     @ m
                                     $dMonad
                                     @ d
                                     @ (b, GHC.Types.Bool)
                                     lvl530
                                     (\ (y' :: d) ->
                                      GHC.Base.return
                                        @ m
                                        $dMonad
                                        @ (b, GHC.Types.Bool)
                                        (h y', GHC.Types.True)))
                                  (GHC.Base.return
                                     @ m
                                     $dMonad
                                     @ (b, GHC.Types.Bool)
                                     (h y, GHC.Types.False))
                             GHC.Types.True
                             -> GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y, GHC.Types.True) } })
                    } in
                    k @ Language.Fortran.Variable
                      @ (Language.Fortran.VarName p)
                      Data.Data.$fData[]_$s$fData[]
                      (k @ p
                         @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                         $dData
                         (GHC.Base.return
                            @ m
                            $dMonad
                            @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p,
                               GHC.Types.Bool)
                            (Language.Fortran.$fDataVarName1 @ p))
                           `cast`
                         (Sym (Data.Data.N:Mp[0]
                                   <m>_R
                                   <p
                                    -> Language.Fortran.Variable -> Language.Fortran.VarName p>_N))
                         a1)
                        `cast`
                      (Sym (Data.Data.N:Mp[0]
                                <m>_R <Language.Fortran.Variable -> Language.Fortran.VarName p>_N))
                      a2 })
                   (\ (ds1 :: (Language.Fortran.VarName p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.VarName p)
                           x' } })) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LSLL),U(A,1*U,U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
     Unfolding: (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (m :: * -> *)
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.VarName p) ->
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 let {
                   lvl529 :: m (Language.Fortran.VarName p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.VarName p)
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.VarName p, GHC.Types.Bool)
                   @ (Language.Fortran.VarName p)
                   (case eta of wild { Language.Fortran.VarName a1 a2 ->
                    let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData1 :: Data.Data.Data d)
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl530 :: m d = ds @ d $dData1 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild1 { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl530
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    k @ Language.Fortran.Variable
                      @ (Language.Fortran.VarName p)
                      Data.Data.$fData[]_$s$fData[]
                      (k @ p
                         @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                         $dData
                         (GHC.Base.return
                            @ m
                            $dMonad
                            @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p,
                               GHC.Types.Bool)
                            (Language.Fortran.$fDataVarName1 @ p))
                           `cast`
                         (Sym (Data.Data.N:Mp[0]
                                   <m>_R
                                   <p
                                    -> Language.Fortran.Variable -> Language.Fortran.VarName p>_N))
                         a1)
                        `cast`
                      (Sym (Data.Data.N:Mp[0]
                                <m>_R <Language.Fortran.Variable -> Language.Fortran.VarName p>_N))
                      a2 })
                   (\ (ds1 :: (Language.Fortran.VarName p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl529
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.VarName p)
                           x' } })) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.VarName p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.VarName p) ->
                 case eta of wild { Language.Fortran.VarName a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ p $dData a1)
                   (GHC.Types.:
                      @ u
                      (ds @ Language.Fortran.Variable Data.Data.$fData[]_$s$fData[] a2)
                      (GHC.Types.[] @ u)) }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.VarName p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (eta :: Language.Fortran.VarName p) ->
                 case eta of wild { Language.Fortran.VarName a1 a2 ->
                 case ds of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> ds1 @ p $dData a1
                   1#
                   -> ds1
                        @ Language.Fortran.Variable
                        Data.Data.$fData[]_$s$fData[]
                        a2 } } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.VarName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r -> r' -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (w4 :: Language.Fortran.VarName p) ->
                 case w4 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapQl1 @ p w @ r @ r' w1 w2 w3 ww1 ww2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.VarName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r' -> r -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (w4 :: Language.Fortran.VarName p) ->
                 case w4 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr3 @ p w @ r @ r' w1 w2 w3 ww1 ww2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgmapT ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (eta :: Language.Fortran.VarName p) ->
                 case eta of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName
                   @ p
                   (ds @ p $dData a1)
                   (ds
                      @ Language.Fortran.Variable
                      Data.Data.$fData[]_$s$fData[]
                      a2) }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.VarName p)
  {- Arity: 4, Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      $dData
                      (z @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p)))) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$cp1Data ::
    Data.Data.Data p =>
    Data.Typeable.Internal.Typeable (Language.Fortran.VarName p)
  {- Arity: 1,
     Strictness: <L,1*U(1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ p ($dData :: Data.Data.Data p) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case Language.Fortran.$fDataVarName2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ((Data.Data.$p1Data @ p $dData)
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)
                                 (GHC.Prim.proxy# @ * @ p))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 (\ (wild :: GHC.Prim.Proxy# (Language.Fortran.VarName p)) -> ds)
                   `cast`
                 (Sym (Data.Typeable.Internal.N:Typeable[0]
                           <*>_N <Language.Fortran.VarName p>_N))) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fDataVarName_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.VarName p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData :: Data.Data.Data p)
                   (ds :: Language.Fortran.VarName p) ->
                 case ds of wild { Language.Fortran.VarName ds1 ds2 ->
                 Language.Fortran.$cLUk6nnNjD0l6PtfmFqmXuq }) -}
6a578be33391db91b5fea0db543565f7
  $fEqArg ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fEqArg_$c== @ p $dEq)
                  (Language.Fortran.$fEqArg_$c/= @ p $dEq) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fEqArgList ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fEqArgList_$c== @ p $dEq)
                  (Language.Fortran.$fEqArgList_$c/= @ p $dEq) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fEqArgList_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgList p
    -> Language.Fortran.ArgList p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.ArgList p)
                   (b :: Language.Fortran.ArgList p) ->
                 case Language.Fortran.$fEqArgList_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fEqArgList_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgList p
    -> Language.Fortran.ArgList p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.ArgList p)
                   (w2 :: Language.Fortran.ArgList p) ->
                 case w1 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.ArgList ww4 ww5 ->
                 Language.Fortran.$w$c==2 @ p w ww1 ww2 ww4 ww5 } }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fEqArgName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fEqArg_$c==2 @ p $dEq)
                  (Language.Fortran.$fEqArgName_$c/= @ p $dEq) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fEqArgName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgName p
    -> Language.Fortran.ArgName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.ArgName p)
                   (b :: Language.Fortran.ArgName p) ->
                 case Language.Fortran.$fEqArg_$c==2 @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6a578be33391db91b5fea0db543565f7
  $fEqArg_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Arg p -> Language.Fortran.Arg p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Arg p)
                   (b :: Language.Fortran.Arg p) ->
                 case Language.Fortran.$fEqArg_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6a578be33391db91b5fea0db543565f7
  $fEqArg_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Arg p -> Language.Fortran.Arg p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.Arg p)
                   (w2 :: Language.Fortran.Arg p) ->
                 case w1 of ww { Language.Fortran.Arg ww1 ww2 ww3 ->
                 case w2 of ww4 { Language.Fortran.Arg ww5 ww6 ww7 ->
                 Language.Fortran.$w$c== @ p w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fEqArg_$c==1 ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcLoc)
                   (w1 :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 case w1 of ww4 { Language.Fortran.SrcLoc ww5 ww6 ww7 ->
                 Language.Fortran.$w$c==1 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fEqArg_$c==2 ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgName p
    -> Language.Fortran.ArgName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fEqAttr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fEqAttr_$c== @ p $dEq)
                  (Language.Fortran.$fEqAttr_$c/= @ p $dEq) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fEqAttr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Attr p
    -> Language.Fortran.Attr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Attr p)
                   (b :: Language.Fortran.Attr p) ->
                 case Language.Fortran.$fEqAttr_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fEqAttr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Attr p
    -> Language.Fortran.Attr p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
6b45e4637f33ab3df335753afdb59e8d
  $fEqBaseType ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fEqBaseType_$c== @ p $dEq)
                  (Language.Fortran.$fEqBaseType_$c/= @ p $dEq) -}
6b45e4637f33ab3df335753afdb59e8d
  $fEqBaseType_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.BaseType p
    -> Language.Fortran.BaseType p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.BaseType p)
                   (b :: Language.Fortran.BaseType p) ->
                 case Language.Fortran.$fEqBaseType_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fEqBaseType_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.BaseType p
    -> Language.Fortran.BaseType p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.BaseType p)
                   (ds1 :: Language.Fortran.BaseType p) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Integer b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Real a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Real b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Character a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Character b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.SomeType a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.SomeType b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.DerivedType a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.DerivedType b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqBaseType_$c==1 @ p $dEq a2 b2 } }
                   Language.Fortran.Recursive a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Recursive b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Pure a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Pure b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Elemental a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Elemental b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Logical a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Logical b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Complex a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Complex b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fEqBaseType_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.SubName p
    -> Language.Fortran.SubName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.SubName p)
                   (ds1 :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> case ds1 of wild1 {
                        Language.Fortran.SubName b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 }
                        Language.Fortran.NullSubName ipv -> GHC.Types.False }
                   Language.Fortran.NullSubName a1
                   -> case ds1 of wild1 {
                        Language.Fortran.SubName ipv ipv1 -> GHC.Types.False
                        Language.Fortran.NullSubName b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
e17095ab710540e6e45e7763d42db35f
  $fEqBinOp ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fEqBinOp_$c== @ p $dEq)
                  (Language.Fortran.$fEqBinOp_$c/= @ p $dEq) -}
e17095ab710540e6e45e7763d42db35f
  $fEqBinOp_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.BinOp p
    -> Language.Fortran.BinOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.BinOp p)
                   (b :: Language.Fortran.BinOp p) ->
                 case Language.Fortran.$fEqBinOp_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e17095ab710540e6e45e7763d42db35f
  $fEqBinOp_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.BinOp p
    -> Language.Fortran.BinOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U> -}
00b5dcb26b4d8331f4d0a27afc418872
  $fEqBlock ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fEqBlock_$c== @ p $dEq)
                  (Language.Fortran.$fEqBlock_$c/= @ p $dEq) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fEqBlock_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Block p
    -> Language.Fortran.Block p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Block p)
                   (b :: Language.Fortran.Block p) ->
                 case Language.Fortran.$fEqBlock_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fEqBlock_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Block p
    -> Language.Fortran.Block p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.Block p)
                   (w2 :: Language.Fortran.Block p) ->
                 case w1 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w2 of ww7 { Language.Fortran.Block ww8 ww9 ww10 ww11 ww12 ww13 ->
                 Language.Fortran.$w$c==3
                   @ p
                   w
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13 } }) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fEqBlock_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fortran p
    -> Language.Fortran.Fortran p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
c4465a5758b20b0d6387c4cda8774a94
  $fEqBlock_$c==2 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Decl p
    -> Language.Fortran.Decl p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
ed3a262a18b570752c320c116efb88d0
  $fEqBlock_$c==3 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Implicit p
    -> Language.Fortran.Implicit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Implicit p)
                   (ds1 :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> case ds1 of wild1 {
                        Language.Fortran.ImplicitNone b1 -> GHC.Classes.== @ p $dEq a1 b1
                        Language.Fortran.ImplicitNull ipv -> GHC.Types.False }
                   Language.Fortran.ImplicitNull a1
                   -> case ds1 of wild1 {
                        Language.Fortran.ImplicitNone ipv -> GHC.Types.False
                        Language.Fortran.ImplicitNull b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
22a7293c3f9ba679ea60d591f21568e8
  $fEqBlock_$c==4 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.Uses p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
d489c902c3045b3ed80ef70b739aa9fb
  $fEqDataForm ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fEqDataForm_$c== @ p $dEq)
                  (Language.Fortran.$fEqDataForm_$c/= @ p $dEq) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fEqDataForm_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.DataForm p
    -> Language.Fortran.DataForm p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.DataForm p)
                   (b :: Language.Fortran.DataForm p) ->
                 case Language.Fortran.$fEqDataForm_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fEqDataForm_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.DataForm p
    -> Language.Fortran.DataForm p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Expr p)
                   = Language.Fortran.$fEqExpr @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = GHC.Classes.$fEq(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dEq1
                       $dEq1
                 } in
                 \ (ds :: Language.Fortran.DataForm p)
                   (ds1 :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data a1 a2 ->
                 case ds1 of wild1 { Language.Fortran.Data b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                        $dEq2
                        a2
                        b2 } } }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fEqDecl ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fEqBlock_$c==2 @ p $dEq)
                  (Language.Fortran.$fEqDecl_$c/= @ p $dEq) -}
c4465a5758b20b0d6387c4cda8774a94
  $fEqDecl_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Decl p
    -> Language.Fortran.Decl p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Decl p)
                   (b :: Language.Fortran.Decl p) ->
                 case Language.Fortran.$fEqBlock_$c==2 @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fEqExpr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fEqExpr_$c== @ p $dEq)
                  (Language.Fortran.$fEqExpr_$c/= @ p $dEq) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fEqExpr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Expr p
    -> Language.Fortran.Expr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Expr p)
                   (b :: Language.Fortran.Expr p) ->
                 case Language.Fortran.$fEqExpr_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fEqExpr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Expr p
    -> Language.Fortran.Expr p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
7ef8d1883356542a2e7829f1c3512bc2
  $fEqFortran ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fEqBlock_$c==1 @ p $dEq)
                  (Language.Fortran.$fEqFortran_$c/= @ p $dEq) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fEqFortran_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fortran p
    -> Language.Fortran.Fortran p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Fortran p)
                   (b :: Language.Fortran.Fortran p) ->
                 case Language.Fortran.$fEqBlock_$c==1 @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
53046a0aa1c261e776a228d9d40263ca
  $fEqFraction ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fEqFraction_$c== @ p $dEq)
                  (Language.Fortran.$fEqFraction_$c/= @ p $dEq) -}
53046a0aa1c261e776a228d9d40263ca
  $fEqFraction_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fraction p
    -> Language.Fortran.Fraction p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Fraction p)
                   (b :: Language.Fortran.Fraction p) ->
                 case Language.Fortran.$fEqFraction_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
53046a0aa1c261e776a228d9d40263ca
  $fEqFraction_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fraction p
    -> Language.Fortran.Fraction p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Fraction p)
                   (ds1 :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.IntegerConst b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 } }
                   Language.Fortran.FractionConst a1 a2 a3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.FractionConst b1 b2 b3
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Base.eqString a2 b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> GHC.Base.eqString a3 b3 } } }
                   Language.Fortran.NullFraction a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.NullFraction b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fEqGSpec ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fEqGSpec_$c== @ p $dEq)
                  (Language.Fortran.$fEqGSpec_$c/= @ p $dEq) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fEqGSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.GSpec p
    -> Language.Fortran.GSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.GSpec p)
                   (b :: Language.Fortran.GSpec p) ->
                 case Language.Fortran.$fEqGSpec_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fEqGSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.GSpec p
    -> Language.Fortran.GSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.GSpec p)
                   (ds1 :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GName b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> Language.Fortran.$fEqExpr_$c== @ p $dEq a2 b2 } }
                   Language.Fortran.GOper a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GOper b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqBinOp_$c== @ p $dEq a2 b2 } }
                   Language.Fortran.GAssg a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GAssg b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
ed3a262a18b570752c320c116efb88d0
  $fEqImplicit ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fEqBlock_$c==3 @ p $dEq)
                  (Language.Fortran.$fEqImplicit_$c/= @ p $dEq) -}
ed3a262a18b570752c320c116efb88d0
  $fEqImplicit_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Implicit p
    -> Language.Fortran.Implicit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Implicit p)
                   (b :: Language.Fortran.Implicit p) ->
                 case Language.Fortran.$fEqBlock_$c==3 @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fEqIntentAttr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fEqIntentAttr_$c== @ p $dEq)
                  (Language.Fortran.$fEqIntentAttr_$c/= @ p $dEq) -}
2e224cb3ca4fa18503a4d24170747dce
  $fEqIntentAttr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.IntentAttr p
    -> Language.Fortran.IntentAttr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.IntentAttr p)
                   (b :: Language.Fortran.IntentAttr p) ->
                 case Language.Fortran.$fEqIntentAttr_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fEqIntentAttr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.IntentAttr p
    -> Language.Fortran.IntentAttr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.IntentAttr p)
                   (ds1 :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.In b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Out a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Out b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.InOut a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.InOut b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fEqInterfaceSpec ::
    GHC.Classes.Eq p =>
    GHC.Classes.Eq (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fEqInterfaceSpec_$c== @ p $dEq)
                  (Language.Fortran.$fEqInterfaceSpec_$c/= @ p $dEq) -}
c4465a5758b20b0d6387c4cda8774a94
  $fEqInterfaceSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.InterfaceSpec p)
                   (b :: Language.Fortran.InterfaceSpec p) ->
                 case Language.Fortran.$fEqInterfaceSpec_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fEqInterfaceSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fEqMeasureUnitSpec ::
    GHC.Classes.Eq p =>
    GHC.Classes.Eq (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fEqMeasureUnitSpec_$c== @ p $dEq)
                  (Language.Fortran.$fEqMeasureUnitSpec_$c/= @ p $dEq) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fEqMeasureUnitSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.MeasureUnitSpec p)
                   (b :: Language.Fortran.MeasureUnitSpec p) ->
                 case Language.Fortran.$fEqMeasureUnitSpec_$c==
                        @ p
                        $dEq
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fEqMeasureUnitSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Fraction p)
                   = Language.Fortran.$fEqFraction @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = GHC.Classes.$fEq(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       GHC.Classes.$fEq[]_$s$fEq[]1
                       $dEq1
                 } in
                 \ (ds :: Language.Fortran.MeasureUnitSpec p)
                   (ds1 :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitProduct b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                  $dEq2
                                  a2
                                  b2 } }
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitQuotient b1 b2 b3
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                       $dEq2
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                       $dEq2
                                       a3
                                       b3 } } }
                   Language.Fortran.UnitNone a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitNone b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fEqProgUnit ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fEqProgUnit_$c== @ p $dEq)
                  (Language.Fortran.$fEqProgUnit_$c/= @ p $dEq) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fEqProgUnit_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ProgUnit p
    -> Language.Fortran.ProgUnit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.ProgUnit p)
                   (b :: Language.Fortran.ProgUnit p) ->
                 case Language.Fortran.$fEqProgUnit_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fEqProgUnit_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.ProgUnit p
    -> Language.Fortran.ProgUnit p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fEqSpec ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fEqSpec_$c== @ p $dEq)
                  (Language.Fortran.$fEqSpec_$c/= @ p $dEq) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fEqSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Spec p
    -> Language.Fortran.Spec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Spec p)
                   (b :: Language.Fortran.Spec p) ->
                 case Language.Fortran.$fEqSpec_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fEqSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Spec p
    -> Language.Fortran.Spec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fEqSrcLoc :: GHC.Classes.Eq Language.Fortran.SrcLoc
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fEqArg_$c==1
                  Language.Fortran.$fEqSrcLoc_$c/= -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fEqSrcLoc_$c/= ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Language.Fortran.SrcLoc) (b :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqArg_$c==1 a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fEqSubName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fEqBaseType_$c==1 @ p $dEq)
                  (Language.Fortran.$fEqSubName_$c/= @ p $dEq) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fEqSubName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.SubName p
    -> Language.Fortran.SubName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.SubName p)
                   (b :: Language.Fortran.SubName p) ->
                 case Language.Fortran.$fEqBaseType_$c==1 @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cac90f1d6845827f0c2780e86e10c606
  $fEqType ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fEqType_$c== @ p $dEq)
                  (Language.Fortran.$fEqType_$c/= @ p $dEq) -}
cac90f1d6845827f0c2780e86e10c606
  $fEqType_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Type p
    -> Language.Fortran.Type p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Type p)
                   (b :: Language.Fortran.Type p) ->
                 case Language.Fortran.$fEqType_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cac90f1d6845827f0c2780e86e10c606
  $fEqType_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Type p
    -> Language.Fortran.Type p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   lvl529 :: Language.Fortran.Expr p
                             -> Language.Fortran.Expr p -> GHC.Types.Bool
                   = Language.Fortran.$fEqExpr_$c== @ p $dEq
                 } in
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Expr p)
                   = Language.Fortran.$fEqExpr @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = GHC.Classes.$fEq(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dEq1
                       $dEq1
                 } in
                 let {
                   $dEq3 :: GHC.Classes.Eq (Language.Fortran.Attr p)
                   = Language.Fortran.$fEqAttr @ p $dEq
                 } in
                 \ (ds :: Language.Fortran.Type p)
                   (ds1 :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> case ds1 of wild1 {
                        Language.Fortran.BaseType b1 b2 b3 b4 b5
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case Language.Fortran.$fEqBaseType_$c==
                                       @ p
                                       $dEq
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Classes.$fEq[]_$c==
                                            @ (Language.Fortran.Attr p)
                                            $dEq3
                                            a3
                                            b3 of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case lvl529 a4 b4 of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True -> lvl529 a5 b5 } } } }
                        Language.Fortran.ArrayT ipv ipv1 ipv2 ipv3 ipv4 ipv5
                        -> GHC.Types.False }
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> case ds1 of wild1 {
                        Language.Fortran.BaseType ipv ipv1 ipv2 ipv3 ipv4
                        -> GHC.Types.False
                        Language.Fortran.ArrayT b1 b2 b3 b4 b5 b6
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                                       $dEq2
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case Language.Fortran.$fEqBaseType_$c==
                                            @ p
                                            $dEq
                                            a3
                                            b3 of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case GHC.Classes.$fEq[]_$c==
                                                 @ (Language.Fortran.Attr p)
                                                 $dEq3
                                                 a4
                                                 b4 of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case lvl529 a5 b5 of wild6 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True -> lvl529 a6 b6 } } } } } } }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fEqUnaryOp ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fEqUnaryOp_$c== @ p $dEq)
                  (Language.Fortran.$fEqUnaryOp_$c/= @ p $dEq) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fEqUnaryOp_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.UnaryOp p
    -> Language.Fortran.UnaryOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.UnaryOp p)
                   (b :: Language.Fortran.UnaryOp p) ->
                 case Language.Fortran.$fEqUnaryOp_$c== @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fEqUnaryOp_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.UnaryOp p
    -> Language.Fortran.UnaryOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.UnaryOp p)
                   (ds1 :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1
                   -> case ds1 of wild1 {
                        Language.Fortran.UMinus b1 -> GHC.Classes.== @ p $dEq a1 b1
                        Language.Fortran.Not ipv -> GHC.Types.False }
                   Language.Fortran.Not a1
                   -> case ds1 of wild1 {
                        Language.Fortran.UMinus ipv -> GHC.Types.False
                        Language.Fortran.Not b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
d59de0314bb55c907d315303e8c78677
  $fEqUseBlock ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fEqUseBlock_$c== @ p $dEq)
                  (Language.Fortran.$fEqUseBlock_$c/= @ p $dEq) -}
d59de0314bb55c907d315303e8c78677
  $fEqUseBlock_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.UseBlock p
    -> Language.Fortran.UseBlock p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.UseBlock p)
                   (w2 :: Language.Fortran.UseBlock p) ->
                 case w1 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.UseBlock ww4 ww5 ->
                 Language.Fortran.$w$c/= @ p w ww1 ww2 ww4 ww5 } }) -}
d59de0314bb55c907d315303e8c78677
  $fEqUseBlock_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.UseBlock p
    -> Language.Fortran.UseBlock p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.UseBlock p)
                   (w2 :: Language.Fortran.UseBlock p) ->
                 case w1 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.UseBlock ww4 ww5 ->
                 Language.Fortran.$w$c==4 @ p w ww1 ww2 ww4 ww5 } }) -}
22a7293c3f9ba679ea60d591f21568e8
  $fEqUses ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fEqBlock_$c==4 @ p $dEq)
                  (Language.Fortran.$fEqUses_$c/= @ p $dEq) -}
22a7293c3f9ba679ea60d591f21568e8
  $fEqUses_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.Uses p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (a :: Language.Fortran.Uses p)
                   (b :: Language.Fortran.Uses p) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fEqVarName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dEq :: GHC.Classes.Eq p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fEqVarName_$c== @ p $dEq)
                  (Language.Fortran.$fEqVarName_$c/= @ p $dEq) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fEqVarName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c/=1 @ p w ww1 ww2 ww4 ww5 } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fEqVarName_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c==5 @ p w ww1 ww2 ww4 ww5 } }) -}
6a578be33391db91b5fea0db543565f7
  $fFunctorArg :: GHC.Base.Functor Language.Fortran.Arg
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Arg
                  Language.Fortran.$fFunctorArg_$cfmap1
                  Language.Fortran.$fFunctorArg_$c<$ -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fFunctorArgList :: GHC.Base.Functor Language.Fortran.ArgList
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ArgList
                  Language.Fortran.$fFunctorArgList_$cfmap1
                  Language.Fortran.$fFunctorArgList_$c<$ -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fFunctorArgList_$c<$ ::
    a -> Language.Fortran.ArgList b -> Language.Fortran.ArgList a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.ArgList b) ->
                 case eta1 of wild { Language.Fortran.ArgList a1 a2 ->
                 Language.Fortran.ArgList
                   @ a
                   eta
                   (Language.Fortran.$fFunctorArgList_$cfmap
                      @ b
                      @ a
                      (\ (ds :: b) -> eta)
                      a2) }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fFunctorArgList_$cfmap ::
    (a -> b) -> Language.Fortran.Expr a -> Language.Fortran.Expr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fFunctorArgList_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.ArgList a -> Language.Fortran.ArgList b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Language.Fortran.ArgList a) ->
                 case w1 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 Language.Fortran.ArgList
                   @ b
                   (w ww1)
                   (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b w ww2) }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fFunctorArgName :: GHC.Base.Functor Language.Fortran.ArgName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ArgName
                  Language.Fortran.$fFunctorArg_$cfmap
                  Language.Fortran.$fFunctorArgName_$c<$ -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fFunctorArgName_$c<$ ::
    a -> Language.Fortran.ArgName b -> Language.Fortran.ArgName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.ArgName b) ->
                 Language.Fortran.$fFunctorArg_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
6a578be33391db91b5fea0db543565f7
  $fFunctorArg_$c<$ ::
    a -> Language.Fortran.Arg b -> Language.Fortran.Arg a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Arg b) ->
                 case eta1 of wild { Language.Fortran.Arg a1 a2 a3 ->
                 Language.Fortran.Arg
                   @ a
                   eta
                   (Language.Fortran.$fFunctorArg_$cfmap
                      @ b
                      @ a
                      (\ (ds :: b) -> eta)
                      a2)
                   a3 }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fFunctorArg_$cfmap ::
    (a -> b)
    -> Language.Fortran.ArgName a -> Language.Fortran.ArgName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
6a578be33391db91b5fea0db543565f7
  $fFunctorArg_$cfmap1 ::
    (a -> b) -> Language.Fortran.Arg a -> Language.Fortran.Arg b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Language.Fortran.Arg a) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 Language.Fortran.Arg
                   @ b
                   (f a1)
                   (Language.Fortran.$fFunctorArg_$cfmap @ a @ b f a2)
                   a3 }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fFunctorAttr :: GHC.Base.Functor Language.Fortran.Attr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Attr
                  Language.Fortran.$fFunctorAttr_$cfmap
                  Language.Fortran.$fFunctorAttr_$c<$ -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fFunctorAttr_$c<$ ::
    a -> Language.Fortran.Attr b -> Language.Fortran.Attr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Attr b) ->
                 Language.Fortran.$fFunctorAttr_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fFunctorAttr_$cfmap ::
    (a -> b) -> Language.Fortran.Attr a -> Language.Fortran.Attr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.Attr a) ->
                 case ds of wild {
                   Language.Fortran.Parameter a1
                   -> Language.Fortran.Parameter @ b (f a1)
                   Language.Fortran.Allocatable a1
                   -> Language.Fortran.Allocatable @ b (f a1)
                   Language.Fortran.External a1
                   -> Language.Fortran.External @ b (f a1)
                   Language.Fortran.Intent a1 a2
                   -> Language.Fortran.Intent
                        @ b
                        (f a1)
                        (Language.Fortran.$fFunctorAttr_$cfmap3 @ a @ b f a2)
                   Language.Fortran.Intrinsic a1
                   -> Language.Fortran.Intrinsic @ b (f a1)
                   Language.Fortran.Optional a1
                   -> Language.Fortran.Optional @ b (f a1)
                   Language.Fortran.Pointer a1 -> Language.Fortran.Pointer @ b (f a1)
                   Language.Fortran.Save a1 -> Language.Fortran.Save @ b (f a1)
                   Language.Fortran.Target a1 -> Language.Fortran.Target @ b (f a1)
                   Language.Fortran.Volatile a1
                   -> Language.Fortran.Volatile @ b (f a1)
                   Language.Fortran.Public a1 -> Language.Fortran.Public @ b (f a1)
                   Language.Fortran.Private a1 -> Language.Fortran.Private @ b (f a1)
                   Language.Fortran.Sequence a1
                   -> Language.Fortran.Sequence @ b (f a1)
                   Language.Fortran.Dimension a1 a2
                   -> Language.Fortran.Dimension
                        @ b
                        (f a1)
                        (GHC.Base.map
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                            case b1 of wild1 { (,) a4 a5 ->
                            (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a4,
                             Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a5) })
                           a2)
                   Language.Fortran.MeasureUnit a1 a2
                   -> Language.Fortran.MeasureUnit
                        @ b
                        (f a1)
                        (Language.Fortran.$fFunctorAttr_$cfmap1 @ a @ b f a2) }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fFunctorAttr_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.MeasureUnitSpec a
    -> Language.Fortran.MeasureUnitSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.MeasureUnitSpec a) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> Language.Fortran.UnitProduct
                        @ b
                        (f a1)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b2 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b2 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f a5) })
                           a2)
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> Language.Fortran.UnitQuotient
                        @ b
                        (f a1)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b2 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b2 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f a5) })
                           a2)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f a5) })
                           a3)
                   Language.Fortran.UnitNone a1
                   -> Language.Fortran.UnitNone @ b (f a1) }) -}
53046a0aa1c261e776a228d9d40263ca
  $fFunctorAttr_$cfmap2 ::
    (a -> b)
    -> Language.Fortran.Fraction a -> Language.Fortran.Fraction b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.Fraction a) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst @ b (f a1) a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst @ b (f a1) a2 a3
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ b (f a1) }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fFunctorAttr_$cfmap3 ::
    (a -> b)
    -> Language.Fortran.IntentAttr a -> Language.Fortran.IntentAttr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.IntentAttr a) ->
                 case ds of wild {
                   Language.Fortran.In a1 -> Language.Fortran.In @ b (f a1)
                   Language.Fortran.Out a1 -> Language.Fortran.Out @ b (f a1)
                   Language.Fortran.InOut a1
                   -> Language.Fortran.InOut @ b (f a1) }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fFunctorBaseType :: GHC.Base.Functor Language.Fortran.BaseType
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.BaseType
                  Language.Fortran.$fFunctorBaseType_$cfmap
                  Language.Fortran.$fFunctorBaseType_$c<$ -}
6b45e4637f33ab3df335753afdb59e8d
  $fFunctorBaseType_$c<$ ::
    a -> Language.Fortran.BaseType b -> Language.Fortran.BaseType a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.BaseType b) ->
                 Language.Fortran.$fFunctorBaseType_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
6b45e4637f33ab3df335753afdb59e8d
  $fFunctorBaseType_$cfmap ::
    (a -> b)
    -> Language.Fortran.BaseType a -> Language.Fortran.BaseType b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.BaseType a) ->
                 case ds of wild {
                   Language.Fortran.Integer a1 -> Language.Fortran.Integer @ b (f a1)
                   Language.Fortran.Real a1 -> Language.Fortran.Real @ b (f a1)
                   Language.Fortran.Character a1
                   -> Language.Fortran.Character @ b (f a1)
                   Language.Fortran.SomeType a1
                   -> Language.Fortran.SomeType @ b (f a1)
                   Language.Fortran.DerivedType a1 a2
                   -> Language.Fortran.DerivedType
                        @ b
                        (f a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f a2)
                   Language.Fortran.Recursive a1
                   -> Language.Fortran.Recursive @ b (f a1)
                   Language.Fortran.Pure a1 -> Language.Fortran.Pure @ b (f a1)
                   Language.Fortran.Elemental a1
                   -> Language.Fortran.Elemental @ b (f a1)
                   Language.Fortran.Logical a1 -> Language.Fortran.Logical @ b (f a1)
                   Language.Fortran.Complex a1
                   -> Language.Fortran.Complex @ b (f a1) }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fFunctorBaseType_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.SubName a -> Language.Fortran.SubName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Language.Fortran.SubName a) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> Language.Fortran.SubName @ b (f a1) a2
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ b (f a1) }) -}
e17095ab710540e6e45e7763d42db35f
  $fFunctorBinOp :: GHC.Base.Functor Language.Fortran.BinOp
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.BinOp
                  Language.Fortran.$fFunctorBinOp_$cfmap
                  Language.Fortran.$fFunctorBinOp_$c<$ -}
e17095ab710540e6e45e7763d42db35f
  $fFunctorBinOp_$c<$ ::
    a -> Language.Fortran.BinOp b -> Language.Fortran.BinOp a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.BinOp b) ->
                 Language.Fortran.$fFunctorBinOp_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b)[OneShot] -> eta)
                   eta1) -}
e17095ab710540e6e45e7763d42db35f
  $fFunctorBinOp_$cfmap ::
    (a -> b) -> Language.Fortran.BinOp a -> Language.Fortran.BinOp b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.BinOp a) ->
                 case ds of wild {
                   Language.Fortran.Plus a1 -> Language.Fortran.Plus @ b (f a1)
                   Language.Fortran.Minus a1 -> Language.Fortran.Minus @ b (f a1)
                   Language.Fortran.Mul a1 -> Language.Fortran.Mul @ b (f a1)
                   Language.Fortran.Div a1 -> Language.Fortran.Div @ b (f a1)
                   Language.Fortran.Or a1 -> Language.Fortran.Or @ b (f a1)
                   Language.Fortran.And a1 -> Language.Fortran.And @ b (f a1)
                   Language.Fortran.Concat a1 -> Language.Fortran.Concat @ b (f a1)
                   Language.Fortran.Power a1 -> Language.Fortran.Power @ b (f a1)
                   Language.Fortran.RelEQ a1 -> Language.Fortran.RelEQ @ b (f a1)
                   Language.Fortran.RelNE a1 -> Language.Fortran.RelNE @ b (f a1)
                   Language.Fortran.RelLT a1 -> Language.Fortran.RelLT @ b (f a1)
                   Language.Fortran.RelLE a1 -> Language.Fortran.RelLE @ b (f a1)
                   Language.Fortran.RelGT a1 -> Language.Fortran.RelGT @ b (f a1)
                   Language.Fortran.RelGE a1
                   -> Language.Fortran.RelGE @ b (f a1) }) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fFunctorBlock :: GHC.Base.Functor Language.Fortran.Block
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Block
                  Language.Fortran.$fFunctorBlock_$cfmap3
                  Language.Fortran.$fFunctorBlock_$c<$ -}
00b5dcb26b4d8331f4d0a27afc418872
  $fFunctorBlock_$c<$ ::
    a -> Language.Fortran.Block b -> Language.Fortran.Block a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S,1*U(A,1*U(1*U,U),1*U,U,1*U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w1 :: Language.Fortran.Block b) ->
                 case w1 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 let {
                   f :: b -> a
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True) (\ (ds :: b) -> w) -}
                   = \ (ds :: b) -> w
                 } in
                 Language.Fortran.Block
                   @ a
                   w
                   (case ww2 of wild { Language.Fortran.UseBlock a1 a2 ->
                    Language.Fortran.UseBlock
                      @ a
                      (Language.Fortran.$fFunctorBlock_$cfmap2 @ b @ a f a1)
                      a2 })
                   (case ww3 of wild {
                      Language.Fortran.ImplicitNone a1
                      -> Language.Fortran.ImplicitNone @ a w
                      Language.Fortran.ImplicitNull a1
                      -> Language.Fortran.ImplicitNull @ a w })
                   ww4
                   (Language.Fortran.$fFunctorBlock_$cfmap1 @ b @ a f ww5)
                   (Language.Fortran.$fFunctorBlock_$cfmap @ b @ a f ww6) }) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fFunctorBlock_$cfmap ::
    (a -> b)
    -> Language.Fortran.Fortran a -> Language.Fortran.Fortran b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
c4465a5758b20b0d6387c4cda8774a94
  $fFunctorBlock_$cfmap1 ::
    (a -> b) -> Language.Fortran.Decl a -> Language.Fortran.Decl b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
22a7293c3f9ba679ea60d591f21568e8
  $fFunctorBlock_$cfmap2 ::
    (a -> b) -> Language.Fortran.Uses a -> Language.Fortran.Uses b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
00b5dcb26b4d8331f4d0a27afc418872
  $fFunctorBlock_$cfmap3 ::
    (a -> b) -> Language.Fortran.Block a -> Language.Fortran.Block b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S,1*U(U,1*U(1*U,U),1*U,U,1*U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Language.Fortran.Block a) ->
                 case w1 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Language.Fortran.Block
                   @ b
                   (w ww1)
                   (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b w ww2)
                   (Language.Fortran.$fFunctorBlock_$cfmap4 @ a @ b w ww3)
                   ww4
                   (Language.Fortran.$fFunctorBlock_$cfmap1 @ a @ b w ww5)
                   (Language.Fortran.$fFunctorBlock_$cfmap @ a @ b w ww6) }) -}
ed3a262a18b570752c320c116efb88d0
  $fFunctorBlock_$cfmap4 ::
    (a -> b)
    -> Language.Fortran.Implicit a -> Language.Fortran.Implicit b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Language.Fortran.Implicit a) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ b (f a1)
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ b (f a1) }) -}
d59de0314bb55c907d315303e8c78677
  $fFunctorBlock_$cfmap5 ::
    (a -> b)
    -> Language.Fortran.UseBlock a -> Language.Fortran.UseBlock b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Language.Fortran.UseBlock a) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ b
                   (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b f a1)
                   a2 }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fFunctorDataForm :: GHC.Base.Functor Language.Fortran.DataForm
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.DataForm
                  Language.Fortran.$fFunctorDataForm_$cfmap
                  Language.Fortran.$fFunctorDataForm_$c<$ -}
d489c902c3045b3ed80ef70b739aa9fb
  $fFunctorDataForm_$c<$ ::
    a -> Language.Fortran.DataForm b -> Language.Fortran.DataForm a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w1 :: Language.Fortran.DataForm b) ->
                 case w1 of ww { Language.Fortran.Data ww1 ww2 ->
                 case Language.Fortran.$w$c<$
                        @ a
                        @ b
                        w
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 Language.Fortran.Data @ a ww4 ww5 } }) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fFunctorDataForm_$cfmap ::
    (a -> b)
    -> Language.Fortran.DataForm a -> Language.Fortran.DataForm b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Language.Fortran.DataForm a) ->
                 case w1 of ww { Language.Fortran.Data ww1 ww2 ->
                 Language.Fortran.Data
                   @ b
                   (w ww1)
                   (GHC.Base.map
                      @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                      @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                      (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                       case b1 of wild { (,) a1 a2 ->
                       (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b w a1,
                        Language.Fortran.$fFunctorArgList_$cfmap @ a @ b w a2) })
                      ww2) }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fFunctorDecl :: GHC.Base.Functor Language.Fortran.Decl
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Decl
                  Language.Fortran.$fFunctorBlock_$cfmap1
                  Language.Fortran.$fFunctorDecl_$c<$ -}
c4465a5758b20b0d6387c4cda8774a94
  $fFunctorDecl_$c<$ ::
    a -> Language.Fortran.Decl b -> Language.Fortran.Decl a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Decl b) ->
                 Language.Fortran.$fFunctorBlock_$cfmap1
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fFunctorExpr :: GHC.Base.Functor Language.Fortran.Expr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Expr
                  Language.Fortran.$fFunctorArgList_$cfmap
                  Language.Fortran.$fFunctorExpr_$c<$ -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fFunctorExpr_$c<$ ::
    a -> Language.Fortran.Expr b -> Language.Fortran.Expr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Expr b) ->
                 Language.Fortran.$fFunctorArgList_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fFunctorFortran :: GHC.Base.Functor Language.Fortran.Fortran
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Fortran
                  Language.Fortran.$fFunctorBlock_$cfmap
                  Language.Fortran.$fFunctorFortran_$c<$ -}
7ef8d1883356542a2e7829f1c3512bc2
  $fFunctorFortran_$c<$ ::
    a -> Language.Fortran.Fortran b -> Language.Fortran.Fortran a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Fortran b) ->
                 Language.Fortran.$fFunctorBlock_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
53046a0aa1c261e776a228d9d40263ca
  $fFunctorFraction :: GHC.Base.Functor Language.Fortran.Fraction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Fraction
                  Language.Fortran.$fFunctorAttr_$cfmap2
                  Language.Fortran.$fFunctorFraction_$c<$ -}
53046a0aa1c261e776a228d9d40263ca
  $fFunctorFraction_$c<$ ::
    a -> Language.Fortran.Fraction b -> Language.Fortran.Fraction a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Fraction b) ->
                 case eta1 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst @ a eta a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst @ a eta a2 a3
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ a eta }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fFunctorGSpec :: GHC.Base.Functor Language.Fortran.GSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.GSpec
                  Language.Fortran.$fFunctorGSpec_$cfmap
                  Language.Fortran.$fFunctorGSpec_$c<$ -}
573851d0f4eec5dd746d11fb7a0852b2
  $fFunctorGSpec_$c<$ ::
    a -> Language.Fortran.GSpec b -> Language.Fortran.GSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Language.Fortran.GSpec b) ->
                 let {
                   f :: b -> a
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True) (\ (ds :: b) -> eta) -}
                   = \ (ds :: b) -> eta
                 } in
                 case eta1 of wild {
                   Language.Fortran.GName a1 a2
                   -> Language.Fortran.GName
                        @ a
                        eta
                        (Language.Fortran.$fFunctorArgList_$cfmap @ b @ a f a2)
                   Language.Fortran.GOper a1 a2
                   -> Language.Fortran.GOper
                        @ a
                        eta
                        (Language.Fortran.$fFunctorBinOp_$cfmap @ b @ a f a2)
                   Language.Fortran.GAssg a1 -> Language.Fortran.GAssg @ a eta }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fFunctorGSpec_$cfmap ::
    (a -> b) -> Language.Fortran.GSpec a -> Language.Fortran.GSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.GSpec a) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> Language.Fortran.GName
                        @ b
                        (f a1)
                        (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a2)
                   Language.Fortran.GOper a1 a2
                   -> Language.Fortran.GOper
                        @ b
                        (f a1)
                        (Language.Fortran.$fFunctorBinOp_$cfmap @ a @ b f a2)
                   Language.Fortran.GAssg a1
                   -> Language.Fortran.GAssg @ b (f a1) }) -}
ed3a262a18b570752c320c116efb88d0
  $fFunctorImplicit :: GHC.Base.Functor Language.Fortran.Implicit
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Implicit
                  Language.Fortran.$fFunctorBlock_$cfmap4
                  Language.Fortran.$fFunctorImplicit_$c<$ -}
ed3a262a18b570752c320c116efb88d0
  $fFunctorImplicit_$c<$ ::
    a -> Language.Fortran.Implicit b -> Language.Fortran.Implicit a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Implicit b) ->
                 case eta1 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ a eta
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ a eta }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fFunctorIntentAttr :: GHC.Base.Functor Language.Fortran.IntentAttr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.IntentAttr
                  Language.Fortran.$fFunctorAttr_$cfmap3
                  Language.Fortran.$fFunctorIntentAttr_$c<$ -}
2e224cb3ca4fa18503a4d24170747dce
  $fFunctorIntentAttr_$c<$ ::
    a -> Language.Fortran.IntentAttr b -> Language.Fortran.IntentAttr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.IntentAttr b) ->
                 case eta1 of wild {
                   Language.Fortran.In a1 -> Language.Fortran.In @ a eta
                   Language.Fortran.Out a1 -> Language.Fortran.Out @ a eta
                   Language.Fortran.InOut a1 -> Language.Fortran.InOut @ a eta }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fFunctorInterfaceSpec ::
    GHC.Base.Functor Language.Fortran.InterfaceSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.InterfaceSpec
                  Language.Fortran.$fFunctorInterfaceSpec_$cfmap
                  Language.Fortran.$fFunctorInterfaceSpec_$c<$ -}
c4465a5758b20b0d6387c4cda8774a94
  $fFunctorInterfaceSpec_$c<$ ::
    a
    -> Language.Fortran.InterfaceSpec b
    -> Language.Fortran.InterfaceSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.InterfaceSpec b) ->
                 Language.Fortran.$fFunctorInterfaceSpec_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
c4465a5758b20b0d6387c4cda8774a94
  $fFunctorInterfaceSpec_$cfmap ::
    (a -> b)
    -> Language.Fortran.InterfaceSpec a
    -> Language.Fortran.InterfaceSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fFunctorMeasureUnitSpec ::
    GHC.Base.Functor Language.Fortran.MeasureUnitSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.MeasureUnitSpec
                  Language.Fortran.$fFunctorAttr_$cfmap1
                  Language.Fortran.$fFunctorMeasureUnitSpec_$c<$ -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fFunctorMeasureUnitSpec_$c<$ ::
    a
    -> Language.Fortran.MeasureUnitSpec b
    -> Language.Fortran.MeasureUnitSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Language.Fortran.MeasureUnitSpec b) ->
                 Language.Fortran.$fFunctorAttr_$cfmap1
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fFunctorProgUnit :: GHC.Base.Functor Language.Fortran.ProgUnit
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ProgUnit
                  Language.Fortran.$fFunctorProgUnit_$cfmap
                  Language.Fortran.$fFunctorProgUnit_$c<$ -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fFunctorProgUnit_$c<$ ::
    a -> Language.Fortran.ProgUnit b -> Language.Fortran.ProgUnit a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.ProgUnit b) ->
                 Language.Fortran.$fFunctorProgUnit_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fFunctorProgUnit_$cfmap ::
    (a -> b)
    -> Language.Fortran.ProgUnit a -> Language.Fortran.ProgUnit b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fFunctorSpec :: GHC.Base.Functor Language.Fortran.Spec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Spec
                  Language.Fortran.$fFunctorSpec_$cfmap
                  Language.Fortran.$fFunctorSpec_$c<$ -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fFunctorSpec_$c<$ ::
    a -> Language.Fortran.Spec b -> Language.Fortran.Spec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Spec b) ->
                 Language.Fortran.$fFunctorSpec_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fFunctorSpec_$cfmap ::
    (a -> b) -> Language.Fortran.Spec a -> Language.Fortran.Spec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fFunctorSubName :: GHC.Base.Functor Language.Fortran.SubName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SubName
                  Language.Fortran.$fFunctorBaseType_$cfmap1
                  Language.Fortran.$fFunctorSubName_$c<$ -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fFunctorSubName_$c<$ ::
    a -> Language.Fortran.SubName b -> Language.Fortran.SubName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.SubName b) ->
                 case eta1 of wild {
                   Language.Fortran.SubName a1 a2
                   -> Language.Fortran.SubName @ a eta a2
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ a eta }) -}
cac90f1d6845827f0c2780e86e10c606
  $fFunctorType :: GHC.Base.Functor Language.Fortran.Type
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Type
                  Language.Fortran.$fFunctorType_$cfmap
                  Language.Fortran.$fFunctorType_$c<$ -}
cac90f1d6845827f0c2780e86e10c606
  $fFunctorType_$c<$ ::
    a -> Language.Fortran.Type b -> Language.Fortran.Type a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Type b) ->
                 Language.Fortran.$fFunctorType_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
cac90f1d6845827f0c2780e86e10c606
  $fFunctorType_$cfmap ::
    (a -> b) -> Language.Fortran.Type a -> Language.Fortran.Type b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Language.Fortran.Type a) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> Language.Fortran.BaseType
                        @ b
                        (f a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap @ a @ b f a2)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr a)
                           @ (Language.Fortran.Attr b)
                           (Language.Fortran.$fFunctorAttr_$cfmap @ a @ b f)
                           a3)
                        (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a4)
                        (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a5)
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.ArrayT
                        @ b
                        (f a1)
                        (GHC.Base.map
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                            case b1 of wild1 { (,) a7 a8 ->
                            (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a7,
                             Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a8) })
                           a2)
                        (Language.Fortran.$fFunctorBaseType_$cfmap @ a @ b f a3)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr a)
                           @ (Language.Fortran.Attr b)
                           (Language.Fortran.$fFunctorAttr_$cfmap @ a @ b f)
                           a4)
                        (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a5)
                        (Language.Fortran.$fFunctorArgList_$cfmap @ a @ b f a6) }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fFunctorUnaryOp :: GHC.Base.Functor Language.Fortran.UnaryOp
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.UnaryOp
                  Language.Fortran.$fFunctorUnaryOp_$cfmap
                  Language.Fortran.$fFunctorUnaryOp_$c<$ -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fFunctorUnaryOp_$c<$ ::
    a -> Language.Fortran.UnaryOp b -> Language.Fortran.UnaryOp a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.UnaryOp b) ->
                 case eta1 of wild {
                   Language.Fortran.UMinus a1 -> Language.Fortran.UMinus @ a eta
                   Language.Fortran.Not a1 -> Language.Fortran.Not @ a eta }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fFunctorUnaryOp_$cfmap ::
    (a -> b)
    -> Language.Fortran.UnaryOp a -> Language.Fortran.UnaryOp b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Language.Fortran.UnaryOp a) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1 -> Language.Fortran.UMinus @ b (f a1)
                   Language.Fortran.Not a1 -> Language.Fortran.Not @ b (f a1) }) -}
d59de0314bb55c907d315303e8c78677
  $fFunctorUseBlock :: GHC.Base.Functor Language.Fortran.UseBlock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.UseBlock
                  Language.Fortran.$fFunctorBlock_$cfmap5
                  Language.Fortran.$fFunctorUseBlock_$c<$ -}
d59de0314bb55c907d315303e8c78677
  $fFunctorUseBlock_$c<$ ::
    a -> Language.Fortran.UseBlock b -> Language.Fortran.UseBlock a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.UseBlock b) ->
                 case eta1 of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ a
                   (Language.Fortran.$fFunctorBlock_$cfmap2
                      @ b
                      @ a
                      (\ (ds :: b) -> eta)
                      a1)
                   a2 }) -}
22a7293c3f9ba679ea60d591f21568e8
  $fFunctorUses :: GHC.Base.Functor Language.Fortran.Uses
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Uses
                  Language.Fortran.$fFunctorBlock_$cfmap2
                  Language.Fortran.$fFunctorUses_$c<$ -}
22a7293c3f9ba679ea60d591f21568e8
  $fFunctorUses_$c<$ ::
    a -> Language.Fortran.Uses b -> Language.Fortran.Uses a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Language.Fortran.Uses b) ->
                 Language.Fortran.$fFunctorBlock_$cfmap2
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fFunctorVarName :: GHC.Base.Functor Language.Fortran.VarName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.VarName
                  Language.Fortran.$fFunctorVarName_$cfmap
                  Language.Fortran.$fFunctorVarName_$c<$ -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fFunctorVarName_$c<$ ::
    a -> Language.Fortran.VarName b -> Language.Fortran.VarName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (ds :: Language.Fortran.VarName b) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName @ a eta a2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fFunctorVarName_$cfmap ::
    (a -> b)
    -> Language.Fortran.VarName a -> Language.Fortran.VarName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Language.Fortran.VarName a) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName @ b (f a1) a2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName ::
    GHC.Classes.Ord p => GHC.Classes.Ord (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dOrd :: GHC.Classes.Ord p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fOrdVarName_$cp1Ord @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$ccompare @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$c< @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$c<= @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$c> @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$c>= @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$cmax @ p $dOrd)
                  (Language.Fortran.$fOrdVarName_$cmin @ p $dOrd) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$c< ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c< @ p w ww1 ww2 ww4 ww5 } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$c<= ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c<= @ p w ww1 ww2 ww4 ww5 } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$c> ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c> @ p w ww1 ww2 ww4 ww5 } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$c>= ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c>= @ p w ww1 ww2 ww4 ww5 } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$ccompare ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$ccompare @ p w ww1 ww2 ww4 ww5 } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$cmax ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.compare @ p w ww1 ww4 of wild {
                   GHC.Types.LT -> Language.Fortran.VarName @ p ww4 ww5
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww2 ww5 of wild1 {
                        DEFAULT -> Language.Fortran.VarName @ p ww4 ww5
                        GHC.Types.GT -> Language.Fortran.VarName @ p ww1 ww2 }
                   GHC.Types.GT -> Language.Fortran.VarName @ p ww1 ww2 } } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$cmin ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w1 :: Language.Fortran.VarName p)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.compare @ p w ww1 ww4 of wild {
                   GHC.Types.LT -> Language.Fortran.VarName @ p ww1 ww2
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww2 ww5 of wild1 {
                        DEFAULT -> Language.Fortran.VarName @ p ww1 ww2
                        GHC.Types.GT -> Language.Fortran.VarName @ p ww4 ww5 }
                   GHC.Types.GT -> Language.Fortran.VarName @ p ww4 ww5 } } }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fOrdVarName_$cp1Ord ::
    GHC.Classes.Ord p => GHC.Classes.Eq (Language.Fortran.VarName p)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dOrd :: GHC.Classes.Ord p) ->
                 Language.Fortran.$fEqVarName @ p (GHC.Classes.$p1Ord @ p $dOrd)) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName ::
    GHC.Read.Read p => GHC.Read.Read (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dRead :: GHC.Read.Read p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fReadVarName_$creadsPrec @ p $dRead)
                  (Language.Fortran.$fReadVarName_$creadList @ p $dRead)
                  (Language.Fortran.$fReadVarName_$creadPrec @ p $dRead)
                  (Language.Fortran.$fReadVarName_$creadListPrec @ p $dRead) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName1 ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Language.Fortran.VarName p] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dRead :: GHC.Read.Read p)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Language.Fortran.VarName p]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.list1
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fReadVarName2 @ p $dRead)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Language.Fortran.VarName p>_R))
                   eta
                   @ b
                   eta1) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName2 ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (Language.Fortran.VarName p)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: (\ @ p
                   ($dRead :: GHC.Read.Read p)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec) ->
                 GHC.Read.parens1
                   @ (Language.Fortran.VarName p)
                   (let {
                      ds :: Text.ParserCombinators.ReadPrec.ReadPrec p
                      = GHC.Read.readPrec @ p $dRead
                    } in
                    (\ (c :: Text.ParserCombinators.ReadPrec.Prec)
                       @ b
                       (eta1 :: Language.Fortran.VarName p
                                -> Text.ParserCombinators.ReadP.P b) ->
                     case c of wild { GHC.Types.I# x ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10#) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl529 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl530 :: Text.ParserCombinators.ReadP.P b
                                = (ds `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <p>_R)
                                     Language.Fortran.$fReadVarName3)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.N:ReadP[0] <p>_R)
                                    @ b
                                    (\ (a1 :: p) ->
                                     GHC.Read.$fReadChar2
                                       Language.Fortran.$fReadVarName3
                                       @ b
                                       (\ (a2 :: Language.Fortran.Variable) ->
                                        eta1 (Language.Fortran.VarName @ p a1 a2)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                 case a1 of wild1 {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a2
                                   -> case GHC.Base.eqString
                                             a2
                                             Language.Fortran.$fDataVarName6 of wild3 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl530 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl529) -}
                            = \ (w4 :: ()) -> lvl529
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ (a :: GHC.Base.String) ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                               `cast`
                             (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                               @ b
                               k) } })
                      `cast`
                    (Trans
                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <Language.Fortran.VarName p>_R))
                         (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <Language.Fortran.VarName p>_R))))
                   eta) -}
0ca00d52484814469a87e8bb916fe9b5
  $fReadVarName3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName_$creadList ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadP.ReadS [Language.Fortran.VarName p]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Language.Fortran.VarName p]
                   (GHC.Read.list1
                      @ (Language.Fortran.VarName p)
                      (Language.Fortran.$fReadVarName2 @ p $dRead)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                <Language.Fortran.VarName p>_R))
                      GHC.Read.$fRead()5
                      @ [Language.Fortran.VarName p]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Language.Fortran.VarName p]))) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName_$creadListPrec ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Language.Fortran.VarName p]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fReadVarName1
                  `cast`
                (forall (p :: <*>_N).
                 <GHC.Read.Read p>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                         <[Language.Fortran.VarName p]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                    <[Language.Fortran.VarName p]>_R))) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName_$creadPrec ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (Language.Fortran.VarName p)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Language.Fortran.$fReadVarName2
                  `cast`
                (forall (p :: <*>_N).
                 <GHC.Read.Read p>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <Language.Fortran.VarName p>_R)) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fReadVarName_$creadsPrec ::
    GHC.Read.Read p =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (Language.Fortran.VarName p)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Language.Fortran.VarName p)
                   ((Language.Fortran.$fReadVarName2 @ p $dRead eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Language.Fortran.VarName p>_R)
                      @ (Language.Fortran.VarName p)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Language.Fortran.VarName p)))) -}
6a578be33391db91b5fea0db543565f7
  $fShowArg ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fShowArg_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowArg_$cshow @ p $dShow)
                  (Language.Fortran.$fShowArg_$cshowList @ p $dShow) -}
cd334bda4c8bfc3be1f77f485bc09a10
  $fShowArg1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Arg "#) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowArgList ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fShowArgList_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowArgList_$cshow @ p $dShow)
                  (Language.Fortran.$fShowArgList_$cshowList @ p $dShow) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowArgList_$cshow ::
    GHC.Show.Show p => Language.Fortran.ArgList p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ArgList p) ->
                 Language.Fortran.$fShowArgList_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowArgList_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ArgList p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.ArgList p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ArgList p)
                   (Language.Fortran.$fShowArgList_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowArgList_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ArgList p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.ArgList p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.ArgList ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec2 @ p w ww1 ww3 ww4 } }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fShowArgName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fShowArgName_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowArgName_$cshow @ p $dShow)
                  (Language.Fortran.$fShowArgName_$cshowList @ p $dShow) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fShowArgName_$cshow ::
    GHC.Show.Show p => Language.Fortran.ArgName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ArgName p) ->
                 Language.Fortran.$fShowArgName_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fShowArgName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ArgName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.ArgName p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ArgName p)
                   (Language.Fortran.$fShowArgName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $fShowArgName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ArgName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.ArgName p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec1 @ p w ww1 w2 }) -}
6a578be33391db91b5fea0db543565f7
  $fShowArg_$cshow ::
    GHC.Show.Show p => Language.Fortran.Arg p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U,1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p ($dShow :: GHC.Show.Show p) (x :: Language.Fortran.Arg p) ->
                 Language.Fortran.$fShowArg_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6a578be33391db91b5fea0db543565f7
  $fShowArg_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Arg p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Arg p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fShowArg_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
6a578be33391db91b5fea0db543565f7
  $fShowArg_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Arg p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Arg p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.Arg ww3 ww4 ww5 ->
                 Language.Fortran.$w$cshowsPrec @ p w ww1 ww3 ww4 ww5 } }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fShowAttr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fShowAttr_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowAttr_$cshow @ p $dShow)
                  (Language.Fortran.$fShowAttr_$cshowList @ p $dShow) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fShowAttr_$cshow ::
    GHC.Show.Show p => Language.Fortran.Attr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Attr p) ->
                 Language.Fortran.$fShowAttr_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fShowAttr_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Attr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Attr p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fShowAttr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $fShowAttr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Attr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Attr p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec3 @ p w ww1 w2 }) -}
6b45e4637f33ab3df335753afdb59e8d
  $fShowBaseType ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fShowBaseType_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowBaseType_$cshow @ p $dShow)
                  (Language.Fortran.$fShowBaseType_$cshowList @ p $dShow) -}
6b45e4637f33ab3df335753afdb59e8d
  $fShowBaseType_$cshow ::
    GHC.Show.Show p => Language.Fortran.BaseType p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$fShowBaseType_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6b45e4637f33ab3df335753afdb59e8d
  $fShowBaseType_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.BaseType p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.BaseType p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fShowBaseType_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
6b45e4637f33ab3df335753afdb59e8d
  $fShowBaseType_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.BaseType p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.BaseType p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec4 @ p w ww1 w2 }) -}
e17095ab710540e6e45e7763d42db35f
  $fShowBinOp ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fShowBinOp_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowBinOp_$cshow @ p $dShow)
                  (Language.Fortran.$fShowBinOp_$cshowList @ p $dShow) -}
e17095ab710540e6e45e7763d42db35f
  $fShowBinOp_$cshow ::
    GHC.Show.Show p => Language.Fortran.BinOp p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fShowBinOp_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e17095ab710540e6e45e7763d42db35f
  $fShowBinOp_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.BinOp p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.BinOp p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fShowBinOp_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
e17095ab710540e6e45e7763d42db35f
  $fShowBinOp_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.BinOp p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.BinOp p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec5 @ p w ww1 w2 }) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fShowBlock ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowBlock_$cshow @ p $dShow)
                  (Language.Fortran.$fShowBlock_$cshowList @ p $dShow) -}
294fd775f7e1fb995bea6fcdb4aa1c1b
  $fShowBlock1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Block "#) -}
62474fc108ccbea68a7d77fcc65624bd
  $fShowBlock2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ImplicitNull "#) -}
bb0b41ec8916c165d0a36f35bd8953c0
  $fShowBlock3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ImplicitNone "#) -}
6a81e3caf8b9b2185d9af87224ae4665
  $fShowBlock4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UseBlock "#) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fShowBlock_$cshow ::
    GHC.Show.Show p => Language.Fortran.Block p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U,1*U(1*U,U(U,U(U),U(U))),1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))),U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Block p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fShowBlock_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Block p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Block p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
00b5dcb26b4d8331f4d0a27afc418872
  $fShowBlock_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Block p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,1*U(1*U,U(U,U(U),U(U))),1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))),U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Block p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.Block ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Language.Fortran.$w$cshowsPrec6
                   @ p
                   w
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8 } }) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fShowBlock_$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Fortran p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)> -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowBlock_$cshowsPrec2 ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Decl p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)> -}
d489c902c3045b3ed80ef70b739aa9fb
  $fShowDataForm ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fShowDataForm_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowDataForm_$cshow @ p $dShow)
                  (Language.Fortran.$fShowDataForm_$cshowList @ p $dShow) -}
5659bc3cdc82bd8e1bb331054dded520
  $fShowDataForm1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Data "#) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fShowDataForm_$cshow ::
    GHC.Show.Show p => Language.Fortran.DataForm p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$fShowDataForm_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fShowDataForm_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.DataForm p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.DataForm p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fShowDataForm_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
d489c902c3045b3ed80ef70b739aa9fb
  $fShowDataForm_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.DataForm p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.DataForm p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.Data ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec10 @ p w ww1 ww3 ww4 } }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowDecl ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec2 @ p $dShow)
                  (Language.Fortran.$fShowDecl_$cshow @ p $dShow)
                  (Language.Fortran.$fShowDecl_$cshowList @ p $dShow) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowDecl_$cshow ::
    GHC.Show.Show p => Language.Fortran.Decl p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Decl p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec2
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowDecl_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Decl p] -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dShow :: GHC.Show.Show p) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Decl p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec2
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowExpr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fShowExpr_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowExpr_$cshow @ p $dShow)
                  (Language.Fortran.$fShowExpr_$cshowList @ p $dShow) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowExpr_$cshow ::
    GHC.Show.Show p => Language.Fortran.Expr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Expr p) ->
                 Language.Fortran.$fShowExpr_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowExpr_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Expr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Expr p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fShowExpr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $fShowExpr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Expr p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec11 @ p w ww1 w2 }) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fShowFortran ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec1 @ p $dShow)
                  (Language.Fortran.$fShowFortran_$cshow @ p $dShow)
                  (Language.Fortran.$fShowFortran_$cshowList @ p $dShow) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fShowFortran_$cshow ::
    GHC.Show.Show p => Language.Fortran.Fortran p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec1
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7ef8d1883356542a2e7829f1c3512bc2
  $fShowFortran_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Fortran p] -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dShow :: GHC.Show.Show p) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec1
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)) -}
53046a0aa1c261e776a228d9d40263ca
  $fShowFraction ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fShowFraction_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowFraction_$cshow @ p $dShow)
                  (Language.Fortran.$fShowFraction_$cshowList @ p $dShow) -}
0657292ec9f14cefe1386c2de5202bc6
  $fShowFraction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NullFraction "#) -}
315862f15c05e3197153fb8ca79e2362
  $fShowFraction2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FractionConst "#) -}
273d692fd4e62a47601af924505e3a55
  $fShowFraction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IntegerConst "#) -}
53046a0aa1c261e776a228d9d40263ca
  $fShowFraction_$cshow ::
    GHC.Show.Show p => Language.Fortran.Fraction p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Fraction p) ->
                 Language.Fortran.$fShowFraction_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
53046a0aa1c261e776a228d9d40263ca
  $fShowFraction_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Fraction p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Fraction p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Fraction p)
                   (Language.Fortran.$fShowFraction_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
53046a0aa1c261e776a228d9d40263ca
  $fShowFraction_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Fraction p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Fraction p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec12 @ p w ww1 w2 }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fShowGSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fShowGSpec_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowGSpec_$cshow @ p $dShow)
                  (Language.Fortran.$fShowGSpec_$cshowList @ p $dShow) -}
617424ab945521e314dfc7865017e9dd
  $fShowGSpec1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GAssg "#) -}
5f990291847db97b9d9a7e7b974fea54
  $fShowGSpec2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GOper "#) -}
0d4b70c21a710ee2f66e48905210bfea
  $fShowGSpec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GName "#) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fShowGSpec_$cshow ::
    GHC.Show.Show p => Language.Fortran.GSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$fShowGSpec_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fShowGSpec_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.GSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.GSpec p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fShowGSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
573851d0f4eec5dd746d11fb7a0852b2
  $fShowGSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.GSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.GSpec p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec13 @ p w ww1 w2 }) -}
ed3a262a18b570752c320c116efb88d0
  $fShowImplicit ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fShowImplicit_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowImplicit_$cshow @ p $dShow)
                  (Language.Fortran.$fShowImplicit_$cshowList @ p $dShow) -}
ed3a262a18b570752c320c116efb88d0
  $fShowImplicit_$cshow ::
    GHC.Show.Show p => Language.Fortran.Implicit p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Implicit p) ->
                 case x of wild {
                   Language.Fortran.ImplicitNone b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowBlock3
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.ImplicitNull b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowBlock2
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
ed3a262a18b570752c320c116efb88d0
  $fShowImplicit_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Implicit p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Implicit p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Implicit p)
                   (Language.Fortran.$fShowImplicit_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
ed3a262a18b570752c320c116efb88d0
  $fShowImplicit_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Implicit p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Implicit p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec7 @ p w ww1 w2 }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fShowIntentAttr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fShowIntentAttr_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowIntentAttr_$cshow @ p $dShow)
                  (Language.Fortran.$fShowIntentAttr_$cshowList @ p $dShow) -}
ba717aeb48350191400f28bcc6ec4480
  $fShowIntentAttr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "InOut "#) -}
aab1e3076c0f67d2e588d0dab2fca3ba
  $fShowIntentAttr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Out "#) -}
6ac86ab19dcf6c96d504cf30a8688fe9
  $fShowIntentAttr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "In "#) -}
2e224cb3ca4fa18503a4d24170747dce
  $fShowIntentAttr_$cshow ::
    GHC.Show.Show p => Language.Fortran.IntentAttr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.IntentAttr p) ->
                 case x of wild {
                   Language.Fortran.In b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr3
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.Out b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr2
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.InOut b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
2e224cb3ca4fa18503a4d24170747dce
  $fShowIntentAttr_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.IntentAttr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.IntentAttr p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.IntentAttr p)
                   (Language.Fortran.$fShowIntentAttr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
2e224cb3ca4fa18503a4d24170747dce
  $fShowIntentAttr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.IntentAttr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.IntentAttr p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec14 @ p w ww1 w2 }) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowInterfaceSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fShowInterfaceSpec_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowInterfaceSpec_$cshow @ p $dShow)
                  (Language.Fortran.$fShowInterfaceSpec_$cshowList @ p $dShow) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowInterfaceSpec_$cshow ::
    GHC.Show.Show p =>
    Language.Fortran.InterfaceSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.InterfaceSpec p) ->
                 Language.Fortran.$fShowInterfaceSpec_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowInterfaceSpec_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.InterfaceSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.InterfaceSpec p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fShowInterfaceSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
c4465a5758b20b0d6387c4cda8774a94
  $fShowInterfaceSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.InterfaceSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.InterfaceSpec p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec15 @ p w ww1 w2 }) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fShowMeasureUnitSpec ::
    GHC.Show.Show p =>
    GHC.Show.Show (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshow @ p $dShow)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshowList @ p $dShow) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fShowMeasureUnitSpec_$cshow ::
    GHC.Show.Show p =>
    Language.Fortran.MeasureUnitSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fShowMeasureUnitSpec_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.MeasureUnitSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.MeasureUnitSpec p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
2d20a52afd34a2922ea97a5d3a8025ba
  $fShowMeasureUnitSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.MeasureUnitSpec p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec16 @ p w ww1 w2 }) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fShowProgUnit ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fShowProgUnit_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowProgUnit_$cshow @ p $dShow)
                  (Language.Fortran.$fShowProgUnit_$cshowList @ p $dShow) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fShowProgUnit_$cshow ::
    GHC.Show.Show p => Language.Fortran.ProgUnit p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ProgUnit p) ->
                 Language.Fortran.$fShowProgUnit_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fShowProgUnit_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ProgUnit p] -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dShow :: GHC.Show.Show p) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fShowProgUnit_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)) -}
dd0d2763607dbd5a6f6c1c5d85fe76dd
  $fShowProgUnit_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ProgUnit p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)> -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fShowSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fShowSpec_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowSpec_$cshow @ p $dShow)
                  (Language.Fortran.$fShowSpec_$cshowList @ p $dShow) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fShowSpec_$cshow ::
    GHC.Show.Show p => Language.Fortran.Spec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Spec p) ->
                 Language.Fortran.$fShowSpec_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fShowSpec_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Spec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Spec p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fShowSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $fShowSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Spec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Spec p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec17 @ p w ww1 w2 }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fShowSrcLoc :: GHC.Show.Show Language.Fortran.SrcLoc
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fShowSrcLoc_$cshowsPrec
                  Language.Fortran.$fShowSrcLoc_$cshow
                  Language.Fortran.$fShowSrcLoc_$cshowList -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fShowSrcLoc1 ::
    Language.Fortran.SrcLoc -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (x :: Language.Fortran.SrcLoc)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Language.Fortran.$w$cshow ww1 ww2 ww3)
                   s }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fShowSrcLoc_$cshow :: Language.Fortran.SrcLoc -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SLL),1*U(U,1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cshow ww1 ww2 ww3 }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fShowSrcLoc_$cshowList ::
    [Language.Fortran.SrcLoc] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Language.Fortran.SrcLoc])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.Fortran.SrcLoc
                   Language.Fortran.$fShowSrcLoc1
                   ls
                   s) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $fShowSrcLoc_$cshowsPrec ::
    GHC.Types.Int -> Language.Fortran.SrcLoc -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SLL),1*U(U,1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Language.Fortran.SrcLoc)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Language.Fortran.$fShowSrcLoc_$cshow x))
                   s) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fShowSubName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fShowSubName_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowSubName_$cshow @ p $dShow)
                  (Language.Fortran.$fShowSubName_$cshowList @ p $dShow) -}
66d35f6d25cdb6723be9bfc6cebccae1
  $fShowSubName1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NullSubName "#) -}
3cf27af0f17bc75ae4e7a7e3eaf45fb0
  $fShowSubName2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SubName "#) -}
6d5ec5e4e99b8592c5d51de1f9abf7c7
  $fShowSubName3 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fShowSubName_$cshow ::
    GHC.Show.Show p => Language.Fortran.SubName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.SubName p) ->
                 case x of wild {
                   Language.Fortran.SubName b1 b2
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowSubName2
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.shows6
                                 (GHC.Show.showLitString b2 Language.Fortran.$fShowSubName3))))
                   Language.Fortran.NullSubName b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowSubName1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fShowSubName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.SubName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.SubName p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.SubName p)
                   (Language.Fortran.$fShowSubName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $fShowSubName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.SubName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.SubName p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec18 @ p w ww1 w2 }) -}
cac90f1d6845827f0c2780e86e10c606
  $fShowType ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fShowType_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowType_$cshow @ p $dShow)
                  (Language.Fortran.$fShowType_$cshowList @ p $dShow) -}
cac90f1d6845827f0c2780e86e10c606
  $fShowType_$cshow ::
    GHC.Show.Show p => Language.Fortran.Type p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Type p) ->
                 Language.Fortran.$fShowType_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cac90f1d6845827f0c2780e86e10c606
  $fShowType_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Type p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Type p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fShowType_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
cac90f1d6845827f0c2780e86e10c606
  $fShowType_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Type p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Type p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec19 @ p w ww1 w2 }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fShowUnaryOp ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fShowUnaryOp_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowUnaryOp_$cshow @ p $dShow)
                  (Language.Fortran.$fShowUnaryOp_$cshowList @ p $dShow) -}
c590a9f3de1d107f03e2daa01103420a
  $fShowUnaryOp1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Not "#) -}
8a0294272ae06ee324e43b2f6ee9a2dd
  $fShowUnaryOp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UMinus "#) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fShowUnaryOp_$cshow ::
    GHC.Show.Show p => Language.Fortran.UnaryOp p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.UnaryOp p) ->
                 case x of wild {
                   Language.Fortran.UMinus b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowUnaryOp2
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.Not b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowUnaryOp1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName3
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fShowUnaryOp_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.UnaryOp p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.UnaryOp p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.UnaryOp p)
                   (Language.Fortran.$fShowUnaryOp_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $fShowUnaryOp_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.UnaryOp p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.UnaryOp p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec20 @ p w ww1 w2 }) -}
d59de0314bb55c907d315303e8c78677
  $fShowUseBlock ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fShowUseBlock_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowUseBlock_$cshow @ p $dShow)
                  (Language.Fortran.$fShowUseBlock_$cshowList @ p $dShow) -}
d59de0314bb55c907d315303e8c78677
  $fShowUseBlock_$cshow ::
    GHC.Show.Show p => Language.Fortran.UseBlock p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U(1*U,1*U(U,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: Language.Fortran.UseBlock p) ->
                 case w1 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 Language.Fortran.$w$cshow1 @ p w ww1 ww2 }) -}
d59de0314bb55c907d315303e8c78677
  $fShowUseBlock_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.UseBlock p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.UseBlock p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.UseBlock p)
                   (Language.Fortran.$fShowUseBlock_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
d59de0314bb55c907d315303e8c78677
  $fShowUseBlock_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.UseBlock p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(1*U,U(U,U(U),U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.UseBlock p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.UseBlock ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec8 @ p w ww1 ww3 ww4 } }) -}
22a7293c3f9ba679ea60d591f21568e8
  $fShowUses ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fShowUses_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowUses_$cshow @ p $dShow)
                  (Language.Fortran.$fShowUses_$cshowList @ p $dShow) -}
22a7293c3f9ba679ea60d591f21568e8
  $fShowUses_$cshow ::
    GHC.Show.Show p => Language.Fortran.Uses p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Uses p) ->
                 Language.Fortran.$fShowUses_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
22a7293c3f9ba679ea60d591f21568e8
  $fShowUses_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Uses p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.Uses p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Uses p)
                   (Language.Fortran.$fShowUses_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
22a7293c3f9ba679ea60d591f21568e8
  $fShowUses_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Uses p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.Uses p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec9 @ p w ww1 w2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fShowVarName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p ($dShow :: GHC.Show.Show p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fShowVarName_$cshowsPrec @ p $dShow)
                  (Language.Fortran.$fShowVarName_$cshow @ p $dShow)
                  (Language.Fortran.$fShowVarName_$cshowList @ p $dShow) -}
680ccbd5bf65b0474c663bd245e5ab56
  $fShowVarName1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VarName "#) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fShowVarName_$cshow ::
    GHC.Show.Show p => Language.Fortran.VarName p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: GHC.Show.Show p) (w1 :: Language.Fortran.VarName p) ->
                 case w1 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cshow2 @ p w ww1 ww2 }) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fShowVarName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.VarName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (eta :: [Language.Fortran.VarName p])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fShowVarName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg6)
                   eta
                   eta1) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $fShowVarName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.VarName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Language.Fortran.VarName p) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Language.Fortran.VarName ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec21 @ p w ww1 ww3 ww4 } }) -}
26c91c6356024c66c1ddaead2c481300
  $fSpanBlock :: Language.Fortran.Span (Language.Fortran.Block a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U,U),A,A)>m,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanBlock_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Block a>_N)) -}
8284540f8bf01a893e25b5212db8cceb
  $fSpanBlock_$csrcSpan ::
    Language.Fortran.Block a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U,U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Block a) ->
                 case ds of wild { Language.Fortran.Block ds1 ds2 ds3 sp ds4 ds5 ->
                 sp }) -}
26c91c6356024c66c1ddaead2c481300
  $fSpanDecl :: Language.Fortran.Span (Language.Fortran.Decl a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanDecl_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Decl a>_N)) -}
1689b2b5ca5704dcf30b5b12480768b4
  $fSpanDecl1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
b3fdf40996a1ac34505bf016b3cce2a3
  $fSpanDecl_$csrcSpan ::
    Language.Fortran.Decl a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Decl a) ->
                 case ds of wild {
                   DEFAULT -> Language.Fortran.$fSpanDecl1
                   Language.Fortran.Decl ds1 sp ds2 ds3 -> sp
                   Language.Fortran.Equivalence x sp ds1 -> sp
                   Language.Fortran.Common ds1 sp ds2 ds3 -> sp
                   Language.Fortran.DerivedTypeDef x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.NullDecl ds1 sp -> sp
                   Language.Fortran.MeasureUnitDef x sp ds1 -> sp }) -}
26c91c6356024c66c1ddaead2c481300
  $fSpanExpr :: Language.Fortran.Span (Language.Fortran.Expr a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanExpr_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Expr a>_N)) -}
568bb227a8eeea6d3394118560534816
  $fSpanExpr1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
63978eb7dddc44367e6c7d7118bb0819
  $fSpanExpr_$csrcSpan ::
    Language.Fortran.Expr a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Expr a) ->
                 case ds of wild {
                   Language.Fortran.Con x sp ds1 -> sp
                   Language.Fortran.ConL ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fSpanExpr1
                   Language.Fortran.ConS x sp ds1 -> sp
                   Language.Fortran.ParenthesizedExpr x sp ds1 -> sp
                   Language.Fortran.Var x sp ds1 -> sp
                   Language.Fortran.Bin x sp ds1 ds2 ds3 -> sp
                   Language.Fortran.Unary x sp ds1 ds2 -> sp
                   Language.Fortran.CallExpr x sp ds1 ds2 -> sp
                   Language.Fortran.NullExpr x sp -> sp
                   Language.Fortran.Null x sp -> sp
                   Language.Fortran.ESeq x sp ds1 ds2 -> sp
                   Language.Fortran.Bound x sp ds1 ds2 -> sp
                   Language.Fortran.Sqrt x sp ds1 -> sp
                   Language.Fortran.ArrayCon x sp ds1 -> sp
                   Language.Fortran.AssgExpr x sp ds1 ds2 -> sp }) -}
26c91c6356024c66c1ddaead2c481300
  $fSpanFortran :: Language.Fortran.Span (Language.Fortran.Fortran a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanFortran_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Fortran a>_N)) -}
c60b6f9fa870eab272354c4c5138d1ce
  $fSpanFortran1 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
aef3e7490214390a235e82d32275886d
  $fSpanFortran_$csrcSpan ::
    Language.Fortran.Fortran a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Fortran a) ->
                 case ds of wild {
                   Language.Fortran.Assg x sp e1 e2 -> sp
                   Language.Fortran.For x sp v e1 e2 e3 fs -> sp
                   Language.Fortran.DoWhile x sp e fs -> sp
                   Language.Fortran.FSeq x sp f1 f2 -> sp
                   Language.Fortran.If x sp e f1 fes f3 -> sp
                   Language.Fortran.Allocate x sp e1 e2 -> sp
                   Language.Fortran.Backspace x sp ds1 -> sp
                   Language.Fortran.Call x sp e as -> sp
                   Language.Fortran.Open x sp s -> sp
                   Language.Fortran.Close x sp s -> sp
                   Language.Fortran.Continue x sp -> sp
                   Language.Fortran.Cycle x sp s -> sp
                   Language.Fortran.DataStmt x sp ds1 -> sp
                   Language.Fortran.Deallocate x sp es e -> sp
                   Language.Fortran.Endfile x sp s -> sp
                   Language.Fortran.Exit x sp s -> sp
                   Language.Fortran.Format x sp ds1 -> sp
                   Language.Fortran.Forall x sp es f -> sp
                   Language.Fortran.Goto x sp s -> sp
                   Language.Fortran.Nullify x sp e -> sp
                   Language.Fortran.Inquire x sp s e -> sp
                   Language.Fortran.Pause x sp ds1 -> sp
                   Language.Fortran.Rewind x sp s -> sp
                   Language.Fortran.Stop x sp e -> sp
                   Language.Fortran.Where x sp e f ds1 -> sp
                   Language.Fortran.Write x sp s e -> sp
                   Language.Fortran.PointerAssg x sp e1 e2 -> sp
                   Language.Fortran.Return x sp e -> sp
                   Language.Fortran.Label x sp s f -> sp
                   Language.Fortran.Print x sp e es -> sp
                   Language.Fortran.ReadS x sp s e -> sp
                   Language.Fortran.TextStmt x sp s -> sp
                   Language.Fortran.NullStmt x sp -> sp
                   Language.Fortran.SelectStmt x sp e fes ds1 -> sp
                   Language.Fortran.OpenCLMap x sp e1 e2 ds1 ds2 f2 -> sp
                   Language.Fortran.OpenCLReduce x sp e1 e2 ds1 ds2 e3 f2 -> sp
                   Language.Fortran.OpenCLSeq ipv ipv1 ipv2 ipv3 ipv4
                   -> Language.Fortran.$fSpanFortran1
                   Language.Fortran.OpenCLBufferRead ds1 sp ds2 -> sp
                   Language.Fortran.OpenCLBufferWrite ds1 sp ds2 -> sp }) -}
26c91c6356024c66c1ddaead2c481300
  $fSpanProgUnit ::
    Language.Fortran.Span (Language.Fortran.ProgUnit a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanProgUnit_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0]
                          <Language.Fortran.ProgUnit a>_N)) -}
6bbfa0a9a5ecdb570b6148f63a37a2cc
  $fSpanProgUnit1 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
a65b149422f12957d4dec3eb82c81437
  $fSpanProgUnit_$csrcSpan ::
    Language.Fortran.ProgUnit a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.ProgUnit a) ->
                 case ds of wild {
                   Language.Fortran.Main x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.Sub x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.Function x sp ds1 ds2 ds3 ds4 ds5 -> sp
                   Language.Fortran.Module x sp ds1 ds2 ds3 ds4 ds5 -> sp
                   Language.Fortran.BlockData x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.PSeq x sp ds1 ds2 -> sp
                   Language.Fortran.Prog x sp ds1 -> sp
                   Language.Fortran.NullProg x sp -> sp
                   Language.Fortran.IncludeProg ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fSpanProgUnit1 }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedArg :: Language.Fortran.Tagged Language.Fortran.Arg
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArg_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Arg>_N)) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedArgList :: Language.Fortran.Tagged Language.Fortran.ArgList
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArgList_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ArgList>_N)) -}
a116a5e253e051db093d1e9890786112
  $fTaggedArgList_$ctag :: Language.Fortran.ArgList a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.ArgList a) ->
                 case ds of wild { Language.Fortran.ArgList x ds1 -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedArgName :: Language.Fortran.Tagged Language.Fortran.ArgName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArgName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ArgName>_N)) -}
014ec2ffbc5ef7342d145e3d067fcdac
  $fTaggedArgName_$ctag :: Language.Fortran.ArgName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.ArgName a) ->
                 case ds of wild {
                   Language.Fortran.ArgName x ds1 -> x
                   Language.Fortran.ASeq x ds1 ds2 -> x
                   Language.Fortran.NullArg x -> x }) -}
73c2fde7df93fc6f7a7f0c178e7a20a8
  $fTaggedArg_$ctag :: Language.Fortran.Arg a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Arg a) ->
                 case ds of wild { Language.Fortran.Arg x ds1 ds2 -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedAttr :: Language.Fortran.Tagged Language.Fortran.Attr
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedAttr_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Attr>_N)) -}
1ad5953c5e22a75da1f8f31abbebf69c
  $fTaggedAttr1 :: a
  {- Strictness: x -}
8039c295a3560294d1eb955fd9d1eaea
  $fTaggedAttr_$ctag :: Language.Fortran.Attr a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Attr a) ->
                 case ds of wild {
                   Language.Fortran.Parameter x -> x
                   Language.Fortran.Allocatable x -> x
                   Language.Fortran.External x -> x
                   Language.Fortran.Intent x ds1 -> x
                   Language.Fortran.Intrinsic x -> x
                   Language.Fortran.Optional x -> x
                   Language.Fortran.Pointer x -> x
                   Language.Fortran.Save x -> x
                   Language.Fortran.Target x -> x
                   Language.Fortran.Volatile x -> x
                   Language.Fortran.Public x -> x
                   Language.Fortran.Private x -> x
                   Language.Fortran.Sequence x -> x
                   Language.Fortran.Dimension x ds1 -> x
                   Language.Fortran.MeasureUnit ipv ipv1
                   -> Language.Fortran.$fTaggedAttr1 @ a }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedBaseType ::
    Language.Fortran.Tagged Language.Fortran.BaseType
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedBaseType_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.BaseType>_N)) -}
a68770ca38f5f672fa127e871971dcd4
  $fTaggedBaseType_$ctag :: Language.Fortran.BaseType a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.BaseType a) ->
                 case ds of wild {
                   Language.Fortran.Integer x -> x
                   Language.Fortran.Real x -> x
                   Language.Fortran.Character x -> x
                   Language.Fortran.SomeType x -> x
                   Language.Fortran.DerivedType x ds1 -> x
                   Language.Fortran.Recursive x -> x
                   Language.Fortran.Pure x -> x
                   Language.Fortran.Elemental x -> x
                   Language.Fortran.Logical x -> x
                   Language.Fortran.Complex x -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedDataForm ::
    Language.Fortran.Tagged Language.Fortran.DataForm
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedDataForm_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.DataForm>_N)) -}
6a3d588b6827fc4da496089dea7a239f
  $fTaggedDataForm_$ctag :: Language.Fortran.DataForm a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.DataForm a) ->
                 case ds of wild { Language.Fortran.Data x ds1 -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedDecl :: Language.Fortran.Tagged Language.Fortran.Decl
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedDecl_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Decl>_N)) -}
62abf4a867b377e06d781d6f45f757d9
  $fTaggedDecl_$ctag :: Language.Fortran.Decl a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Decl a) ->
                 case ds of wild {
                   Language.Fortran.Decl x ds1 ds2 ds3 -> x
                   Language.Fortran.Namelist x ds1 -> x
                   Language.Fortran.DataDecl x ds1 -> x
                   Language.Fortran.Equivalence x sp ds1 -> x
                   Language.Fortran.AttrStmt x ds1 ds2 -> x
                   Language.Fortran.AccessStmt x ds1 ds2 -> x
                   Language.Fortran.ExternalStmt x ds1 -> x
                   Language.Fortran.Interface x ds1 ds2 -> x
                   Language.Fortran.Common x ds1 ds2 ds3 -> x
                   Language.Fortran.DerivedTypeDef x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Include x ds1 -> x
                   Language.Fortran.DSeq x ds1 ds2 -> x
                   Language.Fortran.TextDecl x ds1 -> x
                   Language.Fortran.NullDecl x ds1 -> x
                   Language.Fortran.MeasureUnitDef x ds1 ds2 -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedExpr :: Language.Fortran.Tagged Language.Fortran.Expr
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedExpr_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Expr>_N)) -}
0fbd37bf5c2d20448940f8ce055d03f1
  $fTaggedExpr1 :: a
  {- Strictness: x -}
762d2d5df0d1ac4869817d0ac1eb0569
  $fTaggedExpr_$ctag :: Language.Fortran.Expr a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Expr a) ->
                 case ds of wild {
                   Language.Fortran.Con x sp ds1 -> x
                   Language.Fortran.ConL x sp ds1 ds2 -> x
                   Language.Fortran.ConS x sp ds1 -> x
                   Language.Fortran.ParenthesizedExpr ipv ipv1 ipv2
                   -> Language.Fortran.$fTaggedExpr1 @ a
                   Language.Fortran.Var x sp ds1 -> x
                   Language.Fortran.Bin x sp ds1 ds2 ds3 -> x
                   Language.Fortran.Unary x sp ds1 ds2 -> x
                   Language.Fortran.CallExpr x sp ds1 ds2 -> x
                   Language.Fortran.NullExpr x ds1 -> x
                   Language.Fortran.Null x ds1 -> x
                   Language.Fortran.ESeq x sp ds1 ds2 -> x
                   Language.Fortran.Bound x sp ds1 ds2 -> x
                   Language.Fortran.Sqrt x sp ds1 -> x
                   Language.Fortran.ArrayCon x sp ds1 -> x
                   Language.Fortran.AssgExpr x sp ds1 ds2 -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedFortran :: Language.Fortran.Tagged Language.Fortran.Fortran
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedFortran_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.Fortran>_N)) -}
76dfee5b5bfb7372295f3919aec9f2d0
  $fTaggedFortran1 :: a
  {- Strictness: x -}
88ecb743f777db2c886664063a5e29f0
  $fTaggedFortran_$ctag :: Language.Fortran.Fortran a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Fortran a) ->
                 case ds of wild {
                   DEFAULT -> Language.Fortran.$fTaggedFortran1 @ a
                   Language.Fortran.Assg x s e1 e2 -> x
                   Language.Fortran.For x s v e1 e2 e3 fs -> x
                   Language.Fortran.DoWhile x sp e fs -> x
                   Language.Fortran.FSeq x sp f1 f2 -> x
                   Language.Fortran.If x sp e f1 fes f3 -> x
                   Language.Fortran.Allocate x sp e1 e2 -> x
                   Language.Fortran.Backspace x sp ds1 -> x
                   Language.Fortran.Call x sp e as -> x
                   Language.Fortran.Open x sp s -> x
                   Language.Fortran.Close x sp s -> x
                   Language.Fortran.Continue x sp -> x
                   Language.Fortran.Cycle x sp s -> x
                   Language.Fortran.DataStmt x sp ds1 -> x
                   Language.Fortran.Deallocate x sp es e -> x
                   Language.Fortran.Endfile x sp s -> x
                   Language.Fortran.Exit x sp s -> x
                   Language.Fortran.Format x sp ds1 -> x
                   Language.Fortran.Forall x sp es f -> x
                   Language.Fortran.Goto x sp s -> x
                   Language.Fortran.Nullify x sp e -> x
                   Language.Fortran.Inquire x sp s e -> x
                   Language.Fortran.Pause x sp ds1 -> x
                   Language.Fortran.Rewind x sp s -> x
                   Language.Fortran.Stop x sp e -> x
                   Language.Fortran.Where x sp e f ds1 -> x
                   Language.Fortran.Write x sp s e -> x
                   Language.Fortran.PointerAssg x sp e1 e2 -> x
                   Language.Fortran.Return x sp e -> x
                   Language.Fortran.Label x sp s f -> x
                   Language.Fortran.Print x sp e es -> x
                   Language.Fortran.ReadS x sp s e -> x
                   Language.Fortran.TextStmt x sp s -> x
                   Language.Fortran.NullStmt x sp -> x
                   Language.Fortran.SelectStmt x sp e fes ds1 -> x
                   Language.Fortran.OpenCLMap x sp e1 e2 ds1 ds2 f2 -> x
                   Language.Fortran.OpenCLReduce x sp e1 e2 ds1 ds2 e3 f2 -> x
                   Language.Fortran.OpenCLBufferRead x ds1 ds2 -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedGSpec :: Language.Fortran.Tagged Language.Fortran.GSpec
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedGSpec_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.GSpec>_N)) -}
3ac8094fb909d6edfc9b6cb7bbe3f3bf
  $fTaggedGSpec_$ctag :: Language.Fortran.GSpec a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.GSpec a) ->
                 case ds of wild {
                   Language.Fortran.GName x ds1 -> x
                   Language.Fortran.GOper x ds1 -> x
                   Language.Fortran.GAssg x -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedImplicit ::
    Language.Fortran.Tagged Language.Fortran.Implicit
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedImplicit_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.Implicit>_N)) -}
d48366b43532a53b4be0f4cd856a5a76
  $fTaggedImplicit_$ctag :: Language.Fortran.Implicit a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Implicit a) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone x -> x
                   Language.Fortran.ImplicitNull x -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedProgUnit ::
    Language.Fortran.Tagged Language.Fortran.ProgUnit
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedProgUnit_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ProgUnit>_N)) -}
d54861727bdffd4af93c0a2cf1065949
  $fTaggedProgUnit1 :: a
  {- Strictness: x -}
6c7568785852586846bc7eef9148c8b3
  $fTaggedProgUnit_$ctag :: Language.Fortran.ProgUnit a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.ProgUnit a) ->
                 case ds of wild {
                   Language.Fortran.Main x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Sub x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Function x sp ds1 ds2 ds3 ds4 ds5 -> x
                   Language.Fortran.Module x sp ds1 ds2 ds3 ds4 ds5 -> x
                   Language.Fortran.BlockData x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.PSeq x sp ds1 ds2 -> x
                   Language.Fortran.Prog x sp ds1 -> x
                   Language.Fortran.NullProg x sp -> x
                   Language.Fortran.IncludeProg ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fTaggedProgUnit1 @ a }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedSubName :: Language.Fortran.Tagged Language.Fortran.SubName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedSubName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.SubName>_N)) -}
b0ec87944b4db5824b5b54885609fe94
  $fTaggedSubName_$ctag :: Language.Fortran.SubName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.SubName a) ->
                 case ds of wild {
                   Language.Fortran.SubName x ds1 -> x
                   Language.Fortran.NullSubName x -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedUses :: Language.Fortran.Tagged Language.Fortran.Uses
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedUses_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Uses>_N)) -}
005faaf1fff29b47547d5ef5fa2d8838
  $fTaggedUses_$ctag :: Language.Fortran.Uses a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Uses a) ->
                 case ds of wild {
                   Language.Fortran.Use x ds1 ds2 ds3 -> x
                   Language.Fortran.UseNil x -> x }) -}
d98a5141e506956822df4a093404b8b6
  $fTaggedVarName :: Language.Fortran.Tagged Language.Fortran.VarName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedVarName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.VarName>_N)) -}
55c3d76247db3fb03c6722d11360519e
  $fTaggedVarName_$ctag :: Language.Fortran.VarName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.VarName a) ->
                 case ds of wild { Language.Fortran.VarName x ds1 -> x }) -}
e508325747b2649ab45d680c64ca4ed9
  $s$fData(,) :: Data.Data.Data ([GHC.Types.Char], [GHC.Types.Char])
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char])
                  (Data.Data.$fData(,)_$cp1Data
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgfoldl
                  (Data.Data.$fData(,)_$cgunfold
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$ctoConstr
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cdataTypeOf
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cdataCast1
                  (Data.Data.$fData(,)_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapT
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQl
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQr
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQ
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQi
                  (Data.Data.$fData(,)_$cgmapM
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData(,)_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData(,)_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[]) -}
75312b4fdc81b4150d8fb8b5234cb4a8
  $s$fData(,)1 ::
    Data.Data.Data
      ([GHC.Types.Char],
       [(Language.Fortran.Variable, Language.Fortran.Variable)])
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char],
                     [(Language.Fortran.Variable, Language.Fortran.Variable)])
                  (Data.Data.$fData(,)_$cp1Data
                     @ [GHC.Types.Char]
                     @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                     Data.Data.$fData[]_$s$fData[]
                     Language.Fortran.$s$fData(,)2)
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgfoldl1
                  (Data.Data.$fData(,)_$cgunfold
                     @ [GHC.Types.Char]
                     @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                     Data.Data.$fData[]_$s$fData[]
                     Language.Fortran.$s$fData(,)2)
                  Language.Fortran.$s$fData(,)6
                  Language.Fortran.$s$fData(,)5
                  Language.Fortran.$s$fData(,)4
                  (Data.Data.$fData(,)_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                     Data.Data.$fData[]_$s$fData[]
                     Language.Fortran.$s$fData(,)2)
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapT1
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQl1
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQr1
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQ1
                  Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQi1
                  (Data.Data.$fData(,)_$cgmapM
                     @ [GHC.Types.Char]
                     @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                     Data.Data.$fData[]_$s$fData[]
                     Language.Fortran.$s$fData(,)2)
                  (Data.Data.$fData(,)_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                     Data.Data.$fData[]_$s$fData[]
                     Language.Fortran.$s$fData(,)2)
                  (Data.Data.$fData(,)_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                     Data.Data.$fData[]_$s$fData[]
                     Language.Fortran.$s$fData(,)2) -}
96687440a7dc08fe2320f53bc12031dd
  $s$fData(,)2 ::
    Data.Data.Data
      [(Language.Fortran.Variable, Language.Fortran.Variable)]
  {- Unfolding: InlineRule (0, True, True)
                Language.Fortran.$s$fData(,)_$s$fData[] -}
813d192b1a0b87263fc1a058799e0e77
  $s$fData(,)3 ::
    Data.Data.Data
      (Language.Fortran.Variable, Language.Fortran.Variable)
  {- Unfolding: InlineRule (0, True, True)
                Language.Fortran.$s$fData(,) -}
a551068644d0a0f32582742e8f541a6f
  $s$fData(,)4 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe
         (c ([GHC.Types.Char],
             [(Language.Fortran.Variable, Language.Fortran.Variable)]))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing
                   @ (c ([GHC.Types.Char],
                         [(Language.Fortran.Variable, Language.Fortran.Variable)]))) -}
2f64efadafba289d99feb1f14dcdc904
  $s$fData(,)5 ::
    ([GHC.Types.Char],
     [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: ([GHC.Types.Char],
                           [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 Data.Data.tuple2DataType) -}
f25f124248edea79175fd4b5c361d393
  $s$fData(,)6 ::
    ([GHC.Types.Char],
     [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ([GHC.Types.Char],
                           [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case ds of wild { (,) ds1 ds2 -> Data.Data.tuple2Constr }) -}
d8bc02594e433a9d7fb441a10dc2de08
  $s$fData(,)_$s$fData(,)_$cdataCast1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c ([GHC.Types.Char], [GHC.Types.Char]))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing @ (c ([GHC.Types.Char], [GHC.Types.Char]))) -}
aa236549cb1417938a0075ba8d21fdc0
  $s$fData(,)_$s$fData(,)_$cdataTypeOf ::
    ([GHC.Types.Char], [GHC.Types.Char]) -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 Data.Data.tuple2DataType) -}
364c18bd2dcf6bf2ad4a6e264a5d49d1
  $s$fData(,)_$s$fData(,)_$cgfoldl ::
    (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
    -> (forall g. g -> c g)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> c ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 3,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (c :: * -> *)
                   (f :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                   (z :: forall g. g -> c g)
                   (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case ds of wild { (,) a1 b1 ->
                 f @ [GHC.Types.Char]
                   @ ([GHC.Types.Char], [GHC.Types.Char])
                   Data.Data.$fData[]_$s$fData[]
                   (f @ [GHC.Types.Char]
                      @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                      Data.Data.$fData[]_$s$fData[]
                      (z @ ([GHC.Types.Char]
                            -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                         (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char]))
                      a1)
                   b1 }) -}
c108a84054b829a581144971c5ec5691
  $s$fData(,)_$s$fData(,)_$cgfoldl1 ::
    (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
    -> (forall g. g -> c g)
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> c ([GHC.Types.Char],
          [(Language.Fortran.Variable, Language.Fortran.Variable)])
  {- Arity: 3,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (c :: * -> *)
                   (f :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                   (z :: forall g. g -> c g)
                   (ds :: ([GHC.Types.Char],
                           [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case ds of wild { (,) a1 b1 ->
                 f @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                   @ ([GHC.Types.Char],
                      [(Language.Fortran.Variable, Language.Fortran.Variable)])
                   Language.Fortran.$s$fData(,)2
                   (f @ [GHC.Types.Char]
                      @ ([(Language.Fortran.Variable, Language.Fortran.Variable)]
                         -> ([GHC.Types.Char],
                             [(Language.Fortran.Variable, Language.Fortran.Variable)]))
                      Data.Data.$fData[]_$s$fData[]
                      (z @ ([GHC.Types.Char]
                            -> [(Language.Fortran.Variable, Language.Fortran.Variable)]
                            -> ([GHC.Types.Char],
                                [(Language.Fortran.Variable, Language.Fortran.Variable)]))
                         (GHC.Tuple.(,)
                            @ [GHC.Types.Char]
                            @ [(Language.Fortran.Variable, Language.Fortran.Variable)]))
                      a1)
                   b1 }) -}
99c335d0e6348ed83749d7af2046604f
  $s$fData(,)_$s$fData(,)_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> ([GHC.Types.Char], [GHC.Types.Char]) -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 b1 ->
                 GHC.Types.:
                   @ u
                   (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                   (GHC.Types.:
                      @ u
                      (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] b1)
                      (GHC.Types.[] @ u)) }) -}
611eefa2cae2a6da0df0131639c03b40
  $s$fData(,)_$s$fData(,)_$cgmapQ1 ::
    (forall d. Data.Data.Data d => d -> u)
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: ([GHC.Types.Char],
                           [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case x0 of wild { (,) a1 b1 ->
                 GHC.Types.:
                   @ u
                   (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                   (GHC.Types.:
                      @ u
                      (ds
                         @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                         Language.Fortran.$s$fData(,)2
                         b1)
                      (GHC.Types.[] @ u)) }) -}
ca4b4365571faeb543837b0b23691a09
  $s$fData(,)_$s$fData(,)_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x of wild { (,) a1 b1 ->
                 case ds of wild1 { GHC.Types.I# x1 ->
                 case x1 of wild2 {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1
                   1#
                   -> ds1
                        @ [GHC.Types.Char]
                        Data.Data.$fData[]_$s$fData[]
                        b1 } } }) -}
388a2912c049abc94bad74cbcd302f68
  $s$fData(,)_$s$fData(,)_$cgmapQi1 ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: ([GHC.Types.Char],
                          [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case x of wild { (,) a1 b1 ->
                 case ds of wild1 { GHC.Types.I# x1 ->
                 case x1 of wild2 {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1
                   1#
                   -> ds1
                        @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                        Language.Fortran.$s$fData(,)2
                        b1 } } }) -}
739ec52cd30c0e9d1ae1341d4b920dc9
  $s$fData(,)_$s$fData(,)_$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case eta of wild { (,) a1 b1 ->
                 ds
                   (ds ds1 (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                   (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] b1) }) -}
2e27bf8590f7df64ac26c912f5ed161c
  $s$fData(,)_$s$fData(,)_$cgmapQl1 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: ([GHC.Types.Char],
                            [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case eta of wild { (,) a1 b1 ->
                 ds
                   (ds ds1 (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                   (ds2
                      @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                      Language.Fortran.$s$fData(,)2
                      b1) }) -}
633ba5536b265698d533b4ac86ef8963
  $s$fData(,)_$s$fData(,)_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 b1 ->
                 ds
                   (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                   (ds
                      (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] b1)
                      ds1) }) -}
7b1a13a3792395d13af9d381a4d2e05e
  $s$fData(,)_$s$fData(,)_$cgmapQr1 ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: ([GHC.Types.Char],
                           [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case x0 of wild { (,) a1 b1 ->
                 ds
                   (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                   (ds
                      (ds2
                         @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                         Language.Fortran.$s$fData(,)2
                         b1)
                      ds1) }) -}
2269d3b8a4ca0a9c0d9ac1fe148f5f72
  $s$fData(,)_$s$fData(,)_$cgmapT ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 b1 ->
                 (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1,
                  ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] b1) }) -}
13c219b57169c623917579df0d6b9360
  $s$fData(,)_$s$fData(,)_$cgmapT1 ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
    -> ([GHC.Types.Char],
        [(Language.Fortran.Variable, Language.Fortran.Variable)])
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: ([GHC.Types.Char],
                           [(Language.Fortran.Variable, Language.Fortran.Variable)])) ->
                 case x0 of wild { (,) a1 b1 ->
                 (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1,
                  ds
                    @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                    Language.Fortran.$s$fData(,)2
                    b1) }) -}
000d5a106ba9661e23c1eba9036d87e9
  $s$fData(,)_$s$fData(,)_$ctoConstr ::
    ([GHC.Types.Char], [GHC.Types.Char]) -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case ds of wild { (,) ds1 ds2 -> Data.Data.tuple2Constr }) -}
ac37ef05133809819c8daf71b468d1ef
  $s$fData(,)_$s$fData[] ::
    Data.Data.Data
      [(Language.Fortran.Variable, Language.Fortran.Variable)]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                  (Data.Data.$fData[]_$cp1Data
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgfoldl
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgunfold
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$ctoConstr
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cdataTypeOf
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cdataCast1
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cdataCast2
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapT
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapQl
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapQr
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapQ
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapQi
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapM
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapMp
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3)
                  (Data.Data.$fData[]_$cgmapMo
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)3) -}
a91c5d188d393edd0296d5f5af6f1478
  $s$fDataMaybe :: Data.Data.Data (GHC.Base.Maybe [GHC.Types.Char])
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [GHC.Types.Char])
                  (Data.Data.$fDataMaybe_$cp1Data
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgfoldl
                  (Data.Data.$fDataMaybe_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$ctoConstr
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataTypeOf
                  (Data.Data.$fDataMaybe_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataCast2
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapT
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQl
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQr
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQ
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQi
                  (Data.Data.$fDataMaybe_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fDataMaybe_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fDataMaybe_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
e4888d775b870a9abbe67716e373221a
  $s$fDataMaybe1 :: Data.Data.Data (GHC.Base.Maybe GHC.Types.Int)
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (Data.Data.$fDataMaybe_$cp1Data
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgfoldl1
                  (Data.Data.$fDataMaybe_$cgunfold
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$ctoConstr1
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataTypeOf1
                  (Data.Data.$fDataMaybe_$cdataCast1
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataCast1
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapT1
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQl1
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQr1
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQ1
                  Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQi1
                  (Data.Data.$fDataMaybe_$cgmapM @ GHC.Types.Int Data.Data.$fDataInt)
                  (Data.Data.$fDataMaybe_$cgmapMp
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (Data.Data.$fDataMaybe_$cgmapMo
                     @ GHC.Types.Int
                     Data.Data.$fDataInt) -}
b38c37ec7c74522fbec29530956919bf
  $s$fDataMaybe_$s$fDataMaybe_$cdataCast1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (GHC.Base.Maybe GHC.Types.Int))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (GHC.Base.Maybe GHC.Types.Int))) -}
ee9989c9dceb2dfe3dd262e5294ca913
  $s$fDataMaybe_$s$fDataMaybe_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c (GHC.Base.Maybe [GHC.Types.Char]))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c (GHC.Base.Maybe [GHC.Types.Char]))) -}
3d8d52b275d136105d62dc507198f077
  $s$fDataMaybe_$s$fDataMaybe_$cdataTypeOf ::
    GHC.Base.Maybe [GHC.Types.Char] -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 Data.Data.maybeDataType) -}
40e1cfc32773528dddc611d2420b8b29
  $s$fDataMaybe_$s$fDataMaybe_$cdataTypeOf1 ::
    GHC.Base.Maybe GHC.Types.Int -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                 Data.Data.maybeDataType) -}
0c658f017462cced88d79af702bb7d9d
  $s$fDataMaybe_$s$fDataMaybe_$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> c (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 3, Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (c :: * -> *)
                   (ds :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds1 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case ds1 of wild {
                   GHC.Base.Nothing
                   -> z @ (GHC.Base.Maybe [GHC.Types.Char])
                        (GHC.Base.Nothing @ [GHC.Types.Char])
                   GHC.Base.Just x
                   -> ds
                        @ [GHC.Types.Char]
                        @ (GHC.Base.Maybe [GHC.Types.Char])
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char] -> GHC.Base.Maybe [GHC.Types.Char])
                           (GHC.Base.Just @ [GHC.Types.Char]))
                        x }) -}
d6f407f743e630be841372bda6702712
  $s$fDataMaybe_$s$fDataMaybe_$cgfoldl1 ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.Maybe GHC.Types.Int
    -> c (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 3, Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (c :: * -> *)
                   (ds :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds1 of wild {
                   GHC.Base.Nothing
                   -> z @ (GHC.Base.Maybe GHC.Types.Int)
                        (GHC.Base.Nothing @ GHC.Types.Int)
                   GHC.Base.Just x
                   -> ds
                        @ GHC.Types.Int
                        @ (GHC.Base.Maybe GHC.Types.Int)
                        Data.Data.$fDataInt
                        (z @ (GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int)
                           (GHC.Base.Just @ GHC.Types.Int))
                        x }) -}
9c9375ef73bb1bac6dacf93344fe3531
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe [GHC.Types.Char] -> [u]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ u
                   GHC.Base.Just x
                   -> GHC.Types.:
                        @ u
                        (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] x)
                        (GHC.Types.[] @ u) }) -}
0d642333143531dc7ee406f204dc536f
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQ1 ::
    (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe GHC.Types.Int -> [u]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ u
                   GHC.Base.Just x
                   -> GHC.Types.:
                        @ u
                        (ds @ GHC.Types.Int Data.Data.$fDataInt x)
                        (GHC.Types.[] @ u) }) -}
49b0e000a05ba010d821ce3b32bde75f
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                   GHC.Base.Just x1
                   -> case ds of wild1 { GHC.Types.I# x2 ->
                      case x2 of wild2 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0#
                        -> ds1
                             @ [GHC.Types.Char]
                             Data.Data.$fData[]_$s$fData[]
                             x1 } } }) -}
e3be952ac309a2324a97700f9ff35a24
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQi1 ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe GHC.Types.Int
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                   GHC.Base.Just x1
                   -> case ds of wild1 { GHC.Types.I# x2 ->
                      case x2 of wild2 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> ds1 @ GHC.Types.Int Data.Data.$fDataInt x1 } } }) -}
57d896e6a5ad3cf5dfdf89776bfe8b40
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case eta of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just x
                   -> ds
                        ds1
                        (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] x) }) -}
285aae8850c658fd991de47b8e748c5d
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQl1 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe GHC.Types.Int
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: GHC.Base.Maybe GHC.Types.Int) ->
                 case eta of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just x
                   -> ds ds1 (ds2 @ GHC.Types.Int Data.Data.$fDataInt x) }) -}
f1c541dfa79300db4a87ada95f3d25a5
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just x
                   -> ds
                        (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] x)
                        ds1 }) -}
0f9467bc27802b647f477009cc0b2347
  $s$fDataMaybe_$s$fDataMaybe_$cgmapQr1 ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe GHC.Types.Int
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just x
                   -> ds (ds2 @ GHC.Types.Int Data.Data.$fDataInt x) ds1 }) -}
6a457f076685703bbaa1d48179912ebf
  $s$fDataMaybe_$s$fDataMaybe_$cgmapT ::
    (forall b. Data.Data.Data b => b -> b)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> GHC.Base.Maybe [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Char]
                   GHC.Base.Just x
                   -> GHC.Base.Just
                        @ [GHC.Types.Char]
                        (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] x) }) -}
b6dfc231ecb73cc4638424fea6e4794a
  $s$fDataMaybe_$s$fDataMaybe_$cgmapT1 ::
    (forall b. Data.Data.Data b => b -> b)
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Int
                   GHC.Base.Just x
                   -> GHC.Base.Just
                        @ GHC.Types.Int
                        (ds @ GHC.Types.Int Data.Data.$fDataInt x) }) -}
6bb1b8fef184d9c0b1890d010a4555b6
  $s$fDataMaybe_$s$fDataMaybe_$ctoConstr ::
    GHC.Base.Maybe [GHC.Types.Char] -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Data.Data.nothingConstr
                   GHC.Base.Just ds1 -> Data.Data.justConstr }) -}
eb50fc9251b9f977e839b699e41112f6
  $s$fDataMaybe_$s$fDataMaybe_$ctoConstr1 ::
    GHC.Base.Maybe GHC.Types.Int -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing -> Data.Data.nothingConstr
                   GHC.Base.Just ds1 -> Data.Data.justConstr }) -}
40105d2311c8278441fc398f1957b8a9
  $s$fData[] :: Data.Data.Data [[GHC.Types.Char]]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [[GHC.Types.Char]]
                  (Data.Data.$fData[]_$cp1Data
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgfoldl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fData[]_$s$fData[]_$ctoConstr
                  Language.Fortran.$s$fData[]_$s$fData[]_$cdataTypeOf
                  (Data.Data.$fData[]_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  Language.Fortran.$s$fData[]_$s$fData[]_$cdataCast2
                  (Data.Data.$fData[]_$cgmapT
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQr
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQ
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQi
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
08ac1cd3a8a0743ddabdcb78585e6e81
  $s$fData[]_$s$fData[]_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c [[GHC.Types.Char]])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c [[GHC.Types.Char]])) -}
89eacc7c6bcf81b54ef138e2ade89cbb
  $s$fData[]_$s$fData[]_$cdataTypeOf ::
    [[GHC.Types.Char]] -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: [[GHC.Types.Char]]) -> Data.Data.listDataType) -}
dca6050fdbadf93decada231ff9ac109
  $s$fData[]_$s$fData[]_$ctoConstr ::
    [[GHC.Types.Char]] -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [[GHC.Types.Char]]) ->
                 case ds of wild {
                   [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr }) -}
3f814121318049d279b9cf22955f95c9
  $s$fEq(,) :: GHC.Classes.Eq ([GHC.Types.Char], [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char])
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]1)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]1) -}
a0a199f374d97b13c0949793a76aecd8
  $s$fEqMaybe :: GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  Language.Fortran.$s$fEqMaybe_$s$fEqMaybe_$c==
                  (GHC.Base.$fEqMaybe_$c/= @ GHC.Types.Int GHC.Classes.$fEqInt) -}
1575f208d168bb29d6f3b6e83a1ec372
  $s$fEqMaybe_$s$fEqMaybe_$c== ::
    GHC.Base.Maybe GHC.Types.Int
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Int)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.eqInt a1 b1 } }) -}
69fb3a1bf38a9562155ff5a685fe7375
  $s$fShow(,)_$s$fShow(,)_$cshowList ::
    [([GHC.Types.Char], [GHC.Types.Char])] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [([GHC.Types.Char], [GHC.Types.Char])])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ([GHC.Types.Char], [GHC.Types.Char])
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      GHC.Show.$fShow[]_$s$fShow[]1
                      GHC.Show.$fShow[]_$s$fShow[]1
                      GHC.Show.shows22)
                   eta
                   eta1) -}
f7ee2c15819c2bf0dece4617faaee8a1
  $t1Mltq98siWa3rruNi69Dt1 :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataBinOp21
                   Language.Fortran.$fDataBinOp6) -}
5c7b0f855afeae15479f3f5ecd938d04
  $t1qnG2e03wKqFUA1PtIEn7e :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArg15
                   Language.Fortran.$fDataArg13) -}
84ac1931698b60505f9c99b138381a6b
  $t2bis2A5kzul0VB1cVHCnO4 :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataUseBlock6
                   Language.Fortran.$fDataUseBlock4) -}
14bbdac1b99f28d25737e57ff296f1bd
  $t3oO1tQaUZl83FvQJ4u6x1P :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataMeasureUnitSpec8
                   Language.Fortran.$fDataMeasureUnitSpec4) -}
6096b071af641ad74476e538a8864bd4
  $t5IBBfvIJazmGZ0AUBImoCA :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataDecl20
                   Language.Fortran.$fDataDecl4) -}
da5b52b65286fe4f556ac7013ed36ed8
  $t7VQWdGSfPYu9Iisks7pSs4 :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataProgUnit14
                   Language.Fortran.$fDataProgUnit4) -}
ccc05d64e2d113bbf01fdeaa1f265ff1
  $t8o5Js3295nS1yK5fWYpNml :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataIntentAttr7
                   Language.Fortran.$fDataIntentAttr3) -}
39842d18ddc911621c67d77e6f5ec99f
  $t8ooBCVvkUu0CFtmgl1DgHc :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataExpr20
                   Language.Fortran.$fDataExpr4) -}
948ac17f14b09b436f5eeb7356290bfd
  $t9wUW5raBQcVDAKDv14uNEd :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataSubName8
                   Language.Fortran.$fDataSubName5) -}
dd75fdb8d37b6a3ae8c440d40c33e4af
  $t9z7I6Har3E7EI0Bm9Hcn1M :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataImplicit8
                   Language.Fortran.$fDataImplicit5) -}
9bba63394ecf1756760400b89ba1dc6a
  $t9zwlS1ZPD8rGUQKFJ0pOs1 :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataType7
                   Language.Fortran.$fDataType4) -}
81f294671c0bdfb55fcead9affd86b86
  $tAYWq9LlwbwV5ZuB247N72k :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataDataForm6
                   Language.Fortran.$fDataDataForm4) -}
bd2d458b0033065376d1e494fdfbe40d
  $tAu5XAGgwqIJFgAQgfVhFZd :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataSpec44
                   Language.Fortran.$fDataSpec4) -}
a3ea60d24e09d38bfad76ba36e1cbbde
  $tCLEx3Oi2MB55JzB9GYZf6v :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataBaseType15
                   Language.Fortran.$fDataBaseType4) -}
ce9a28461346618fc500e1d4f443ff37
  $tD3uxCVrcHH32NBssdQhe1C :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataSrcLoc4
                   Language.Fortran.$fDataSrcLoc2) -}
000f0019e0dea2185078e83faa24d8ae
  $tD9QMegU2padFswPGA4PbPq :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataFortran44
                   Language.Fortran.$fDataFortran4) -}
e617dd816ae032a8894f0f1ab567c6ad
  $tGkmznj2VlO42PYwprZUrCU :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataBlock6
                   Language.Fortran.$fDataBlock4) -}
147320989376f46d382781c4bd891ebb
  $tGoaQjPIFzFlK8YmKo4dBNa :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArgName8
                   Language.Fortran.$fDataArgName4) -}
60e027b96f806a84705a47474787c411
  $tGrPxyCsDdGxJ0qjZk7a7Iw :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataGSpec8
                   Language.Fortran.$fDataGSpec4) -}
73eb4844c6a79c95b588391761b0aba8
  $tH4ixff6wOjR83m2qXz10ep :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataUses7
                   Language.Fortran.$fDataUses4) -}
de9c71646eb343a6a68aba6d41f1fe86
  $tHcv3IdLRyWt6uBs4pZDsWx :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataUnaryOp8
                   Language.Fortran.$fDataUnaryOp5) -}
8437e9eedd9170a2a0235cda1d079aea
  $tI9xo0NVFjIgHN2GbtIenwT :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataFraction7
                   Language.Fortran.$fDataFraction3) -}
3502d182b283fdef27f551a54ddbfd70
  $tIkp3PU8lbwe5Ja5bwBrN6O :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataAttr20
                   Language.Fortran.$fDataAttr4) -}
97bd49835ed13ed868f9a2b17296f198
  $tLKbbOeOd5coIUvDeDrohlQ :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataInterfaceSpec8
                   Language.Fortran.$fDataInterfaceSpec4) -}
cc9dd9e153248bb3eb810d1f5730b53d
  $tLUk6nnNjD0l6PtfmFqmXuq :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataVarName6
                   Language.Fortran.$fDataVarName4) -}
8a742e2f3df696b2145cb1818e38abe9
  $ta2TTLH2iFC1qRliXzNZGA :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArgList6
                   Language.Fortran.$fDataArgList4) -}
1174ba92c975d2270cfde97fa0268232
  $tc'ASeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1430663169351271444##
                   14831423806659498065##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ASeq1) -}
3c30bef5fe954e2166f6c1f574769a16
  $tc'ASeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ASeq"#) -}
e77cdc49f5c632789f7e78e9a0b32061
  $tc'Access :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17427988989052167623##
                   10847134855895069208##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Access1) -}
aec124d897d4d5f3815445ff73af3b58
  $tc'Access1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Access"#) -}
b80f9991525dec303275436d2bd84ace
  $tc'AccessStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4980230130294697334##
                   15485469474073404886##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AccessStmt1) -}
7f8cf37254389e84b52f66ad9f9da2f5
  $tc'AccessStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AccessStmt"#) -}
1beec5da83421bef1fdba6531b501c8d
  $tc'Action :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8057336795527682207##
                   16078626631217755940##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Action1) -}
d76e089730b068541cd2740515c814c1
  $tc'Action1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Action"#) -}
78a65f3477a57a8daa213a0b4f417330
  $tc'Advance :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6998976045090835637##
                   5451939738632365257##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Advance1) -}
10323b4c557f00567736cbc564afc8df
  $tc'Advance1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Advance"#) -}
ef3e2c054eceb8f6df943518f571a48b
  $tc'Allocatable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6742727601091219660##
                   13194843469481175427##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Allocatable1) -}
ab4ac0b5cdde6d00bd980b5237032051
  $tc'Allocatable1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Allocatable"#) -}
6032eb8352297fcbe5ce15c11c6eb4a9
  $tc'Allocate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11543305643231056020##
                   16063675490755885420##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Allocate1) -}
3dd8fda74ddf8494d5c3eed1bc01abbd
  $tc'Allocate1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Allocate"#) -}
3406cccd25406852158c56157fe3df48
  $tc'And :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4048942120175696995##
                   745228531087716614##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'And1) -}
72f0cf5460d3223597cecff8fb9570e3
  $tc'And1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'And"#) -}
a575a47e5fce601fbebdd8e72cbe15b6
  $tc'Arg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8424778287208876139##
                   8250628384707765253##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Arg1) -}
9d4bc3127ad95ba3cb613c65aef690e5
  $tc'Arg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Arg"#) -}
c10a6b812783ae9af36ed8f549dab821
  $tc'ArgList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5962186796357952784##
                   4648669446901938983##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArgList1) -}
ddba09054d8e3b76d518dbe3e7e5c530
  $tc'ArgList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ArgList"#) -}
16b4293f3e26fcc6f9cbe3bf35e2a736
  $tc'ArgName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14799275069218680431##
                   13814264233420484910##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArgName1) -}
ffa6fc9dac0182d7ac736084f82ada3c
  $tc'ArgName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ArgName"#) -}
cc5879dbb8a10655382bd21fef5b7bd3
  $tc'ArrayCon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2898142810574139460##
                   10036730011667769972##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArrayCon1) -}
c567c798f7e4211b80f9f61e07397205
  $tc'ArrayCon1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ArrayCon"#) -}
6b8faf5b7161fc7f45e786e96e765484
  $tc'ArrayT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1176004802943107701##
                   17875977301774460406##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArrayT1) -}
bbc76b54e459564d8928f58143b93e5a
  $tc'ArrayT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ArrayT"#) -}
15531646e9030125eae6c7b34c98f61e
  $tc'Assg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7215683918535987082##
                   4571441452025926409##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Assg1) -}
cecb23e3aee08189e35f97457dc92814
  $tc'Assg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Assg"#) -}
2b4e0c0d7a23c7db4c4ee4b1cd50e94f
  $tc'AssgExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17691451561763622535##
                   5025940141679131599##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AssgExpr1) -}
334cbba107e4138e5e9fdf590c9373b9
  $tc'AssgExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AssgExpr"#) -}
c8779d55b4bdef9baa4445a37bfda17c
  $tc'AttrStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16649380110814568978##
                   7589545053255107650##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AttrStmt1) -}
c522f0977a6b49074acda1b4654997c6
  $tc'AttrStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AttrStmt"#) -}
ea41aaed11b684f62cb63f2b14f580d7
  $tc'Backspace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12891997672952679622##
                   12154101790454008539##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Backspace1) -}
3cc71a524d474ed2faa2948d99719f0e
  $tc'Backspace1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Backspace"#) -}
714abb84610f5ed58ed79aa4caa561d0
  $tc'BaseType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17256277534187136751##
                   17250267982418825480##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'BaseType1) -}
bdc98c298e8ac380359f5fcf12cf649d
  $tc'BaseType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BaseType"#) -}
0590009d8642a1fdda32c3e778f713af
  $tc'Bin :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7239696061352443130##
                   15190423192325770331##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Bin1) -}
5c5fe21f513fdd0ea19a5982aa01658b
  $tc'Bin1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Bin"#) -}
8e9de7daa7ce4bd68292440e9acbc0a0
  $tc'Blank :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12786098772430356056##
                   7147211986003288958##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Blank1) -}
6f804ce1b346b924ebeb94611af8c942
  $tc'Blank1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Blank"#) -}
fd206ad7926d3cb8acfe67620896d5da
  $tc'Block :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2340734246067257221##
                   3808082874022095349##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Block1) -}
d585d6b93822ee18105be245896e10ae
  $tc'Block1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Block"#) -}
8ec029e773dcd455cd8f6e2a88181819
  $tc'BlockData :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5943884226468377047##
                   5927215796014706236##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'BlockData1) -}
364bf34ee4fe0be1d8048c7f63295e72
  $tc'BlockData1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BlockData"#) -}
4b035e085e86f294ca34692bd6f9992c
  $tc'Bound :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12227668862897588450##
                   4855304778765380491##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Bound1) -}
cfd5c6d04480a9bf808ea554e1a65940
  $tc'Bound1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Bound"#) -}
c702cdbfb8b38063ef0223c5311f7b24
  $tc'C:Span :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5447161017188369336##
                   11898638682319665683##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'C:Span1) -}
ab1c5618be7f16016809e6716e836b23
  $tc'C:Span1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Span"#) -}
192949ee70d10dceb19123f54f2a45db
  $tc'C:Tagged :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1337409234434465242##
                   492726471080052666##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'C:Tagged1) -}
ff359ed599cb63d0c55b98282f47f7ce
  $tc'C:Tagged1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Tagged"#) -}
b306a23bb37b43dd393179563dc30d26
  $tc'Call :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9678940379185050939##
                   14909980406755362056##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Call1) -}
de487b49af44761684b769d85c317e98
  $tc'Call1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Call"#) -}
d44028959a9c9318a680018b44752f0a
  $tc'CallExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12689534022657190081##
                   817493501046599182##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'CallExpr1) -}
afb507d21b1c3fd348804322b4529eb8
  $tc'CallExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CallExpr"#) -}
d9e1902f0b828e99752fd0e12d37cb37
  $tc'Character :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2734536977244340323##
                   9554671715671419039##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Character1) -}
f35449d974ed13907de8b1b8fe4bc7d9
  $tc'Character1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Character"#) -}
fd3f29e26abe0f1876131a00cd88da8e
  $tc'Close :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   159421999477974888##
                   6438575382052366315##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Close1) -}
630478468b3105815277d2a222f8d135
  $tc'Close1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Close"#) -}
5871d16b9038157dfa03ba7d0d7a26fe
  $tc'Common :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1887535897273478843##
                   13618268550542059313##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Common1) -}
d7eee204a0a3289a71c90e1d2f0d5f8a
  $tc'Common1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Common"#) -}
be4676f4aa0f21c9d550beee27b5a9b3
  $tc'Complex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7946070006447525243##
                   14182419496696272748##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Complex1) -}
5bc5f9fd2cf0ce0257ed8feea4772023
  $tc'Complex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Complex"#) -}
b9f7609b0ed94d008a0f8d2c364ea8ff
  $tc'Con :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12799553001583701788##
                   2730110052154576941##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Con1) -}
2172562fd105fd289e6ffd8219cffb77
  $tc'Con1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Con"#) -}
a45846af3291f96f8d2c283b390563f2
  $tc'ConL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8102401550233393326##
                   4016200454235873631##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ConL1) -}
f31947da7c19990add52e8b534fb586d
  $tc'ConL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ConL"#) -}
8a46c084477236cd4b5ff96c7581cc05
  $tc'ConS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11189555220482506584##
                   18174378520217833352##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ConS1) -}
aa4fa3208813ede1642c231cb905ab5f
  $tc'ConS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ConS"#) -}
9b9a07d45d2bcc28868d767165fd1d7a
  $tc'Concat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13895116663708088306##
                   2007742559325036007##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Concat1) -}
6d9b7a43a2f54ca8ef3998ecc9a8f52e
  $tc'Concat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Concat"#) -}
79d8230742480e8a20881fa69539c298
  $tc'Continue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11102472215678715470##
                   13904104310490697293##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Continue1) -}
d0847aaaaba888b36a3c159fb40d2b5d
  $tc'Continue1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Continue"#) -}
2165acefa3699b197ce1200708597dc3
  $tc'Cycle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13284486968581751546##
                   16156976485580199147##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Cycle1) -}
591273bbf96f35d4beafdef1caf1225c
  $tc'Cycle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Cycle"#) -}
aff3f6f3589a0bf7b071d4e224192579
  $tc'DSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6960074596785140410##
                   5873464244460323915##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DSeq1) -}
9b9ba4d02d03755f6fe26f6c1a125f5c
  $tc'DSeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DSeq"#) -}
35b9ae460dac5904c538065cfc78d0fd
  $tc'Data :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2851424163788406258##
                   3838986012472073127##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Data1) -}
eb03377b837f239f767e5a65cbac53a1
  $tc'Data1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Data"#) -}
9904619832af3af27fe6fd7be4454331
  $tc'DataDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9311167056441235391##
                   17753630900894167752##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DataDecl1) -}
f34a79d92cf7de261f8153e20fe7b5f4
  $tc'DataDecl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DataDecl"#) -}
4cf6f6dbd8aa7372276bafd7822460cd
  $tc'DataStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1368932127412345969##
                   17556421421907500935##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DataStmt1) -}
d4dfe3b81f7b2440a2cbb5bc5aed2f91
  $tc'DataStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DataStmt"#) -}
d6c338dee36b18e56ea4b8e45652e6b3
  $tc'Deallocate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11512379287678223431##
                   14799480753316436362##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Deallocate1) -}
a0a5c41cb9eacf9036dff9d5006b0d8c
  $tc'Deallocate1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Deallocate"#) -}
3e1f191e32dea29ca06391f0527aebc6
  $tc'Decl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11010633107448794031##
                   16461256608332517099##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Decl1) -}
be6e55a4f013a1d3b2d815fdc95d7820
  $tc'Decl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Decl"#) -}
92a9f383aceb98b899d2efcd6d400a5b
  $tc'Delim :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10244976877110782829##
                   13260562590054535577##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Delim1) -}
07dd49c1020e87840475ef0e5a35d553
  $tc'Delim1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Delim"#) -}
bca64026a56a459f6c71a0b8613a8886
  $tc'Delimiter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4953868808007244310##
                   5110493210599942821##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Delimiter1) -}
4433ba1470d11307ffe5e7c0225f4506
  $tc'Delimiter1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Delimiter"#) -}
4a7c1c7a5a5f986d1bdfdc1d39879e03
  $tc'DerivedType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5731943761711457154##
                   7877115118230703378##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DerivedType1) -}
abf8e16f159edeb0869d952f1c33825b
  $tc'DerivedType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DerivedType"#) -}
80daefff9e281fa5ea68d4b618e5fd3d
  $tc'DerivedTypeDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15106373511455520796##
                   17543768725266971271##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DerivedTypeDef1) -}
29882fad8ec7896fc7c331484b50f37f
  $tc'DerivedTypeDef1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DerivedTypeDef"#) -}
97e7d6d60b90483b00e5c384b3d38548
  $tc'Dimension :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17606495253386670717##
                   1734410751008347824##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Dimension1) -}
25f1e172498a1c661b2973fc626bd9ae
  $tc'Dimension1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Dimension"#) -}
20043ce99ca8451552afe3deec4c348c
  $tc'Direct :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11994903147964483813##
                   16538668638646611151##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Direct1) -}
8d10d4c98b18f708de6816c19fc2b331
  $tc'Direct1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Direct"#) -}
b08b4ef28963f7b9150305286c21e9ca
  $tc'Div :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9401976071952002943##
                   13355098546785136395##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Div1) -}
3b18a6f4953e0eb2fd67a848b556d34e
  $tc'Div1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Div"#) -}
70d0b794d5e7f79a2109b26be4da725b
  $tc'DoWhile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   838594234435454405##
                   4053220855284596414##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DoWhile1) -}
df8284d0d9d9297484dfd75a4193c288
  $tc'DoWhile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DoWhile"#) -}
d94d0b81d7ec1bcbedf55d866fb0e2d5
  $tc'ESeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16340697058947133933##
                   2130532602795523910##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ESeq1) -}
a0769f516fcdc99a9e351a9c685197f7
  $tc'ESeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ESeq"#) -}
cb4eea915e1d1d96a08293dc56c01ad0
  $tc'Elemental :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16335159515933241802##
                   6807280041699608621##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Elemental1) -}
0e921fe00d7e2e2465a184bc18dcce84
  $tc'Elemental1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Elemental"#) -}
177b65c962fa93e8dd11d6400fa6a540
  $tc'End :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7949571672346317650##
                   10503330753093602983##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'End1) -}
f08768f52b35501cfc9e45594420e27b
  $tc'End1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'End"#) -}
cbe391e85f98cc48dab1aedb2d2e919c
  $tc'Endfile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   499045527957393368##
                   10535555090247438977##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Endfile1) -}
5c5771d83ca368c04db8c8b39150bc8c
  $tc'Endfile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Endfile"#) -}
5c1779e126ad12115dcb785ef1e4cf0c
  $tc'Eor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9216260523517461795##
                   15613447335343628328##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Eor1) -}
322c0c7d0feac382df7e844f34b0f701
  $tc'Eor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Eor"#) -}
b55860ee772d793cfc287dfe6817e7b3
  $tc'Equivalence :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5859733700006610934##
                   4469530198253517554##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Equivalence1) -}
ec898399885cdceda02b69b2ab1dbf7d
  $tc'Equivalence1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Equivalence"#) -}
d085cb4196e940dd5b8d8c3daa2f36f4
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   939357049258776942##
                   14996238090388566217##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Err1) -}
d5de48982d2cecd8ad7cd06b3443229c
  $tc'Err1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Err"#) -}
552693fc65944ee38c326bac79f52fd7
  $tc'ExFile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14100379180562785208##
                   12148513372494547110##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ExFile1) -}
be69be8fe2bb0cd9090126b305def792
  $tc'ExFile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ExFile"#) -}
46729d8012848fa4fb240c60e7d93f5b
  $tc'Exist :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12447257212386177643##
                   16311305267334041958##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Exist1) -}
e1e3b17915f5017e44476d781cbe919e
  $tc'Exist1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Exist"#) -}
4347a0ac4fb42a2d520398f36c3dae68
  $tc'Exit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15034529003860829984##
                   9720232973744582128##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Exit1) -}
742725db5ea7929611f479a56c95a8b7
  $tc'Exit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Exit"#) -}
776e75c30b226f85da2ab59ddc667a4f
  $tc'External :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10254662166436904107##
                   14419590629362434702##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'External1) -}
550f1fd0ece62a004ccfb9bd3b2c1d97
  $tc'External1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'External"#) -}
00f2d38a945cdfca6149200ce1e4a2d7
  $tc'ExternalStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3967316904845829088##
                   17419818764260316233##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ExternalStmt1) -}
f07ed80aaed997277c9709dbfbabd8ab
  $tc'ExternalStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ExternalStmt"#) -}
32a649a4009841fd41a893af40b64f5a
  $tc'FMT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1979861947629449462##
                   14550277756911233788##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FMT1) -}
95cf764f083c7217b0122a58c7037e55
  $tc'FMT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FMT"#) -}
30a12d7f9f0b6a91d1c8ce4ae1fd2035
  $tc'FSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7032018497571248247##
                   8643490941712536709##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FSeq1) -}
69609a70f48007813d90b93837c8f44b
  $tc'FSeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FSeq"#) -}
53e77872be69423e4013542d3ddc8d3d
  $tc'File :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12795172934399739688##
                   6255799053914281314##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'File1) -}
a88f50f277fe244201f9ec4ac58c5567
  $tc'File1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'File"#) -}
e402cdf3573daabbdf8b80e59d2c8809
  $tc'Floating :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11964578434642930705##
                   8657083037679711653##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Floating1) -}
0ebab43d2df4f88e7d98b875a30a1309
  $tc'Floating1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Floating"#) -}
8e39ca60acc3f630841a78d5ca06c9c5
  $tc'For :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1449478764789572147##
                   6940007492307140815##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'For1) -}
cef5f997972ad116a327fd757bb67573
  $tc'For1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'For"#) -}
8b97c97f239ae3dc6f9d8444b78a1445
  $tc'Forall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   903645603127780277##
                   14402898448607657527##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Forall1) -}
7b78ac30d85fa446da9159924c7dd8e6
  $tc'Forall1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Forall"#) -}
b234cd4743fb26bb903f357487775c2d
  $tc'Form :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3191659402459979752##
                   5137622967931672300##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Form1) -}
60a411212aa93f1df242a62a3c80a7a4
  $tc'Form1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Form"#) -}
0699c3a2fee6e93e33a7e58538164c9a
  $tc'Format :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7817588906038065553##
                   4773366207698605634##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Format1) -}
6e7bd32d231fb35e979b53ae5c47122c
  $tc'Format1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Format"#) -}
823a0e1dd19fc67d0228f7c05c5e7972
  $tc'Formatted :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17849928435305499798##
                   6779164556233753063##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Formatted1) -}
14e32fecfaf7d22415fa3661462d3ed2
  $tc'Formatted1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Formatted"#) -}
4f48bc82a0040770c07ad2ed4861e9d0
  $tc'FractionConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12214436117059838720##
                   9604525603569636372##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FractionConst1) -}
eec4f44a92cf08e9b9df084f65ba73d8
  $tc'FractionConst1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FractionConst"#) -}
59b9604375e6e35ce22139bad5da3989
  $tc'Function :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15932923572255282600##
                   1380473790138901671##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Function1) -}
fd544ab7f94f058de9a841a1ccfe58a5
  $tc'Function1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Function"#) -}
1ec4fb2fa7367bc66b179633f74e711e
  $tc'FunctionInterface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   98272325473477072##
                   14802996522438111631##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FunctionInterface1) -}
7d2c099338b7d5fb96efef7b921bbde7
  $tc'FunctionInterface1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FunctionInterface"#) -}
96b12afd1059e2e7d51ffc6b01d3e5b4
  $tc'GAssg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10180508735591215944##
                   6171278344466298500##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GAssg1) -}
6f14186432df76fcbd74e74b2e050539
  $tc'GAssg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'GAssg"#) -}
0cf1256b75c9d786f2bfcf0b4523dca0
  $tc'GName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9483032079470950456##
                   13046416804590759247##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GName1) -}
27fdea64458d3dfe372c1b9353c36f0a
  $tc'GName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'GName"#) -}
be632b0437777005dadde88a5cb48cdf
  $tc'GOper :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12610379522328720229##
                   2174807797465879265##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GOper1) -}
bedbea1b9afd40e3f3a0f6cf48d2c6f8
  $tc'GOper1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'GOper"#) -}
c66c60bbf578c9bf0c52dbf24d0d5ed1
  $tc'Goto :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10116742045860949718##
                   10385614462642479299##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Goto1) -}
cfb828b4ee84b4977956a474041e820b
  $tc'Goto1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Goto"#) -}
e540d7b6ee725b752aa5e8b9538bdb44
  $tc'IOLength :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16382181006120063377##
                   4632338411139830144##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IOLength1) -}
aec2ac15adb28fa495f180405ebb91cb
  $tc'IOLength1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IOLength"#) -}
eea7730071320589f961f782846d3c60
  $tc'IOStat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18267806094648537409##
                   8289440068484178524##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IOStat1) -}
4f956ba812c90d98cd000f18f4ac1393
  $tc'IOStat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IOStat"#) -}
04e6e32043ab937067c849ff61d7af28
  $tc'If :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16553232921001331071##
                   9593438609313703806##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'If1) -}
35b68f86b9b4ab6ae2ee9db0ef3afe6b
  $tc'If1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'If"#) -}
97531064185acdc3f616c045063947d0
  $tc'ImplicitNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9028113633463009610##
                   9002396542370114185##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ImplicitNone1) -}
5849bbd992aac49275ff5b665b38b316
  $tc'ImplicitNone1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ImplicitNone"#) -}
9a33e91ea7c7ffe4d0ffa2ab75364e60
  $tc'ImplicitNull :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2656675398173063095##
                   13648186820347386164##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ImplicitNull1) -}
4256b48b309f479847d3ce6dfa844cd5
  $tc'ImplicitNull1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ImplicitNull"#) -}
d96db2fd359871942e25a9bb9c5751de
  $tc'In :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14319107252058522098##
                   4584312249679832946##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'In1) -}
1e8835c218a65cf3001ffb7b75836347
  $tc'In1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'In"#) -}
443f2e5d7a15758e26a731351ab85d87
  $tc'InOut :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12950299849800246190##
                   3192055734973335675##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'InOut1) -}
ec4c0f8eb8fb8e4d3d0c89aaaff41318
  $tc'InOut1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'InOut"#) -}
2a5bb433b6285754a6430748b8ea657c
  $tc'Include :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12064277285499959584##
                   146076729090347919##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Include1) -}
1f5313f454ae16a04a526b329c13c690
  $tc'Include1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Include"#) -}
b8fb2f32ecaebfa0605f78a300500040
  $tc'IncludeProg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12875014849865221249##
                   5640321063493961530##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IncludeProg1) -}
639862f639e33907afe777f3cd85ab50
  $tc'IncludeProg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IncludeProg"#) -}
0168628d92d8ed002e8d4e14d8cd5d72
  $tc'Inquire :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4193996544830801171##
                   339275500744183988##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Inquire1) -}
0e69c57a25b0694a03318fc68a91ce59
  $tc'Inquire1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Inquire"#) -}
6f950400381e4376231a422f8fa803d0
  $tc'Integer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13098358049099156658##
                   4913393095099630547##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Integer1) -}
0ffe20be647eaaf20fdc5a104d9ae087
  $tc'Integer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Integer"#) -}
e2096f18bf3c4345a54e5a92b94525c9
  $tc'IntegerConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2584219108722774503##
                   10772664335189080937##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IntegerConst1) -}
b225e29febbfb01f26dec07f0b800e54
  $tc'IntegerConst1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IntegerConst"#) -}
223a52dde40c92b335e1a731f391780f
  $tc'Intent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13115706059446527643##
                   2212505500306962278##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Intent1) -}
579826983c36701d2e3b1aac407c61ba
  $tc'Intent1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Intent"#) -}
ada112b4b24ee0e570ffb32f79e9c6e1
  $tc'Interface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12460917020206242497##
                   13115878671291564260##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Interface1) -}
007d9cba7fad6ef0bfa1925b10628306
  $tc'Interface1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Interface"#) -}
e309b7a31624d7315424a6b95e1c8da1
  $tc'Intrinsic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2501093132345901220##
                   10142753020317922882##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Intrinsic1) -}
90901965b2fb965c6bebef8085ed6acb
  $tc'Intrinsic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Intrinsic"#) -}
fdc5ee889887790cd85a041ecc509a15
  $tc'Label :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15628723305419340409##
                   18227662195544251574##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Label1) -}
53f77f77735f5969e6d633f8d761be6f
  $tc'Label1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Label"#) -}
daf7231c805ccd0fb987ecdc23c2b460
  $tc'Logical :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16715904333965354687##
                   12356902185932763875##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Logical1) -}
7169f5b5fb7b76949f1df303dfaef50b
  $tc'Logical1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Logical"#) -}
907d1da55fd6444b8e7e4b1438dd1223
  $tc'Main :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1540584118892841228##
                   9820498550831858342##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Main1) -}
c03fe3fc069769728486b04db89ec9bb
  $tc'Main1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Main"#) -}
309c4d5b012df9a6352315a0b6441229
  $tc'MeasureUnit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6312732046343882897##
                   14262772743420224177##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'MeasureUnit1) -}
5b21bd02f542a4a11eaf6aa7379807c7
  $tc'MeasureUnit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MeasureUnit"#) -}
c3315d863bd97e3a8418688fb73b610b
  $tc'MeasureUnitDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9495226604044870990##
                   16571451137990199932##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'MeasureUnitDef1) -}
b097577a427ce440c0889923cdd65480
  $tc'MeasureUnitDef1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MeasureUnitDef"#) -}
2c9495dc535d22cffca75f7cbf5f3486
  $tc'Minus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15009428916519561492##
                   9015530827211053601##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Minus1) -}
6acb6a1f7cbe10051e38e18acc719fb5
  $tc'Minus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Minus"#) -}
226d8ef9611ba153e08dd0f52967b948
  $tc'Module :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11833664315729229819##
                   5375975121000314977##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Module1) -}
c8db3c7fbb7a528816737e14b9e0bcf1
  $tc'Module1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Module"#) -}
6845e6fc57a818f644f354720ce3e6b3
  $tc'ModuleProcedure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3542150709300192606##
                   6120760146661617413##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ModuleProcedure1) -}
1ca744c153bc8f56b568047005279f0a
  $tc'ModuleProcedure1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ModuleProcedure"#) -}
a930ecf05eb70e1ef5bdae6e778f9a9d
  $tc'Mul :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   931573833048428520##
                   6918955569629496240##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Mul1) -}
fffb41078ba48602c573dc7a71874919
  $tc'Mul1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Mul"#) -}
c8f721e40941e4390683319f2d20f3ea
  $tc'NML :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7617966598082998418##
                   3221325863908274995##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NML1) -}
f3545c45f4c540bb4ce3bce2de66c83a
  $tc'NML1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NML"#) -}
8d6d9be00fa84f5d5bd36861dd79a803
  $tc'Name :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14475245514668979577##
                   1854946028501334183##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Name1) -}
c1d151f24cbdc9be29cf8ffb76ee5afb
  $tc'Name1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Name"#) -}
0dc444637203e38b157e6bf644eb5c44
  $tc'Named :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9544754146436858111##
                   3441305979048111811##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Named1) -}
7e3493cf772a7859c9e268afecf5a1cd
  $tc'Named1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Named"#) -}
90285f2e8b3798852bba84803f3bc3b0
  $tc'Namelist :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1891170241788160322##
                   15167549447500206667##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Namelist1) -}
4447a9c99d36b9ba40a6712de59954fc
  $tc'Namelist1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Namelist"#) -}
b5e0f8d0e5b462477bc84b81089b4f84
  $tc'NextRec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10407687404225168473##
                   8666056460410561092##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NextRec1) -}
c7220e551d3385db9d9ce7e61ccd1614
  $tc'NextRec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NextRec"#) -}
39c717298ccc8248089ee1b77cc4879d
  $tc'NoSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14749878069797111483##
                   8827084479489752527##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NoSpec1) -}
0af60aaffd1aa72ec18d967bbc976442
  $tc'NoSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoSpec"#) -}
26b8499b15c882273054d70575c73d2c
  $tc'Not :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11227611300523277643##
                   12838589015644858177##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Not1) -}
4a23227a9740b3fb96bd2bd35a1d34db
  $tc'Not1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Not"#) -}
2154bc5def826907f6e5f501198e50a6
  $tc'Null :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2086356649817584771##
                   9470156864440600389##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Null1) -}
ceb08d1e62239fdb32255885a119a60d
  $tc'Null1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Null"#) -}
c25ed266082a72fe0db264184702323b
  $tc'NullArg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1725560960270008434##
                   16226134793641039461##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullArg1) -}
dee4528c3b4520c719ccd78306d159e8
  $tc'NullArg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullArg"#) -}
75e47a136c4da867a7e7d85421c3751a
  $tc'NullDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11229691958030565106##
                   12416830227461092088##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullDecl1) -}
06a5649acc2cc30ceb0ead840916aed5
  $tc'NullDecl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullDecl"#) -}
6c1e27c184305ed3a031457a33560e89
  $tc'NullExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10275295123598133481##
                   14106474797233116500##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullExpr1) -}
712fe899cc8bd3ca9d2f65ae8ca1f197
  $tc'NullExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullExpr"#) -}
dc873b4e4df7f4d098d37752dacb9ff7
  $tc'NullFraction :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11864352029024753180##
                   3283160202870193375##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullFraction1) -}
54076967036d1737da07c0a184cecc90
  $tc'NullFraction1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullFraction"#) -}
0e0c5236fde7f93396cdccb64b213ebf
  $tc'NullProg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4768811136234876714##
                   11979074723627454846##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullProg1) -}
9b55ecf0433406443ad661cf9b8c2246
  $tc'NullProg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullProg"#) -}
d2c8dc123c1db556dd55e2cb0c2ec1c7
  $tc'NullStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18336300892362812829##
                   5639687648863890777##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullStmt1) -}
9f3e33f87fed9e45ef864fb03a82f3c4
  $tc'NullStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullStmt"#) -}
46c774481f5152ba6d92e75836fe3034
  $tc'NullSubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16671739221562042451##
                   2612373742199624713##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullSubName1) -}
17982351abec77efd87906421854645d
  $tc'NullSubName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NullSubName"#) -}
f453a8b4d28bd30699fc5cce48392288
  $tc'Nullify :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12052713501940834772##
                   9042426267564701535##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Nullify1) -}
afffe3565b473e0a15d0ca42ab602e98
  $tc'Nullify1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nullify"#) -}
5c3928ac38f7de327a7f98e0d80222f2
  $tc'Number :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4198321350956379350##
                   14540908598440232859##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Number1) -}
51059ddef3bacfa0f665f2148c295678
  $tc'Number1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Number"#) -}
8b5bba3ef31e393e17f65c3989959c75
  $tc'Open :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1574288794461443667##
                   11648231366901293958##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Open1) -}
315c943d4de5c1e6abe187a51516cb07
  $tc'Open1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Open"#) -}
53ad89e028c43df98172612759627f06
  $tc'OpenCLBufferRead :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3973145859955440763##
                   12922290647039750530##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLBufferRead1) -}
22d5b6fd290c10c9abe9c49d001c1313
  $tc'OpenCLBufferRead1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OpenCLBufferRead"#) -}
ed01f2f7e8be7fd4e789a30ce692f0ef
  $tc'OpenCLBufferWrite :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4859502872388821390##
                   17846060313801386337##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLBufferWrite1) -}
6a445078a37b3674e3385a12af03cb6f
  $tc'OpenCLBufferWrite1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OpenCLBufferWrite"#) -}
1ff193c1738bd882445cf2febd2aa84f
  $tc'OpenCLMap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10004538105895150856##
                   17677281585851374348##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLMap1) -}
6b526ce1e07b37015ecaed7e495486b8
  $tc'OpenCLMap1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OpenCLMap"#) -}
0123ca68cf0e579e86675005ae9f85ea
  $tc'OpenCLReduce :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10919186707943993810##
                   14776898213153942152##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLReduce1) -}
3aa9507cabb9a8a666976b2dd45f4e6e
  $tc'OpenCLReduce1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OpenCLReduce"#) -}
26a87b3d56f60e7aacdb9828ba0d5f07
  $tc'OpenCLSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1852927694858316##
                   17203109370244805392##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLSeq1) -}
9987792e533f04027c138d6ccffbcb91
  $tc'OpenCLSeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OpenCLSeq"#) -}
237c8d82f786c31e0a152ca47a039d0f
  $tc'Opened :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3484187209979491142##
                   15785782046077458394##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Opened1) -}
7d0ea42dda5b899984d2d10683dce80d
  $tc'Opened1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Opened"#) -}
8114ed918d343c9b97cb86cbea74455d
  $tc'Optional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9853142971915872611##
                   14423394680090532020##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Optional1) -}
42375d89355e7e79075c3247abaea2b2
  $tc'Optional1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Optional"#) -}
6172f1f94b830e20f0b4197b1f502146
  $tc'Or :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13483110816970746976##
                   16405330319381048741##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Or1) -}
8a26391bab03454e6ba7b203e6c32fcd
  $tc'Or1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Or"#) -}
2804e23a9f1f0f63fe043d853968cbae
  $tc'Out :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13556918784003176097##
                   16130282206478827334##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Out1) -}
a38bc77ac4f272f7974da90720065b4e
  $tc'Out1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Out"#) -}
2b3aff0c6020cf152e2c79dce5a94890
  $tc'PSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1024941755830270233##
                   12053154522857665260##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'PSeq1) -}
1be3eaec985cba1e1dd9b4574d6e94a1
  $tc'PSeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PSeq"#) -}
09fab3c10bfaaf1938d5adf7a4fddf4d
  $tc'Pad :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6092372941448229498##
                   2108015858228889266##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pad1) -}
da73bace23775891372007a8ff88ea40
  $tc'Pad1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pad"#) -}
00c40315cbdd197725a632838de24246
  $tc'Parameter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9541067203100961049##
                   16976851097945321117##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Parameter1) -}
d7753087306d83b393f247de300ae2be
  $tc'Parameter1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Parameter"#) -}
9a04be97ccbf0d2db57da1606395ab19
  $tc'ParenthesizedExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4463899863532581039##
                   7220650110277326209##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ParenthesizedExpr1) -}
c6802b291c47f0f6e823cb92fc07c2a2
  $tc'ParenthesizedExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ParenthesizedExpr"#) -}
7a836656aecd8d5575a404ca043dc52a
  $tc'Pause :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2115407901264392278##
                   4348440044910694591##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pause1) -}
39043b286fc213ea2bea4c6edf16c906
  $tc'Pause1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pause"#) -}
a994a2bf0b08ae565ff798e31f8bf1c1
  $tc'Plus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6478315461126133596##
                   12330827883812469027##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Plus1) -}
2ddadf526cc2674eed6b6e2215044282
  $tc'Plus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Plus"#) -}
ac3f359a1981b6dc913b1bc92efd8372
  $tc'Pointer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   163016874754991098##
                   12257843113322278603##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pointer1) -}
b882d0ea8bbe2ab8b802ac236e0b04c2
  $tc'Pointer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pointer"#) -}
75993b682dc0b895b00885ae86ddf095
  $tc'PointerAssg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   332672349116735666##
                   3924740247105626070##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'PointerAssg1) -}
bb0cc84d34d7708a9fed8b1d49b5498e
  $tc'PointerAssg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PointerAssg"#) -}
dc9d210b2f596ae765beba500bef57ba
  $tc'Position :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10100159120083452603##
                   6415744455385794983##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Position1) -}
95cfceabc437b5293a324578e446f841
  $tc'Position1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Position"#) -}
b9e4fc185718f4859aa393c59d0027d3
  $tc'Power :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12195705897700916393##
                   2157602813655024085##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Power1) -}
70e5c7be4e37bdbc7cf8e33c81a845d0
  $tc'Power1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Power"#) -}
cbec29a005fb635f35c6554d655a1915
  $tc'Print :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8007491298278916303##
                   8456913078777502352##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Print1) -}
1edb339cf565e65bda4b02990c4f38aa
  $tc'Print1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Print"#) -}
fe0d7f810cbbec10723301679eae5847
  $tc'Private :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2713423166370794959##
                   3787236859187988194##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Private1) -}
7bc8cecf0864cff484716e3d07169335
  $tc'Private1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Private"#) -}
196a089aef581816bc5741bdc28136d2
  $tc'Prog :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1410879304477244110##
                   3237013506933422683##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Prog1) -}
33fea4b32e1e6f4ff9f1e1a243ea7733
  $tc'Prog1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Prog"#) -}
8afb48965e6ec322358848e904d6cc39
  $tc'Public :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1298230817489747128##
                   15167488385054384333##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Public1) -}
15f856d03ea55539ab68b26ed2937184
  $tc'Public1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Public"#) -}
2b21cc472a3f38e1e4d9a91655979954
  $tc'Pure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17202502438536778756##
                   5183086480965602822##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pure1) -}
40cc21e5a8a20cb55dea5ac5b12603d3
  $tc'Pure1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pure"#) -}
0683f4a878a3505eebc438785f8336eb
  $tc'Read :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12851796668544667478##
                   8571278704095528074##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Read1) -}
d3512f38ab39ebb59134342f841402e6
  $tc'Read1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Read"#) -}
e6f29a5595eaca65845dc5451f9cfd95
  $tc'ReadS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9831625657963751829##
                   12580987348485652861##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ReadS1) -}
c4610d4533994b70379b6f55cff0b0ea
  $tc'ReadS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ReadS"#) -}
121a356041dec916e490d45bfae3dd02
  $tc'ReadWrite :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9784805536088526238##
                   13248645820484975224##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ReadWrite1) -}
9f1314319a99fc7fe5574f5bbbdd79ea
  $tc'ReadWrite1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ReadWrite"#) -}
4e57b62491951ea8481803a31a8bb9e1
  $tc'Real :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13369435194480308742##
                   12087736652296269679##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Real1) -}
b0e7936414230e7c101bab45ea09ea9d
  $tc'Real1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Real"#) -}
47d1304af667fce43033225b74026d67
  $tc'Rec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10415619390480636540##
                   11923713962123085305##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Rec1) -}
3d2c6da177dfca44e9a4659e45fcaf61
  $tc'Rec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Rec"#) -}
d89763a9b69caeb45c4415271b48fc22
  $tc'Recl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   183067147385123338##
                   12595649448907502557##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Recl1) -}
0a27bdd7d0dfc084cdb4102351527da6
  $tc'Recl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Recl"#) -}
65dc85a8e7001281ba598bf9695c7dfa
  $tc'Recursive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6029336876022794470##
                   7916488544328407305##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Recursive1) -}
8d3c4c8d77cf6e619c2952ab39ba96bb
  $tc'Recursive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Recursive"#) -}
b2fd9bce53b4cb03f4e3072fb5cc763d
  $tc'RelEQ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7268392025601455674##
                   5864718225406221657##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelEQ1) -}
3f0628e5d39663f9c0c373b034a7aa5a
  $tc'RelEQ1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RelEQ"#) -}
e53420b88e07bdd32ce6b39352d8942b
  $tc'RelGE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6552332047468529921##
                   9926520484282999128##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelGE1) -}
fae483869ceb743aa1c1e03bb88f159c
  $tc'RelGE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RelGE"#) -}
5d2b53305ee118bbac939553f5be1e8d
  $tc'RelGT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11726749783336937185##
                   2587507694231342657##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelGT1) -}
449cb33e60ce08917169371352816ca5
  $tc'RelGT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RelGT"#) -}
ca4c7c1098ef8cd4894bf9595f6e67ce
  $tc'RelLE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2636466848139454357##
                   16926108920722320016##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelLE1) -}
1a963d61f6ad8850769be7a4427c7187
  $tc'RelLE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RelLE"#) -}
32e83a2da419ec83bbf4a2df275e915e
  $tc'RelLT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17109384265848613775##
                   11939843782641449330##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelLT1) -}
47f4f9d9b4976f807deea52e34e63356
  $tc'RelLT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RelLT"#) -}
0d26ccecca1d10d071091a1bbf1826ab
  $tc'RelNE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12341956889124870890##
                   15446299473537682784##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelNE1) -}
4820abe77d65cfb026f18b33c6981ca0
  $tc'RelNE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RelNE"#) -}
48f9cc3aee8d014b46548a2f85fbc9f9
  $tc'Return :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15341635806137837705##
                   11122345828881818383##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Return1) -}
1b8c490e34fda4ca171651774c429ae1
  $tc'Return1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Return"#) -}
c4dc9868a2a015e45e237304a2e7e090
  $tc'Rewind :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12030621411618994050##
                   1226948661621481293##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Rewind1) -}
7d5b026d093afd0837498f6829165957
  $tc'Rewind1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Rewind"#) -}
c2972725c125e1449126da4c506d9dd1
  $tc'Save :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7376184218445029686##
                   4201503001806864061##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Save1) -}
8cb626634c1db70f6fff1e3fe9e171b7
  $tc'Save1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Save"#) -}
96429fafeb20d7e58c523da0f22bc8cd
  $tc'SelectStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7528922671575497430##
                   6018042922653170229##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SelectStmt1) -}
ed546192888bd168927bf97d930151f2
  $tc'SelectStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SelectStmt"#) -}
cb7ea2d02c6a0d083ec696626cfbf1f7
  $tc'Sequence :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16590429394629151721##
                   14254247535551016803##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sequence1) -}
a704f6bce2f71ce90190010dd54b59fe
  $tc'Sequence1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Sequence"#) -}
3a7ec09f5fe7d8547ca6ed98b03e1994
  $tc'Sequential :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3492048831786927350##
                   1097594410048069314##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sequential1) -}
59cf1ade09ef7e685c40ea16301a6c92
  $tc'Sequential1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Sequential"#) -}
952efd5f0063e3db05e9f9531d1a7400
  $tc'Size :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1204336623527660376##
                   1441333287371107217##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Size1) -}
e97a2f8a4bd7ca1dd3d5825473e6f3ed
  $tc'Size1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Size"#) -}
2fe24f71d61ccec7fe94b3bfe22f71e7
  $tc'SomeType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5048189699893337501##
                   15656523050286967475##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SomeType1) -}
1ce0fd34f45183fa55e5da43f583fbc7
  $tc'SomeType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SomeType"#) -}
dc10896e5f9f638b6e547c365efeba52
  $tc'Sqrt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3244421798010361706##
                   7689121999848029938##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sqrt1) -}
f3fe977b6fdf20943ef068d0d6866e2a
  $tc'Sqrt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Sqrt"#) -}
bb1fcda19d38cec71373c83ac4afd1c3
  $tc'SrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6564248150725249765##
                   8767179671154035593##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SrcLoc1) -}
761143cef525577cdd408879d540622e
  $tc'SrcLoc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SrcLoc"#) -}
7611f258e5b0a7df8ea93aa542da9346
  $tc'Status :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18158487272079532932##
                   13629637238022100967##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Status1) -}
93ff46e0fc98a8d79e5a54a03e45b3b3
  $tc'Status1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Status"#) -}
5c9614a681b28c591adefd79b84004a8
  $tc'Stop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7485142865699076713##
                   11245716360633717538##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Stop1) -}
0acbc99240416a6bbb5fb5a244a636db
  $tc'Stop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Stop"#) -}
08af2da3fb271c019269460eeb92a069
  $tc'StringLit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3898676927152297791##
                   1670374109575213983##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'StringLit1) -}
8031bb2d791a89da035b4140d537eb14
  $tc'StringLit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'StringLit"#) -}
75332d228a8c697421e5aefe252cb294
  $tc'Sub :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9431123953424818915##
                   2652008098758186374##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sub1) -}
6dc2e7826125bec7dd659f96a15f8375
  $tc'Sub1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Sub"#) -}
810c9c35e744f102181d66fd31375cfd
  $tc'SubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12154576836730845508##
                   5380600756926478241##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SubName1) -}
40a2d9b4280de7c8a7a906fe11e9dcf7
  $tc'SubName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SubName"#) -}
f242a9ca7ad01d4e6e414c35860ebed7
  $tc'SubroutineInterface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16495190428053349464##
                   9626938628537016920##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SubroutineInterface1) -}
79b9b976ac24223bb2b78e8ad8f89f3e
  $tc'SubroutineInterface1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SubroutineInterface"#) -}
2d10f840a42f968719b39d61c1716472
  $tc'Target :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8836156527070093176##
                   17187963376519512957##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Target1) -}
f4e61327f4fb441628b95f4154226173
  $tc'Target1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Target"#) -}
13a8d3494447184069cdd4ecd65801c3
  $tc'TextDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   998471510000206180##
                   13246262958909818767##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'TextDecl1) -}
b8db2854b4253eb49307bdeb7b9dc744
  $tc'TextDecl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TextDecl"#) -}
e02a9e2d59e3aac993619fbe731a4401
  $tc'TextStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8951367410252054710##
                   18289473463362738981##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'TextStmt1) -}
373a777c139ba4f2dc0c56898289a883
  $tc'TextStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TextStmt"#) -}
5a3d7c521fbb579102d6a847d1a0e6ad
  $tc'UMinus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2027684103530894054##
                   15062005542769835491##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UMinus1) -}
0ac3bded86a681131177892d0db9ebb6
  $tc'UMinus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UMinus"#) -}
73bcd1899babee8617d99a02409fed5b
  $tc'Unary :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15346093399270849627##
                   6667387749729639847##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unary1) -}
21b1137d4048d1a74936fdd432703a80
  $tc'Unary1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Unary"#) -}
deba95e2ac3d6a4f4e1cbf2695440951
  $tc'Unformatted :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6012744213495838713##
                   18262586213625417704##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unformatted1) -}
74fc9aa8051b3c1fa5d770a2e060d75a
  $tc'Unformatted1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Unformatted"#) -}
dd7dd50cf3aef47aecc1d822f7f017c4
  $tc'Unit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7584482862223681968##
                   5436468401219547601##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unit1) -}
ac628bbbe1857315ae2c9f1cddcd733b
  $tc'Unit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Unit"#) -}
78001f6be846387bf6fe3f72c0ff7117
  $tc'UnitNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17965947979946671134##
                   13584815321258908768##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitNone1) -}
21cf8556136c5b85a00cae1857bf17a9
  $tc'UnitNone1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UnitNone"#) -}
dd3c5e16ede3819a73cc3a86458aa3e4
  $tc'UnitProduct :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16446143605249493460##
                   10776656954891131791##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitProduct1) -}
738085eeaf0441c1c55525845fc07389
  $tc'UnitProduct1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UnitProduct"#) -}
bfb6840a55758cd5f4cc94b653dca251
  $tc'UnitQuotient :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15402029286761530018##
                   3600225496793726596##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitQuotient1) -}
f9d3ebcb2f24729ab10a646367a23c14
  $tc'UnitQuotient1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UnitQuotient"#) -}
72073501ec5db844548bebc3aca73caf
  $tc'Use :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6241970182427794105##
                   13063702831416202682##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Use1) -}
edd3967fcdc535c1487ea297944b8266
  $tc'Use1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Use"#) -}
5cf1fe1de2fb02616bd44fe47dde51e0
  $tc'UseBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13502697146736995697##
                   6802623418634846570##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UseBlock1) -}
6f5716086cca7aee23eb74da1db39214
  $tc'UseBlock1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UseBlock"#) -}
9a758d300da0ba068a06e7979f07ff4a
  $tc'UseNil :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13317345995133545112##
                   11264609075842242485##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UseNil1) -}
66d82f8cc6cc2e498210dca17e9e1262
  $tc'UseNil1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UseNil"#) -}
24b4a068114789e721961d37a2ac248b
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   577704936971081207##
                   9257602848704298400##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Var1) -}
111e779698c72fd1f35f5589d04341a0
  $tc'Var1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Var"#) -}
b814da287bb89bd439d646ac71095741
  $tc'VarName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11333846943832533658##
                   6633556995182460403##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'VarName1) -}
d756e4bc6c94d7da2c75d2d0b171ebfb
  $tc'VarName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VarName"#) -}
098400ed226b1cee457dcc4197d96e8b
  $tc'Volatile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6575157594135875392##
                   6785387708861431243##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Volatile1) -}
d9996085abc7f94b5dff936080abadb1
  $tc'Volatile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Volatile"#) -}
1f1394eeaf633e9f92d9359d561fb642
  $tc'Where :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5727139825186087067##
                   2727237431235856492##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Where1) -}
b24f090cb32815bbf9a1b9d08e9c59e9
  $tc'Where1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Where"#) -}
79624188488a55194aeb8b5e0a3cc267
  $tc'Write :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13524968075640907647##
                   11894693647771032634##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Write1) -}
1ba3224dabc3a47aa89356adeb56a3bb
  $tc'Write1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Write"#) -}
d8d7350de03a862879c583594588906b
  $tc'WriteSp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17590220674950812719##
                   7033353948841276211##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'WriteSp1) -}
762c3c56ba182889d46772f19e5c7603
  $tc'WriteSp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'WriteSp"#) -}
24732330f3be34917fa2a49e5bfdfd50
  $tcArg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11297984408639489004##
                   15999878566552054401##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcArg1) -}
e396f3e6636d5b302c3599ace16341f3
  $tcArg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Arg"#) -}
8fc1aedebe495176476d2d07c08f5286
  $tcArgList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17085691833968039316##
                   4384770729493771167##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcArgList1) -}
c06b0a9afbd37bc7721eef7b6575b652
  $tcArgList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ArgList"#) -}
70fdc67987a1c79276411749a698e05f
  $tcArgName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9242974714316311215##
                   9957090134460514018##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcArgName1) -}
5cef3a44658b702ef3d40b926af33719
  $tcArgName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ArgName"#) -}
14b6bf59bdc2aef1731d6682aa9955d6
  $tcAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9037790331881822576##
                   12484905115659523528##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcAttr1) -}
25bc73d73fe515dea12e828f1c927fda
  $tcAttr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Attr"#) -}
e4f45199d04e182bfd7b21e48d9e950f
  $tcBaseType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1260076333345940747##
                   10788170460963483881##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcBaseType1) -}
329d01942d621ee8fc275f5d4282e7bc
  $tcBaseType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BaseType"#) -}
fe8fdadba60500b674d6b1d936a7e692
  $tcBinOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1845785492847154914##
                   6631801608391496845##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcBinOp1) -}
2fb3ba3959f6477bc5aa93b21fe9315b
  $tcBinOp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "BinOp"#) -}
52d5042e5fbaf10dc91858cb6e7263e5
  $tcBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8622183916436018781##
                   7917166659374511045##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcBlock1) -}
5a8e982eb6ebcefd0e502fd44704f76a
  $tcBlock1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Block"#) -}
954fda127eb52e4c3677464fd93e98c3
  $tcDataForm :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9284199641136566210##
                   5278240442727744153##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcDataForm1) -}
d914940654a6876b41e477c1e2451173
  $tcDataForm1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "DataForm"#) -}
9662494c825638a2b6a5d48dba02301a
  $tcDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1333565254055508066##
                   2348454038217729491##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcDecl1) -}
97415ed0ca2d638af7d2baccda1b8ec7
  $tcDecl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Decl"#) -}
0a586c1fde93d50dcf1105bf9b95ac98
  $tcExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13621902738272893592##
                   4484539928315244892##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcExpr1) -}
87e7573c91433ae64a19c17310f2cc90
  $tcExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Expr"#) -}
4144af81a75c152e2e545d1e38a57af9
  $tcFortran :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6882220124880764793##
                   15271875958298145102##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcFortran1) -}
9c3c5096bbe7db39f5a345d17c03a48a
  $tcFortran1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Fortran"#) -}
53b8432ccdcd7a82e15efdd98313e25a
  $tcFraction :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17714422405102536858##
                   17389403018657959412##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcFraction1) -}
1da37ddd2806bd5c5663a1108336bb5b
  $tcFraction1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Fraction"#) -}
22967d32d48c31b6dcfb056176e5601c
  $tcGSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9862831229811979126##
                   9644970275925022743##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcGSpec1) -}
2ac90915bc5213e0eda6ec768f9ed563
  $tcGSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "GSpec"#) -}
5ebbb9a64ec6fdf7b2a58c8641c33d40
  $tcImplicit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   798838976179940601##
                   18248231120233087656##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcImplicit1) -}
f2696ec17cda42767547b13475673066
  $tcImplicit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Implicit"#) -}
5453f1b103f3f0f2d153ba75d79d36dc
  $tcIntentAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7948506444303774333##
                   4885414271858797651##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcIntentAttr1) -}
566c1bb12e4e655183ac271428c2c047
  $tcIntentAttr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "IntentAttr"#) -}
73ba0a3e6400d8ecc4bc1af5ba634a31
  $tcInterfaceSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12927311303432418960##
                   10842732309658907923##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcInterfaceSpec1) -}
33bb81ac8c1d02a685af19362f9382d6
  $tcInterfaceSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "InterfaceSpec"#) -}
2991d3dedcbb1d38394d018046bf316d
  $tcMeasureUnitSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12909754064354899##
                   16261568203038643638##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcMeasureUnitSpec1) -}
1c9c2a919e68d2614ce66c23fc34ea7a
  $tcMeasureUnitSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "MeasureUnitSpec"#) -}
45066e6abc5d40ac128b2c9ae8ed5710
  $tcProgUnit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10056753431434216976##
                   6055604396548152995##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcProgUnit1) -}
67f959934cab5943243d6e8c45de1461
  $tcProgUnit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ProgUnit"#) -}
00145c129115e6bb3eed0fa929d6d7bd
  $tcSpan :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5821331303947423472##
                   9719847090265327304##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcSpan1) -}
b5850e474a32f9086a3fc46c7a9438e9
  $tcSpan1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Span"#) -}
f75a8274d260e5285e5656e3a97096a8
  $tcSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9675708239615344341##
                   9600527172562018424##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcSpec1) -}
09ecf1768bfab3af3a8438a34af1f9cb
  $tcSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Spec"#) -}
530039f0d7fea6430744f0c330b9e64c
  $tcSrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3080101248344241265##
                   5859815666103468669##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcSrcLoc1) -}
ba155bc8d99d4d9e6930530cc3875509
  $tcSrcLoc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SrcLoc"#) -}
0e4bc4e1c8ff79f7900f9d4a0cd813c9
  $tcSubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1824721943276726566##
                   8805268855664748890##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcSubName1) -}
4e993ce12c30e6ea7ce1b032dcb5d809
  $tcSubName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SubName"#) -}
348488b6b9ef23c94b6034eb2262811d
  $tcTagged :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10129301192653241482##
                   7140878356493264080##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcTagged1) -}
1dcfa6aa967197b4942a035c42f92f1d
  $tcTagged1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tagged"#) -}
936cab3cc9c6aa622689db2f31ef024a
  $tcType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1220767263731147235##
                   9614101381113798831##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcType1) -}
eb6185251aa71b3647aad4404afcfbc8
  $tcType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Type"#) -}
a69f55932cbb7b647918212e15fd8f6a
  $tcUnaryOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6152895793842022613##
                   3913372895388833325##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcUnaryOp1) -}
5ef8a5dde8e3db09c9d578af0cc78f7a
  $tcUnaryOp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "UnaryOp"#) -}
9ad999893a18489bc89486da27d99513
  $tcUseBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9533103736263371791##
                   3422293205816457763##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcUseBlock1) -}
90e73383b4b55b8c37bc0ada00c45423
  $tcUseBlock1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "UseBlock"#) -}
c4d922800076cd7d7b16ec16525f9801
  $tcUses :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4363150290659116846##
                   4164391352706304496##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcUses1) -}
447427cd4f151d2993964e1ad9c755e8
  $tcUses1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Uses"#) -}
c363aba06cb34590abcf001da5383f30
  $tcVarName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1672502290831751764##
                   46662296866082288##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcVarName1) -}
d344faf4a84644791ac77c734ef04aaa
  $tcVarName1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "VarName"#) -}
4fb9c211a93d66d99d0c59faf6f4a993
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.Fortran.$trModule2
                   Language.Fortran.$trModule1) -}
bef4ecb3e505d5fc0fdd734625a6d06c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Language.Fortran"#) -}
33545f026e4d4b8da5ea7b378bffbd37
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
85499ec5139fcd3561e162d1803180a9
  $w$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U(1*U,1*U(U),1*U(U))><S,1*U><L,1*U(1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc)
                   (ww2 :: Language.Fortran.Uses p)
                   (ww3 :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of ww4 { Language.Fortran.SrcLoc ww5 ww6 ww7 ->
                      case ww3 of ww8 { Language.Fortran.SrcLoc ww9 ww10 ww11 ->
                      case GHC.Base.eqString ww5 ww9 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case ww6 of wild2 { GHC.Types.I# x ->
                           case ww10 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case ww7 of wild5 { GHC.Types.I# x1 ->
                                case ww11 of wild6 { GHC.Types.I# y1 ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x1 y1) of wild7 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True -> GHC.Types.False } } } } } } } } } }) -}
c196aef1222e8f6b36a888adb596c505
  $w$c/=1 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.== @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString ww1 ww3 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
6f87f9338b274d2aaa27f44ff7083965
  $w$c< ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.True
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$c<1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.False }) -}
e9c8a115e74e8f88ce38a01e4822c8ec
  $w$c<$ ::
    a
    -> [(Language.Fortran.Expr b, Language.Fortran.Expr b)]
    -> (# a, [(Language.Fortran.Expr a, Language.Fortran.Expr a)] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: a)
                   (ww :: [(Language.Fortran.Expr b, Language.Fortran.Expr b)]) ->
                 (# w,
                    let {
                      f :: b -> a
                        {- Arity: 1, Strictness: <L,A>,
                           Unfolding: InlineRule (1, True, True) (\ (ds :: b) -> w) -}
                      = \ (ds :: b) -> w
                    } in
                    GHC.Base.map
                      @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                      @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                      (\ (b1 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                       case b1 of wild { (,) a1 a2 ->
                       (Language.Fortran.$fFunctorArgList_$cfmap @ b @ a f a1,
                        Language.Fortran.$fFunctorArgList_$cfmap @ b @ a f a2) })
                      ww #)) -}
3168047516b298fa9ee9450ce4685044
  $w$c<= ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.True
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$c<=1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.False }) -}
f9579b9853ba0b00ed43856644ffed41
  $w$c== ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> GHC.Types.Bool
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))><L,U><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.ArgName p)
                   (ww2 :: Language.Fortran.SrcSpan)
                   (ww3 :: p)
                   (ww4 :: Language.Fortran.ArgName p)
                   (ww5 :: Language.Fortran.SrcSpan) ->
                 case GHC.Classes.== @ p w ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArg_$c==2 @ p w ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww2 of ww6 { (,) ww7 ww8 ->
                           case ww5 of ww9 { (,) ww10 ww11 ->
                           case ww7 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                           case ww10 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                           case GHC.Base.eqString ww13 ww17 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww14 of wild3 { GHC.Types.I# x ->
                                case ww18 of wild4 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x y) of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case ww15 of wild6 { GHC.Types.I# x1 ->
                                     case ww19 of wild7 { GHC.Types.I# y1 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y1) of wild8 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> Language.Fortran.$fEqArg_$c==1
                                            ww8
                                            ww11 } } } } } } } } } } } } }) -}
d23eb1c9bf389ce943aa0efbd50aa5dd
  $w$c==1 ::
    GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U(U)><S,1*U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: GHC.Types.Int) ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.eqInt ww2 ww5 } } } }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $w$c==2 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Expr p
    -> p
    -> Language.Fortran.Expr p
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
8e5d35b56d9adf07dc13e958da34fb28
  $w$c==3 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.UseBlock p
    -> Language.Fortran.Implicit p
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.Decl p
    -> Language.Fortran.Fortran p
    -> p
    -> Language.Fortran.UseBlock p
    -> Language.Fortran.Implicit p
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.Decl p
    -> Language.Fortran.Fortran p
    -> GHC.Types.Bool
  {- Arity: 13, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))><L,U><L,U><L,U><L,1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.UseBlock p)
                   (ww2 :: Language.Fortran.Implicit p)
                   (ww3 :: Language.Fortran.SrcSpan)
                   (ww4 :: Language.Fortran.Decl p)
                   (ww5 :: Language.Fortran.Fortran p)
                   (ww6 :: p)
                   (ww7 :: Language.Fortran.UseBlock p)
                   (ww8 :: Language.Fortran.Implicit p)
                   (ww9 :: Language.Fortran.SrcSpan)
                   (ww10 :: Language.Fortran.Decl p)
                   (ww11 :: Language.Fortran.Fortran p) ->
                 case GHC.Classes.== @ p w ww ww6 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { Language.Fortran.UseBlock a1 a2 ->
                      case ww7 of wild2 { Language.Fortran.UseBlock b1 b2 ->
                      case Language.Fortran.$fEqBlock_$c==4 @ p w a1 b1 of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case a2 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                           case b2 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                           case GHC.Base.eqString ww13 ww17 of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww14 of wild5 { GHC.Types.I# x ->
                                case ww18 of wild6 { GHC.Types.I# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x y) of wild7 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case ww15 of wild8 { GHC.Types.I# x1 ->
                                     case ww19 of wild9 { GHC.Types.I# y1 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y1) of wild10 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case Language.Fortran.$fEqBlock_$c==3
                                                 @ p
                                                 w
                                                 ww2
                                                 ww8 of wild11 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case ww3 of ww20 { (,) ww21 ww22 ->
                                               case ww9 of ww23 { (,) ww24 ww25 ->
                                               case ww21 of ww26 { Language.Fortran.SrcLoc ww27 ww28 ww29 ->
                                               case ww24 of ww30 { Language.Fortran.SrcLoc ww31 ww32 ww33 ->
                                               case GHC.Base.eqString ww27 ww31 of wild12 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> case ww28 of wild13 { GHC.Types.I# x2 ->
                                                    case ww32 of wild14 { GHC.Types.I# y2 ->
                                                    case GHC.Prim.tagToEnum#
                                                           @ GHC.Types.Bool
                                                           (GHC.Prim.==# x2 y2) of wild15 {
                                                      GHC.Types.False -> GHC.Types.False
                                                      GHC.Types.True
                                                      -> case ww29 of wild16 { GHC.Types.I# x3 ->
                                                         case ww33 of wild17 { GHC.Types.I# y3 ->
                                                         case GHC.Prim.tagToEnum#
                                                                @ GHC.Types.Bool
                                                                (GHC.Prim.==# x3 y3) of wild18 {
                                                           GHC.Types.False -> GHC.Types.False
                                                           GHC.Types.True
                                                           -> case ww22 of ww34 { Language.Fortran.SrcLoc ww35 ww36 ww37 ->
                                                              case ww25 of ww38 { Language.Fortran.SrcLoc ww39 ww40 ww41 ->
                                                              case GHC.Base.eqString
                                                                     ww35
                                                                     ww39 of wild19 {
                                                                GHC.Types.False -> GHC.Types.False
                                                                GHC.Types.True
                                                                -> case ww36 of wild20 { GHC.Types.I# x4 ->
                                                                   case ww40 of wild21 { GHC.Types.I# y4 ->
                                                                   case GHC.Prim.tagToEnum#
                                                                          @ GHC.Types.Bool
                                                                          (GHC.Prim.==#
                                                                             x4
                                                                             y4) of wild22 {
                                                                     GHC.Types.False
                                                                     -> GHC.Types.False
                                                                     GHC.Types.True
                                                                     -> case ww37 of wild23 { GHC.Types.I# x5 ->
                                                                        case ww41 of wild24 { GHC.Types.I# y5 ->
                                                                        case GHC.Prim.tagToEnum#
                                                                               @ GHC.Types.Bool
                                                                               (GHC.Prim.==#
                                                                                  x5
                                                                                  y5) of wild25 {
                                                                          GHC.Types.False
                                                                          -> GHC.Types.False
                                                                          GHC.Types.True
                                                                          -> case Language.Fortran.$fEqBlock_$c==2
                                                                                    @ p
                                                                                    w
                                                                                    ww4
                                                                                    ww10 of wild26 {
                                                                               GHC.Types.False
                                                                               -> GHC.Types.False
                                                                               GHC.Types.True
                                                                               -> Language.Fortran.$fEqBlock_$c==1
                                                                                    @ p
                                                                                    w
                                                                                    ww5
                                                                                    ww11 } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }) -}
9c14bebaca53835ee08617a03a479a8d
  $w$c==4 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U(1*U,1*U(U),1*U(U))><S,1*U><L,1*U(1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc)
                   (ww2 :: Language.Fortran.Uses p)
                   (ww3 :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> Language.Fortran.$fEqArg_$c==1 ww1 ww3 }) -}
a2b5b5d978313401ee2db39a0e0c6f8f
  $w$c==5 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.== @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Base.eqString ww1 ww3 }) -}
2dad6323b9fc0d32ae7c6d8ba1efe933
  $w$c> ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$c>1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.True }) -}
730a7315db12b8ac29813c637de34e25
  $w$c>= ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$c>=1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.True }) -}
89d5fea96805ec03402e82691d28c46b
  $w$ccompare ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Ordering
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.GT }) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $w$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> c Language.Fortran.SrcLoc
  {- Arity: 5,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (c :: * -> *)
                   (w :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (w1 :: forall g. g -> c g)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (w @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (w @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (w1
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)
                         ww)
                      ww1)
                   ww2) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $w$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> m Language.Fortran.SrcLoc
  {- Arity: 5,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (m :: * -> *)
                   (w :: GHC.Base.Monad m)
                   (w1 :: forall d. Data.Data.Data d => d -> m d)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = w1 @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       w
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          w
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m w @ b (c' x')))
                 } in
                 k @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (k @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (k @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (GHC.Base.return
                            @ m
                            w
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)
                         ww)
                      ww1)
                   ww2) -}
d4d45769399fe3ed8e0615e3282cf5b7
  $w$cgmapM1 ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> p -> Language.Fortran.Variable -> m (Language.Fortran.VarName p)
  {- Arity: 5,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ (m :: * -> *)
                   (w1 :: GHC.Base.Monad m)
                   (w2 :: forall d. Data.Data.Data d => d -> m d)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData1 :: Data.Data.Data d)
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl529 :: m d = w2 @ d $dData1 x
                     } in
                     GHC.Base.>>=
                       @ m
                       w1
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          w1
                          @ d
                          @ b
                          lvl529
                          (\ (x' :: d) -> GHC.Base.return @ m w1 @ b (c' x')))
                 } in
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      w
                      (GHC.Base.return
                         @ m
                         w1
                         @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p))
                      ww)
                   ww1) -}
1a43f3e055efb57aebce2a17b695d276
  $w$cgmapQi ::
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> u
  {- Arity: 5,
     Strictness: <S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ u
                   (ww :: GHC.Prim.Int#)
                   (w :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1
                   1# -> w @ GHC.Types.Int Data.Data.$fDataInt ww2
                   2# -> w @ GHC.Types.Int Data.Data.$fDataInt ww3 }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $w$cgmapQi1 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> p
    -> Language.Fortran.Expr p
    -> u
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [0] -}
d09f243eb3eeec0d44a1b799f2b23e72
  $w$cgmapQi2 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.SubName p) ->
                 case w2 of wild {
                   Language.Fortran.SubName a1 a2
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w1 @ p w a1
                        1# -> w1 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2 }
                   Language.Fortran.NullSubName a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 } }) -}
ed3a262a18b570752c320c116efb88d0
  $w$cgmapQi3 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.Implicit p) ->
                 case w2 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 }
                   Language.Fortran.ImplicitNull a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 } }) -}
7736fe35a4dbe1e780310541ec73b867
  $w$cgmapQi4 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> u
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: Language.Fortran.Uses p)
                   (ww2 :: Language.Fortran.SrcLoc) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0#
                   -> w1
                        @ (Language.Fortran.Uses p)
                        (Language.Fortran.$fDataUses @ p w)
                        ww1
                   1#
                   -> w1
                        @ Language.Fortran.SrcLoc
                        Language.Fortran.$fDataSrcLoc
                        ww2 }) -}
53046a0aa1c261e776a228d9d40263ca
  $w$cgmapQi5 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.Fraction p) ->
                 case w2 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w1 @ p w a1
                        1# -> w1 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2 }
                   Language.Fortran.FractionConst a1 a2 a3
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w1 @ p w a1
                        1# -> w1 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2
                        2# -> w1 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3 }
                   Language.Fortran.NullFraction a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 } }) -}
2e224cb3ca4fa18503a4d24170747dce
  $w$cgmapQi6 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.IntentAttr p) ->
                 case w2 of wild {
                   Language.Fortran.In a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 }
                   Language.Fortran.Out a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 }
                   Language.Fortran.InOut a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 } }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $w$cgmapQi7 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w1 :: forall d. Data.Data.Data d => d -> u)
                   (w2 :: Language.Fortran.UnaryOp p) ->
                 case w2 of wild {
                   Language.Fortran.UMinus a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 }
                   Language.Fortran.Not a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w1 @ p w a1 } }) -}
e380aafdbc8d4aa4106f14db624c279d
  $w$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 6,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ r
                   @ r'
                   (w :: r -> r' -> r)
                   (w1 :: r)
                   (w2 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w (w (w w1 (w2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww))
                      (w2 @ GHC.Types.Int Data.Data.$fDataInt ww1))
                   (w2 @ GHC.Types.Int Data.Data.$fDataInt ww2)) -}
1cf417c0d0f0334812a1c3985ea84c64
  $w$cgmapQl1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Variable
    -> r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r -> r' -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 w1
                   (w1 w2 (w3 @ p w ww))
                   (w3
                      @ Language.Fortran.Variable
                      Data.Data.$fData[]_$s$fData[]
                      ww1)) -}
5927d8ca7f4655d19c569bd5f35640dc
  $w$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 6,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ r
                   @ r'
                   (w :: r' -> r -> r)
                   (w1 :: r)
                   (w2 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w (w2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww)
                   (w (w2 @ GHC.Types.Int Data.Data.$fDataInt ww1)
                      (w (w2 @ GHC.Types.Int Data.Data.$fDataInt ww2) w1))) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $w$cgmapQr1 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 6,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0] -}
9398f4a877279f667ae18e0df204c07b
  $w$cgmapQr2 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 6,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r' -> r -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc) ->
                 w1
                   (w3
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p w)
                      ww)
                   (w1
                      (w3 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc ww1)
                      w2)) -}
b03feab1126baaa51f106ae2b9ad9b34
  $w$cgmapQr3 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Variable
    -> r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w1 :: r' -> r -> r)
                   (w2 :: r)
                   (w3 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 w1
                   (w3 @ p w ww)
                   (w1
                      (w3 @ Language.Fortran.Variable Data.Data.$fData[]_$s$fData[] ww1)
                      w2)) -}
43c2e4e6db773bb5ef99bf585d69acf2
  $w$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r) -> c Language.Fortran.SrcLoc
  {- Arity: 2, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ (c :: * -> *)
                   (w :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w1 :: forall r. r -> c r) ->
                 w @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (w @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (w @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (w1
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)))) -}
d09f243eb3eeec0d44a1b799f2b23e72
  $w$cgunfold1 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.SubName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww1
                      ret_ty (c (Language.Fortran.SubName p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w1
                             @ p
                             @ (Language.Fortran.SubName p)
                             w
                             (w2
                                @ (p -> Language.Fortran.SubName p)
                                (Language.Fortran.NullSubName @ p))
                        1#
                        -> w1
                             @ GHC.Base.String
                             @ (Language.Fortran.SubName p)
                             Data.Data.$fData[]_$s$fData[]
                             (w1
                                @ p
                                @ (GHC.Base.String -> Language.Fortran.SubName p)
                                w
                                (w2
                                   @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                                   (Language.Fortran.SubName @ p))) } } }) -}
e17095ab710540e6e45e7763d42db35f
  $w$cgunfold2 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.BinOp p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,U>,
     Inline: [0] -}
ed3a262a18b570752c320c116efb88d0
  $w$cgunfold3 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.Implicit p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww1
                      ret_ty (c (Language.Fortran.Implicit p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w1
                             @ p
                             @ (Language.Fortran.Implicit p)
                             w
                             (w2
                                @ (p -> Language.Fortran.Implicit p)
                                (Language.Fortran.ImplicitNull @ p))
                        1#
                        -> w1
                             @ p
                             @ (Language.Fortran.Implicit p)
                             w
                             (w2
                                @ (p -> Language.Fortran.Implicit p)
                                (Language.Fortran.ImplicitNone @ p)) } } }) -}
53046a0aa1c261e776a228d9d40263ca
  $w$cgunfold4 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.Fraction p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww1
                      ret_ty (c (Language.Fortran.Fraction p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w1
                             @ p
                             @ (Language.Fortran.Fraction p)
                             w
                             (w2
                                @ (p -> Language.Fortran.Fraction p)
                                (Language.Fortran.NullFraction @ p))
                        1#
                        -> w1
                             @ GHC.Base.String
                             @ (Language.Fortran.Fraction p)
                             Data.Data.$fData[]_$s$fData[]
                             (w1
                                @ p
                                @ (GHC.Base.String -> Language.Fortran.Fraction p)
                                w
                                (w2
                                   @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                                   (Language.Fortran.IntegerConst @ p)))
                        2#
                        -> w1
                             @ GHC.Base.String
                             @ (Language.Fortran.Fraction p)
                             Data.Data.$fData[]_$s$fData[]
                             (w1
                                @ GHC.Base.String
                                @ (GHC.Base.String -> Language.Fortran.Fraction p)
                                Data.Data.$fData[]_$s$fData[]
                                (w1
                                   @ p
                                   @ (GHC.Base.String
                                      -> GHC.Base.String -> Language.Fortran.Fraction p)
                                   w
                                   (w2
                                      @ (p
                                         -> GHC.Base.String
                                         -> GHC.Base.String
                                         -> Language.Fortran.Fraction p)
                                      (Language.Fortran.FractionConst @ p)))) } } }) -}
2e224cb3ca4fa18503a4d24170747dce
  $w$cgunfold5 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww1
                      ret_ty (c (Language.Fortran.IntentAttr p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w1
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w2
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.InOut @ p))
                        1#
                        -> w1
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w2
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.In @ p))
                        2#
                        -> w1
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w2
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.Out @ p)) } } }) -}
18f51ff76072ffaca3ec46558a1d5bc9
  $w$cgunfold6 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ (c :: * -> *)
                   (w1 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w2 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild {
                   DEFAULT
                   -> case Data.Data.constrIndex1 ww1
                      ret_ty (c (Language.Fortran.UnaryOp p))
                      of {}
                   Data.Data.AlgConstr idx
                   -> case idx of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w1
                             @ p
                             @ (Language.Fortran.UnaryOp p)
                             w
                             (w2 @ (p -> Language.Fortran.UnaryOp p) (Language.Fortran.Not @ p))
                        1#
                        -> w1
                             @ p
                             @ (Language.Fortran.UnaryOp p)
                             w
                             (w2
                                @ (p -> Language.Fortran.UnaryOp p)
                                (Language.Fortran.UMinus @ p)) } } }) -}
e2c882a99950e327a138da22a342c003
  $w$cshow ::
    GHC.Base.String
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U(U)><L,1*U(U)>, Inline: [0] -}
3c2e4496493e922a6309bdcd85c25f4a
  $w$cshow1 ::
    GHC.Show.Show p =>
    Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U><L,1*U(U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Language.Fortran.$fShowBlock4
                   (Language.Fortran.$w$cshowsPrec9
                      @ p
                      w
                      11#
                      ww
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.showSpace1
                         (case ww1 of ww2 { Language.Fortran.SrcLoc ww3 ww4 ww5 ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            (Language.Fortran.$w$cshow ww3 ww4 ww5)
                            (GHC.Types.[] @ GHC.Types.Char) })))) -}
b8ee36ef48a76e8707a0e0057adcb3c5
  $w$cshow2 ::
    GHC.Show.Show p =>
    p -> Language.Fortran.Variable -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Language.Fortran.$fShowVarName1
                   (GHC.Show.showsPrec
                      @ p
                      w
                      Language.Fortran.$fReadVarName3
                      ww
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.showSpace1
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows6
                            (GHC.Show.showLitString ww1 Language.Fortran.$fShowSubName3))))) -}
d00b80af35f6ef4b90e05975103f1b61
  $w$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,U(C(C1(U)),A,A)><S,U><L,U><L,1*U><L,U(U(U,U(U),U(U)),U(U,U(U),U(U)))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.ArgName p)
                   (ww3 :: Language.Fortran.SrcSpan) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec1 @ p w 11# ww2
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Language.Fortran.$fShowArg1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (case ww3 of ww4 { (,) ww5 ww6 ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.shows7
                                      (case ww5 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                                       GHC.Base.++
                                         @ GHC.Types.Char
                                         (Language.Fortran.$w$cshow ww8 ww9 ww10)
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows5
                                            (GHC.Show.$fShow(,)_$sgo
                                               (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)
                                               (\ (s :: GHC.Base.String) ->
                                                case ww6 of ww11 { Language.Fortran.SrcLoc ww12 ww13 ww14 ->
                                                GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Language.Fortran.$w$cshow ww12 ww13 ww14)
                                                  s })
                                               (GHC.Types.[] @ GHC.Show.ShowS))) }) })))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p1
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
dd55ce63dac1f7711c0f1fc53db78e0e
  $w$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.ArgName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
022650b5d943cbe1299f462b4400cd71
  $w$cshowsPrec10 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(U)),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: [(Language.Fortran.Expr p, Language.Fortran.Expr p)]) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 ww1
                 } in
                 let {
                   lvl529 :: (Language.Fortran.Expr p, Language.Fortran.Expr p)
                             -> GHC.Base.String -> [GHC.Types.Char]
                     {- Arity: 2 -}
                   = \ (w3 :: (Language.Fortran.Expr p, Language.Fortran.Expr p))
                       (w4 :: GHC.Base.String)[OneShot] ->
                     case w3 of ww3 { (,) ww4 ww5 ->
                     GHC.Types.:
                       @ GHC.Types.Char
                       GHC.Show.shows7
                       (Language.Fortran.$w$cshowsPrec11
                          @ p
                          w
                          0#
                          ww4
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows5
                             (GHC.Show.$fShow(,)_$sgo
                                (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w4)
                                (Language.Fortran.$w$cshowsPrec11 @ p w 0# ww5)
                                (GHC.Types.[] @ GHC.Show.ShowS)))) }
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Language.Fortran.$fShowDataForm1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Show.showList__
                                @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                                lvl529
                                ww2
                                x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p1
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $w$cshowsPrec11 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
53046a0aa1c261e776a228d9d40263ca
  $w$cshowsPrec12 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Fraction p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Language.Fortran.Fraction p) ->
                 case w1 of wild {
                   Language.Fortran.IntegerConst b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      let {
                        p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Language.Fortran.$fShowFraction3
                            (f (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        b2
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p1
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }
                   Language.Fortran.FractionConst b1 b2 b3
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      let {
                        p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Language.Fortran.$fShowFraction2
                            (f (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        b2
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showSpace1
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.shows6
                                                 (GHC.Show.showLitString
                                                    b3
                                                    (GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.shows6
                                                       x)))))))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p1
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }
                   Language.Fortran.NullFraction b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowFraction1 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowFraction1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
573851d0f4eec5dd746d11fb7a0852b2
  $w$cshowsPrec13 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.GSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Language.Fortran.GSpec p) ->
                 case w1 of wild {
                   Language.Fortran.GName b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Fortran.$w$cshowsPrec11 @ p w 11# b2
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowGSpec3
                             (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowGSpec3
                                (f (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))))) }
                   Language.Fortran.GOper b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Fortran.$w$cshowsPrec5 @ p w 11# b2
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowGSpec2
                             (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowGSpec2
                                (f (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))))) }
                   Language.Fortran.GAssg b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowGSpec1 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowGSpec1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
2e224cb3ca4fa18503a4d24170747dce
  $w$cshowsPrec14 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.IntentAttr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Language.Fortran.IntentAttr p) ->
                 case w1 of wild {
                   Language.Fortran.In b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr3
                             (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   Language.Fortran.Out b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr2
                             (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   Language.Fortran.InOut b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr1
                             (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
c4465a5758b20b0d6387c4cda8774a94
  $w$cshowsPrec15 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.InterfaceSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
2d20a52afd34a2922ea97a5d3a8025ba
  $w$cshowsPrec16 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
ba4cf92c8e04874adf9aa301c7b40b26
  $w$cshowsPrec17 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Spec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
d09f243eb3eeec0d44a1b799f2b23e72
  $w$cshowsPrec18 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.SubName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Language.Fortran.SubName p) ->
                 case w1 of wild {
                   Language.Fortran.SubName b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      let {
                        p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Language.Fortran.$fShowSubName2
                            (f (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        b2
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p1
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }
                   Language.Fortran.NullSubName b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowSubName1 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowSubName1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
cac90f1d6845827f0c2780e86e10c606
  $w$cshowsPrec19 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Type p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $w$cshowsPrec2 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> p -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(U)),A,A)><S,U><L,U><L,1*U>,
     Inline: [0] -}
18f51ff76072ffaca3ec46558a1d5bc9
  $w$cshowsPrec20 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.UnaryOp p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Language.Fortran.UnaryOp p) ->
                 case w1 of wild {
                   Language.Fortran.UMinus b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowUnaryOp2 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowUnaryOp2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   Language.Fortran.Not b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowUnaryOp1 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowUnaryOp1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
45df3849d2747dcd21ca5340f075c778
  $w$cshowsPrec21 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> p -> Language.Fortran.Variable -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Variable) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 ww1
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Language.Fortran.$fShowVarName1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   ww2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p1
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $w$cshowsPrec3 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Attr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
6b45e4637f33ab3df335753afdb59e8d
  $w$cshowsPrec4 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.BaseType p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
e17095ab710540e6e45e7763d42db35f
  $w$cshowsPrec5 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.BinOp p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
2ec188c87b0f866cf0f167b66fbccbc7
  $w$cshowsPrec6 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> Language.Fortran.UseBlock p
    -> Language.Fortran.Implicit p
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.Decl p
    -> Language.Fortran.Fortran p
    -> GHC.Show.ShowS
  {- Arity: 8,
     Strictness: <L,U(C(C1(U)),A,A)><S,U><L,U><L,1*U(1*U,U(U,U(U),U(U)))><L,1*U><L,U(U(U,U(U),U(U)),U(U,U(U),U(U)))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.UseBlock p)
                   (ww3 :: Language.Fortran.Implicit p)
                   (ww4 :: Language.Fortran.SrcSpan)
                   (ww5 :: Language.Fortran.Decl p)
                   (ww6 :: Language.Fortran.Fortran p) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww7 { Language.Fortran.UseBlock ww8 ww9 ->
                     Language.Fortran.$w$cshowsPrec8 @ p w 11# ww8 ww9 }
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec7 @ p w 11# ww3
                 } in
                 let {
                   f3 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$fShowBlock_$cshowsPrec2
                       @ p
                       w
                       Language.Fortran.$fReadVarName3
                       ww5
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$fShowBlock_$cshowsPrec1
                       @ p
                       w
                       Language.Fortran.$fReadVarName3
                       ww6
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Language.Fortran.$fShowBlock1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (f2
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (case ww4 of ww7 { (,) ww8 ww9 ->
                                          GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows7
                                            (case ww8 of ww10 { Language.Fortran.SrcLoc ww11 ww12 ww13 ->
                                             GHC.Base.++
                                               @ GHC.Types.Char
                                               (Language.Fortran.$w$cshow ww11 ww12 ww13)
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.shows5
                                                  (GHC.Show.$fShow(,)_$sgo
                                                     (GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.shows4
                                                        (GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.showSpace1
                                                           (f3
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Char
                                                                 GHC.Show.showSpace1
                                                                 (g x)))))
                                                     (\ (s :: GHC.Base.String) ->
                                                      case ww9 of ww14 { Language.Fortran.SrcLoc ww15 ww16 ww17 ->
                                                      GHC.Base.++
                                                        @ GHC.Types.Char
                                                        (Language.Fortran.$w$cshow ww15 ww16 ww17)
                                                        s })
                                                     (GHC.Types.[] @ GHC.Show.ShowS))) }) })))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p1
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
ed3a262a18b570752c320c116efb88d0
  $w$cshowsPrec7 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Implicit p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Language.Fortran.Implicit p) ->
                 case w1 of wild {
                   Language.Fortran.ImplicitNone b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowBlock3 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowBlock3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }
                   Language.Fortran.ImplicitNull b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName3 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowBlock2 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowBlock2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) } }) -}
d3689aec66f4ff08c7957d3f21ddb20f
  $w$cshowsPrec8 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><S,U><L,1*U><L,U(U,U(U),U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: Language.Fortran.Uses p)
                   (ww2 :: Language.Fortran.SrcLoc) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec9 @ p w 11# ww1
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Language.Fortran.$fShowBlock4
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                              GHC.Base.++
                                @ GHC.Types.Char
                                (Language.Fortran.$w$cshow ww4 ww5 ww6)
                                x })))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p1
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
22a7293c3f9ba679ea60d591f21568e8
  $w$cshowsPrec9 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Uses p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,U><S,1*U>,
     Inline: [0] -}
fd45c3abbcc1cd23ca18c96ee1403b96
  $w$ctoConstr :: Language.Fortran.Expr p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Expr p) ->
                 case w of wild {
                   Language.Fortran.Con ds ds1 ds2
                   -> Language.Fortran.$cBnoJ3Fz73Zm4yWidz7liRC
                   Language.Fortran.ConL ds ds1 ds2 ds3
                   -> Language.Fortran.$cKixEZNPGwILIKGvB325tuX
                   Language.Fortran.ConS ds ds1 ds2
                   -> Language.Fortran.$cJycyi77aaqH3o3UgNEeNZw
                   Language.Fortran.ParenthesizedExpr ds ds1 ds2
                   -> Language.Fortran.$c4ANqVaXyL4yIdeOK79e62B
                   Language.Fortran.Var ds ds1 ds2
                   -> Language.Fortran.$cCh7W1cTHWOrHcDXoX6md4V
                   Language.Fortran.Bin ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$c22KnKYxEP4y33Osr94L5dt
                   Language.Fortran.Unary ds ds1 ds2 ds3
                   -> Language.Fortran.$c78tQ8qZxOZr324tkfj0IRz
                   Language.Fortran.CallExpr ds ds1 ds2 ds3
                   -> Language.Fortran.$cLYSRIS5IXhsKtPBuLbJhSN
                   Language.Fortran.NullExpr ds ds1
                   -> Language.Fortran.$cETFTR8syJoXGSa4EBKNf90
                   Language.Fortran.Null ds ds1
                   -> Language.Fortran.$cD3qrJPFo7TpKgBpACeEzmz
                   Language.Fortran.ESeq ds ds1 ds2 ds3
                   -> Language.Fortran.$c1bIlWY0B7An9HoCGDZAyX6
                   Language.Fortran.Bound ds ds1 ds2 ds3
                   -> Language.Fortran.$cLBPxZUMv6542zJYgjft5l3
                   Language.Fortran.Sqrt ds ds1 ds2
                   -> Language.Fortran.$cD23qQhICPJIAlRuFWUrWTG
                   Language.Fortran.ArrayCon ds ds1 ds2
                   -> Language.Fortran.$cFXzcZuUPSalBxcWakFNiwk
                   Language.Fortran.AssgExpr ds ds1 ds2 ds3
                   -> Language.Fortran.$c1IznUHFLi46FHd3grEUQfU }) -}
cd26706e4e94cf728d05a3d7b1b9056d
  $w$ctoConstr1 :: Language.Fortran.Attr p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Attr p) ->
                 case w of wild {
                   Language.Fortran.Parameter ds
                   -> Language.Fortran.$c7B7CwvLXlI65LliAKSg6fB
                   Language.Fortran.Allocatable ds
                   -> Language.Fortran.$cElP7vJxaWuY2h5QpZwARwX
                   Language.Fortran.External ds
                   -> Language.Fortran.$cGP3vwUNcJksADq43fmNFtK
                   Language.Fortran.Intent ds ds1
                   -> Language.Fortran.$c9jJakhk2EHs3dQvW2C6t8f
                   Language.Fortran.Intrinsic ds
                   -> Language.Fortran.$cIyLi8J1OHq723JJNc4oM1a
                   Language.Fortran.Optional ds
                   -> Language.Fortran.$cGTpusTKqFxJ22IdjCosmhu
                   Language.Fortran.Pointer ds
                   -> Language.Fortran.$c1kxrjM0ubOr2AKqDtvXYpv
                   Language.Fortran.Save ds
                   -> Language.Fortran.$cHEASYRzErmJGPCyxQpLXIW
                   Language.Fortran.Target ds
                   -> Language.Fortran.$cDdcoueG3JQzDl7jqyfcnZb
                   Language.Fortran.Volatile ds
                   -> Language.Fortran.$cbejFFDHCLXEwDZCBT24qk
                   Language.Fortran.Public ds
                   -> Language.Fortran.$c7lfNiGPDM2tJsjHmBnjtvF
                   Language.Fortran.Private ds
                   -> Language.Fortran.$cAbMSwCXSfl8LUbBeST0WD9
                   Language.Fortran.Sequence ds
                   -> Language.Fortran.$cHuyzJGnP4eNEshO9nUNJvc
                   Language.Fortran.Dimension ds ds1
                   -> Language.Fortran.$c8tHUVs27NcXHKX7Nm6RrSS
                   Language.Fortran.MeasureUnit ds ds1
                   -> Language.Fortran.$c2DhuP2n5J9jK7fCzidnavw }) -}
6b45e4637f33ab3df335753afdb59e8d
  $w$ctoConstr2 :: Language.Fortran.BaseType p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.BaseType p) ->
                 case w of wild {
                   Language.Fortran.Integer ds
                   -> Language.Fortran.$c2zM3Wvd2OSTKQWpzDfGPs3
                   Language.Fortran.Real ds
                   -> Language.Fortran.$c57WXxHeFdMP6uTlDFEoR2e
                   Language.Fortran.Character ds
                   -> Language.Fortran.$c7OcYfPjTVfVKWmGVGvQDuT
                   Language.Fortran.SomeType ds
                   -> Language.Fortran.$cKvdQh7V79Kp1D1pJcVfiuV
                   Language.Fortran.DerivedType ds ds1
                   -> Language.Fortran.$cBOqujp4qXetGp5vwKhj7Tb
                   Language.Fortran.Recursive ds
                   -> Language.Fortran.$cLvbK0pIELosBhNJL5acEyk
                   Language.Fortran.Pure ds
                   -> Language.Fortran.$c5PpNSQeZhEd6mfzscovZzk
                   Language.Fortran.Elemental ds
                   -> Language.Fortran.$c5SQPygD1Ty89qjjuuJHaUt
                   Language.Fortran.Logical ds
                   -> Language.Fortran.$c153RCtDJMOyJaz55P4WRZA
                   Language.Fortran.Complex ds
                   -> Language.Fortran.$c4YtPC6DHZWXAfR4LZG1kUS }) -}
e17095ab710540e6e45e7763d42db35f
  $w$ctoConstr3 :: Language.Fortran.BinOp p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.BinOp p) ->
                 case w of wild {
                   Language.Fortran.Plus ds
                   -> Language.Fortran.$cLMazxJn46665m8Yj6dJ4f2
                   Language.Fortran.Minus ds
                   -> Language.Fortran.$cCR6r44wooKB4ahO4Z7xi2
                   Language.Fortran.Mul ds
                   -> Language.Fortran.$cKcegaxJX2G4G3MxjzGOVFy
                   Language.Fortran.Div ds
                   -> Language.Fortran.$cBxm7TsMN2Uv3pnUvfizH4a
                   Language.Fortran.Or ds -> Language.Fortran.$cBSwpqhq0QE6EPH9yiaMC9K
                   Language.Fortran.And ds
                   -> Language.Fortran.$cKshv8guM6KWBTLkG9LdK8Q
                   Language.Fortran.Concat ds
                   -> Language.Fortran.$c8oI8VcsgCvA41cZKrFA3aS
                   Language.Fortran.Power ds
                   -> Language.Fortran.$c85seZPcVf6L6w9soyXu5VI
                   Language.Fortran.RelEQ ds
                   -> Language.Fortran.$cHXnvV5ahnQ2LFa0mdMe6uA
                   Language.Fortran.RelNE ds
                   -> Language.Fortran.$c38rK9vmzDD4E6uZr2fvSTl
                   Language.Fortran.RelLT ds
                   -> Language.Fortran.$cKaQG7L5fPygCJMfpz2UOZd
                   Language.Fortran.RelLE ds
                   -> Language.Fortran.$cBkX4OAQJ9orEBepae4Ozqm
                   Language.Fortran.RelGT ds
                   -> Language.Fortran.$c12Sm1gxWcOn3cUJRtBlJgB
                   Language.Fortran.RelGE ds
                   -> Language.Fortran.$c3qv8lWLr4xn6EqXsj3zYHw }) -}
7ef8d1883356542a2e7829f1c3512bc2
  $w$ctoConstr4 :: Language.Fortran.Fortran p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Fortran p) ->
                 case w of wild {
                   Language.Fortran.Assg ds ds1 ds2 ds3
                   -> Language.Fortran.$cJIuXgcJUNEdIDk2n1uvBTZ
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$c8mencuMehIDCmyd4I42Hz1
                   Language.Fortran.DoWhile ds ds1 ds2 ds3
                   -> Language.Fortran.$c7d8OlwqiJau34WHIostq8f
                   Language.Fortran.FSeq ds ds1 ds2 ds3
                   -> Language.Fortran.$cA6zFekJaEKo1Ig9n9uLZdR
                   Language.Fortran.If ds ds1 ds2 ds3 ds4 ds5
                   -> Language.Fortran.$cDUwJELfr3Fz4arRtKikbg0
                   Language.Fortran.Allocate ds ds1 ds2 ds3
                   -> Language.Fortran.$c3YEyxCulpF32LgLHGSyebX
                   Language.Fortran.Backspace ds ds1 ds2
                   -> Language.Fortran.$cI4PF9mC7gG22viZwqmXmQI
                   Language.Fortran.Call ds ds1 ds2 ds3
                   -> Language.Fortran.$c18aqH9BmJhgHld6kuetHv6
                   Language.Fortran.Open ds ds1 ds2
                   -> Language.Fortran.$cCHtw2VnCYTERZ4xHeWpE4
                   Language.Fortran.Close ds ds1 ds2
                   -> Language.Fortran.$cAzhApblMBHHJU8C7xBa9fJ
                   Language.Fortran.Continue ds ds1
                   -> Language.Fortran.$cC0nxMGD6gUKFvIpMtayQcB
                   Language.Fortran.Cycle ds ds1 ds2
                   -> Language.Fortran.$c3mMEKtaZYQL3iBM6k8DhAO
                   Language.Fortran.DataStmt ds ds1 ds2
                   -> Language.Fortran.$c7Gl0pQ9Y43l2rL5R2ucb0T
                   Language.Fortran.Deallocate ds ds1 ds2 ds3
                   -> Language.Fortran.$cLTiyBcAAGRR1kehXcN8BdU
                   Language.Fortran.Endfile ds ds1 ds2
                   -> Language.Fortran.$c5p5tLEohJso2vKXnu75TMm
                   Language.Fortran.Exit ds ds1 ds2
                   -> Language.Fortran.$cBHObfxlHoGgA4QTTVq6oi4
                   Language.Fortran.Format ds ds1 ds2
                   -> Language.Fortran.$cDjimyCQcrglDvnGq9cCHps
                   Language.Fortran.Forall ds ds1 ds2 ds3
                   -> Language.Fortran.$c60GMhfP1qJqKHS0iBvnyL8
                   Language.Fortran.Goto ds ds1 ds2
                   -> Language.Fortran.$c1Wz6iPX2W8tHU6q9f5HuxM
                   Language.Fortran.Nullify ds ds1 ds2
                   -> Language.Fortran.$c9oM7r2u0wZ0FXo9rh1iD7p
                   Language.Fortran.Inquire ds ds1 ds2 ds3
                   -> Language.Fortran.$c8a2uDwF9ZA71XaRMXFjhlN
                   Language.Fortran.Pause ds ds1 ds2
                   -> Language.Fortran.$c1fQMqkMbKQTLcoqlmJAEse
                   Language.Fortran.Rewind ds ds1 ds2
                   -> Language.Fortran.$c7DRQkmBPZA34szLkne8yRT
                   Language.Fortran.Stop ds ds1 ds2
                   -> Language.Fortran.$c5sCdJIX6mGtF7T4I5o5IXH
                   Language.Fortran.Where ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cF1IKYwsRetP0SeNkioe6Y7
                   Language.Fortran.Write ds ds1 ds2 ds3
                   -> Language.Fortran.$c8x2pi9QDrqRCm6uWv2rvPl
                   Language.Fortran.PointerAssg ds ds1 ds2 ds3
                   -> Language.Fortran.$cIM0ypPVSiloC4bjtwrXHRp
                   Language.Fortran.Return ds ds1 ds2
                   -> Language.Fortran.$cJK1JTGWnd4sK8HL1FrCJ9G
                   Language.Fortran.Label ds ds1 ds2 ds3
                   -> Language.Fortran.$c5gqDvaOFUnJ5QtGWu4MTYJ
                   Language.Fortran.Print ds ds1 ds2 ds3
                   -> Language.Fortran.$cEYy6jWMRHxp5HZSgP2Q9ZK
                   Language.Fortran.ReadS ds ds1 ds2 ds3
                   -> Language.Fortran.$c1MhfwF7Y9jS0tsFMiHDDeD
                   Language.Fortran.TextStmt ds ds1 ds2
                   -> Language.Fortran.$cA4QSI58ZfFkLxGkxSbd69y
                   Language.Fortran.NullStmt ds ds1
                   -> Language.Fortran.$cBjUNnw5gxKeGq6ZKrPavlh
                   Language.Fortran.SelectStmt ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$c8alWOQnlY8j5XvDy7ZLFeQ
                   Language.Fortran.OpenCLMap ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cFGQSZussvkOFNnRO51hGKa
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cB89Tp5UcFJY5zWyNR39ve9
                   Language.Fortran.OpenCLSeq ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$c8KKprhwZTDWIjt2XeaMi66
                   Language.Fortran.OpenCLBufferRead ds ds1 ds2
                   -> Language.Fortran.$cGmWj83OUQ795Ps0R1oraOm
                   Language.Fortran.OpenCLBufferWrite ds ds1 ds2
                   -> Language.Fortran.$cJ89XmQl4LdA2XZ14ZkwIS3 }) -}
c4465a5758b20b0d6387c4cda8774a94
  $w$ctoConstr5 :: Language.Fortran.Decl p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Decl p) ->
                 case w of wild {
                   Language.Fortran.Decl ds ds1 ds2 ds3
                   -> Language.Fortran.$c5IBBfvIJazmGZ0AUBImoCA
                   Language.Fortran.Namelist ds ds1
                   -> Language.Fortran.$cDsG5sYerBcHB9v8lVsfVY5
                   Language.Fortran.DataDecl ds ds1
                   -> Language.Fortran.$cIcMUtRli3Fb6z5cNjlPbsf
                   Language.Fortran.Equivalence ds ds1 ds2
                   -> Language.Fortran.$c8uxH7NWw8crDcRrppV58Jw
                   Language.Fortran.AttrStmt ds ds1 ds2
                   -> Language.Fortran.$ccuN7R8hpA70mFie3N0Ynq
                   Language.Fortran.AccessStmt ds ds1 ds2
                   -> Language.Fortran.$cBUetck2MQOs1Upzg5eNaup
                   Language.Fortran.ExternalStmt ds ds1
                   -> Language.Fortran.$cJLXsf9lxOoaFiQSAQ8W4hd
                   Language.Fortran.Interface ds ds1 ds2
                   -> Language.Fortran.$c4SKEEpjEDeOD124ZRzk6QM
                   Language.Fortran.Common ds ds1 ds2 ds3
                   -> Language.Fortran.$c18YkNDG5QMhL8iPWXWrllf
                   Language.Fortran.DerivedTypeDef ds ds1 ds2 ds3 ds4 ds5
                   -> Language.Fortran.$c2AYhPPmEPMTJeQTk3WUMe2
                   Language.Fortran.Include ds ds1
                   -> Language.Fortran.$c1qcO2l0Dlc4HmQDSBM7P6x
                   Language.Fortran.DSeq ds ds1 ds2
                   -> Language.Fortran.$cIe4io6ptRQTBZkPPhPd59J
                   Language.Fortran.TextDecl ds ds1
                   -> Language.Fortran.$c5wamPn3Wrx17qM0d44RERP
                   Language.Fortran.NullDecl ds ds1
                   -> Language.Fortran.$c6VZm4EXLGcl6lxcJFA1Hbq
                   Language.Fortran.MeasureUnitDef ds ds1 ds2
                   -> Language.Fortran.$c4h74CzRNc1XLVWLIn3H4X2 }) -}
ba4cf92c8e04874adf9aa301c7b40b26
  $w$ctoConstr6 :: Language.Fortran.Spec p -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Spec p) ->
                 case w of wild {
                   Language.Fortran.Access ds ds1
                   -> Language.Fortran.$c61GRAacu9E7KjUErp8I6wr
                   Language.Fortran.Action ds ds1
                   -> Language.Fortran.$cERfpYlJLt2r1ym8wgeAxzB
                   Language.Fortran.Advance ds ds1
                   -> Language.Fortran.$cJUigIhd9rkN7twKvBnXy7l
                   Language.Fortran.Blank ds ds1
                   -> Language.Fortran.$cIMGNvWbJdnq9xozMAhQSu2
                   Language.Fortran.Delim ds ds1
                   -> Language.Fortran.$cHWt0CBnUqw77wKA6I45BBj
                   Language.Fortran.Direct ds ds1
                   -> Language.Fortran.$cEWJ0Auj1ARaDjMLQKis4KM
                   Language.Fortran.End ds ds1
                   -> Language.Fortran.$cAYXgtZzgYPd88xyJVp9FSm
                   Language.Fortran.Err ds ds1
                   -> Language.Fortran.$cIAevgWXYHzwLRUFBHwuUZ8
                   Language.Fortran.ExFile ds ds1
                   -> Language.Fortran.$c2mK1s9VxLdt4GGXKi4786u
                   Language.Fortran.Exist ds ds1
                   -> Language.Fortran.$c5UkOpWTdNZeHmddgiPGy4V
                   Language.Fortran.Eor ds ds1
                   -> Language.Fortran.$cDjBpcn6xMzsHPN22w1wI82
                   Language.Fortran.File ds ds1
                   -> Language.Fortran.$cu5gtSoLHcOBiRcc4Ziped
                   Language.Fortran.FMT ds ds1
                   -> Language.Fortran.$cFQ6NHQIThDN3fFSD7smHNn
                   Language.Fortran.Form ds ds1
                   -> Language.Fortran.$c64mCk8Ne1Wa90P1TKqd60d
                   Language.Fortran.Formatted ds ds1
                   -> Language.Fortran.$c5uLIP5eW38kBLuMWdEWDVA
                   Language.Fortran.Unformatted ds ds1
                   -> Language.Fortran.$cA3gtOKVvfj24du9egUU4pL
                   Language.Fortran.IOLength ds ds1
                   -> Language.Fortran.$cGxIc2mtUiNe1Nyz5GUgXvl
                   Language.Fortran.IOStat ds ds1
                   -> Language.Fortran.$cJGg760wRwEQJEY2f8Sd1Z7
                   Language.Fortran.Name ds ds1
                   -> Language.Fortran.$c20exh3Nv2bF91fBcfHsSli
                   Language.Fortran.Named ds ds1
                   -> Language.Fortran.$cEJEHRNo6HpQ0IZ7fc5UH2m
                   Language.Fortran.NoSpec ds ds1
                   -> Language.Fortran.$cInvqrPypDap7KpUF8KbmzY
                   Language.Fortran.Number ds ds1
                   -> Language.Fortran.$c77NRxilTXqq793JqKDeH3Z
                   Language.Fortran.Floating ds ds1 ds2
                   -> Language.Fortran.$c1CQ0luLqwKE0fss1qXQrBR
                   Language.Fortran.NextRec ds ds1
                   -> Language.Fortran.$c8V4DuEbkPAEIfcWhxCrJ2n
                   Language.Fortran.NML ds ds1
                   -> Language.Fortran.$cAF3epF9VjKiAWOEkFMvaa4
                   Language.Fortran.Opened ds ds1
                   -> Language.Fortran.$cEErEL27lDw1B0N3YvXaWET
                   Language.Fortran.Pad ds ds1
                   -> Language.Fortran.$cCJsE0jKA293JmiK7bwItsB
                   Language.Fortran.Position ds ds1
                   -> Language.Fortran.$cBxpvXAA12XjHuly5nuTiE8
                   Language.Fortran.Read ds ds1
                   -> Language.Fortran.$c5koiIUnlOzUKTeNbDqPNFO
                   Language.Fortran.ReadWrite ds ds1
                   -> Language.Fortran.$c4SQpifNfQuGHtJQ44yIpuU
                   Language.Fortran.Rec ds ds1
                   -> Language.Fortran.$c3arFYhpAYyHAt36aWemnjU
                   Language.Fortran.Recl ds ds1
                   -> Language.Fortran.$cHZ7uyMpPcEEEcwapdnRQaU
                   Language.Fortran.Sequential ds ds1
                   -> Language.Fortran.$cCnG8eZj9IrVCmtlLEFwUGg
                   Language.Fortran.Size ds ds1
                   -> Language.Fortran.$cDRxAjenayYj94ZvPWP7a56
                   Language.Fortran.Status ds ds1
                   -> Language.Fortran.$cD3uCaXvvn8S1Kmgoi15Hal
                   Language.Fortran.StringLit ds ds1
                   -> Language.Fortran.$cG9ZNuwcTtgaIpzhpWIwrk0
                   Language.Fortran.Unit ds ds1
                   -> Language.Fortran.$c8EqkxogGSaf38UCer6UE7V
                   Language.Fortran.WriteSp ds ds1
                   -> Language.Fortran.$c7ZgxpdN9n7XBLTHFJWmMgw
                   Language.Fortran.Delimiter ds
                   -> Language.Fortran.$c8g6LBR4Z66Q9zl9ZbnAs01 }) -}
6a578be33391db91b5fea0db543565f7
  data Arg p
    = Arg p (Language.Fortran.ArgName p) Language.Fortran.SrcSpan
fd45c3abbcc1cd23ca18c96ee1403b96
  data ArgList p = ArgList p (Language.Fortran.Expr p)
dd55ce63dac1f7711c0f1fc53db78e0e
  data ArgName p
    = ArgName p GHC.Base.String
    | ASeq p (Language.Fortran.ArgName p) (Language.Fortran.ArgName p)
    | NullArg p
cd26706e4e94cf728d05a3d7b1b9056d
  data Attr p
    = Parameter p
    | Allocatable p
    | External p
    | Intent p (Language.Fortran.IntentAttr p)
    | Intrinsic p
    | Optional p
    | Pointer p
    | Save p
    | Target p
    | Volatile p
    | Public p
    | Private p
    | Sequence p
    | Dimension p [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
    | MeasureUnit p (Language.Fortran.MeasureUnitSpec p)
6b45e4637f33ab3df335753afdb59e8d
  data BaseType p
    = Integer p
    | Real p
    | Character p
    | SomeType p
    | DerivedType p (Language.Fortran.SubName p)
    | Recursive p
    | Pure p
    | Elemental p
    | Logical p
    | Complex p
e17095ab710540e6e45e7763d42db35f
  data BinOp p
    = Plus p
    | Minus p
    | Mul p
    | Div p
    | Or p
    | And p
    | Concat p
    | Power p
    | RelEQ p
    | RelNE p
    | RelLT p
    | RelLE p
    | RelGT p
    | RelGE p
00b5dcb26b4d8331f4d0a27afc418872
  data Block p
    = Block p
            (Language.Fortran.UseBlock p)
            (Language.Fortran.Implicit p)
            Language.Fortran.SrcSpan
            (Language.Fortran.Decl p)
            (Language.Fortran.Fortran p)
d489c902c3045b3ed80ef70b739aa9fb
  data DataForm p
    = Data p [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
c4465a5758b20b0d6387c4cda8774a94
  data Decl p
    = Decl p
           Language.Fortran.SrcSpan
           [(Language.Fortran.Expr p, Language.Fortran.Expr p,
             GHC.Base.Maybe GHC.Types.Int)]
           (Language.Fortran.Type p)
    | Namelist p [(Language.Fortran.Expr p, [Language.Fortran.Expr p])]
    | DataDecl p (Language.Fortran.DataForm p)
    | Equivalence p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | AttrStmt p
               (Language.Fortran.Attr p)
               [(Language.Fortran.Expr p, Language.Fortran.Expr p,
                 GHC.Base.Maybe GHC.Types.Int)]
    | AccessStmt p (Language.Fortran.Attr p) [Language.Fortran.GSpec p]
    | ExternalStmt p [GHC.Base.String]
    | Interface p
                (GHC.Base.Maybe (Language.Fortran.GSpec p))
                [Language.Fortran.InterfaceSpec p]
    | Common p
             Language.Fortran.SrcSpan
             (GHC.Base.Maybe GHC.Base.String)
             [Language.Fortran.Expr p]
    | DerivedTypeDef p
                     Language.Fortran.SrcSpan
                     (Language.Fortran.SubName p)
                     [Language.Fortran.Attr p]
                     [Language.Fortran.Attr p]
                     [Language.Fortran.Decl p]
    | Include p (Language.Fortran.Expr p)
    | DSeq p (Language.Fortran.Decl p) (Language.Fortran.Decl p)
    | TextDecl p GHC.Base.String
    | NullDecl p Language.Fortran.SrcSpan
    | MeasureUnitDef p
                     Language.Fortran.SrcSpan
                     [(Language.Fortran.MeasureUnit,
                       Language.Fortran.MeasureUnitSpec p)]
fd45c3abbcc1cd23ca18c96ee1403b96
  data Expr p
    = Con p Language.Fortran.SrcSpan GHC.Base.String
    | ConL p Language.Fortran.SrcSpan GHC.Types.Char GHC.Base.String
    | ConS p Language.Fortran.SrcSpan GHC.Base.String
    | ParenthesizedExpr p
                        Language.Fortran.SrcSpan
                        (Language.Fortran.Expr p)
    | Var p
          Language.Fortran.SrcSpan
          [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
    | Bin p
          Language.Fortran.SrcSpan
          (Language.Fortran.BinOp p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
    | Unary p
            Language.Fortran.SrcSpan
            (Language.Fortran.UnaryOp p)
            (Language.Fortran.Expr p)
    | CallExpr p
               Language.Fortran.SrcSpan
               (Language.Fortran.Expr p)
               (Language.Fortran.ArgList p)
    | NullExpr p Language.Fortran.SrcSpan
    | Null p Language.Fortran.SrcSpan
    | ESeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.Expr p)
    | Bound p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            (Language.Fortran.Expr p)
    | Sqrt p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | ArrayCon p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | AssgExpr p
               Language.Fortran.SrcSpan
               GHC.Base.String
               (Language.Fortran.Expr p)
7ef8d1883356542a2e7829f1c3512bc2
  data Fortran p
    = Assg p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.Expr p)
    | For p
          Language.Fortran.SrcSpan
          (Language.Fortran.VarName p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Fortran p)
    | DoWhile p
              Language.Fortran.SrcSpan
              (Language.Fortran.Expr p)
              (Language.Fortran.Fortran p)
    | FSeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.Fortran p)
           (Language.Fortran.Fortran p)
    | If p
         Language.Fortran.SrcSpan
         (Language.Fortran.Expr p)
         (Language.Fortran.Fortran p)
         [(Language.Fortran.Expr p, Language.Fortran.Fortran p)]
         (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | Allocate p
               Language.Fortran.SrcSpan
               (Language.Fortran.Expr p)
               (Language.Fortran.Expr p)
    | Backspace p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Call p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.ArgList p)
    | Open p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Close p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Continue p Language.Fortran.SrcSpan
    | Cycle p Language.Fortran.SrcSpan GHC.Base.String
    | DataStmt p Language.Fortran.SrcSpan (Language.Fortran.DataForm p)
    | Deallocate p
                 Language.Fortran.SrcSpan
                 [Language.Fortran.Expr p]
                 (Language.Fortran.Expr p)
    | Endfile p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Exit p Language.Fortran.SrcSpan GHC.Base.String
    | Format p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Forall p
             Language.Fortran.SrcSpan
             ([(GHC.Base.String, Language.Fortran.Expr p,
                Language.Fortran.Expr p, Language.Fortran.Expr p)],
              Language.Fortran.Expr p)
             (Language.Fortran.Fortran p)
    | Goto p Language.Fortran.SrcSpan GHC.Base.String
    | Nullify p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | Inquire p
              Language.Fortran.SrcSpan
              [Language.Fortran.Spec p]
              [Language.Fortran.Expr p]
    | Pause p Language.Fortran.SrcSpan GHC.Base.String
    | Rewind p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Stop p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | Where p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            (Language.Fortran.Fortran p)
            (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | Write p
            Language.Fortran.SrcSpan
            [Language.Fortran.Spec p]
            [Language.Fortran.Expr p]
    | PointerAssg p
                  Language.Fortran.SrcSpan
                  (Language.Fortran.Expr p)
                  (Language.Fortran.Expr p)
    | Return p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | Label p
            Language.Fortran.SrcSpan
            GHC.Base.String
            (Language.Fortran.Fortran p)
    | Print p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            [Language.Fortran.Expr p]
    | ReadS p
            Language.Fortran.SrcSpan
            [Language.Fortran.Spec p]
            [Language.Fortran.Expr p]
    | TextStmt p Language.Fortran.SrcSpan GHC.Base.String
    | NullStmt p Language.Fortran.SrcSpan
    | SelectStmt p
                 Language.Fortran.SrcSpan
                 (Language.Fortran.Expr p)
                 [(Language.Fortran.Expr p, Language.Fortran.Fortran p)]
                 (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | OpenCLMap p
                Language.Fortran.SrcSpan
                [Language.Fortran.VarName p]
                [Language.Fortran.VarName p]
                [(Language.Fortran.VarName p, Language.Fortran.Expr p,
                  Language.Fortran.Expr p, Language.Fortran.Expr p)]
                [Language.Fortran.VarName p]
                (Language.Fortran.Fortran p)
    | OpenCLReduce p
                   Language.Fortran.SrcSpan
                   [Language.Fortran.VarName p]
                   [Language.Fortran.VarName p]
                   [(Language.Fortran.VarName p, Language.Fortran.Expr p,
                     Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   [Language.Fortran.VarName p]
                   [(Language.Fortran.VarName p, Language.Fortran.Expr p)]
                   (Language.Fortran.Fortran p)
    | OpenCLSeq p
                Language.Fortran.SrcSpan
                [Language.Fortran.VarName p]
                [Language.Fortran.VarName p]
                (Language.Fortran.Fortran p)
    | OpenCLBufferRead p
                       Language.Fortran.SrcSpan
                       (Language.Fortran.VarName p)
    | OpenCLBufferWrite p
                        Language.Fortran.SrcSpan
                        (Language.Fortran.VarName p)
53046a0aa1c261e776a228d9d40263ca
  data Fraction p
    = IntegerConst p GHC.Base.String
    | FractionConst p GHC.Base.String GHC.Base.String
    | NullFraction p
573851d0f4eec5dd746d11fb7a0852b2
  data GSpec p
    = GName p (Language.Fortran.Expr p)
    | GOper p (Language.Fortran.BinOp p)
    | GAssg p
ed3a262a18b570752c320c116efb88d0
  data Implicit p = ImplicitNone p | ImplicitNull p
2e224cb3ca4fa18503a4d24170747dce
  data IntentAttr p = In p | Out p | InOut p
c4465a5758b20b0d6387c4cda8774a94
  data InterfaceSpec p
    = FunctionInterface p
                        (Language.Fortran.SubName p)
                        (Language.Fortran.Arg p)
                        (Language.Fortran.Uses p)
                        (Language.Fortran.Implicit p)
                        (Language.Fortran.Decl p)
    | SubroutineInterface p
                          (Language.Fortran.SubName p)
                          (Language.Fortran.Arg p)
                          (Language.Fortran.Uses p)
                          (Language.Fortran.Implicit p)
                          (Language.Fortran.Decl p)
    | ModuleProcedure p [Language.Fortran.SubName p]
371fdd44cdce36d08f19eb19bf24d7dd
  type MeasureUnit = GHC.Base.String
2d20a52afd34a2922ea97a5d3a8025ba
  data MeasureUnitSpec p
    = UnitProduct p
                  [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
    | UnitQuotient p
                   [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
    | UnitNone p
560bedfe49d5934c1863dc54ac29ae0c
  type ProgName = GHC.Base.String
dd0d2763607dbd5a6f6c1c5d85fe76dd
  data ProgUnit p
    = Main p
           Language.Fortran.SrcSpan
           (Language.Fortran.SubName p)
           (Language.Fortran.Arg p)
           (Language.Fortran.Block p)
           [Language.Fortran.ProgUnit p]
    | Sub p
          Language.Fortran.SrcSpan
          (GHC.Base.Maybe (Language.Fortran.BaseType p))
          (Language.Fortran.SubName p)
          (Language.Fortran.Arg p)
          (Language.Fortran.Block p)
    | Function p
               Language.Fortran.SrcSpan
               (GHC.Base.Maybe (Language.Fortran.BaseType p))
               (Language.Fortran.SubName p)
               (Language.Fortran.Arg p)
               (GHC.Base.Maybe (Language.Fortran.VarName p))
               (Language.Fortran.Block p)
    | Module p
             Language.Fortran.SrcSpan
             (Language.Fortran.SubName p)
             (Language.Fortran.Uses p)
             (Language.Fortran.Implicit p)
             (Language.Fortran.Decl p)
             [Language.Fortran.ProgUnit p]
    | BlockData p
                Language.Fortran.SrcSpan
                (Language.Fortran.SubName p)
                (Language.Fortran.Uses p)
                (Language.Fortran.Implicit p)
                (Language.Fortran.Decl p)
    | PSeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.ProgUnit p)
           (Language.Fortran.ProgUnit p)
    | Prog p Language.Fortran.SrcSpan (Language.Fortran.ProgUnit p)
    | NullProg p Language.Fortran.SrcSpan
    | IncludeProg p
                  Language.Fortran.SrcSpan
                  (Language.Fortran.Decl p)
                  (GHC.Base.Maybe (Language.Fortran.Fortran p))
61c057161e42f4aa29fb8dd8afb17b21
  type Program p = [Language.Fortran.ProgUnit p]
178765c969ba9395d0fac6b77b9f7495
  type Renames =
    [(Language.Fortran.Variable, Language.Fortran.Variable)]
26c91c6356024c66c1ddaead2c481300
  class Span t where
    srcSpan :: t -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    {-# MINIMAL srcSpan #-}
ba4cf92c8e04874adf9aa301c7b40b26
  data Spec p
    = Access p (Language.Fortran.Expr p)
    | Action p (Language.Fortran.Expr p)
    | Advance p (Language.Fortran.Expr p)
    | Blank p (Language.Fortran.Expr p)
    | Delim p (Language.Fortran.Expr p)
    | Direct p (Language.Fortran.Expr p)
    | End p (Language.Fortran.Expr p)
    | Err p (Language.Fortran.Expr p)
    | ExFile p (Language.Fortran.Expr p)
    | Exist p (Language.Fortran.Expr p)
    | Eor p (Language.Fortran.Expr p)
    | File p (Language.Fortran.Expr p)
    | FMT p (Language.Fortran.Expr p)
    | Form p (Language.Fortran.Expr p)
    | Formatted p (Language.Fortran.Expr p)
    | Unformatted p (Language.Fortran.Expr p)
    | IOLength p (Language.Fortran.Expr p)
    | IOStat p (Language.Fortran.Expr p)
    | Name p (Language.Fortran.Expr p)
    | Named p (Language.Fortran.Expr p)
    | NoSpec p (Language.Fortran.Expr p)
    | Number p (Language.Fortran.Expr p)
    | Floating p (Language.Fortran.Expr p) (Language.Fortran.Expr p)
    | NextRec p (Language.Fortran.Expr p)
    | NML p (Language.Fortran.Expr p)
    | Opened p (Language.Fortran.Expr p)
    | Pad p (Language.Fortran.Expr p)
    | Position p (Language.Fortran.Expr p)
    | Read p (Language.Fortran.Expr p)
    | ReadWrite p (Language.Fortran.Expr p)
    | Rec p (Language.Fortran.Expr p)
    | Recl p (Language.Fortran.Expr p)
    | Sequential p (Language.Fortran.Expr p)
    | Size p (Language.Fortran.Expr p)
    | Status p (Language.Fortran.Expr p)
    | StringLit p GHC.Base.String
    | Unit p (Language.Fortran.Expr p)
    | WriteSp p (Language.Fortran.Expr p)
    | Delimiter p
43c2e4e6db773bb5ef99bf585d69acf2
  data SrcLoc
    = SrcLoc {srcFilename :: GHC.Base.String,
              srcLine :: GHC.Types.Int,
              srcColumn :: GHC.Types.Int}
a18da1424c2a105ac654e1e8b2930f03
  type SrcSpan = (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
d09f243eb3eeec0d44a1b799f2b23e72
  data SubName p = SubName p GHC.Base.String | NullSubName p
d98a5141e506956822df4a093404b8b6
  class Tagged (d :: * -> *) where
    tag :: d a -> a
    {-# MINIMAL tag #-}
cac90f1d6845827f0c2780e86e10c606
  data Type p
    = BaseType p
               (Language.Fortran.BaseType p)
               [Language.Fortran.Attr p]
               (Language.Fortran.Expr p)
               (Language.Fortran.Expr p)
    | ArrayT p
             [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
             (Language.Fortran.BaseType p)
             [Language.Fortran.Attr p]
             (Language.Fortran.Expr p)
             (Language.Fortran.Expr p)
18f51ff76072ffaca3ec46558a1d5bc9
  data UnaryOp p = UMinus p | Not p
d59de0314bb55c907d315303e8c78677
  data UseBlock p
    = UseBlock (Language.Fortran.Uses p) Language.Fortran.SrcLoc
22a7293c3f9ba679ea60d591f21568e8
  data Uses p
    = Use p
          (GHC.Base.String, Language.Fortran.Renames)
          (Language.Fortran.Uses p)
          p
    | UseNil p
d4d45769399fe3ed8e0615e3282cf5b7
  data VarName p = VarName p Language.Fortran.Variable
9c4437b362682825a1225c414b36a0c2
  type Variable = GHC.Base.String
937293bf8b997ee0249577ca693be248
  srcColumn :: Language.Fortran.SrcLoc -> GHC.Types.Int
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds3 }) -}
eb911b891160c33666f082b2362a3c91
  srcFilename :: Language.Fortran.SrcLoc -> GHC.Base.String
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds1 }) -}
aba8cf16bc5c492917070c451b179553
  srcLine :: Language.Fortran.SrcLoc -> GHC.Types.Int
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds2 }) -}
instance Data.Data.Data [Language.Fortran.Arg]
  = Language.Fortran.$fDataArg
instance Data.Data.Data [Language.Fortran.ArgList]
  = Language.Fortran.$fDataArgList
instance Data.Data.Data [Language.Fortran.ArgName]
  = Language.Fortran.$fDataArgName
instance Data.Data.Data [Language.Fortran.Attr]
  = Language.Fortran.$fDataAttr
instance Data.Data.Data [Language.Fortran.BaseType]
  = Language.Fortran.$fDataBaseType
instance Data.Data.Data [Language.Fortran.BinOp]
  = Language.Fortran.$fDataBinOp
instance Data.Data.Data [Language.Fortran.Block]
  = Language.Fortran.$fDataBlock
instance Data.Data.Data [Language.Fortran.DataForm]
  = Language.Fortran.$fDataDataForm
instance Data.Data.Data [Language.Fortran.Decl]
  = Language.Fortran.$fDataDecl
instance Data.Data.Data [Language.Fortran.Expr]
  = Language.Fortran.$fDataExpr
instance Data.Data.Data [Language.Fortran.Fortran]
  = Language.Fortran.$fDataFortran
instance Data.Data.Data [Language.Fortran.Fraction]
  = Language.Fortran.$fDataFraction
instance Data.Data.Data [Language.Fortran.GSpec]
  = Language.Fortran.$fDataGSpec
instance Data.Data.Data [Language.Fortran.Implicit]
  = Language.Fortran.$fDataImplicit
instance Data.Data.Data [Language.Fortran.IntentAttr]
  = Language.Fortran.$fDataIntentAttr
instance Data.Data.Data [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fDataInterfaceSpec
instance Data.Data.Data [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fDataMeasureUnitSpec
instance Data.Data.Data [Language.Fortran.ProgUnit]
  = Language.Fortran.$fDataProgUnit
instance Data.Data.Data [Language.Fortran.Spec]
  = Language.Fortran.$fDataSpec
instance Data.Data.Data [Language.Fortran.SrcLoc]
  = Language.Fortran.$fDataSrcLoc
instance Data.Data.Data [Language.Fortran.SubName]
  = Language.Fortran.$fDataSubName
instance Data.Data.Data [Language.Fortran.Type]
  = Language.Fortran.$fDataType
instance Data.Data.Data [Language.Fortran.UnaryOp]
  = Language.Fortran.$fDataUnaryOp
instance Data.Data.Data [Language.Fortran.UseBlock]
  = Language.Fortran.$fDataUseBlock
instance Data.Data.Data [Language.Fortran.Uses]
  = Language.Fortran.$fDataUses
instance Data.Data.Data [Language.Fortran.VarName]
  = Language.Fortran.$fDataVarName
instance GHC.Classes.Eq [Language.Fortran.Arg]
  = Language.Fortran.$fEqArg
instance GHC.Classes.Eq [Language.Fortran.ArgList]
  = Language.Fortran.$fEqArgList
instance GHC.Classes.Eq [Language.Fortran.ArgName]
  = Language.Fortran.$fEqArgName
instance GHC.Classes.Eq [Language.Fortran.Attr]
  = Language.Fortran.$fEqAttr
instance GHC.Classes.Eq [Language.Fortran.BaseType]
  = Language.Fortran.$fEqBaseType
instance GHC.Classes.Eq [Language.Fortran.BinOp]
  = Language.Fortran.$fEqBinOp
instance GHC.Classes.Eq [Language.Fortran.Block]
  = Language.Fortran.$fEqBlock
instance GHC.Classes.Eq [Language.Fortran.DataForm]
  = Language.Fortran.$fEqDataForm
instance GHC.Classes.Eq [Language.Fortran.Decl]
  = Language.Fortran.$fEqDecl
instance GHC.Classes.Eq [Language.Fortran.Expr]
  = Language.Fortran.$fEqExpr
instance GHC.Classes.Eq [Language.Fortran.Fortran]
  = Language.Fortran.$fEqFortran
instance GHC.Classes.Eq [Language.Fortran.Fraction]
  = Language.Fortran.$fEqFraction
instance GHC.Classes.Eq [Language.Fortran.GSpec]
  = Language.Fortran.$fEqGSpec
instance GHC.Classes.Eq [Language.Fortran.Implicit]
  = Language.Fortran.$fEqImplicit
instance GHC.Classes.Eq [Language.Fortran.IntentAttr]
  = Language.Fortran.$fEqIntentAttr
instance GHC.Classes.Eq [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fEqInterfaceSpec
instance GHC.Classes.Eq [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fEqMeasureUnitSpec
instance GHC.Classes.Eq [Language.Fortran.ProgUnit]
  = Language.Fortran.$fEqProgUnit
instance GHC.Classes.Eq [Language.Fortran.Spec]
  = Language.Fortran.$fEqSpec
instance GHC.Classes.Eq [Language.Fortran.SrcLoc]
  = Language.Fortran.$fEqSrcLoc
instance GHC.Classes.Eq [Language.Fortran.SubName]
  = Language.Fortran.$fEqSubName
instance GHC.Classes.Eq [Language.Fortran.Type]
  = Language.Fortran.$fEqType
instance GHC.Classes.Eq [Language.Fortran.UnaryOp]
  = Language.Fortran.$fEqUnaryOp
instance GHC.Classes.Eq [Language.Fortran.UseBlock]
  = Language.Fortran.$fEqUseBlock
instance GHC.Classes.Eq [Language.Fortran.Uses]
  = Language.Fortran.$fEqUses
instance GHC.Classes.Eq [Language.Fortran.VarName]
  = Language.Fortran.$fEqVarName
instance GHC.Base.Functor [Language.Fortran.Arg]
  = Language.Fortran.$fFunctorArg
instance GHC.Base.Functor [Language.Fortran.ArgList]
  = Language.Fortran.$fFunctorArgList
instance GHC.Base.Functor [Language.Fortran.ArgName]
  = Language.Fortran.$fFunctorArgName
instance GHC.Base.Functor [Language.Fortran.Attr]
  = Language.Fortran.$fFunctorAttr
instance GHC.Base.Functor [Language.Fortran.BaseType]
  = Language.Fortran.$fFunctorBaseType
instance GHC.Base.Functor [Language.Fortran.BinOp]
  = Language.Fortran.$fFunctorBinOp
instance GHC.Base.Functor [Language.Fortran.Block]
  = Language.Fortran.$fFunctorBlock
instance GHC.Base.Functor [Language.Fortran.DataForm]
  = Language.Fortran.$fFunctorDataForm
instance GHC.Base.Functor [Language.Fortran.Decl]
  = Language.Fortran.$fFunctorDecl
instance GHC.Base.Functor [Language.Fortran.Expr]
  = Language.Fortran.$fFunctorExpr
instance GHC.Base.Functor [Language.Fortran.Fortran]
  = Language.Fortran.$fFunctorFortran
instance GHC.Base.Functor [Language.Fortran.Fraction]
  = Language.Fortran.$fFunctorFraction
instance GHC.Base.Functor [Language.Fortran.GSpec]
  = Language.Fortran.$fFunctorGSpec
instance GHC.Base.Functor [Language.Fortran.Implicit]
  = Language.Fortran.$fFunctorImplicit
instance GHC.Base.Functor [Language.Fortran.IntentAttr]
  = Language.Fortran.$fFunctorIntentAttr
instance GHC.Base.Functor [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fFunctorInterfaceSpec
instance GHC.Base.Functor [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fFunctorMeasureUnitSpec
instance GHC.Base.Functor [Language.Fortran.ProgUnit]
  = Language.Fortran.$fFunctorProgUnit
instance GHC.Base.Functor [Language.Fortran.Spec]
  = Language.Fortran.$fFunctorSpec
instance GHC.Base.Functor [Language.Fortran.SubName]
  = Language.Fortran.$fFunctorSubName
instance GHC.Base.Functor [Language.Fortran.Type]
  = Language.Fortran.$fFunctorType
instance GHC.Base.Functor [Language.Fortran.UnaryOp]
  = Language.Fortran.$fFunctorUnaryOp
instance GHC.Base.Functor [Language.Fortran.UseBlock]
  = Language.Fortran.$fFunctorUseBlock
instance GHC.Base.Functor [Language.Fortran.Uses]
  = Language.Fortran.$fFunctorUses
instance GHC.Base.Functor [Language.Fortran.VarName]
  = Language.Fortran.$fFunctorVarName
instance GHC.Classes.Ord [Language.Fortran.VarName]
  = Language.Fortran.$fOrdVarName
instance GHC.Read.Read [Language.Fortran.VarName]
  = Language.Fortran.$fReadVarName
instance GHC.Show.Show [Language.Fortran.Arg]
  = Language.Fortran.$fShowArg
instance GHC.Show.Show [Language.Fortran.ArgList]
  = Language.Fortran.$fShowArgList
instance GHC.Show.Show [Language.Fortran.ArgName]
  = Language.Fortran.$fShowArgName
instance GHC.Show.Show [Language.Fortran.Attr]
  = Language.Fortran.$fShowAttr
instance GHC.Show.Show [Language.Fortran.BaseType]
  = Language.Fortran.$fShowBaseType
instance GHC.Show.Show [Language.Fortran.BinOp]
  = Language.Fortran.$fShowBinOp
instance GHC.Show.Show [Language.Fortran.Block]
  = Language.Fortran.$fShowBlock
instance GHC.Show.Show [Language.Fortran.DataForm]
  = Language.Fortran.$fShowDataForm
instance GHC.Show.Show [Language.Fortran.Decl]
  = Language.Fortran.$fShowDecl
instance GHC.Show.Show [Language.Fortran.Expr]
  = Language.Fortran.$fShowExpr
instance GHC.Show.Show [Language.Fortran.Fortran]
  = Language.Fortran.$fShowFortran
instance GHC.Show.Show [Language.Fortran.Fraction]
  = Language.Fortran.$fShowFraction
instance GHC.Show.Show [Language.Fortran.GSpec]
  = Language.Fortran.$fShowGSpec
instance GHC.Show.Show [Language.Fortran.Implicit]
  = Language.Fortran.$fShowImplicit
instance GHC.Show.Show [Language.Fortran.IntentAttr]
  = Language.Fortran.$fShowIntentAttr
instance GHC.Show.Show [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fShowInterfaceSpec
instance GHC.Show.Show [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fShowMeasureUnitSpec
instance GHC.Show.Show [Language.Fortran.ProgUnit]
  = Language.Fortran.$fShowProgUnit
instance GHC.Show.Show [Language.Fortran.Spec]
  = Language.Fortran.$fShowSpec
instance GHC.Show.Show [Language.Fortran.SrcLoc]
  = Language.Fortran.$fShowSrcLoc
instance GHC.Show.Show [Language.Fortran.SubName]
  = Language.Fortran.$fShowSubName
instance GHC.Show.Show [Language.Fortran.Type]
  = Language.Fortran.$fShowType
instance GHC.Show.Show [Language.Fortran.UnaryOp]
  = Language.Fortran.$fShowUnaryOp
instance GHC.Show.Show [Language.Fortran.UseBlock]
  = Language.Fortran.$fShowUseBlock
instance GHC.Show.Show [Language.Fortran.Uses]
  = Language.Fortran.$fShowUses
instance GHC.Show.Show [Language.Fortran.VarName]
  = Language.Fortran.$fShowVarName
instance Language.Fortran.Span [Language.Fortran.Block]
  = Language.Fortran.$fSpanBlock
instance Language.Fortran.Span [Language.Fortran.Decl]
  = Language.Fortran.$fSpanDecl
instance Language.Fortran.Span [Language.Fortran.Expr]
  = Language.Fortran.$fSpanExpr
instance Language.Fortran.Span [Language.Fortran.Fortran]
  = Language.Fortran.$fSpanFortran
instance Language.Fortran.Span [Language.Fortran.ProgUnit]
  = Language.Fortran.$fSpanProgUnit
instance Language.Fortran.Tagged [Language.Fortran.Arg]
  = Language.Fortran.$fTaggedArg
instance Language.Fortran.Tagged [Language.Fortran.ArgList]
  = Language.Fortran.$fTaggedArgList
instance Language.Fortran.Tagged [Language.Fortran.ArgName]
  = Language.Fortran.$fTaggedArgName
instance Language.Fortran.Tagged [Language.Fortran.Attr]
  = Language.Fortran.$fTaggedAttr
instance Language.Fortran.Tagged [Language.Fortran.BaseType]
  = Language.Fortran.$fTaggedBaseType
instance Language.Fortran.Tagged [Language.Fortran.DataForm]
  = Language.Fortran.$fTaggedDataForm
instance Language.Fortran.Tagged [Language.Fortran.Decl]
  = Language.Fortran.$fTaggedDecl
instance Language.Fortran.Tagged [Language.Fortran.Expr]
  = Language.Fortran.$fTaggedExpr
instance Language.Fortran.Tagged [Language.Fortran.Fortran]
  = Language.Fortran.$fTaggedFortran
instance Language.Fortran.Tagged [Language.Fortran.GSpec]
  = Language.Fortran.$fTaggedGSpec
instance Language.Fortran.Tagged [Language.Fortran.Implicit]
  = Language.Fortran.$fTaggedImplicit
instance Language.Fortran.Tagged [Language.Fortran.ProgUnit]
  = Language.Fortran.$fTaggedProgUnit
instance Language.Fortran.Tagged [Language.Fortran.SubName]
  = Language.Fortran.$fTaggedSubName
instance Language.Fortran.Tagged [Language.Fortran.Uses]
  = Language.Fortran.$fTaggedUses
instance Language.Fortran.Tagged [Language.Fortran.VarName]
  = Language.Fortran.$fTaggedVarName
"SPEC/Language.Fortran $fData(,) @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                  Language.Fortran.SrcLoc)
                                                                    ($dData :: Data.Data.Data
                                                                                 Language.Fortran.SrcLoc)
  Data.Data.$fData(,) @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      $dData
                      $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)
"SPEC/Language.Fortran $fData(,) @ [Char] @ [(Variable, Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                  [(Language.Fortran.Variable,
                                                                                                    Language.Fortran.Variable)])
                                                                                    ($dData :: Data.Data.Data
                                                                                                 [GHC.Types.Char])
  Data.Data.$fData(,) @ [GHC.Types.Char]
                      @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                      $dData
                      $dData1
  = Language.Fortran.$s$fData(,)1
"SPEC/Language.Fortran $fData(,) @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                  [GHC.Types.Char])
                                                                    ($dData :: Data.Data.Data
                                                                                 [GHC.Types.Char])
  Data.Data.$fData(,) @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      $dData
                      $dData1
  = Language.Fortran.$s$fData(,)
"SPEC/Language.Fortran $fData(,)_$cdataCast1 @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                              [GHC.Types.Char])
                                                                                ($dData :: Data.Data.Data
                                                                                             [GHC.Types.Char])
  Data.Data.$fData(,)_$cdataCast1 @ [GHC.Types.Char]
                                  @ [GHC.Types.Char]
                                  $dData
                                  $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cdataCast1
"SPEC/Language.Fortran $fData(,)_$cdataTypeOf @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                               [GHC.Types.Char])
                                                                                 ($dData :: Data.Data.Data
                                                                                              [GHC.Types.Char])
  Data.Data.$fData(,)_$cdataTypeOf @ [GHC.Types.Char]
                                   @ [GHC.Types.Char]
                                   $dData
                                   $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cdataTypeOf
"SPEC/Language.Fortran $fData(,)_$cgfoldl @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           Language.Fortran.SrcLoc)
                                                                             ($dData :: Data.Data.Data
                                                                                          Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgfoldl @ Language.Fortran.SrcLoc
                               @ Language.Fortran.SrcLoc
                               $dData
                               $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)_$cgfoldl
"SPEC/Language.Fortran $fData(,)_$cgfoldl @ [Char] @ [(Variable,
                                                      Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                                                                                 [(Language.Fortran.Variable,
                                                                                                                                                                   Language.Fortran.Variable)])
                                                                                                                                                   ($dData :: Data.Data.Data
                                                                                                                                                                [GHC.Types.Char])
  Data.Data.$fData(,)_$cgfoldl @ [GHC.Types.Char]
                               @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgfoldl1
"SPEC/Language.Fortran $fData(,)_$cgfoldl @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           [GHC.Types.Char])
                                                                             ($dData :: Data.Data.Data
                                                                                          [GHC.Types.Char])
  Data.Data.$fData(,)_$cgfoldl @ [GHC.Types.Char]
                               @ [GHC.Types.Char]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgfoldl
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                          Language.Fortran.SrcLoc)
                                                                            ($dData :: Data.Data.Data
                                                                                         Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapQ @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc
                              $dData
                              $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQ
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ [Char] @ [(Variable,
                                                     Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                                                                               [(Language.Fortran.Variable,
                                                                                                                                                                 Language.Fortran.Variable)])
                                                                                                                                                 ($dData :: Data.Data.Data
                                                                                                                                                              [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQ @ [GHC.Types.Char]
                              @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                              $dData
                              $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQ1
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                          [GHC.Types.Char])
                                                                            ($dData :: Data.Data.Data
                                                                                         [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQ @ [GHC.Types.Char]
                              @ [GHC.Types.Char]
                              $dData
                              $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQ
"SPEC/Language.Fortran $fData(,)_$cgmapQi @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           Language.Fortran.SrcLoc)
                                                                             ($dData :: Data.Data.Data
                                                                                          Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapQi @ Language.Fortran.SrcLoc
                               @ Language.Fortran.SrcLoc
                               $dData
                               $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQi
"SPEC/Language.Fortran $fData(,)_$cgmapQi @ [Char] @ [(Variable,
                                                      Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                                                                                 [(Language.Fortran.Variable,
                                                                                                                                                                   Language.Fortran.Variable)])
                                                                                                                                                   ($dData :: Data.Data.Data
                                                                                                                                                                [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQi @ [GHC.Types.Char]
                               @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQi1
"SPEC/Language.Fortran $fData(,)_$cgmapQi @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           [GHC.Types.Char])
                                                                             ($dData :: Data.Data.Data
                                                                                          [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQi @ [GHC.Types.Char]
                               @ [GHC.Types.Char]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQi
"SPEC/Language.Fortran $fData(,)_$cgmapQl @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           Language.Fortran.SrcLoc)
                                                                             ($dData :: Data.Data.Data
                                                                                          Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapQl @ Language.Fortran.SrcLoc
                               @ Language.Fortran.SrcLoc
                               $dData
                               $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQl
"SPEC/Language.Fortran $fData(,)_$cgmapQl @ [Char] @ [(Variable,
                                                      Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                                                                                 [(Language.Fortran.Variable,
                                                                                                                                                                   Language.Fortran.Variable)])
                                                                                                                                                   ($dData :: Data.Data.Data
                                                                                                                                                                [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQl @ [GHC.Types.Char]
                               @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQl1
"SPEC/Language.Fortran $fData(,)_$cgmapQl @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           [GHC.Types.Char])
                                                                             ($dData :: Data.Data.Data
                                                                                          [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQl @ [GHC.Types.Char]
                               @ [GHC.Types.Char]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQl
"SPEC/Language.Fortran $fData(,)_$cgmapQr @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           Language.Fortran.SrcLoc)
                                                                             ($dData :: Data.Data.Data
                                                                                          Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapQr @ Language.Fortran.SrcLoc
                               @ Language.Fortran.SrcLoc
                               $dData
                               $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)_$cgmapQr
"SPEC/Language.Fortran $fData(,)_$cgmapQr @ [Char] @ [(Variable,
                                                      Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                                                                                 [(Language.Fortran.Variable,
                                                                                                                                                                   Language.Fortran.Variable)])
                                                                                                                                                   ($dData :: Data.Data.Data
                                                                                                                                                                [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQr @ [GHC.Types.Char]
                               @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQr1
"SPEC/Language.Fortran $fData(,)_$cgmapQr @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                           [GHC.Types.Char])
                                                                             ($dData :: Data.Data.Data
                                                                                          [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQr @ [GHC.Types.Char]
                               @ [GHC.Types.Char]
                               $dData
                               $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapQr
"SPEC/Language.Fortran $fData(,)_$cgmapT @ SrcLoc @ SrcLoc" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                          Language.Fortran.SrcLoc)
                                                                            ($dData :: Data.Data.Data
                                                                                         Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapT @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc
                              $dData
                              $dData1
  = Language.Fortran.$fDataArg_$s$fData(,)_$cgmapT
"SPEC/Language.Fortran $fData(,)_$cgmapT @ [Char] @ [(Variable,
                                                     Variable)]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                                                                                               [(Language.Fortran.Variable,
                                                                                                                                                                 Language.Fortran.Variable)])
                                                                                                                                                 ($dData :: Data.Data.Data
                                                                                                                                                              [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapT @ [GHC.Types.Char]
                              @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                              $dData
                              $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapT1
"SPEC/Language.Fortran $fData(,)_$cgmapT @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                          [GHC.Types.Char])
                                                                            ($dData :: Data.Data.Data
                                                                                         [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapT @ [GHC.Types.Char]
                              @ [GHC.Types.Char]
                              $dData
                              $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$cgmapT
"SPEC/Language.Fortran $fData(,)_$ctoConstr @ [Char] @ [Char]" [ALWAYS] forall ($dData1 :: Data.Data.Data
                                                                                             [GHC.Types.Char])
                                                                               ($dData :: Data.Data.Data
                                                                                            [GHC.Types.Char])
  Data.Data.$fData(,)_$ctoConstr @ [GHC.Types.Char]
                                 @ [GHC.Types.Char]
                                 $dData
                                 $dData1
  = Language.Fortran.$s$fData(,)_$s$fData(,)_$ctoConstr
"SPEC/Language.Fortran $fDataMaybe @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                       GHC.Types.Int)
  Data.Data.$fDataMaybe @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe1
"SPEC/Language.Fortran $fDataMaybe @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                          [GHC.Types.Char])
  Data.Data.$fDataMaybe @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe
"SPEC/Language.Fortran $fDataMaybe_$cdataCast2 @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                   GHC.Types.Int)
  Data.Data.$fDataMaybe_$cdataCast2 @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataCast1
"SPEC/Language.Fortran $fDataMaybe_$cdataCast2 @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                      [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cdataCast2 @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataCast2
"SPEC/Language.Fortran $fDataMaybe_$cdataTypeOf @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                    GHC.Types.Int)
  Data.Data.$fDataMaybe_$cdataTypeOf @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataTypeOf1
"SPEC/Language.Fortran $fDataMaybe_$cdataTypeOf @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                       [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cdataTypeOf @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cdataTypeOf
"SPEC/Language.Fortran $fDataMaybe_$cgfoldl @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgfoldl @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgfoldl1
"SPEC/Language.Fortran $fDataMaybe_$cgfoldl @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgfoldl @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgfoldl
"SPEC/Language.Fortran $fDataMaybe_$cgmapQ @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                               GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQ @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQ1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQ @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                  [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQ @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQ
"SPEC/Language.Fortran $fDataMaybe_$cgmapQi @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQi @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQi1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQi @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQi @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQi
"SPEC/Language.Fortran $fDataMaybe_$cgmapQl @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQl @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQl1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQl @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQl @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQl
"SPEC/Language.Fortran $fDataMaybe_$cgmapQr @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQr @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQr1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQr @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQr @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapQr
"SPEC/Language.Fortran $fDataMaybe_$cgmapT @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                               GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapT @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapT1
"SPEC/Language.Fortran $fDataMaybe_$cgmapT @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                  [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapT @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$cgmapT
"SPEC/Language.Fortran $fDataMaybe_$ctoConstr @ Int" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                  GHC.Types.Int)
  Data.Data.$fDataMaybe_$ctoConstr @ GHC.Types.Int $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$ctoConstr1
"SPEC/Language.Fortran $fDataMaybe_$ctoConstr @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                     [GHC.Types.Char])
  Data.Data.$fDataMaybe_$ctoConstr @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fDataMaybe_$s$fDataMaybe_$ctoConstr
"SPEC/Language.Fortran $fData[] @ (Variable, Variable)" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                     (Language.Fortran.Variable,
                                                                                      Language.Fortran.Variable))
  Data.Data.$fData[] @ (Language.Fortran.Variable,
                        Language.Fortran.Variable)
                     $dData
  = Language.Fortran.$s$fData(,)_$s$fData[]
"SPEC/Language.Fortran $fData[] @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                       [GHC.Types.Char])
  Data.Data.$fData[] @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fData[]
"SPEC/Language.Fortran $fData[]_$cdataCast2 @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fData[]_$cdataCast2 @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fData[]_$s$fData[]_$cdataCast2
"SPEC/Language.Fortran $fData[]_$cdataTypeOf @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fData[]_$cdataTypeOf @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fData[]_$s$fData[]_$cdataTypeOf
"SPEC/Language.Fortran $fData[]_$ctoConstr @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                  [GHC.Types.Char])
  Data.Data.$fData[]_$ctoConstr @ [GHC.Types.Char] $dData
  = Language.Fortran.$s$fData[]_$s$fData[]_$ctoConstr
"SPEC/Language.Fortran $fEq(,) @ [Char] @ [Char]" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                              [GHC.Types.Char])
                                                                  ($dEq :: GHC.Classes.Eq
                                                                             [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      $dEq
                      $dEq1
  = Language.Fortran.$s$fEq(,)
"SPEC/Language.Fortran $fEqMaybe @ Int" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                   GHC.Types.Int)
  GHC.Base.$fEqMaybe @ GHC.Types.Int $dEq
  = Language.Fortran.$s$fEqMaybe
"SPEC/Language.Fortran $fEqMaybe_$c== @ Int" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                        GHC.Types.Int)
  GHC.Base.$fEqMaybe_$c== @ GHC.Types.Int $dEq
  = Language.Fortran.$s$fEqMaybe_$s$fEqMaybe_$c==
"SPEC/Language.Fortran $fShow(,)_$cshowList @ [Char] @ [Char]" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                                             [GHC.Types.Char])
                                                                               ($dShow :: GHC.Show.Show
                                                                                            [GHC.Types.Char])
  GHC.Show.$fShow(,)_$cshowList @ [GHC.Types.Char]
                                @ [GHC.Types.Char]
                                $dShow
                                $dShow1
  = Language.Fortran.$s$fShow(,)_$s$fShow(,)_$cshowList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

