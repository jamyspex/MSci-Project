
==================== FINAL INTERFACE ====================
2018-12-03 15:55:04.120877 UTC

interface main@main:LanguageFortranTools 8002
  interface hash: 41aef159037eef5e73e2c4ab0defc3dc
  ABI hash: 7890a5e96ab51325aa3603dbd4691bf4
  export-list hash: 83b35210801e0c6fe3fd2a2c2ff1ecd0
  orphan hash: 190978ba4daf548db931d6d161786e60
  flag hash: 7c02f8b77a7db746ad4b6beb3be70535
  sig of: Nothing
  used TH splices: False
  where
exports:
  LanguageFortranTools.addImplicitNone
  LanguageFortranTools.addToValueTable
  LanguageFortranTools.addToValueTable_type
  LanguageFortranTools.appendAnnotation
  LanguageFortranTools.appendAnnotationList
  LanguageFortranTools.appendAnnotationMap
  LanguageFortranTools.appendFortran_recursive
  LanguageFortranTools.appendToMap
  LanguageFortranTools.applyGeneratedSrcSpans
  LanguageFortranTools.applyGlobalSrcSpan
  LanguageFortranTools.applySrcSpan
  LanguageFortranTools.checkSrcLocBefore
  LanguageFortranTools.checkSrcLocEqualLines
  LanguageFortranTools.checkSrcSpanAfter
  LanguageFortranTools.checkSrcSpanBefore
  LanguageFortranTools.checkSrcSpanBefore_line
  LanguageFortranTools.checkSrcSpanContainsSrcSpan
  LanguageFortranTools.combineAnnotations
  LanguageFortranTools.combineMaps
  LanguageFortranTools.commentSeparator
  LanguageFortranTools.commentSeparator'
  LanguageFortranTools.compilerName
  LanguageFortranTools.deleteValueFromTable
  LanguageFortranTools.errorLocationFormatting
  LanguageFortranTools.errorLocationRangeFormatting
  LanguageFortranTools.evaluateExpr
  LanguageFortranTools.evaluateExpr_type
  LanguageFortranTools.evaluateRange
  LanguageFortranTools.extractAllVarNames
  LanguageFortranTools.extractArgName
  LanguageFortranTools.extractAssigneeFromDecl
  LanguageFortranTools.extractAssignments
  LanguageFortranTools.extractBaseType
  LanguageFortranTools.extractBlock
  LanguageFortranTools.extractBufferReads
  LanguageFortranTools.extractBufferReads'
  LanguageFortranTools.extractBufferWrites
  LanguageFortranTools.extractBufferWrites'
  LanguageFortranTools.extractContainedOperands
  LanguageFortranTools.extractContainedVars
  LanguageFortranTools.extractContainedVarsWV
  LanguageFortranTools.extractDecl
  LanguageFortranTools.extractEvaluatedType
  LanguageFortranTools.extractEvaluatedValue
  LanguageFortranTools.extractExpr
  LanguageFortranTools.extractExpr_list
  LanguageFortranTools.extractFirstChildFor
  LanguageFortranTools.extractFirstFortran
  LanguageFortranTools.extractFor
  LanguageFortranTools.extractForWithFollowing
  LanguageFortranTools.extractForWithFollowing_beta
  LanguageFortranTools.extractFortran
  LanguageFortranTools.extractIndent
  LanguageFortranTools.extractKernels
  LanguageFortranTools.extractKernels'
  LanguageFortranTools.extractLineNumber
  LanguageFortranTools.extractLoopIters
  LanguageFortranTools.extractLoopIters'
  LanguageFortranTools.extractLoopVars
  LanguageFortranTools.extractLoopVars'
  LanguageFortranTools.extractLoops
  LanguageFortranTools.extractLoops'
  LanguageFortranTools.extractMaybeVarNames
  LanguageFortranTools.extractOpenCLReduces
  LanguageFortranTools.extractOpenCLReduces'
  LanguageFortranTools.extractOperands
  LanguageFortranTools.extractPrimaryReductionFunction
  LanguageFortranTools.extractPrimaryReductionOp
  LanguageFortranTools.extractPriorToFor
  LanguageFortranTools.extractReductionVarNames
  LanguageFortranTools.extractUsedVarName
  LanguageFortranTools.extractVarNames
  LanguageFortranTools.extractVarNames_loopVars
  LanguageFortranTools.findDeclLine
  LanguageFortranTools.findDeclLineVars
  LanguageFortranTools.generateAdditionExpr
  LanguageFortranTools.generateAndExpr
  LanguageFortranTools.generateAndExprFromList
  LanguageFortranTools.generateArrayVar
  LanguageFortranTools.generateAssgCode
  LanguageFortranTools.generateDivisionExpr
  LanguageFortranTools.generateESeq
  LanguageFortranTools.generateFSeq
  LanguageFortranTools.generateFloatConstant
  LanguageFortranTools.generateIf
  LanguageFortranTools.generateIntConstant
  LanguageFortranTools.generateLTExpr
  LanguageFortranTools.generateProductExpr
  LanguageFortranTools.generateSrcSpan
  LanguageFortranTools.generateSrcSpanMerge
  LanguageFortranTools.generateSubtractionExpr
  LanguageFortranTools.generateVar
  LanguageFortranTools.getEarliestSrcLoc
  LanguageFortranTools.getEarliestSrcSpan
  LanguageFortranTools.getIterLoopVars
  LanguageFortranTools.getLatestSrcSpan
  LanguageFortranTools.getLoopVar
  LanguageFortranTools.getLoopVars
  LanguageFortranTools.getReadArgs
  LanguageFortranTools.getReadArgs'
  LanguageFortranTools.getSrcSpanNonIntersection
  LanguageFortranTools.getSubNames
  LanguageFortranTools.getUnitName
  LanguageFortranTools.getUnitName'
  LanguageFortranTools.getUses
  LanguageFortranTools.getWrittenArgs
  LanguageFortranTools.getWrittenArgs'
  LanguageFortranTools.hasOperand
  LanguageFortranTools.inlineDeclsFromUsedModules
  LanguageFortranTools.isDeclOnly
  LanguageFortranTools.isImplicitNoneDecl
  LanguageFortranTools.isRelevantModuleLine
  LanguageFortranTools.isUseDecl
  LanguageFortranTools.isVar
  LanguageFortranTools.isVarDeclWithMultipleVars
  LanguageFortranTools.listCartesianProduct
  LanguageFortranTools.listConcatUnique
  LanguageFortranTools.listCountAppearances
  LanguageFortranTools.listExtractSingleAppearances
  LanguageFortranTools.listExtractSingleAppearances'
  LanguageFortranTools.listIntersection
  LanguageFortranTools.listRemoveDuplications
  LanguageFortranTools.listSubtract
  LanguageFortranTools.listSubtractWithExemption
  LanguageFortranTools.listUnion
  LanguageFortranTools.lookupValueTable
  LanguageFortranTools.lookupValueTable_type
  LanguageFortranTools.maybeBinOp
  LanguageFortranTools.maybeBinOp_float
  LanguageFortranTools.maybeBinOp_integral
  LanguageFortranTools.maybeNegative
  LanguageFortranTools.normaliseSrcSpan
  LanguageFortranTools.nullAnno
  LanguageFortranTools.nullSrcLoc
  LanguageFortranTools.nullSrcSpan
  LanguageFortranTools.oneVarDeclPerVarDeclLine
  LanguageFortranTools.orElem
  LanguageFortranTools.outputExprFormatting
  LanguageFortranTools.outputTab
  LanguageFortranTools.parseFile
  LanguageFortranTools.preProcessingHelper
  LanguageFortranTools.readUsedModuleDecls
  LanguageFortranTools.removeAllAnnotations
  LanguageFortranTools.removeAnnotations
  LanguageFortranTools.removeLoopConstructs_recursive
  LanguageFortranTools.replaceAllOccurences_varname
  LanguageFortranTools.replaceAllOccurences_varnamePairs
  LanguageFortranTools.replaceFortran
  LanguageFortranTools.replaceFortran'
  LanguageFortranTools.replaceProgUnit
  LanguageFortranTools.replaceProgUnit'
  LanguageFortranTools.replaceSrSpan
  LanguageFortranTools.replaceVarname
  LanguageFortranTools.resolveType
  LanguageFortranTools.runCpp
  LanguageFortranTools.shiftSrcSpan
  LanguageFortranTools.shiftSrcSpanLineGlobal
  LanguageFortranTools.split
  LanguageFortranTools.splitDelim
  LanguageFortranTools.splitOutVarDecls
  LanguageFortranTools.srcSpanInSrcSpan
  LanguageFortranTools.srcSpanInSrcSpanRange
  LanguageFortranTools.srcSpanLineCount
  LanguageFortranTools.standardiseSrcSpan
  LanguageFortranTools.stretchSrc
  LanguageFortranTools.stretchSrcSpanLine
  LanguageFortranTools.tabInc
  LanguageFortranTools.takeLast
  LanguageFortranTools.trimFront
  LanguageFortranTools.usesVarName
  LanguageFortranTools.usesVarName_list
  LanguageFortranTools.varNameListStr
  LanguageFortranTools.varNameStr
  LanguageFortranTools.Anno
  LanguageFortranTools.CodeStash
  LanguageFortranTools.ModuleVarsTable
  LanguageFortranTools.ValueTable
module dependencies: F95IntrinsicFunctions Language.Fortran
                     Language.Fortran.Lexer Language.Fortran.Parser
                     Language.Fortran.PreProcess PreProcessor Warning
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.3.0.0@directory-1.3.0.0
                      filepath-1.4.1.1@filepath-1.4.1.1 ghc-prim-0.5.0.0
                      haskell-src-1.0.2.0@haskell-src-1.0.2.0-3zoaErItXGVA1GHC7t3Glx
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      parsec-3.1.11@parsec-3.1.11-113irVHGgd88sRnywByDNw
                      process-1.4.3.0@process-1.4.3.0
                      syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS
                      text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      unix-2.7.2.1@unix-2.7.2.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS:Data.Generics.Instances
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text
                         text-1.2.2.1@text-1.2.2.1-Ji7hMs2U4BkBwavd4taEVR:Data.Text.Lazy
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Data da440c60016500822a3d4307ca5dea66
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:Data.Typeable 9257e47d10882145c67c5b489965cfb7
import  -/  base-4.9.1.0:Data.Typeable.Internal 0e9bdefa4325a0112d8e73b5e1e1f85d
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.Float 33e2b9ffe427edd6a5c2fd6a3b26703c
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  base-4.9.1.0:Text.Read 75c59863e882ebaec4532e9465e2ee9b
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  directory-1.3.0.0@directory-1.3.0.0:System.Directory 8ff5ebd6a93811413df021d2be39a158
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  F95IntrinsicFunctions 1b7f8e2622be78a835577e1b6cb9c90b
  exports: dc77bc6122892f669e7921a25fe21f4c
  f95IntrinsicFunctions 2ee4e8be5b6033feb7926734889188a8
import  -/  Language.Fortran c957d8f93581b3ce2cc521df25110d11
  exports: cb4e2f808f933bd0493dcd95204741d0
  And aef4f42907f720cfb3297c11e0aba2bb
  ArgName b4db00709e962bb265fdd46af8204459
  ArgName dd55ce63dac1f7711c0f1fc53db78e0e
  ArrayCon ee778ab7f8280f6d94edcd75396bf223
  ArrayT 1071841314ea2748dea0af6459ed7756
  Assg e4ff0447498349c3e2879e1af28dc289
  BaseType ca5d7487fbe699d664f7837b2f094048
  BaseType 6b45e4637f33ab3df335753afdb59e8d
  Bin 31bb1b9369e8820657f411d90ee9619c
  BinOp e17095ab710540e6e45e7763d42db35f
  Block 00b5dcb26b4d8331f4d0a27afc418872
  Bound a7e9d9367588a2936807387b6760ad5e
  Con e9784612770372502a12b479082c4a0e
  Concat f22f1a8c98fc0643070588290f542ec2
  Decl d78489b6b11f87857f4ba3465cebf581
  Decl c4465a5758b20b0d6387c4cda8774a94
  Div ed67099c3b8ec7b7f48b784c091ff524
  ESeq 61c466a4f3e2f7ae4bd9f94819dbe388
  Expr fd45c3abbcc1cd23ca18c96ee1403b96
  FSeq 66c58ad61465e02006618848a2dea986
  For 8eaaf1a59a9e6e9d8f36eff8caf7c991
  Fortran 7ef8d1883356542a2e7829f1c3512bc2
  If 2ebe473c51363820c571e0150fe25882
  Integer 247d786a49e53a070207e400ccb2363d
  Minus 74fd79e66076db48c9d27b6cd0f2b01a
  Mul 408f573b36ba1a21b1233ab02a2b76a6
  Not c97753c57fd22b797b4238078b501d5f
  Null f9b4d2f804869f054752a44b06f43d80
  NullExpr d53181ba59030b4ed334d3840cb5eea1
  NullStmt 4b8e91715bb30324591f7bab6148c0f6
  OpenCLBufferRead 7062856698f9bec8c015dbffd83f3cd0
  OpenCLBufferWrite 4bb6fbfda0c948d2b7b329fa92eecc3b
  OpenCLMap f735cdb4fcfce00b0cd641aaa6255a4b
  OpenCLReduce 811a5024d542e78a43320fc6af66c91a
  Or 213d2e6b495d5f025e4a6b3f58e82a27
  Plus 2246ba64804dd1a40f56ff697ab3e419
  Power 753f6c40069c6ea46ebd079a08a3e781
  ProgUnit dd0d2763607dbd5a6f6c1c5d85fe76dd
  Program 61c057161e42f4aa29fb8dd8afb17b21
  Real 1f5e3d6d1fce569b7e0ec8170f09616e
  RelEQ e383106dcc01fdbdb318a2418931514b
  RelGE a6976d1051d998d5b2d827b29c70a53e
  RelGT 78f85566cdeecd7e16397ffbd97af6ea
  RelLE 2cfacf5d401677794942ab69624e48fb
  RelLT 4a6ed8a832e87679ad5328c766213c64
  RelNE 1dbde836a3bb3ab52805a364d01adc7a
  SrcLoc a58d61bb9404a2380d0de8c4177e198c
  SrcLoc 43c2e4e6db773bb5ef99bf585d69acf2
  SrcSpan a18da1424c2a105ac654e1e8b2930f03
  SubName ef668be18c70f035fc2c52ca19281445
  SubName d09f243eb3eeec0d44a1b799f2b23e72
  Type cac90f1d6845827f0c2780e86e10c606
  UMinus 328b23b9188e7113c6107be4fbbd3e34
  Unary 9d829a97b22d5a23fc3b2ccddd0720fd
  Use 8a7dc7b8366e35090672c54debf5617f
  Uses 22a7293c3f9ba679ea60d591f21568e8
  Var 223ccce2fd2a845a28913e272a1a9b28
  VarName 64af05f1c71bcd1dfd571ca0d5218f1b
  VarName d4d45769399fe3ed8e0615e3282cf5b7
  srcColumn 937293bf8b997ee0249577ca693be248
  srcFilename eb911b891160c33666f082b2362a3c91
  srcLine aba8cf16bc5c492917070c451b179553
  srcSpan fbf339ac9b9eae31a89ba940dccb0289
import  -/  Language.Fortran.Parser 59e506b7f9b623442ab6ce146631eefb
  exports: 83a6073254db4377feeca61632e25716
  parse 530daab529c9862d7dbb0192dfb8a4ce
import  -/  PreProcessor 24c50a585a4c30c7e7fe641b3f79d39c
  exports: 972843a1d8ebd6ae3ac01d38b3b14b9a
  preProcess 7e825d887f66be5ebff7e77c572ae38b
  removeBlankLines 4795a6b3d92f60411c950a865062aa83
import  -/  Warning 37568988846bf7dc0ef160b198d03155
  exports: 66d1a373648e452607e9cbdbd4f3a821
  warning 2d503229580d8b0284bd2609701ac214
import  -/  process-1.4.3.0@process-1.4.3.0:System.Process 1ee59b956b7cad68338d3f6ab3e772ed
import  -/  syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS:Data.Generics ea99a8062a9608312218ffd7309b5391
import  -/  syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS:Data.Generics.Aliases 09d594ec9a31e3c858478cc583771648
import  -/  syb-0.6@syb-0.6-IcoSwlPi2Nx4zSqMmorFPS:Data.Generics.Schemes 4b69980d384f37e61fe24ae708a71220
a3354f9bfd2798d3cfe65b7cc83baad1
  $s$fDataExpr ::
    Data.Data.Data
      (Language.Fortran.Expr
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Expr
                       (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fDataExpr_$cp1Data
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgfoldl
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgunfold
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$ctoConstr
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cdataTypeOf
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cdataCast1
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cdataCast2
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapT
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapQl
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapQr
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapQ
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapQi
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapM
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapMp
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataExpr_$cgmapMo
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1) -}
44c52edcc8337878d7b58a274d2d2453
  $s$fDataExpr1 ::
    Data.Data.Data
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
  {- Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.$s$fDataExpr_$s$fDataMap -}
875c054376aac00d82b07869a16f0090
  $s$fDataExpr2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe
         (c (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing
                   @ (c (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]))) -}
fe0e494981f4ffd17225e8499f8c2d86
  $s$fDataExpr3 ::
    Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]) ->
                 Data.Map.Base.mapDataType) -}
062565b3ab1aceb606a9cfd231245e65
  $s$fDataExpr4 ::
    Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]) ->
                 Data.Map.Base.fromListConstr) -}
321d6d4b3b07d7eb89154af4837ef99b
  $s$fDataExpr5 :: Data.Data.Data [GHC.Base.String]
  {- Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.$s$fDataExpr_$s$fData[] -}
8f07e770865d25cba5e684cbeab70aa8
  $s$fDataExpr_$s$fDataMap ::
    Data.Data.Data
      (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Map.Base.$fDataMap_$cp1Data
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgfoldl
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgunfold
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  LanguageFortranTools.$s$fDataExpr4
                  LanguageFortranTools.$s$fDataExpr3
                  LanguageFortranTools.$s$fDataExpr2
                  (Data.Map.Base.$fDataMap_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapT
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapQl
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapQr
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapQ
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapQi
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapM
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1)
                  (Data.Map.Base.$fDataMap_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     Data.Data.$fData[]_$s$fData[]
                     LanguageFortranTools.$s$fDataExpr5
                     GHC.Classes.$fOrd[]_$s$fOrd[]1) -}
1ae3264e37cbc5227d26df087300df13
  $s$fDataExpr_$s$fData[] :: Data.Data.Data [[GHC.Types.Char]]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [[GHC.Types.Char]]
                  (Data.Data.$fData[]_$cp1Data
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgfoldl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  LanguageFortranTools.$s$fDataExpr_$s$fData[]_$ctoConstr
                  LanguageFortranTools.$s$fDataExpr_$s$fData[]_$cdataTypeOf
                  (Data.Data.$fData[]_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  LanguageFortranTools.$s$fDataExpr_$s$fData[]_$cdataCast2
                  (Data.Data.$fData[]_$cgmapT
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQr
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQ
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQi
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
815ca355e13271212be9cd20f3d8cdc7
  $s$fDataExpr_$s$fData[]_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c [[GHC.Types.Char]])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c [[GHC.Types.Char]])) -}
21c6582572ed4c459e3154ff15b4e46d
  $s$fDataExpr_$s$fData[]_$cdataTypeOf ::
    [[GHC.Types.Char]] -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: [[GHC.Types.Char]]) -> Data.Data.listDataType) -}
70db4337f0087adede4054ae47f138eb
  $s$fDataExpr_$s$fData[]_$ctoConstr ::
    [[GHC.Types.Char]] -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [[GHC.Types.Char]]) ->
                 case ds of wild {
                   [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr }) -}
d958f79c0d6b6a7aab11f0555d41ac13
  $s$fDataFortran ::
    Data.Data.Data
      (Language.Fortran.Fortran
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Fortran
                       (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fDataFortran_$cp1Data
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgfoldl
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgunfold
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$ctoConstr
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  LanguageFortranTools.$s$fDataFortran2
                  (Language.Fortran.$fDataFortran_$cdataCast1
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  LanguageFortranTools.$s$fDataFortran1
                  (Language.Fortran.$fDataFortran_$cgmapT
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapQl
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapQr
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapQ
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapQi
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapM
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapMp
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataFortran_$cgmapMo
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1) -}
78122296eda902965f1b7e20fe88396a
  $s$fDataFortran1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe
         (c (Language.Fortran.Fortran
               (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing
                   @ (c (Language.Fortran.Fortran
                           (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])))) -}
b274f1a7bd696b8b11725b9791870ff2
  $s$fDataFortran2 ::
    Language.Fortran.Fortran
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Language.Fortran.Fortran
                            (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])) ->
                 Language.Fortran.$tD9QMegU2padFswPGA4PbPq) -}
3e21de823c629210031f155a3dfc3ea3
  $s$fDataProgUnit ::
    Data.Data.Data
      (Language.Fortran.ProgUnit
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.ProgUnit
                       (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fDataProgUnit_$cp1Data
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgfoldl
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgunfold
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  LanguageFortranTools.$s$fDataProgUnit3
                  LanguageFortranTools.$s$fDataProgUnit2
                  (Language.Fortran.$fDataProgUnit_$cdataCast1
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  LanguageFortranTools.$s$fDataProgUnit1
                  (Language.Fortran.$fDataProgUnit_$cgmapT
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapQl
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapQr
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapQ
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapQi
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapM
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapMp
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1)
                  (Language.Fortran.$fDataProgUnit_$cgmapMo
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fDataExpr1) -}
62ec46db4d98ae5c5e41f3f45dc58eaa
  $s$fDataProgUnit1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe
         (c (Language.Fortran.ProgUnit
               (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing
                   @ (c (Language.Fortran.ProgUnit
                           (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])))) -}
6ac3a85f3c4e9e781898a9cd6db14ed8
  $s$fDataProgUnit2 ::
    Language.Fortran.ProgUnit
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Language.Fortran.ProgUnit
                            (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])) ->
                 Language.Fortran.$t7VQWdGSfPYu9Iisks7pSs4) -}
f12a1f83143c721c7c2925946e5e8c2f
  $s$fDataProgUnit3 ::
    Language.Fortran.ProgUnit
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.ProgUnit
                            (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])) ->
                 case ds of wild {
                   Language.Fortran.Main ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$c4xrtyfBJfgG9CdmZCyXplY
                   Language.Fortran.Sub ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$c7zjF0LiJYf2AdH4exyJgTk
                   Language.Fortran.Function ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cHz24H293oUm0OxUULdlqBb
                   Language.Fortran.Module ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cJF7ERNq7h76LqRZ36w7OdI
                   Language.Fortran.BlockData ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cJMYppX9bYODKKluMTnLSGS
                   Language.Fortran.PSeq ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cBhco6aZ1tyeC07hEtbJOeV
                   Language.Fortran.Prog ds1 ds2 ds3
                   -> Language.Fortran.$c1punZIYcQoU5BRBrTkMOur
                   Language.Fortran.NullProg ds1 ds2
                   -> Language.Fortran.$c4IpgnqT1fRXLxfwDHaby2z
                   Language.Fortran.IncludeProg ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cCGFBodCaxL10tlXfi5MSfH }) -}
5b92d116f29cd8f4315e642e96f10573
  $s$fEqExpr ::
    GHC.Classes.Eq
      (Language.Fortran.Expr
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.Expr
                       (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fEqExpr_$c==
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fEqExpr1)
                  LanguageFortranTools.$s$fEqExpr_$s$fEqExpr_$c/= -}
930c333c94b99033acfe408bdf5a873b
  $s$fEqExpr1 ::
    GHC.Classes.Eq
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.$s$fEqExpr_$s$fEqMap -}
700b64d85c04e98b7a16bdb76685849f
  $s$fEqExpr2 :: GHC.Classes.Eq [GHC.Base.String]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]2 -}
130b00422c16298edbe5ef927c308a93
  $s$fEqExpr3 :: GHC.Classes.Eq [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
0619d57967ff20f9be2dfdb73bda9bd3
  $s$fEqExpr_$s$fEqExpr_$c/= ::
    Language.Fortran.Expr
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.Expr
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Language.Fortran.Expr
                           (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
                   (b :: Language.Fortran.Expr
                           (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])) ->
                 case Language.Fortran.$fEqExpr_$c==
                        @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                        LanguageFortranTools.$s$fEqExpr1
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
74b06425e45c72223afde99e0da41569
  $s$fEqExpr_$s$fEqMap ::
    GHC.Classes.Eq
      (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Map.Base.$fEqMap_$c==
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     LanguageFortranTools.$s$fEqExpr3
                     LanguageFortranTools.$s$fEqExpr2)
                  LanguageFortranTools.$s$fEqExpr_$s$fEqMap_$c/= -}
b2bebfc404ead33309c75039e24f61e9
  $s$fEqExpr_$s$fEqMap_$c/= ::
    Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
                   (y :: Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]) ->
                 GHC.Classes.not
                   (Data.Map.Base.$fEqMap_$c==
                      @ [GHC.Types.Char]
                      @ [GHC.Base.String]
                      LanguageFortranTools.$s$fEqExpr3
                      LanguageFortranTools.$s$fEqExpr2
                      x
                      y)) -}
4aa3f41a6e87fa7b1f9a5cd0c3b9b12e
  $s$fEqVarName ::
    GHC.Classes.Eq
      (Language.Fortran.VarName
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.VarName
                       (Data.Map.Base.Map GHC.Base.String [GHC.Base.String]))
                  (Language.Fortran.$fEqVarName_$c==
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fEqExpr1)
                  (Language.Fortran.$fEqVarName_$c/=
                     @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                     LanguageFortranTools.$s$fEqExpr1) -}
78372ac2d776ba3344a796a158835030
  $s$fShowExpr_$cshow2 ::
    [Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Data.Map.Base.Map
                             [GHC.Types.Char] [GHC.Base.String]])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
                   LanguageFortranTools.$s$fShowExpr_$cshow3
                   ls
                   s) -}
76b483c427e58bcbaf809817820c3b39
  $s$fShowExpr_$cshow3 ::
    Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w3 :: Data.Map.Base.Map
                            [GHC.Types.Char] [GHC.Base.String]) ->
                 Data.Map.Base.$w$cshowsPrec
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   GHC.Show.$fShow[]_$s$fShow[]1
                   GHC.Show.$fShow[]_$s$fShow[]2
                   0#
                   w3) -}
be73b61a4c04969948be385c078d314d
  $s$fShowExpr_$cshow4 :: GHC.Show.Show [GHC.Base.String]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShow[]_$s$fShow[]2 -}
8e816d55046f52e22fee3132c6a7976a
  $s$fShowExpr_$cshow5 :: GHC.Show.Show [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShow[]_$s$fShow[]1 -}
d40de022a39fb4f7235aecee0bcca732
  $s$fShowExpr_$cshow_$s$fShowMap ::
    GHC.Show.Show
      (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String])
                  (Data.Map.Base.$fShowMap_$cshowsPrec
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     LanguageFortranTools.$s$fShowExpr_$cshow5
                     LanguageFortranTools.$s$fShowExpr_$cshow4)
                  (Data.Map.Base.$fShowMap_$cshow
                     @ [GHC.Types.Char]
                     @ [GHC.Base.String]
                     LanguageFortranTools.$s$fShowExpr_$cshow5
                     LanguageFortranTools.$s$fShowExpr_$cshow4)
                  LanguageFortranTools.$s$fShowExpr_$cshow2 -}
e7e312ac7fe485d0deebe13c67a82813
  $sdelete_$sgo10 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
3476ad97e94ac179f3ee9c3f582efb40
  $sfindWithDefault1 ::
    a -> GHC.Base.String -> Data.Map.Base.Map GHC.Base.String a -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><S,1*U><S,1*U> -}
7c855092d7e72ba004632c29d86f0854
  $sfromList ::
    [(GHC.Base.String, a)] -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(GHC.Base.String, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ GHC.Base.String @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Base.Bin
                             @ GHC.Base.String
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Base.Tip @ GHC.Base.String @ a)
                             (Data.Map.Base.Tip @ GHC.Base.String @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                LanguageFortranTools.$sfromList_$spoly_go10
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)) }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                LanguageFortranTools.$sfromList_$s$wpoly_go10
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  1# } } } } } }) -}
c47284447edf8b3d3b947d4ee36bdd5c
  $sfromList_$s$wpoly_go10 ::
    [GHC.Types.Char]
    -> a
    -> [([GHC.Types.Char], a)]
    -> Data.Map.Base.Map [GHC.Types.Char] a
    -> GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,1*U><L,U> -}
ca6d2244f1a8423280f0dcb4060525e8
  $sfromList_$spoly_go10 ::
    [GHC.Types.Char]
    -> a
    -> [([GHC.Types.Char], a)]
    -> Data.Map.Base.Map [GHC.Types.Char] a
    -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U> -}
509c63c02932db66f6016983d268736c
  $sinsert_$sgo10 ::
    GHC.Base.String
    -> a1
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
f181fdfa18ecd3a39c8fa28fba68e30e
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
c285302f5680a51bf477e4e56530d3eb
  $stypeRep#10 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#11
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Types.$tcChar
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
3cf459fd6957c8ecfa3784416b79c013
  $stypeRep#11 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   16781394633280494409##
                   2520638044472077920##) -}
5a177d5210c061f0fc62afc6289b6165
  $stypeRep#14 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#15
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Types.$tc[]
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
322ab19310ddeeae2a5b330862af0971
  $stypeRep#15 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17730107610217102821##
                   9866972337190828755##) -}
db82e31b631b0caddc74b5fcfded0e38
  $stypeRep#18 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#14 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.$stypeRep#19
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
e3593b8bcbbd05ba833a28183e8f5f76
  $stypeRep#19 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.$stypeRep#10
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
03a0090c6ab899f8bed6d555880b39db
  $stypeRep#2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
9349fd346c31adc3031b3e745ee3d034
  $stypeRep#22 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#2 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.$stypeRep#23
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
6a462e775db3de8f295b6bef05674496
  $stypeRep#23 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.$stypeRep#18
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
4e063cc2b2afde23c9c321fa8598d6f0
  $stypeRep#26 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#14 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.$stypeRep#23
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
0e20e0c41aceab5f3b74628e78172e29
  $stypeRep#29 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#22 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.$stypeRep#30
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
ddab36700a246318296c0300a6ce51a9
  $stypeRep#3 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17306070887558246498##
                   16032333906417739553##) -}
764cdd33dcfbce7ff6eb622cafbf671a
  $stypeRep#30 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.$stypeRep#26
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
eb38538a8749a4f3872f022f6b39e6b1
  $stypeRep#33 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
2197871c0cbb0ed1596fb8b843b1f7dc
  $stypeRep#34 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   6882220124880764793##
                   15271875958298145102##) -}
750de22129d2896f33cac06346af94f6
  $stypeRep#37 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#38
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcVarName
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
dfc2345f28270df92667c891326ec3c5
  $stypeRep#38 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1672502290831751764##
                   46662296866082288##) -}
c396896a0f473a661e7dc84fb9ad143e
  $stypeRep#41 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#42
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcSubName
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
9a2e89b898cfdc833557c11e7d2e2763
  $stypeRep#42 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   1824721943276726566##
                   8805268855664748890##) -}
6a3217353dcc031ce962914016a5e09a
  $stypeRep#46 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   17502837480397947244##
                   15872498598114190556##) -}
8cf30f8639e5639ce10eccaba8732faa
  $stypeRep#49 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#50
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcSrcLoc
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
f585740ed97e74b881bc6e9a17c6bf35
  $stypeRep#50 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   3080101248344241265##
                   5859815666103468669##) -}
2fe69efc49a41dbe28bede56381af8ee
  $stypeRep#54 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.$stypeRep#49
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
99414129eb6f2c7ed7073668393183c9
  $stypeRep#57 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#58
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcExpr
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
a58f32bb6341668b64d813318115d95a
  $stypeRep#58 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   13621902738272893592##
                   4484539928315244892##) -}
ed90b90e03c2c24856ff9d72155d8fb2
  $stypeRep#59 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
41cb7f8eb03578853235818cd35ec9b5
  $stypeRep#6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#7
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcProgUnit
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
69b1f265b1ca8e0903ee2bffc9f9f16e
  $stypeRep#7 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   10056753431434216976##
                   6055604396548152995##) -}
1c0cad77ac74940cfb380f9030e60772
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   LanguageFortranTools.$trModule2
                   LanguageFortranTools.$trModule1) -}
26392228807dfae52d2dfcc02cbfeeb7
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "LanguageFortranTools"#) -}
b1ded09fcbcd6f751cb5955627ed66bb
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
a608d6db407b6596fdccbe16809864c9
  $wcheckSrcLocBefore ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.ltInt ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
99f2cf0ff5f423002c82695e6a16fc52
  $wcheckSrcSpanAfter ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.gtInt ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
5b49f0fd62c7248a9ca08b52fbc48364
  $wcheckSrcSpanBefore ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.ltInt ww1 ww3 }
                   GHC.Types.True -> GHC.Types.True }) -}
6cf3429f7a18f8886570e5229f8a6505
  $wcheckSrcSpanContainsSrcSpan ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: GHC.Prim.Int#)
                   (ww5 :: GHC.Types.Int)
                   (ww6 :: GHC.Types.Int)
                   (ww7 :: GHC.Types.Int) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     case ww2 of wild { GHC.Types.I# x ->
                     case ww6 of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.># x y) of wild2 {
                       GHC.Types.False
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# x y) of wild3 {
                            GHC.Types.False -> GHC.Types.False
                            GHC.Types.True -> GHC.Classes.gtInt ww3 ww7 }
                       GHC.Types.True -> GHC.Types.True } } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww4) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww4) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww1 of wild2 { GHC.Types.I# x ->
                           case ww5 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> $j GHC.Prim.void# } } } }
                   GHC.Types.True -> $j GHC.Prim.void# }) -}
c3ecb2c581c9c3db35d30e0d8be9872e
  $werrorLocationFormatting ::
    GHC.Prim.Int# -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        ww
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   (GHC.CString.unpackAppendCString#
                      ":"#
                      (case ww1 of ww2 { GHC.Types.I# ww3 ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww3
                              (GHC.Types.[] @ GHC.Types.Char) of ww8 { (#,#) ww9 ww10 ->
                       GHC.Types.: @ GHC.Types.Char ww9 ww10 } })) }) -}
cd7e831d3d4078066e1a42221aa3d736
  $werrorLocationRangeFormatting ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   "line "#
                   (case ww of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                      (GHC.CString.unpackAppendCString#
                         " and line "#
                         (case ww1 of ww8 { GHC.Types.I# ww9 ->
                          case GHC.Show.$wshowSignedInt
                                 0#
                                 ww9
                                 (GHC.Types.[] @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                          GHC.Types.: @ GHC.Types.Char ww11 ww12 } })) } })) -}
452b49144cf9124d6e027e8bad94e5b9
  $wextractAssigneeFromDecl ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Language.Fortran.Decl
                           LanguageFortranTools.Anno) ->
                 case w of wild {
                   DEFAULT
                   -> case LanguageFortranTools.extractAssigneeFromDecl1
                      ret_ty (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
                      of {}
                   Language.Fortran.Decl anno src lst typ
                   -> case lst of wild1 {
                        []
                        -> case GHC.List.badHead
                           ret_ty (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
                           of {}
                        : x ds1
                        -> case x of wild2 { (,,) x1 ds ds2 ->
                           case x1 of wild3 {
                             DEFAULT
                             -> case GHC.List.badHead
                                ret_ty (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
                                of {}
                             Language.Fortran.Var ds3 ds4 lst1
                             -> LanguageFortranTools.$wgo lst1 } } } }) -}
4d5c65cc236b2ed0c78b2d62752c547e
  $wextractContainedOperands ::
    Data.Data.Data p =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   (w1 :: Language.Fortran.Expr p) ->
                 letrec {
                   go9 :: [Language.Fortran.Expr p]
                          -> [Language.Fortran.Expr p] -> [Language.Fortran.Expr p]
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [Language.Fortran.Expr p])
                       (eta :: [Language.Fortran.Expr p]) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go9
                            ys
                            (GHC.Base.++
                               @ (Language.Fortran.Expr p)
                               eta
                               (LanguageFortranTools.$wextractOperands @ p w y)) }
                 } in
                 go9
                   (LanguageFortranTools.$wextractContainedVars @ p w1)
                   (GHC.Types.[] @ (Language.Fortran.Expr p))) -}
0dddd057b20fcd6e6614c28bd84f02b8
  $wextractContainedVars ::
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ p (w :: Language.Fortran.Expr p) ->
                 case w of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.Expr p)
                   Language.Fortran.Var ds ds1 lst
                   -> LanguageFortranTools.extractContainedOperands1
                        @ p
                        lst
                        (GHC.Types.[] @ (Language.Fortran.Expr p)) }) -}
2771f4e6410b09dfde795b0443f47756
  $wextractContainedVarsWV ::
    Data.Data.Data p =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Inline: [0] -}
8e5d992b492fc88edbf1d75f1937a74b
  $wextractOperands ::
    Data.Data.Data p =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Inline: [0] -}
3a45b2fd5524a146b8cd06b96660c6db
  $wgo ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      [Language.Fortran.Expr LanguageFortranTools.Anno])]
    -> (# LanguageFortranTools.Anno, Language.Fortran.Variable #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
08e20d1232bfab4383be93bf86575e8c
  $wgo1 :: [GHC.Types.Char] -> GHC.Prim.Char#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
789eb590e955264ed4636b9b66f38f37
  $wgo2 :: [GHC.Types.Char] -> GHC.Prim.Char#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
b362f76eb29848377009a8a44801d7cc
  $wlistCountAppearances ::
    GHC.Classes.Eq a => a -> [a] -> GHC.Prim.Int#
  {- Arity: 3, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Classes.Eq a) (w1 :: a) (w2 :: [a]) ->
                 case w2 of wild {
                   []
                   -> case LanguageFortranTools.listCountAppearances1
                      ret_ty GHC.Prim.Int#
                      of {}
                   : x ds
                   -> case ds of wild1 {
                        []
                        -> case GHC.Classes.== @ a w w1 x of wild2 {
                             GHC.Types.False -> 0# GHC.Types.True -> 1# }
                        : ipv ipv1
                        -> case GHC.Classes.== @ a w w1 x of wild2 {
                             GHC.Types.False
                             -> LanguageFortranTools.listCountAppearances_$s$wlistCountAppearances
                                  @ a
                                  ipv
                                  ipv1
                                  w1
                                  w
                             GHC.Types.True
                             -> case LanguageFortranTools.listCountAppearances_$s$wlistCountAppearances
                                       @ a
                                       ipv
                                       ipv1
                                       w1
                                       w of ww { DEFAULT ->
                                GHC.Prim.+# 1# ww } } } }) -}
9383eff024a97613d5c0b315851c0bca
  $wpreProcessingHelper ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, LanguageFortranTools.CodeStash,
           LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>, Inline: [0] -}
442c03a16c33c4b43913c897620b9e00
  $wreplaceVarname ::
    LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno
    -> Language.Fortran.Variable
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U(U,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: LanguageFortranTools.Anno)
                   (ww1 :: Language.Fortran.Variable)
                   (w :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (ww2 :: LanguageFortranTools.Anno)
                   (ww3 :: Language.Fortran.Variable) ->
                 case LanguageFortranTools.replaceVarname1 ww ww2 of wild {
                   GHC.Types.False
                   -> Language.Fortran.VarName @ LanguageFortranTools.Anno ww2 ww3
                   GHC.Types.True
                   -> case GHC.Base.eqString ww1 ww3 of wild1 {
                        GHC.Types.False
                        -> Language.Fortran.VarName @ LanguageFortranTools.Anno ww2 ww3
                        GHC.Types.True -> w } }) -}
680c310ba297dda1de61a00421a96789
  $wsrcSpanInSrcSpan ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: GHC.Prim.Int#)
                   (ww5 :: GHC.Types.Int)
                   (ww6 :: GHC.Types.Int)
                   (ww7 :: GHC.Types.Int) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     case ww6 of wild { GHC.Types.I# x ->
                     case ww2 of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<# x y) of wild2 {
                       GHC.Types.False
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# x y) of wild3 {
                            GHC.Types.False -> GHC.Types.False
                            GHC.Types.True -> GHC.Classes.leInt ww7 ww3 }
                       GHC.Types.True -> GHC.Types.True } } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww4 ww) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww5 of wild2 { GHC.Types.I# x ->
                           case ww1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> $j GHC.Prim.void# } } } }
                   GHC.Types.True -> $j GHC.Prim.void# }) -}
9a7d3f8daeabfae5ffaaab532729059f
  $wtakeLast :: GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 2, Strictness: <S,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: GHC.Prim.Int#) (w :: [a]) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> LanguageFortranTools.takeLast1 @ a
                   GHC.Types.True
                   -> GHC.List.reverse1
                        @ a
                        (GHC.List.$wunsafeTake
                           @ a
                           ww
                           (GHC.List.reverse1 @ a w (GHC.Types.[] @ a)))
                        (GHC.Types.[] @ a) }) -}
e22809b44b97ccfdb28bfb19047d139f
  type Anno = Data.Map.Base.Map GHC.Base.String [GHC.Base.String]
8db81f826e64fb3d0da9e254dc4a6a55
  type CodeStash = Data.Map.Base.Map GHC.Types.Int [GHC.Base.String]
2d3509d9190540c2ff64d7aa77e642a6
  type ModuleVarsTable =
    Data.Map.Base.Map GHC.Base.String GHC.Base.String
a6a5d1540a20832381bbaf30c8315a50
  type ValueTable =
    Data.Map.Base.Map
      GHC.Base.String
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
19bb806352330c0e9bd06d7e3094e8d0
  addImplicitNone :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (contentLines :: [GHC.Base.String]) ->
                 case LanguageFortranTools.addImplicitNone_$s$wgo
                        (GHC.Types.[] @ GHC.Base.String)
                        (GHC.Types.[] @ GHC.Base.String)
                        contentLines of ww { (#,,#) ww1 ww2 ww3 ->
                 GHC.Base.++
                   @ [GHC.Types.Char]
                   ww1
                   (GHC.Types.:
                      @ [GHC.Types.Char]
                      LanguageFortranTools.addImplicitNone1
                      ww2) }) -}
c79f6787f419c145c092ef3cde15c6e2
  addImplicitNone1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "      implicit none"#) -}
9fd49cdf51210bf0a0e732eeb00b6353
  addImplicitNone_$s$wgo ::
    [[GHC.Types.Char]]
    -> [[GHC.Types.Char]]
    -> [[GHC.Types.Char]]
    -> (# [GHC.Base.String], [GHC.Base.String], GHC.Types.Bool #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U> -}
24127fd3e69a9e4d54f6f047e10aed1c
  addToValueTable ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> GHC.Types.Float
    -> LanguageFortranTools.ValueTable
    -> LanguageFortranTools.ValueTable
  {- Arity: 3, Strictness: <S(LS),1*U(A,1*U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (var :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (value :: GHC.Types.Float)
                   (table :: LanguageFortranTools.ValueTable) ->
                 case var of wild { Language.Fortran.VarName ds str ->
                 LanguageFortranTools.$sinsert_$sgo10
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   str
                   (value, LanguageFortranTools.addToValueTable1)
                   table }) -}
c99ec39bd9b00b66e155f97d8c2a8ec8
  addToValueTable1 ::
    Language.Fortran.BaseType LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Language.Fortran.Real
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
ade893fc38375613b40a99fec3e96d18
  addToValueTable_type ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> GHC.Types.Float
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
    -> LanguageFortranTools.ValueTable
    -> LanguageFortranTools.ValueTable
  {- Arity: 4, Strictness: <S(LS),1*U(A,1*U)><L,U><L,U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ (var :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (value :: GHC.Types.Float)
                   (typ :: Language.Fortran.BaseType LanguageFortranTools.Anno)
                   (table :: LanguageFortranTools.ValueTable) ->
                 case var of wild { Language.Fortran.VarName ds str ->
                 LanguageFortranTools.$sinsert_$sgo10
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   str
                   (value, typ)
                   table }) -}
99aca3dcb141660efe924d41377444a3
  appendAnnotation ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.String
    -> GHC.Base.String
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: (\ (original :: Language.Fortran.Fortran
                                  LanguageFortranTools.Anno)
                   (key :: GHC.Base.String)
                   (appendage :: GHC.Base.String) ->
                 case original of wild {
                   DEFAULT -> wild
                   Language.Fortran.For anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.For
                        @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                        (LanguageFortranTools.appendAnnotation_$sappendToMap
                           @ [GHC.Types.Char]
                           key
                           appendage
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLMap anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.OpenCLMap
                        @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                        (LanguageFortranTools.appendAnnotation_$sappendToMap
                           @ [GHC.Types.Char]
                           key
                           appendage
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLReduce anno f2 f3 f4 f5 f6 f7 f8
                   -> Language.Fortran.OpenCLReduce
                        @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                        (LanguageFortranTools.appendAnnotation_$sappendToMap
                           @ [GHC.Types.Char]
                           key
                           appendage
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                        f8 }) -}
9dcc85f8da6917e20fb269b80bbcc21c
  appendAnnotationList ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U>,
     Unfolding: (\ (original :: Language.Fortran.Fortran
                                  LanguageFortranTools.Anno)
                   (key :: GHC.Base.String)
                   (appendage :: [GHC.Base.String]) ->
                 letrec {
                   go9 :: [GHC.Base.String]
                          -> Language.Fortran.Fortran LanguageFortranTools.Anno
                          -> Language.Fortran.Fortran LanguageFortranTools.Anno
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [GHC.Base.String])
                       (eta :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go9 ys (LanguageFortranTools.appendAnnotation eta key y) }
                 } in
                 go9 appendage original) -}
cc81568ce9b1db55601acb0f7996f784
  appendAnnotationMap ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno)
                   (newMap :: LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT -> LanguageFortranTools.appendAnnotationMap2
                   Language.Fortran.For anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.For
                        @ LanguageFortranTools.Anno
                        (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                           @ [GHC.Types.Char]
                           newMap
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLMap anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.OpenCLMap
                        @ LanguageFortranTools.Anno
                        (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                           @ [GHC.Types.Char]
                           newMap
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLReduce anno f2 f3 f4 f5 f6 f7 f8
                   -> Language.Fortran.OpenCLReduce
                        @ LanguageFortranTools.Anno
                        (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                           @ [GHC.Types.Char]
                           newMap
                           anno)
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                        f8 }) -}
7c084cfd619bd3e0765ce8066e72ce6a
  appendAnnotationMap1 ::
    (Data.Map.Base.Map GHC.Base.String [a]
     -> Data.Map.Base.Map GHC.Base.String [a])
    -> Data.Map.Base.Map [GHC.Types.Char] [a]
    -> Data.Map.Base.Map GHC.Base.String [a]
    -> Data.Map.Base.Map GHC.Base.String [a]
  {- Arity: 3, Strictness: <C(S),1*C1(U)><S,1*U><L,U> -}
8f48fe51d8e8979db90050d78ba0e13d
  appendAnnotationMap2 ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Strictness: x -}
39529d5254501bf8b3376ea4264e3a19
  appendAnnotationMap_$scombineMaps ::
    Data.Map.Base.Map GHC.Base.String [a]
    -> Data.Map.Base.Map GHC.Base.String [a]
    -> Data.Map.Base.Map GHC.Base.String [a]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   (map1 :: Data.Map.Base.Map GHC.Base.String [a])
                   (map2 :: Data.Map.Base.Map GHC.Base.String [a]) ->
                 LanguageFortranTools.appendAnnotationMap1
                   @ a
                   (GHC.Base.id @ (Data.Map.Base.Map GHC.Base.String [a]))
                   map2
                   map1) -}
154dfc40be1a0c765d5292037bbcf6c1
  appendAnnotation_$sappendToMap ::
    GHC.Base.String
    -> a
    -> Data.Map.Base.Map GHC.Base.String [a]
    -> Data.Map.Base.Map GHC.Base.String [a]
  {- Arity: 3, Strictness: <S,U><L,U><S,U>,
     Unfolding: (\ @ a
                   (key :: GHC.Base.String)
                   (item :: a)
                   (map :: Data.Map.Base.Map GHC.Base.String [a]) ->
                 LanguageFortranTools.$sinsert_$sgo10
                   @ [a]
                   key
                   (GHC.Base.++
                      @ a
                      (LanguageFortranTools.$sfindWithDefault1
                         @ [a]
                         (GHC.Types.[] @ a)
                         key
                         map)
                      (GHC.Types.: @ a item (GHC.Types.[] @ a)))
                   map) -}
4a73f638f4b7d944226ec9c29c89a7cb
  appendFortran_recursive ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
dc2f60dee1c2c768663fa5922bc11748
  appendToMap ::
    GHC.Classes.Ord k =>
    k -> a -> Data.Map.Base.Map k [a] -> Data.Map.Base.Map k [a]
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,U><L,U><S,U>,
     Unfolding: (\ @ k
                   @ a
                   ($dOrd :: GHC.Classes.Ord k)
                   (key :: k)
                   (item :: a)
                   (map :: Data.Map.Base.Map k [a]) ->
                 Data.Map.Base.insert
                   @ k
                   @ [a]
                   $dOrd
                   key
                   (GHC.Base.++
                      @ a
                      (Data.Map.Base.findWithDefault
                         @ k
                         @ [a]
                         $dOrd
                         (GHC.Types.[] @ a)
                         key
                         map)
                      (GHC.Types.: @ a item (GHC.Types.[] @ a)))
                   map) -}
abc3393b31513f41cb818c5f6e8c39dc
  applyGeneratedSrcSpans ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (a :: * -> *)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno)) ->
                 Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans2
                   @ (a LanguageFortranTools.Anno)
                   $dData) -}
1c7205d081d3c2b3ccdb6b90d7288052
  applyGeneratedSrcSpans2 :: Data.Data.Data a => a -> a
  {- Arity: 1,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) ->
                 case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#46
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case LanguageFortranTools.applyGeneratedSrcSpans5 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#46
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case LanguageFortranTools.applyGeneratedSrcSpans3 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#46
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild1 { Data.Typeable.Internal.TypeRep dt9 dt10 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt7 dt9) of wild2 {
                   GHC.Types.False -> GHC.Base.id @ a
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt8 dt10) of wild4 {
                        GHC.Types.False -> GHC.Base.id @ a
                        GHC.Types.True
                        -> LanguageFortranTools.standardiseSrcSpan
                             `cast`
                           (UnsafeCo representational Language.Fortran.SrcSpan a
                            ->_R UnsafeCo representational Language.Fortran.SrcSpan a) } } } } } } } } }) -}
d778a072f8039cd76dd2138d083ee68f
  applyGeneratedSrcSpans3 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.applyGeneratedSrcSpans4) -}
9440ffc1adcb2c5c597a045e425203c8
  applyGeneratedSrcSpans4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.$stypeRep#54
                   LanguageFortranTools.$stypeRep#54) -}
a65f897c989af0d1d7a95032c4f706f4
  applyGeneratedSrcSpans5 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.$stypeRep#54) -}
2ae1a23f51be4d9898dd8356e2c6fe69
  applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1 ::
    Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
  {- Unfolding: (Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans2
                   @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataProgUnit) -}
584e9fa33307e59c8b1b371760903ff7
  applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2 ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Unfolding: (Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans2
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran) -}
0f377425da450ed79516074ff6cd0fa8
  applyGlobalSrcSpan ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    Language.Fortran.SrcSpan
    -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U)><L,U>,
     Unfolding: (\ @ (a :: * -> *)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (srcSpan :: Language.Fortran.SrcSpan)
                   (codeSeg :: a LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True)
                                   (\ (current :: Language.Fortran.SrcSpan) -> srcSpan) -}
                   = \ (current :: Language.Fortran.SrcSpan) -> srcSpan
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                    case LanguageFortranTools.applyGlobalSrcSpan4 of kt_fps1 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                    case LanguageFortranTools.applyGlobalSrcSpan1 of kt_fps2 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild1 { Data.Typeable.Internal.TypeRep dt9 dt10 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt7 dt9) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a1
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt8 dt10) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a1
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a1
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a1) } } } } } } } } })
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   codeSeg) -}
4c7996c54c6d87a362f64b04e838b57a
  applyGlobalSrcSpan1 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.applyGlobalSrcSpan2) -}
5864f1b18740c51683682679aea47eb9
  applyGlobalSrcSpan2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.applyGlobalSrcSpan_types
                   LanguageFortranTools.applyGlobalSrcSpan_types) -}
325d1a09840b3b02cffb1e45b67c04df
  applyGlobalSrcSpan3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#50
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcSrcLoc
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
2ed841c1eb01f196531d5003d34e4c74
  applyGlobalSrcSpan4 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.applyGlobalSrcSpan_types) -}
db2f68621e7183f75dee9667076f90f0
  applyGlobalSrcSpan_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.applyGlobalSrcSpan3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
d4b821d052069b1ae211d09fce67cb07
  applySrcSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (src :: Language.Fortran.SrcSpan)
                   (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> LanguageFortranTools.applySrcSpan1
                   Language.Fortran.OpenCLMap anno ds1 read written loopvs iterloopvs fortran
                   -> Language.Fortran.OpenCLMap
                        @ LanguageFortranTools.Anno
                        anno
                        src
                        read
                        written
                        loopvs
                        iterloopvs
                        fortran
                   Language.Fortran.OpenCLReduce anno ds1 read written loopvs iterloopvs rvs fortran
                   -> Language.Fortran.OpenCLReduce
                        @ LanguageFortranTools.Anno
                        anno
                        src
                        read
                        written
                        loopvs
                        iterloopvs
                        rvs
                        fortran }) -}
af833fe60ae5bec570cd9e4c37cec148
  applySrcSpan1 :: Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Strictness: x -}
44a93ac0ce2939531e607f4ceb3bbfee
  checkSrcLocBefore ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)L),1*U(A,1*U(U),1*U(U))><S(LS(S)L),1*U(A,1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcLoc)
                   (w1 :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 case ww2 of ww4 { GHC.Types.I# ww5 ->
                 case w1 of ww6 { Language.Fortran.SrcLoc ww7 ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 LanguageFortranTools.$wcheckSrcLocBefore
                   ww5
                   ww3
                   ww11
                   ww9 } } } }) -}
98fbc29b8d9a27e7e16c5ca3321ff967
  checkSrcLocEqualLines ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)L),1*U(A,1*U(U),A)><S(LS(S)L),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Language.Fortran.SrcLoc)
                   (ds1 :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds2 l1 ds3 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc ds4 l2 ds5 ->
                 GHC.Classes.eqInt l1 l2 } }) -}
83822a4891ce742ba9bc58d3f7c76a5f
  checkSrcSpanAfter ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)><S(LS(LS(S)L)),1*U(A,1*U(A,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case w1 of ww9 { (,) ww10 ww11 ->
                 case ww11 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                 case ww14 of ww16 { GHC.Types.I# ww17 ->
                 LanguageFortranTools.$wcheckSrcSpanAfter
                   ww8
                   ww6
                   ww17
                   ww15 } } } } } }) -}
3265fed738c647c8f56797925ccfce8f
  checkSrcSpanBefore ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LS(S)L)),1*U(A,1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case w1 of ww9 { (,) ww10 ww11 ->
                 case ww10 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                 case ww14 of ww16 { GHC.Types.I# ww17 ->
                 LanguageFortranTools.$wcheckSrcSpanBefore
                   ww8
                   ww6
                   ww17
                   ww15 } } } } } }) -}
7d93eca39e9cb15af266b3c50e034551
  checkSrcSpanBefore_line ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),A),A)><S(S(LS(S)L)L),1*U(1*U(A,1*U(U),A),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                   (ds1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds2 beforeEnd ->
                 case ds2 of wild1 { Language.Fortran.SrcLoc file_before line_before column_before ->
                 case ds1 of wild2 { (,) ds3 afterEnd ->
                 case ds3 of wild3 { Language.Fortran.SrcLoc file_after line_after column_after ->
                 GHC.Classes.ltInt line_before line_after } } } }) -}
fe45dcdef31c4f10058cd3a6fb545d90
  checkSrcSpanContainsSrcSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case ww2 of ww9 { Language.Fortran.SrcLoc ww10 ww11 ww12 ->
                 case w1 of ww13 { (,) ww14 ww15 ->
                 case ww14 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                 case ww18 of ww20 { GHC.Types.I# ww21 ->
                 case ww15 of ww22 { Language.Fortran.SrcLoc ww23 ww24 ww25 ->
                 LanguageFortranTools.$wcheckSrcSpanContainsSrcSpan
                   ww8
                   ww6
                   ww11
                   ww12
                   ww21
                   ww19
                   ww24
                   ww25 } } } } } } } }) -}
59a711db5664b0b539106b5d4baa7cb5
  combineAnnotations ::
    LanguageFortranTools.Anno
    -> LanguageFortranTools.Anno -> LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (LanguageFortranTools.appendAnnotationMap_$scombineMaps
                   @ [GHC.Types.Char]) -}
36b30c1166f90ccbb57ffb59fe770f13
  combineMaps ::
    GHC.Classes.Ord k =>
    Data.Map.Base.Map k [a]
    -> Data.Map.Base.Map k [a] -> Data.Map.Base.Map k [a]
  {- Arity: 3, Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U>,
     Unfolding: (\ @ k
                   @ a
                   ($dOrd :: GHC.Classes.Ord k)
                   (map1 :: Data.Map.Base.Map k [a])
                   (map2 :: Data.Map.Base.Map k [a]) ->
                 letrec {
                   go10 :: (Data.Map.Base.Map k [a] -> Data.Map.Base.Map k [a])
                           -> Data.Map.Base.Map k [a]
                           -> Data.Map.Base.Map k [a]
                           -> Data.Map.Base.Map k [a]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: Data.Map.Base.Map k [a] -> Data.Map.Base.Map k [a])
                       (ds :: Data.Map.Base.Map k [a]) ->
                     case ds of wild {
                       Data.Map.Base.Bin dt kx x l r
                       -> go10
                            (let {
                               xs :: Data.Map.Base.Map k [a] -> Data.Map.Base.Map k [a]
                               = go10 z' r
                             } in
                             \ (eta :: Data.Map.Base.Map k [a]) ->
                             xs
                               (Data.Map.Base.insert
                                  @ k
                                  @ [a]
                                  $dOrd
                                  kx
                                  (GHC.Base.++
                                     @ a
                                     (Data.Map.Base.findWithDefault
                                        @ k
                                        @ [a]
                                        $dOrd
                                        (GHC.Types.[] @ a)
                                        kx
                                        eta)
                                     x)
                                  eta))
                            l
                       Data.Map.Base.Tip -> z' }
                 } in
                 go10 (GHC.Base.id @ (Data.Map.Base.Map k [a])) map2 map1) -}
72ed49229ad21cb8bafd41ea1e6fde9a
  commentSeparator :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (str :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   "! ----"#
                   (case str of wild {
                      [] -> LanguageFortranTools.commentSeparator8
                      : ipv ipv1
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           (LanguageFortranTools.commentSeparator'
                              (GHC.CString.unpackAppendCString#
                                 " "#
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    wild
                                    LanguageFortranTools.commentSeparator7))
                              LanguageFortranTools.commentSeparator2)
                           LanguageFortranTools.commentSeparator1 })) -}
dd838e6880558ddb737f8e2a948a4b81
  commentSeparator' ::
    GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
eba77be2475b627f80ccb722cf8e2a5c
  commentSeparator1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
d9678520d4ee30a34126d86e97936e74
  commentSeparator2 :: [GHC.Types.Char]
  {- Unfolding: (LanguageFortranTools.commentSeparator4
                   LanguageFortranTools.commentSeparator3) -}
175cd6e324cd3ac399fd2245eeac74ac
  commentSeparator3 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 122#) -}
6a10f256232646ce33fbcc10043a3d6a
  commentSeparator4 :: GHC.Types.Int -> [GHC.Types.Char]
  {- Unfolding: (GHC.Enum.efdtCharFB
                   @ (GHC.Types.Int -> [GHC.Types.Char])
                   LanguageFortranTools.commentSeparator6
                   LanguageFortranTools.commentSeparator5
                   45#
                   45#
                   45#) -}
377ae5566f2012a65fd2b9f52fedd3e4
  commentSeparator5 :: GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.List.flipSeqTake
                   @ [GHC.Types.Char]
                   (GHC.Types.[] @ GHC.Types.Char)) -}
60e977f615ee041ccc133e7f7769bd7c
  commentSeparator6 ::
    GHC.Types.Char
    -> (GHC.Types.Int -> [GHC.Types.Char])
    -> GHC.Types.Int
    -> [GHC.Types.Char]
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (GHC.List.takeFB
                   @ GHC.Types.Char
                   @ [GHC.Types.Char]
                   (GHC.Types.: @ GHC.Types.Char)
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d414be8f12e038ca70db75c49ae67cbe
  commentSeparator7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
1c1234909a7f9e7f4500a728c9fb4d7c
  commentSeparator8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   LanguageFortranTools.commentSeparator9
                   LanguageFortranTools.commentSeparator1) -}
9e208da1308de2a920bb3d54c9b46076
  commentSeparator9 :: GHC.Base.String
  {- Unfolding: (case LanguageFortranTools.commentSeparator2 of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char : ds seps -> seps }) -}
af3b337e7deea7084cf6d3ad27314e83
  compilerName :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "ParallelFortran"#) -}
df828722c6ab6b340b2929b8caf4e928
  deleteValueFromTable ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> LanguageFortranTools.ValueTable
    -> LanguageFortranTools.ValueTable
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (var :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (table :: LanguageFortranTools.ValueTable) ->
                 case var of wild { Language.Fortran.VarName ds str ->
                 LanguageFortranTools.$sdelete_$sgo10
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   str
                   table }) -}
ade5e4011267f0b3e68f4c6bf90cd5b5
  errorLocationFormatting ::
    Language.Fortran.SrcSpan -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)L),1*U(1*U(A,1*U(U),1*U(U)),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 LanguageFortranTools.$werrorLocationFormatting ww8 ww6 } } }) -}
71bdde10a74b6c8cdcece9e502f1b1dd
  errorLocationRangeFormatting ::
    Language.Fortran.SrcSpan -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SS),1*U(1*U(A,1*U(U),A),1*U(A,1*U(U),A))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww2 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                 LanguageFortranTools.$werrorLocationRangeFormatting
                   ww5
                   ww9 } } }) -}
62620ee21f752bed948b5a6b77659df8
  evaluateExpr ::
    LanguageFortranTools.ValueTable
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe GHC.Types.Float
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (vt :: LanguageFortranTools.ValueTable)
                   (expr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.evaluateExpr_type vt expr of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Float
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) val ds1 ->
                      GHC.Base.Just @ GHC.Types.Float val } }) -}
57ee2bca36bf14540a9b9916d63eaa6d
  evaluateExpr_type ::
    LanguageFortranTools.ValueTable
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
ab4f18ddaefe5574bba2452796f37538
  evaluateRange ::
    LanguageFortranTools.ValueTable
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe [GHC.Types.Float]
  {- Arity: 4, Strictness: <L,U><S,1*U><L,1*U><L,1*U>,
     Unfolding: (\ (vt :: LanguageFortranTools.ValueTable)
                   (startExpr :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (endExpr :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (stepExpr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.evaluateExpr_type vt startExpr of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Float]
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) val ds1 ->
                      case LanguageFortranTools.evaluateExpr_type vt endExpr of wild2 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Float]
                        GHC.Base.Just ds2
                        -> case ds2 of wild3 { (,) val1 ds3 ->
                           case LanguageFortranTools.evaluateExpr_type vt stepExpr of wild4 {
                             GHC.Base.Nothing -> GHC.Base.Nothing @ [GHC.Types.Float]
                             GHC.Base.Just ds4
                             -> case ds4 of wild5 { (,) val2 ds5 ->
                                GHC.Base.Just
                                  @ [GHC.Types.Float]
                                  (case val of ds6 { GHC.Types.F# ds7 ->
                                   case {__pkg_ccall base-4.9.1.0 rintFloat GHC.Prim.Float#
                                                                            -> GHC.Prim.State#
                                                                                 GHC.Prim.RealWorld
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  GHC.Prim.Float# #)}
                                          ds7
                                          GHC.Prim.realWorld# of wild6 { (#,#) ds8 ds9 ->
                                   case val2 of ds10 { GHC.Types.F# ds11 ->
                                   case {__pkg_ccall base-4.9.1.0 rintFloat GHC.Prim.Float#
                                                                            -> GHC.Prim.State#
                                                                                 GHC.Prim.RealWorld
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  GHC.Prim.Float# #)}
                                          ds11
                                          GHC.Prim.realWorld# of wild7 { (#,#) ds12 ds13 ->
                                   case val1 of ds14 { GHC.Types.F# ds15 ->
                                   case {__pkg_ccall base-4.9.1.0 rintFloat GHC.Prim.Float#
                                                                            -> GHC.Prim.State#
                                                                                 GHC.Prim.RealWorld
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  GHC.Prim.Float# #)}
                                          ds15
                                          GHC.Prim.realWorld# of wild8 { (#,#) ds16 ds17 ->
                                   let {
                                     x1 :: GHC.Prim.Int# = GHC.Prim.float2Int# ds9
                                   } in
                                   let {
                                     x2 :: GHC.Prim.Int#
                                     = GHC.Prim.+#
                                         (GHC.Prim.float2Int# ds9)
                                         (GHC.Prim.float2Int# ds13)
                                   } in
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.>=# x2 x1) of wild9 {
                                     GHC.Types.False
                                     -> GHC.Enum.efdtIntDnFB
                                          @ [GHC.Types.Float]
                                          LanguageFortranTools.evaluateRange_c
                                          (GHC.Types.[] @ GHC.Types.Float)
                                          x1
                                          x2
                                          (GHC.Prim.float2Int# ds17)
                                     GHC.Types.True
                                     -> GHC.Enum.efdtIntUpFB
                                          @ [GHC.Types.Float]
                                          LanguageFortranTools.evaluateRange_c
                                          (GHC.Types.[] @ GHC.Types.Float)
                                          x1
                                          x2
                                          (GHC.Prim.float2Int# ds17) } } } } } } }) } } } } } }) -}
cc08d412391c93a3d94858b7c5a45698
  evaluateRange_c ::
    GHC.Types.Int -> [GHC.Types.Float] -> [GHC.Types.Float]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [GHC.Types.Float]) ->
                 GHC.Types.:
                   @ GHC.Types.Float
                   (GHC.Float.RealFracMethods.int2Float x)
                   ys) -}
86e7bb58fcd61ba1c9214f48532a0256
  extractAllVarNames ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    a LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (a :: * -> *)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (eta :: a LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno))
                   LanguageFortranTools.extractAllVarNames1
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   eta) -}
3cb96fbac8226fec8933f90f46df0737
  extractAllVarNames1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractAllVarNames2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractVarNames
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Expr
                                                             LanguageFortranTools.Anno)) } } } }) -}
1c3b66d24a7a1d80bfd7b077ae63834b
  extractAllVarNames10 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#15
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Types.$tc[]
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
12960fc9e52a6d15a4688fbbc9f670ab
  extractAllVarNames2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#57 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames3
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
5ec79348c271d4c83af5e773856ae215
  extractAllVarNames3 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractAllVarNames4
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
a84f857349cf44519fe84ffffc824e44
  extractAllVarNames4 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractAllVarNames_types1 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractAllVarNames_types of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractAllVarNames_types } } } } } }) -}
092d0afe93f939cdf87e8df8caf650f6
  extractAllVarNames5 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractAllVarNames6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
28de1965e23e8078464ddf8ed66accfc
  extractAllVarNames6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames_types1
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
43164115b3d9b51b277a05a2159ed100
  extractAllVarNames7 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
1bd644727e7e11acad395c412055c87c
  extractAllVarNames8 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractAllVarNames9
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
8f7911f3c68ca9d952c89721cad00fba
  extractAllVarNames9 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#11
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   GHC.Types.$tcChar
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
fd280dd2bf6dcd8dd75ce7bac2655042
  extractAllVarNames_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractAllVarNames_types1
                   LanguageFortranTools.extractAllVarNames5) -}
a30fc633f9c6b85ba8b7852a3efc3fd9
  extractAllVarNames_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractAllVarNames7
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
728f6b1c6133de24ee1492ed5361a216
  extractArgName ::
    Language.Fortran.ArgName LanguageFortranTools.Anno
    -> [Language.Fortran.ArgName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.ArgName
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.ArgName LanguageFortranTools.Anno)
                   Language.Fortran.ArgName ds ds1
                   -> GHC.Types.:
                        @ (Language.Fortran.ArgName LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.ArgName LanguageFortranTools.Anno)) }) -}
39645f5b02a3ff61a46cb5621de8142e
  extractAssigneeFromDecl ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.Decl LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.$wextractAssigneeFromDecl
                        w of ww { (#,#) ww1 ww2 ->
                 Language.Fortran.VarName @ LanguageFortranTools.Anno ww1 ww2 }) -}
69701249e987c245398ae4cf5f18bb98
  extractAssigneeFromDecl1 ::
    Language.Fortran.VarName LanguageFortranTools.Anno
  {- Strictness: x -}
d06c509687e2b75fc33d6dddf17b459e
  extractAssignments ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.Assg ds ds1 ds2 ds3
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
62eed54c3078de2b4d8bb649e98ffba1
  extractBaseType ::
    Language.Fortran.Type LanguageFortranTools.Anno
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Type LanguageFortranTools.Anno) ->
                 case ds of wild {
                   Language.Fortran.BaseType ds1 bt ds2 ds3 ds4 -> bt
                   Language.Fortran.ArrayT ds1 ds2 bt ds3 ds4 ds5 -> bt }) -}
e72118255719a5a240a30f7f3cbc8856
  extractBlock ::
    Language.Fortran.Block LanguageFortranTools.Anno
    -> [Language.Fortran.Block LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (block :: Language.Fortran.Block LanguageFortranTools.Anno) ->
                 GHC.Types.:
                   @ (Language.Fortran.Block LanguageFortranTools.Anno)
                   block
                   (GHC.Types.[]
                      @ (Language.Fortran.Block LanguageFortranTools.Anno))) -}
a3f45d5b6a53414ae1cd35b025a54b81
  extractBufferReads ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractBufferReads1
                   @ a
                   $dData
                   ast) -}
b1e3fcd4fc0fadad9418b04ce5b6f6c5
  extractBufferReads' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLBufferRead ds ds1 ds2
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
3fce103db6fd9de401c24bcf1f13fd7e
  extractBufferReads1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractBufferReads2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractBufferReads'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
0c9979a423895af557084201d2033a81
  extractBufferReads2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractBufferReads_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractBufferReads_types } } } }) -}
9b5681babdc9932b4dbb1a3d71a3d019
  extractBufferReads3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractBufferReads_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractBufferReads_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractBufferReads_types1 } } } } } }) -}
7b9ae55a550f52a4ee983928dfd82377
  extractBufferReads4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferReads5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
1e8147caf6b5811eccb55368adaf9006
  extractBufferReads5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractBufferReads_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
ed9998237597f8075870431165c4458e
  extractBufferReads6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
08bbe621eb9cfd8f3f10666bf3348899
  extractBufferReads_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferReads3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
7cc864bc0906d0ca04a8a1588d0dd39a
  extractBufferReads_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferReads_types2
                   LanguageFortranTools.extractBufferReads4) -}
faeb3cd4054efc5f028459ef2c45959c
  extractBufferReads_types2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferReads6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
e3a1ededa940a53183ac1f5fa3a96f92
  extractBufferWrites ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractBufferWrites1
                   @ a
                   $dData
                   ast) -}
4be21018dae8380108b2bbc7010a5556
  extractBufferWrites' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLBufferWrite ds ds1 ds2
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
c8945ecab912a7fb27a129c2a4737f36
  extractBufferWrites1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractBufferWrites2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractBufferWrites'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
9c2d6a065acd9220be95828cf136182a
  extractBufferWrites2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractBufferWrites_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractBufferWrites_types } } } }) -}
d559043bf59a95650df69ff27b43b12d
  extractBufferWrites3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractBufferWrites_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractBufferWrites_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractBufferWrites_types1 } } } } } }) -}
46aa2029a58804b44d2c45a373888293
  extractBufferWrites4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferWrites5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
0d1667e375dfe3a99659f7c222dd444d
  extractBufferWrites5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractBufferWrites_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
29b423c425e22716252c34e35abea8bb
  extractBufferWrites6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
d25b38f5b4c8f0835c511428186b7d9a
  extractBufferWrites_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferWrites3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
8419dd27bcde73c9e386ddb044595548
  extractBufferWrites_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferWrites_types2
                   LanguageFortranTools.extractBufferWrites4) -}
933abdc9ab2a41d2a7aa70c7828f548f
  extractBufferWrites_types2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractBufferWrites6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
ad7a63c662cf122960b20a3bede2f27f
  extractContainedOperands ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractContainedOperands @ p w1 w2) -}
74c781fa3b9238d7052767abfd07bb36
  extractContainedOperands1 ::
    [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
    -> [Language.Fortran.Expr p] -> [Language.Fortran.Expr p]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
0331c35bcc1dc0d38694c0dba9afce40
  extractContainedVars ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractContainedVars @ p w2) -}
73ecb6f522a615c9642c4942e4625153
  extractContainedVarsWV ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractContainedVarsWV @ p w1 w2) -}
0893c4a1d85744d1348f3d50e05122a0
  extractDecl ::
    Language.Fortran.Decl LanguageFortranTools.Anno
    -> [Language.Fortran.Decl LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (decl :: Language.Fortran.Decl LanguageFortranTools.Anno) ->
                 GHC.Types.:
                   @ (Language.Fortran.Decl LanguageFortranTools.Anno)
                   decl
                   (GHC.Types.[]
                      @ (Language.Fortran.Decl LanguageFortranTools.Anno))) -}
8e4e168659a85455639957893bdf2d79
  extractEvaluatedType ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: GHC.Base.Maybe
                              (GHC.Types.Float,
                               Language.Fortran.BaseType LanguageFortranTools.Anno)) ->
                 case expr of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) ds1 typ ->
                      GHC.Base.Just
                        @ (Language.Fortran.BaseType LanguageFortranTools.Anno)
                        typ } }) -}
6f20877d26bce069a9adfa8256a9d071
  extractEvaluatedValue ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe GHC.Types.Float
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (expr :: GHC.Base.Maybe
                              (GHC.Types.Float,
                               Language.Fortran.BaseType LanguageFortranTools.Anno)) ->
                 case expr of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Float
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) val ds1 ->
                      GHC.Base.Just @ GHC.Types.Float val } }) -}
97cf1ec599eecd56ac1929221fcc2a8f
  extractExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (expr :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 expr) -}
90ec2eadeb0a2ed115fbe8bc2fb1ab33
  extractExpr_list ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.:
                        @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[] @ (Language.Fortran.Expr LanguageFortranTools.Anno))
                   Language.Fortran.ESeq ds1 ds2 ds3 ds4
                   -> GHC.Types.[]
                        @ (Language.Fortran.Expr LanguageFortranTools.Anno) }) -}
cb5c88e5217910e2a4a35949970b6528
  extractFirstChildFor ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Fortran
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> LanguageFortranTools.extractFirstChildFor1
                   Language.Fortran.For ds1 ds2 ds3 ds4 ds5 ds6 fortran
                   -> case LanguageFortranTools.extractForWithFollowing_beta
                             fortran of wild1 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Base.Just a
                        -> GHC.Base.Just
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                             (LanguageFortranTools.extractPriorToFor fortran,
                              case a of wild2 { (,) firstFor followingFortran -> firstFor },
                              case a of wild2 { (,) firstFor followingFortran ->
                              followingFortran }) } }) -}
be6f3dad7bacf0b7b6ab914852823b5a
  extractFirstChildFor1 ::
    GHC.Base.Maybe
      (Language.Fortran.Fortran LanguageFortranTools.Anno,
       Language.Fortran.Fortran LanguageFortranTools.Anno,
       Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Strictness: x -}
21ac384425554ea549e1f4507ad7a908
  extractFirstFortran ::
    Data.Data.Data a =>
    a -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (codeSeg :: a) ->
                 case Data.Generics.Schemes.everything
                        @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                        (GHC.Base.++
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                        LanguageFortranTools.extractFirstFortran1
                        @ a
                        $dData
                        codeSeg of wild {
                   []
                   -> GHC.List.badHead
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   : x ds1 -> x }) -}
ba950aabf74d6804bddf364446ef691a
  extractFirstFortran1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractFirstFortran2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno))
                             (GHC.Types.[]
                                @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) } } } }) -}
4ff178eebe266fca5597c3568532a3f1
  extractFirstFortran2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractFirstFortran_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractFirstFortran_types } } } }) -}
e4635dadf33190580dce5da774303ab2
  extractFirstFortran3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractFirstFortran_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractFirstFortran_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractFirstFortran_types1 } } } } } }) -}
7ec9a495f9771d81eda6694791e093b0
  extractFirstFortran4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractFirstFortran5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
cb5dd49d24b868a014f1dff11ffbc9e8
  extractFirstFortran5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractFirstFortran_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
5370e26b1520389bbd1018f512473ea5
  extractFirstFortran6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
25a0a5465a4f024c3587e6f1381249bc
  extractFirstFortran_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractFirstFortran3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
d443b571626b22be2a7cd6eae087297d
  extractFirstFortran_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractFirstFortran_types2
                   LanguageFortranTools.extractFirstFortran4) -}
c4fdc3ef4c578eef70d30f777c1bfbea
  extractFirstFortran_types2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractFirstFortran6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
b17d482359c357df966fde4937c74e1d
  extractFor ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
037f078ae055a21e1adce7843bfcaea4
  extractForWithFollowing ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [(Language.Fortran.Fortran LanguageFortranTools.Anno,
         Language.Fortran.Fortran LanguageFortranTools.Anno)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                           Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.FSeq ds1 ds2 fortran1 fortran2
                   -> case fortran1 of wild1 {
                        DEFAULT
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                        Language.Fortran.For ds3 ds4 ds5 ds6 ds7 ds8 ds9
                        -> GHC.Types.:
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                             (wild1, fortran2)
                             (GHC.Types.[]
                                @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                   Language.Fortran.Fortran LanguageFortranTools.Anno)) } }) -}
fdfef57adda899e9ca995f0fa47bbecd
  extractForWithFollowing_beta ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> case Language.Fortran.$fDataFortran_$cgmapQ
                             @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                             LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                             @ (GHC.Base.Maybe
                                  (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                   Language.Fortran.Fortran LanguageFortranTools.Anno))
                             LanguageFortranTools.extractForWithFollowing_beta1
                             wild of wild1 {
                        []
                        -> GHC.Base.Nothing
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                        : ipv ipv1 -> ipv }
                   Language.Fortran.FSeq ds ds1 fortran1 fortran2
                   -> case fortran1 of wild1 {
                        DEFAULT
                        -> case Language.Fortran.$fDataFortran_$cgmapQ
                                  @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                  LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                                  @ (GHC.Base.Maybe
                                       (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                        Language.Fortran.Fortran LanguageFortranTools.Anno))
                                  LanguageFortranTools.extractForWithFollowing_beta1
                                  wild of wild2 {
                             []
                             -> GHC.Base.Nothing
                                  @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                     Language.Fortran.Fortran LanguageFortranTools.Anno)
                             : ipv ipv1 -> ipv }
                        Language.Fortran.For ds2 ds3 ds4 ds5 ds6 ds7 ds8
                        -> GHC.Base.Just
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                             (wild1, fortran2) } }) -}
ed72317d2ea7c823c66ee1275424bd2f
  extractForWithFollowing_beta1 ::
    Data.Data.Data d =>
    d
    -> GHC.Base.Maybe
         (Language.Fortran.Fortran LanguageFortranTools.Anno,
          Language.Fortran.Fortran LanguageFortranTools.Anno)
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ d ($dData :: Data.Data.Data d) (eta :: d) ->
                 case (Data.Data.$p1Data @ d $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <d>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ d) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractForWithFollowing_beta2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Base.Nothing
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                           Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Base.Nothing
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> letrec {
                             lvl122 :: forall d1.
                                       Data.Data.Data d1 =>
                                       d1
                                       -> GHC.Base.Maybe
                                            (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                             Language.Fortran.Fortran LanguageFortranTools.Anno)
                               {- Arity: 2,
                                  Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U> -}
                             = \ @ d1 ($dData1 :: Data.Data.Data d1) (eta1 :: d1) ->
                               case (Data.Data.$p1Data @ d1 $dData1)
                                      `cast`
                                    (Data.Typeable.Internal.N:Typeable[0] <*>_N <d1>_N)
                                      (GHC.Prim.proxy#
                                         @ *
                                         @ d1) of wild7 { Data.Typeable.Internal.TypeRep dt4 dt5 ds1 ds8 ds9 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.eqWord# dt4 dt2) of wild8 {
                                 GHC.Types.False
                                 -> GHC.Base.Nothing
                                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                         Language.Fortran.Fortran LanguageFortranTools.Anno)
                                 GHC.Types.True
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqWord# dt5 dt3) of wild9 {
                                      GHC.Types.False
                                      -> GHC.Base.Nothing
                                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                              Language.Fortran.Fortran LanguageFortranTools.Anno)
                                      GHC.Types.True
                                      -> extractForWithFollowing_beta7
                                           eta1
                                             `cast`
                                           (UnsafeCo representational d1 (Language.Fortran.Fortran
                                                                            LanguageFortranTools.Anno)) } } }
                             extractForWithFollowing_beta7 :: Language.Fortran.Fortran
                                                                LanguageFortranTools.Anno
                                                              -> GHC.Base.Maybe
                                                                   (Language.Fortran.Fortran
                                                                      LanguageFortranTools.Anno,
                                                                    Language.Fortran.Fortran
                                                                      LanguageFortranTools.Anno)
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (codeSeg :: Language.Fortran.Fortran
                                               LanguageFortranTools.Anno) ->
                               case codeSeg of wild7 {
                                 DEFAULT
                                 -> case Language.Fortran.$fDataFortran_$cgmapQ
                                           @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                           LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                                           @ (GHC.Base.Maybe
                                                (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                                 Language.Fortran.Fortran
                                                   LanguageFortranTools.Anno))
                                           lvl122
                                           wild7 of wild8 {
                                      []
                                      -> GHC.Base.Nothing
                                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                              Language.Fortran.Fortran LanguageFortranTools.Anno)
                                      : ipv ipv1 -> ipv }
                                 Language.Fortran.FSeq ds ds1 fortran1 fortran2
                                 -> case fortran1 of wild8 {
                                      DEFAULT
                                      -> case Language.Fortran.$fDataFortran_$cgmapQ
                                                @ (Data.Map.Base.Map
                                                     GHC.Base.String [GHC.Base.String])
                                                LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                                                @ (GHC.Base.Maybe
                                                     (Language.Fortran.Fortran
                                                        LanguageFortranTools.Anno,
                                                      Language.Fortran.Fortran
                                                        LanguageFortranTools.Anno))
                                                lvl122
                                                wild7 of wild9 {
                                           []
                                           -> GHC.Base.Nothing
                                                @ (Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno,
                                                   Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno)
                                           : ipv ipv1 -> ipv }
                                      Language.Fortran.For ds8 ds9 ds10 ds11 ds12 ds13 ds14
                                      -> GHC.Base.Just
                                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno,
                                              Language.Fortran.Fortran LanguageFortranTools.Anno)
                                           (wild8, fortran2) } }
                           } in
                           extractForWithFollowing_beta7
                             eta
                               `cast`
                             (UnsafeCo representational d (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
8a38b7783675fcda3a0858b9c594abdc
  extractForWithFollowing_beta2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractForWithFollowing_beta_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractForWithFollowing_beta_types } } } }) -}
85fe129b9f8bc6371c977948cfa60cfd
  extractForWithFollowing_beta3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractForWithFollowing_beta_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractForWithFollowing_beta_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractForWithFollowing_beta_types1 } } } } } }) -}
dca8ca9b0dd06afc65cc0bdd8d208c2c
  extractForWithFollowing_beta4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractForWithFollowing_beta5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
75b6cb8688fbe54031990b89459aaaa8
  extractForWithFollowing_beta5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractForWithFollowing_beta_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
676dde4e94bd799d43f36cbd3c76d47f
  extractForWithFollowing_beta6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
6c05ba912bfdd290cbbc05c8083fe230
  extractForWithFollowing_beta_types ::
    [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractForWithFollowing_beta3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
a0f6788f5c7fb484dd9ac528c528497d
  extractForWithFollowing_beta_types1 ::
    [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractForWithFollowing_beta_types2
                   LanguageFortranTools.extractForWithFollowing_beta4) -}
74106b2b5cfd6c07b2c3b11b232bd968
  extractForWithFollowing_beta_types2 ::
    [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractForWithFollowing_beta6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
78e9c8da56c08a2f5c0b60c687536111
  extractFortran ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (fort :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 GHC.Types.:
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   fort
                   (GHC.Types.[]
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))) -}
d8e2a14d2b7cfef4629470f7d77c909a
  extractIndent :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c6339b05bbe16f67d59f5f4f7d0b4085
  extractKernels ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractKernels1
                   @ a
                   $dData
                   ast) -}
88db57c2315e4f967245826e6cfcaf5b
  extractKernels' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLMap ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
2cd7601336f9409ad360edc60b95ff96
  extractKernels1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractKernels2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractKernels'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
cac91b620b30b79b4f9c0009dd0c57da
  extractKernels2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractKernels_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractKernels_types } } } }) -}
45d742e0f740510987498da0fae95a03
  extractKernels3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractKernels_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractKernels_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractKernels_types1 } } } } } }) -}
44cd4f260f178497df7873a233688109
  extractKernels4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractKernels5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
e7b901bb02739e12b4dc2feaa949f7fd
  extractKernels5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractKernels_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
4a4e03264820ade42b4324d6a0f1f9c4
  extractKernels6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
b05d0dc541ca12d7ddaf72ca1b880fa2
  extractKernels_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractKernels3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
36475c214a03d97d9116bbe5bf017beb
  extractKernels_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractKernels_types2
                   LanguageFortranTools.extractKernels4) -}
6560623c8fe73bb8ea42293b6860a43e
  extractKernels_types2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractKernels6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
c9de7252f341a83b89a9038864bc3291
  extractLineNumber :: Language.Fortran.SrcSpan -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LSL)L),1*U(1*U(A,1*U(U),A),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds1 ds2 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc ds3 line ds4 ->
                 line } }) -}
14a8a201024a363eb99389909191bf2c
  extractLoopIters ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [GHC.Base.String]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ast :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [GHC.Base.String]
                   (GHC.Base.++ @ GHC.Base.String)
                   LanguageFortranTools.extractLoopIters1
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   ast) -}
ac86017cd19d055cac492f0da6e49ecd
  extractLoopIters' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Base.String
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> case ds2 of wild1 { Language.Fortran.VarName ds7 idx ->
                      GHC.Types.:
                        @ GHC.Base.String
                        idx
                        (GHC.Types.[] @ GHC.Base.String) } }) -}
f7c4e1055fe073eee90e069b84ca1e21
  extractLoopIters1 :: Data.Data.Data a => a -> [GHC.Base.String]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractLoopIters2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Types.[] @ GHC.Base.String
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Types.[] @ GHC.Base.String
                        GHC.Types.True
                        -> LanguageFortranTools.extractLoopIters'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
cd4dcdaac4a7b0024d1bde4ff3bb5990
  extractLoopIters2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractAllVarNames3 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractAllVarNames3 } } } }) -}
3cc939ec3da2237440656c11a73a87af
  extractLoopVars ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno))
                   LanguageFortranTools.extractLoopVars1
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   codeSeg) -}
37e41f571a8de93bb2890afd6ab788c1
  extractLoopVars' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.For ds1 ds2 var ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        var
                        (GHC.Types.[]
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno)) }) -}
9656c2c0592a21cdcf856237d38fe05c
  extractLoopVars1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractLoopIters2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractLoopVars'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
e932b75466ddc0c3b09beec3af77e729
  extractLoops ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractLoops1
                   @ a
                   $dData
                   ast) -}
1538eca1987be277ed70c8ab493c6912
  extractLoops' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
8de7c59c338a067ac8c97a24eae51d86
  extractLoops1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractLoops2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractFor
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
15299e27bce511fea09a9736320b8146
  extractLoops2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractLoops_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractLoops_types } } } }) -}
819696a830bac80c6ca55df9d603f30e
  extractLoops3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractLoops_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractLoops_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractLoops_types1 } } } } } }) -}
3c3df09cdc94b944984de362babf2114
  extractLoops4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractLoops5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
d41b9bbbf21acde35440d5012e991698
  extractLoops5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractLoops_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
52bd2d452c14c981db23caa5176f820d
  extractLoops6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
ea0e5b9cedb3b1f8cff83485b942f3bc
  extractLoops_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractLoops3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
5de7e8b0efd04af89d6b04dd9e56d2cc
  extractLoops_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractLoops_types2
                   LanguageFortranTools.extractLoops4) -}
1d9d26873e451e82e0041140881d481e
  extractLoops_types2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractLoops6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
5f0509b512923d68a86aa5de75f6b8a4
  extractMaybeVarNames ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Expr
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Base.Nothing
                        @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                   Language.Fortran.Var ds1 ds2 lst
                   -> GHC.Base.Just
                        @ [Language.Fortran.VarName LanguageFortranTools.Anno]
                        (LanguageFortranTools.extractMaybeVarNames_go lst) }) -}
8ff753a4daa0c4169d74aa4700a6edd9
  extractMaybeVarNames_go ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      [Language.Fortran.Expr LanguageFortranTools.Anno])]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U> -}
d1130492fa858966c0cb10b7dee661d8
  extractOpenCLReduces ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (ast :: a) ->
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.Fortran LanguageFortranTools.Anno]
                   (GHC.Base.++
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))
                   LanguageFortranTools.extractOpenCLReduces1
                   @ a
                   $dData
                   ast) -}
82c206b10d3b012c23525ec8e1feef08
  extractOpenCLReduces' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> GHC.Types.:
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.Fortran LanguageFortranTools.Anno)) }) -}
041cda3e408d671c996648e8034b67bf
  extractOpenCLReduces1 ::
    Data.Data.Data a =>
    a -> [Language.Fortran.Fortran LanguageFortranTools.Anno]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) (eta :: a) ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.extractOpenCLReduces2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False
                        -> GHC.Types.[]
                             @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                        GHC.Types.True
                        -> LanguageFortranTools.extractOpenCLReduces'
                             eta
                               `cast`
                             (UnsafeCo representational a (Language.Fortran.Fortran
                                                             LanguageFortranTools.Anno)) } } } }) -}
542df5bab10acfeecb4454213ad0b92b
  extractOpenCLReduces2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractOpenCLReduces_types of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 Data.Typeable.Internal.TypeRep
                   dt3
                   dt5
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractOpenCLReduces_types } } } }) -}
d7f2a39c7103c71632e98a11f93b37b1
  extractOpenCLReduces3 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractOpenCLReduces_types2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.extractOpenCLReduces_types1 of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractOpenCLReduces_types1 } } } } } }) -}
a2f71611014487f67c8a8ca40955e1ae
  extractOpenCLReduces4 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractOpenCLReduces5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
1d2c8b188dd019806b97e68a496a0bf8
  extractOpenCLReduces5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractOpenCLReduces_types2
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
8c6aeb092c52d4ac7c7c28eccee3d0c3
  extractOpenCLReduces6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
b1a2580130c250c886c50c5592784941
  extractOpenCLReduces_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractOpenCLReduces3
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
9ce3457be68ec58740aa8da28f3dac54
  extractOpenCLReduces_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractOpenCLReduces_types2
                   LanguageFortranTools.extractOpenCLReduces4) -}
d52d2e2a4dfb6d52adef9197e1ee0a52
  extractOpenCLReduces_types2 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.extractOpenCLReduces6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
4ddf57e446d8f47e8d5ca35eb2b33baf
  extractOperands ::
    (Data.Typeable.Internal.Typeable p, Data.Data.Data p) =>
    Language.Fortran.Expr p -> [Language.Fortran.Expr p]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   (w :: Data.Typeable.Internal.Typeable p)
                   (w1 :: Data.Data.Data p)
                   (w2 :: Language.Fortran.Expr p) ->
                 LanguageFortranTools.$wextractOperands @ p w1 w2) -}
29cbab7a680a1e1ce0e818f14785e0ac
  extractOperands_$sextractOperands ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
49e11240ac424d2be24fb360fce42874
  extractPrimaryReductionFunction ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (assignee :: Language.Fortran.Expr
                                  LanguageFortranTools.Anno)
                   (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   Language.Fortran.Var ds1 ds2 list
                   -> let {
                        lvl122 :: Language.Fortran.Expr LanguageFortranTools.Anno
                        = LanguageFortranTools.extractPrimaryReductionFunction1 assignee
                      } in
                      letrec {
                        go9 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                 [Language.Fortran.Expr LanguageFortranTools.Anno])]
                               -> GHC.Base.String -> GHC.Base.String
                          {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                        = \ (ds3 :: [(Language.Fortran.VarName LanguageFortranTools.Anno,
                                      [Language.Fortran.Expr LanguageFortranTools.Anno])])
                            (eta :: GHC.Base.String) ->
                          case ds3 of wild1 {
                            [] -> eta
                            : y ys
                            -> go9
                                 ys
                                 (case y of wild2 { (,) var exprList ->
                                  case GHC.List.elem
                                         @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                         LanguageFortranTools.$s$fEqExpr
                                         lvl122
                                         (GHC.Base.map
                                            @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                            @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                            LanguageFortranTools.extractPrimaryReductionFunction1
                                            exprList) of wild3 {
                                    GHC.Types.False -> eta
                                    GHC.Types.True
                                    -> case var of wild4 { Language.Fortran.VarName ds4 str ->
                                       str } } }) }
                      } in
                      go9 list (GHC.Types.[] @ GHC.Types.Char) }) -}
0cc882adb74ed9881aa10b046afd6273
  extractPrimaryReductionFunction1 ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Unfolding: (Data.Generics.Schemes.everywhere
                   LanguageFortranTools.applyGeneratedSrcSpans2
                   @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataExpr) -}
cda64d1992e89c20ebcc7a87e588ea11
  extractPrimaryReductionOp ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Base.Maybe
         (Language.Fortran.BinOp LanguageFortranTools.Anno)
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
bb2418fcdb7a29c9550575429bb29f4d
  extractPriorToFor ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno) ->
                 case codeSeg of wild {
                   DEFAULT
                   -> (Language.Fortran.$fDataFortran1
                         @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                         LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                         LanguageFortranTools.extractPriorToFor2
                         wild)
                        `cast`
                      (Data.Data.N:ID[0]
                           <Language.Fortran.Fortran
                              (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])>_R)
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> LanguageFortranTools.extractPriorToFor1
                   Language.Fortran.FSeq ds ds1 ds2 ds3
                   -> case ds2 of wild1 {
                        DEFAULT
                        -> (Language.Fortran.$fDataFortran1
                              @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                              LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                              LanguageFortranTools.extractPriorToFor2
                              wild)
                             `cast`
                           (Data.Data.N:ID[0]
                                <Language.Fortran.Fortran
                                   (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])>_R)
                        Language.Fortran.For ds4 ds5 ds6 ds7 ds8 ds9 ds10
                        -> LanguageFortranTools.extractPriorToFor1 } }) -}
9dabbe8ee4efd63dfac8b7869bb17ea6
  extractPriorToFor1 ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Strictness: m33,
     Unfolding: (Language.Fortran.NullStmt
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan) -}
39e462d712f060f1acbfebe429e0ff50
  extractPriorToFor2 :: Data.Data.Data b => b -> b
  {- Arity: 1,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ b ($dData :: Data.Data.Data b) ->
                 case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case LanguageFortranTools.extractPriorToFor3 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case (Data.Data.$p1Data @ b $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <b>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ b) of wild1 { Data.Typeable.Internal.TypeRep dt6 dt7 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt3 dt6) of wild2 {
                   GHC.Types.False -> GHC.Base.id @ b
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt5 dt7) of wild4 {
                        GHC.Types.False -> GHC.Base.id @ b
                        GHC.Types.True
                        -> letrec {
                             lvl122 :: forall b1. Data.Data.Data b1 => b1 -> b1
                               {- Arity: 1,
                                  Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)> -}
                             = \ @ b1 ($dData1 :: Data.Data.Data b1) ->
                               case GHC.Fingerprint.fingerprintFingerprints
                                      (GHC.Types.:
                                         @ GHC.Fingerprint.Type.Fingerprint
                                         LanguageFortranTools.$stypeRep#34
                                         kt_fps) of dt8 { GHC.Fingerprint.Type.Fingerprint dt9 dt10 ->
                               case GHC.Fingerprint.fingerprintFingerprints
                                      (GHC.Types.:
                                         @ GHC.Fingerprint.Type.Fingerprint
                                         LanguageFortranTools.$stypeRep#34
                                         kt_fps1) of dt11 { GHC.Fingerprint.Type.Fingerprint dt12 dt13 ->
                               case (Data.Data.$p1Data @ b1 $dData1)
                                      `cast`
                                    (Data.Typeable.Internal.N:Typeable[0] <*>_N <b1>_N)
                                      (GHC.Prim.proxy#
                                         @ *
                                         @ b1) of wild7 { Data.Typeable.Internal.TypeRep dt14 dt15 ds1 ds2 ds3 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.eqWord# dt12 dt14) of wild8 {
                                 GHC.Types.False -> GHC.Base.id @ b1
                                 GHC.Types.True
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqWord# dt13 dt15) of wild9 {
                                      GHC.Types.False -> GHC.Base.id @ b1
                                      GHC.Types.True
                                      -> extractPriorToFor4
                                           `cast`
                                         (UnsafeCo representational (Language.Fortran.Fortran
                                                                       LanguageFortranTools.Anno) b1
                                          ->_R UnsafeCo representational (Language.Fortran.Fortran
                                                                            LanguageFortranTools.Anno) b1) } } } } }
                             extractPriorToFor4 :: Language.Fortran.Fortran
                                                     LanguageFortranTools.Anno
                                                   -> Language.Fortran.Fortran
                                                        LanguageFortranTools.Anno
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (codeSeg :: Language.Fortran.Fortran
                                               LanguageFortranTools.Anno) ->
                               case codeSeg of wild {
                                 DEFAULT
                                 -> (Language.Fortran.$fDataFortran1
                                       @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                       LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                                       lvl122
                                       wild)
                                      `cast`
                                    (Data.Data.N:ID[0]
                                         <Language.Fortran.Fortran
                                            (Data.Map.Base.Map
                                               GHC.Base.String [GHC.Base.String])>_R)
                                 Language.Fortran.For ds ds1 ds2 ds3 ds4 ds8 ds9
                                 -> LanguageFortranTools.extractPriorToFor1
                                 Language.Fortran.FSeq ds ds1 ds2 ds3
                                 -> case ds2 of wild7 {
                                      DEFAULT
                                      -> (Language.Fortran.$fDataFortran1
                                            @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                            LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                                            lvl122
                                            wild)
                                           `cast`
                                         (Data.Data.N:ID[0]
                                              <Language.Fortran.Fortran
                                                 (Data.Map.Base.Map
                                                    GHC.Base.String [GHC.Base.String])>_R)
                                      Language.Fortran.For ds4 ds8 ds9 ds10 ds11 ds12 ds13
                                      -> LanguageFortranTools.extractPriorToFor1 } }
                           } in
                           extractPriorToFor4
                             `cast`
                           (UnsafeCo representational (Language.Fortran.Fortran
                                                         LanguageFortranTools.Anno) b
                            ->_R UnsafeCo representational (Language.Fortran.Fortran
                                                              LanguageFortranTools.Anno) b) } } } } } } }) -}
6cbad1857209c9f2881c36ec6ecc3dff
  extractPriorToFor3 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.extractAllVarNames3) -}
a1a04805dacf1581947cd1681b1ca40b
  extractReductionVarNames ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.OpenCLReduce ds1 ds2 ds3 ds4 ds5 ds6 redVars ds7
                   -> GHC.Base.build
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        (\ @ b1
                           (c :: Language.Fortran.VarName LanguageFortranTools.Anno
                                 -> b1 -> b1)[OneShot]
                           (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                              Language.Fortran.Expr LanguageFortranTools.Anno)
                           @ b1
                           (GHC.Base.mapFB
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                              @ b1
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                                 Language.Fortran.Expr LanguageFortranTools.Anno)
                              c
                              (Data.Tuple.fst
                                 @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                 @ (Language.Fortran.Expr LanguageFortranTools.Anno)))
                           n1
                           redVars) }) -}
c1c69f7b93f2c215f1547082497f1513
  extractUsedVarName ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.Var ds1 ds2 list
                   -> GHC.Base.build
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                        (\ @ b1
                           (c :: Language.Fortran.VarName LanguageFortranTools.Anno
                                 -> b1 -> b1)[OneShot]
                           (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                              [Language.Fortran.Expr LanguageFortranTools.Anno])
                           @ b1
                           (GHC.Base.mapFB
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                              @ b1
                              @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                                 [Language.Fortran.Expr LanguageFortranTools.Anno])
                              c
                              LanguageFortranTools.extractUsedVarName1)
                           n1
                           list) }) -}
7c7f7efab2cb2f4945209b69e2c4c7c3
  extractUsedVarName1 ::
    (Language.Fortran.VarName LanguageFortranTools.Anno,
     [Language.Fortran.Expr LanguageFortranTools.Anno])
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.VarName LanguageFortranTools.Anno,
                           [Language.Fortran.Expr LanguageFortranTools.Anno])) ->
                 case ds of wild { (,) varname exprs -> varname }) -}
0c06747830f37e92c31e4dbe6aedfd6f
  extractVarNames ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Fortran.Expr
                            LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.[]
                        @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   Language.Fortran.Var ds1 ds2 lst
                   -> LanguageFortranTools.extractVarNames_go lst }) -}
92ae97226feeff7a387eca445dba5878
  extractVarNames_go ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      [Language.Fortran.Expr LanguageFortranTools.Anno])]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, Strictness: <S,1*U> -}
e5687abd17158fb41c65509413698561
  extractVarNames_loopVars ::
    [(Language.Fortran.VarName LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno,
      Language.Fortran.Expr LanguageFortranTools.Anno)]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.Base.map
                   @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                      Language.Fortran.Expr LanguageFortranTools.Anno,
                      Language.Fortran.Expr LanguageFortranTools.Anno,
                      Language.Fortran.Expr LanguageFortranTools.Anno)
                   @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                   LanguageFortranTools.extractVarNames_loopVars1) -}
66f86861e576ec47d333c0a75128a90d
  extractVarNames_loopVars1 ::
    (Language.Fortran.VarName LanguageFortranTools.Anno,
     Language.Fortran.Expr LanguageFortranTools.Anno,
     Language.Fortran.Expr LanguageFortranTools.Anno,
     Language.Fortran.Expr LanguageFortranTools.Anno)
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U(U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.VarName LanguageFortranTools.Anno,
                           Language.Fortran.Expr LanguageFortranTools.Anno,
                           Language.Fortran.Expr LanguageFortranTools.Anno,
                           Language.Fortran.Expr LanguageFortranTools.Anno)) ->
                 case ds of wild { (,,,) x ds1 ds2 ds3 -> x }) -}
e8b676942df107f42b46480250f50c8e
  findDeclLine :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case Data.OldList.isInfixOf
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        LanguageFortranTools.findDeclLine1
                        line of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case LanguageFortranTools.$wgo1 line of ww {
                        DEFAULT -> GHC.Types.True '!'# -> GHC.Types.False } }) -}
404bdeef0a0e53d810d6beadb7857637
  findDeclLine1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "::"#) -}
a03ae6ecbf4e0f270670b112d35e109c
  findDeclLineVars :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case Data.OldList.isInfixOf
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        LanguageFortranTools.findDeclLine1
                        line of wild {
                   GHC.Types.False -> GHC.Types.[] @ GHC.Base.String
                   GHC.Types.True
                   -> case LanguageFortranTools.$wgo2 line of ww {
                        DEFAULT
                        -> case LanguageFortranTools.splitDelim
                                  LanguageFortranTools.findDeclLineVars6
                                  line of wild1 {
                             [] -> case GHC.List.badHead ret_ty [GHC.Base.String] of {}
                             : x ds1
                             -> case LanguageFortranTools.splitDelim
                                       LanguageFortranTools.findDeclLine1
                                       (GHC.List.filter
                                          @ GHC.Types.Char
                                          LanguageFortranTools.findDeclLineVars5
                                          x) of wild2 {
                                  []
                                  -> case LanguageFortranTools.findDeclLineVars4
                                     ret_ty [GHC.Base.String]
                                     of {}
                                  : lhs ds
                                  -> case ds of wild3 {
                                       []
                                       -> case LanguageFortranTools.findDeclLineVars4
                                          ret_ty [GHC.Base.String]
                                          of {}
                                       : rhs ds2
                                       -> case ds2 of wild4 {
                                            []
                                            -> GHC.Base.map
                                                 @ [GHC.Types.Char]
                                                 @ [GHC.Types.Char]
                                                 LanguageFortranTools.findDeclLineVars2
                                                 (LanguageFortranTools.splitDelim
                                                    LanguageFortranTools.findDeclLineVars1
                                                    rhs)
                                            : ipv ipv1
                                            -> case LanguageFortranTools.findDeclLineVars4
                                               ret_ty [GHC.Base.String]
                                               of {} } } } }
                        '!'# -> GHC.Types.[] @ GHC.Base.String } }) -}
eb8a4ad3237a47b4333328de361665b0
  findDeclLineVars1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
743b8c02c06a8bdac7be54a95d5c999d
  findDeclLineVars2 :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Base.String) ->
                 case LanguageFortranTools.splitDelim
                        LanguageFortranTools.findDeclLineVars3
                        x of wild {
                   [] -> GHC.List.badHead @ GHC.Base.String : x1 ds1 -> x1 }) -}
0cd010202ed560c25a1d1baea7131382
  findDeclLineVars3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "="#) -}
065a90c5f43b10f089a535cd984db131
  findDeclLineVars4 :: (GHC.Base.String, GHC.Base.String)
  {- Strictness: x -}
115a1c99a50bee01a4d8262a2cd65d9e
  findDeclLineVars5 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.True ' '# -> GHC.Types.False } }) -}
c26d39453559be6893766ffe482c3c9e
  findDeclLineVars6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "!"#) -}
1a1fe3b617c314f3472027164db13694
  generateAdditionExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateAdditionExpr1
                   expr1
                   expr2) -}
fe6cbeb4cd4fbb76f5e674fa68dc0ccd
  generateAdditionExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Language.Fortran.Plus
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
4809467470552b292769f8fdd595513a
  generateAndExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateAndExpr1
                   expr1
                   expr2) -}
1799b2a4ddba48d90621e3b8dd72e86e
  generateAndExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Language.Fortran.And
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
ec2e058c9a61c2a070809e5c65a87f61
  generateAndExprFromList ::
    [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (list :: [Language.Fortran.Expr
                               LanguageFortranTools.Anno]) ->
                 case list of wild {
                   []
                   -> GHC.List.foldl2
                        @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                   : x xs
                   -> LanguageFortranTools.generateAndExprFromList_go xs x }) -}
64d06a7e8294d09402b716635e20f4ae
  generateAndExprFromList_go ::
    [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
11ed22caf0a9996357d1cb6d5af1e578
  generateArrayVar ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> [Language.Fortran.Expr LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (varname :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (exprs :: [Language.Fortran.Expr LanguageFortranTools.Anno]) ->
                 Language.Fortran.Var
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Types.:
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                         [Language.Fortran.Expr LanguageFortranTools.Anno])
                      (varname, exprs)
                      (GHC.Types.[]
                         @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                            [Language.Fortran.Expr LanguageFortranTools.Anno])))) -}
baf053e0f63bff8c8b8bcc6c48d141a9
  generateAssgCode ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Assg
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   expr1
                   expr2) -}
24a25c778d2b1977fea1f354cc126b8f
  generateDivisionExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateDivisionExpr1
                   expr1
                   expr2) -}
c4a368c61ec4a4d89b319fc54ec83fe9
  generateDivisionExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Language.Fortran.Div
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
9cdd15cd307dad9af29d05d8fff8b71d
  generateESeq ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.VarName
                             LanguageFortranTools.Anno]) ->
                 case ds of wild {
                   [] -> LanguageFortranTools.generateESeq1
                   : var ds1
                   -> case ds1 of wild1 {
                        [] -> LanguageFortranTools.generateVar var
                        : ipv ipv1
                        -> Language.Fortran.ESeq
                             @ LanguageFortranTools.Anno
                             (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                             LanguageFortranTools.nullSrcSpan
                             (LanguageFortranTools.generateESeq_$sgenerateESeq ipv ipv1)
                             (LanguageFortranTools.generateVar var) } }) -}
da61b46b05a7351b4f1b73c75bb3d3f3
  generateESeq1 :: Language.Fortran.Expr LanguageFortranTools.Anno
  {- Strictness: x -}
ae77a2a5e4fec78e1a16f44678407ae5
  generateESeq_$sgenerateESeq ::
    Language.Fortran.VarName
      (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]])
    -> [Language.Fortran.VarName
          (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]])]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U> -}
1e00a8acec4e54a010d5c4d6f04bac61
  generateFSeq ::
    [Language.Fortran.Fortran LanguageFortranTools.Anno]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.Fortran
                             LanguageFortranTools.Anno]) ->
                 case ds of wild {
                   [] -> LanguageFortranTools.extractPriorToFor1
                   : statement ds1
                   -> case ds1 of wild1 {
                        [] -> statement
                        : ipv ipv1
                        -> Language.Fortran.FSeq
                             @ LanguageFortranTools.Anno
                             (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                             LanguageFortranTools.nullSrcSpan
                             statement
                             (LanguageFortranTools.generateFSeq_$sgenerateFSeq ipv ipv1) } }) -}
9fefe703c1b97bbc243a76a4d00d4137
  generateFSeq_$sgenerateFSeq ::
    Language.Fortran.Fortran
      (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]])
    -> [Language.Fortran.Fortran
          (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]])]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U> -}
25a278360ce029023f4bffe6692b407d
  generateFloatConstant ::
    GHC.Types.Float -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,1*U(U)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (value :: GHC.Types.Float) ->
                 Language.Fortran.Con
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Float.$fShowFloat_$cshow value)) -}
97983c6db70187f347b69b240a50a2ee
  generateIf ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m5,
     Unfolding: InlineRule (2, True, False)
                (\ (expr :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (fortran :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 Language.Fortran.If
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   expr
                   fortran
                   (GHC.Types.[]
                      @ (Language.Fortran.Expr LanguageFortranTools.Anno,
                         Language.Fortran.Fortran LanguageFortranTools.Anno))
                   (GHC.Base.Nothing
                      @ (Language.Fortran.Fortran LanguageFortranTools.Anno))) -}
15603276f1aca276b29ee11bb7132c17
  generateIntConstant ::
    GHC.Types.Int -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,1*U(U)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (value :: GHC.Types.Int) ->
                 Language.Fortran.Con
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Show.$fShowInt_$cshow value)) -}
12e687e45edf5afbef215d935dba4104
  generateLTExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateLTExpr1
                   expr1
                   expr2) -}
c2f3602f588ffdd3a97addd6dceb9e40
  generateLTExpr1 :: Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m11,
     Unfolding: (Language.Fortran.RelLT
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
a2e3d57ac97eb4661f84c829507ede93
  generateProductExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateProductExpr1
                   expr1
                   expr2) -}
a79c0a2c5f9fddef631156750e436e3f
  generateProductExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Language.Fortran.Mul
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
e283ce1fd9d05cd994044befc212af2f
  generateSrcSpan ::
    GHC.Base.String
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2,
     Strictness: <S,1*U><S(SS),1*U(1*U(A,U,U),1*U(A,U,U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: Language.Fortran.SrcSpan) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww2 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                 case w of wild {
                   []
                   -> (Language.Fortran.SrcLoc
                         LanguageFortranTools.nullSrcLoc2
                         ww5
                         ww6,
                       Language.Fortran.SrcLoc LanguageFortranTools.nullSrcLoc2 ww9 ww10)
                   : ipv ipv1
                   -> (Language.Fortran.SrcLoc wild ww5 ww6,
                       Language.Fortran.SrcLoc wild ww9 ww10) } } } }) -}
806c5ded3a006ac5c2d14a1a94cf3eaf
  generateSrcSpanMerge ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U,A)><L,1*U(A,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (src1 :: Language.Fortran.SrcSpan)
                   (src2 :: Language.Fortran.SrcSpan) ->
                 (case src1 of wild { (,) src1_s src1_e -> src1_s },
                  case src2 of wild { (,) src2_s src2_e -> src2_e })) -}
6075eabbf6676385f0a6855cf8e61901
  generateSubtractionExpr ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U><L,U>m6,
     Unfolding: InlineRule (2, True, False)
                (\ (expr1 :: Language.Fortran.Expr LanguageFortranTools.Anno)
                   (expr2 :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 Language.Fortran.Bin
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   LanguageFortranTools.generateSubtractionExpr1
                   expr1
                   expr2) -}
e7c4989cdd2079b048a210117790abe2
  generateSubtractionExpr1 ::
    Language.Fortran.BinOp LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Language.Fortran.Minus
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
9d0fea224f278c04fc62fa0745c0e6f6
  generateVar ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <L,U>m5,
     Unfolding: InlineRule (1, True, False)
                (\ (varname :: Language.Fortran.VarName
                                 LanguageFortranTools.Anno) ->
                 Language.Fortran.Var
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                   LanguageFortranTools.nullSrcSpan
                   (GHC.Types.:
                      @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                         [Language.Fortran.Expr LanguageFortranTools.Anno])
                      (varname,
                       GHC.Types.[] @ (Language.Fortran.Expr LanguageFortranTools.Anno))
                      (GHC.Types.[]
                         @ (Language.Fortran.VarName LanguageFortranTools.Anno,
                            [Language.Fortran.Expr LanguageFortranTools.Anno])))) -}
e6fd096b3bb3185df19347177d4025a7
  getEarliestSrcLoc ::
    [Language.Fortran.SrcLoc] -> GHC.Base.Maybe Language.Fortran.SrcLoc
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.SrcLoc]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Language.Fortran.SrcLoc
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Language.Fortran.SrcLoc
                        (case GHC.List.$w!!
                                @ Language.Fortran.SrcLoc
                                wild
                                0# of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                         case ipv of wild1 { Language.Fortran.SrcLoc file_before line_before column_before ->
                         case line_before of wild2 { GHC.Types.I# x ->
                         case ww2 of wild3 { GHC.Types.I# y ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# x y) of wild4 {
                           GHC.Types.False
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# x y) of wild5 {
                                GHC.Types.False
                                -> case LanguageFortranTools.getEarliestSrcLoc_$s$wgo1
                                          ww3
                                          y
                                          ww1
                                          ipv1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                                   Language.Fortran.SrcLoc ww5 ww6 ww7 }
                                GHC.Types.True
                                -> case column_before of wild6 { GHC.Types.I# x1 ->
                                   case ww3 of wild7 { GHC.Types.I# y1 ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x1 y1) of wild8 {
                                     GHC.Types.False
                                     -> case LanguageFortranTools.getEarliestSrcLoc_$s$wgo
                                               y1
                                               y
                                               ww1
                                               ipv1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                                        Language.Fortran.SrcLoc ww5 ww6 ww7 }
                                     GHC.Types.True
                                     -> case LanguageFortranTools.getEarliestSrcLoc_$s$wgo
                                               x1
                                               x
                                               file_before
                                               ipv1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                                        Language.Fortran.SrcLoc ww5 ww6 ww7 } } } } }
                           GHC.Types.True
                           -> case LanguageFortranTools.getEarliestSrcLoc_$s$wgo1
                                     column_before
                                     x
                                     file_before
                                     ipv1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                              Language.Fortran.SrcLoc ww5 ww6 ww7 } } } } } }) }) -}
660277717077991e7b21aace1f2f796d
  getEarliestSrcLoc_$s$wgo ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> [Language.Fortran.SrcLoc]
    -> (# GHC.Base.String, GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U> -}
4772561008115361b9725cda3e5851bc
  getEarliestSrcLoc_$s$wgo1 ::
    GHC.Types.Int
    -> GHC.Prim.Int#
    -> [GHC.Types.Char]
    -> [Language.Fortran.SrcLoc]
    -> (# GHC.Base.String, GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U(U)><L,U><L,U><S,1*U> -}
98f9b1b0a30d6978a0e6d8f7d74a2ecb
  getEarliestSrcSpan ::
    [Language.Fortran.SrcSpan]
    -> GHC.Base.Maybe Language.Fortran.SrcSpan
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.SrcSpan]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Language.Fortran.SrcSpan
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Language.Fortran.SrcSpan
                        (case GHC.List.$w!!
                                @ Language.Fortran.SrcSpan
                                wild
                                0# of ww { (,) ww1 ww2 ->
                         case LanguageFortranTools.getEarliestSrcSpan_$s$wgo
                                ww2
                                ww1
                                ipv
                                ipv1 of ww3 { (#,#) ww4 ww5 ->
                         (ww4, ww5) } }) }) -}
e9306fb69ffefb9d7200569ef7ead013
  getEarliestSrcSpan_$s$wgo ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> (# Language.Fortran.SrcLoc, Language.Fortran.SrcLoc #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U(U),U(U))><L,U><L,U> -}
30a19f11b480a46d089b7eb958c51f6d
  getIterLoopVars ::
    Language.Fortran.Fortran t -> [Language.Fortran.VarName t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: Language.Fortran.Fortran t) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName t)
                   Language.Fortran.OpenCLMap ds1 ds2 vrs vws lvars ilvars stmt1
                   -> ilvars
                   Language.Fortran.OpenCLReduce ds1 ds2 vrs vws lvars ilvars rvarexprs stmt1
                   -> ilvars }) -}
da55b8d6804e41a444f3277ca7efba3a
  getLatestSrcSpan ::
    [Language.Fortran.SrcSpan]
    -> GHC.Base.Maybe Language.Fortran.SrcSpan
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.SrcSpan]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ Language.Fortran.SrcSpan
                   : ipv ipv1
                   -> GHC.Base.Just
                        @ Language.Fortran.SrcSpan
                        (case GHC.List.$w!!
                                @ Language.Fortran.SrcSpan
                                wild
                                0# of ww { (,) ww1 ww2 ->
                         case LanguageFortranTools.getLatestSrcSpan_$s$wgo
                                ww2
                                ww1
                                ipv
                                ipv1 of ww3 { (#,#) ww4 ww5 ->
                         (ww4, ww5) } }) }) -}
1809260334fd2f1dfece0f2fd8c8115e
  getLatestSrcSpan_$s$wgo ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> [(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)]
    -> (# Language.Fortran.SrcLoc, Language.Fortran.SrcLoc #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U(U),U(U))><L,U><L,U> -}
008b4a920ef497f7b1207632cbc03f3c
  getLoopVar ::
    Language.Fortran.Fortran p
    -> GHC.Base.Maybe (Language.Fortran.VarName p)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p (ds :: Language.Fortran.Fortran p) ->
                 case ds of wild {
                   DEFAULT -> GHC.Base.Nothing @ (Language.Fortran.VarName p)
                   Language.Fortran.For ds1 ds2 var ds3 ds4 ds5 ds6
                   -> GHC.Base.Just @ (Language.Fortran.VarName p) var }) -}
1f9f90cde5eb615120c1a938b5f46b1b
  getLoopVars ::
    Language.Fortran.Fortran t -> [Language.Fortran.VarName t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ t (ds :: Language.Fortran.Fortran t) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName t)
                   Language.Fortran.OpenCLMap ds1 ds2 vrs vws lvars ilvars stmt1
                   -> GHC.Base.map
                        @ (Language.Fortran.VarName t, Language.Fortran.Expr t,
                           Language.Fortran.Expr t, Language.Fortran.Expr t)
                        @ (Language.Fortran.VarName t)
                        (LanguageFortranTools.getLoopVars1 @ t)
                        lvars
                   Language.Fortran.OpenCLReduce ds1 ds2 vrs vws lvars ilvars rvarexprs stmt1
                   -> GHC.Base.map
                        @ (Language.Fortran.VarName t, Language.Fortran.Expr t,
                           Language.Fortran.Expr t, Language.Fortran.Expr t)
                        @ (Language.Fortran.VarName t)
                        (LanguageFortranTools.getLoopVars1 @ t)
                        lvars }) -}
7b73137087caf5b926bd218e76418438
  getLoopVars1 ::
    (Language.Fortran.VarName t, Language.Fortran.Expr t,
     Language.Fortran.Expr t, Language.Fortran.Expr t)
    -> Language.Fortran.VarName t
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U(U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ t
                   (ds :: (Language.Fortran.VarName t, Language.Fortran.Expr t,
                           Language.Fortran.Expr t, Language.Fortran.Expr t)) ->
                 case ds of wild { (,,,) v ds1 ds2 ds3 -> v }) -}
bdf521d0abb825e5f9aeb0c80ed064a1
  getReadArgs ::
    (Data.Typeable.Internal.Typeable t, Data.Data.Data a) =>
    a -> [Language.Fortran.VarName t]
  {- Arity: 3,
     Strictness: <L,1*C1(U)><S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: (\ @ t
                   @ a
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   ($dData :: Data.Data.Data a)
                   (ast :: a) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case LanguageFortranTools.getReadArgs1 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ($dTypeable
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <t>_N)
                                 (GHC.Prim.proxy# @ * @ t))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName t]
                   (GHC.Base.++ @ (Language.Fortran.VarName t))
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) (eta :: a1)[OneShot] ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                    case ds of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt dt2) of wild2 {
                      GHC.Types.False -> GHC.Types.[] @ (Language.Fortran.VarName t)
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                           GHC.Types.False -> GHC.Types.[] @ (Language.Fortran.VarName t)
                           GHC.Types.True
                           -> LanguageFortranTools.getReadArgs'
                                @ t
                                eta
                                  `cast`
                                (UnsafeCo representational a1 (Language.Fortran.Fortran
                                                                 t)) } } } })
                   @ a
                   $dData
                   ast) -}
7766ce1dcc7aa6b35abf547eab16c828
  getReadArgs' ::
    Language.Fortran.Fortran t -> [Language.Fortran.VarName t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (codeSeg :: Language.Fortran.Fortran t) ->
                 case codeSeg of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName t)
                   Language.Fortran.OpenCLMap ds ds1 vrs vws ds2 ds3 ds4 -> vrs
                   Language.Fortran.OpenCLReduce ds ds1 vrs vws ds2 ds3 ds4 ds5
                   -> vrs }) -}
bd505a99178f74cba428fd775b271d31
  getReadArgs1 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Fortran.$tcFortran
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
15196d5082254ff05b5a3fe9fb1bdaf1
  getSrcSpanNonIntersection ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> (Language.Fortran.SrcSpan, Language.Fortran.SrcSpan)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,1*U)><L,U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (src1 :: Language.Fortran.SrcSpan)
                   (src2 :: Language.Fortran.SrcSpan) ->
                 ((case src1 of wild { (,) src1_s src1_e -> src1_s },
                   case src2 of wild { (,) src2_s src2_e -> src2_s }),
                  (case src2 of wild { (,) src2_s src2_e -> src2_e },
                   case src1 of wild { (,) src1_s src1_e -> src1_e }))) -}
7bf4972c728c27b1ec43d53672dacd81
  getSubNames ::
    Language.Fortran.SubName LanguageFortranTools.Anno
    -> [Language.Fortran.SubName LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (sub :: Language.Fortran.SubName LanguageFortranTools.Anno) ->
                 case sub of wild {
                   Language.Fortran.SubName ds ds1
                   -> GHC.Types.:
                        @ (Language.Fortran.SubName LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[]
                           @ (Language.Fortran.SubName LanguageFortranTools.Anno))
                   Language.Fortran.NullSubName ipv
                   -> GHC.Types.[]
                        @ (Language.Fortran.SubName LanguageFortranTools.Anno) }) -}
08b9880150cff0450dd83e0f310a818e
  getUnitName ::
    Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (progunit :: Language.Fortran.ProgUnit
                                  LanguageFortranTools.Anno) ->
                 LanguageFortranTools.getUnitName_go
                   (Language.Fortran.$fDataProgUnit_$cgmapQ
                      @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                      LanguageFortranTools.$s$fDataExpr_$s$fDataMap
                      @ [GHC.Types.Char]
                      LanguageFortranTools.getUnitName1
                      progunit)
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2e5e19497ae501f0f29fd01d246a4bbb
  getUnitName' ::
    Language.Fortran.SubName LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SubName LanguageFortranTools.Anno) ->
                 case ds of wild {
                   Language.Fortran.SubName ds1 str -> str
                   Language.Fortran.NullSubName ipv
                   -> GHC.Types.[] @ GHC.Types.Char }) -}
a251f6a67befc33c9d732e779be1bf04
  getUnitName1 :: Data.Data.Data d => d -> [GHC.Types.Char]
  {- Arity: 2,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U>,
     Unfolding: (\ @ d ($dData :: Data.Data.Data d) (eta :: d) ->
                 case (Data.Data.$p1Data @ d $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <d>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ d) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                 case LanguageFortranTools.getUnitName2 of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt dt2) of wild2 {
                   GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                        GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                        GHC.Types.True
                        -> case eta
                                  `cast`
                                (UnsafeCo representational d (Language.Fortran.SubName
                                                                LanguageFortranTools.Anno)) of wild7 {
                             Language.Fortran.SubName ds str -> str
                             Language.Fortran.NullSubName ipv
                             -> GHC.Types.[] @ GHC.Types.Char } } } } }) -}
bbed222fe61b61a0578f48fceff7fe9b
  getUnitName2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#41 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames3
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
dff2149fa8d63beec540a92867dda0d2
  getUnitName_go ::
    [[GHC.Types.Char]] -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
a038a990529caacbbdbd30d93408e59e
  getUses ::
    Language.Fortran.Uses LanguageFortranTools.Anno
    -> [Language.Fortran.Uses LanguageFortranTools.Anno]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (uses :: Language.Fortran.Uses LanguageFortranTools.Anno) ->
                 case uses of wild {
                   Language.Fortran.Use ds ds1 ds2 ds3
                   -> GHC.Types.:
                        @ (Language.Fortran.Uses LanguageFortranTools.Anno)
                        wild
                        (GHC.Types.[] @ (Language.Fortran.Uses LanguageFortranTools.Anno))
                   Language.Fortran.UseNil ipv
                   -> GHC.Types.[]
                        @ (Language.Fortran.Uses LanguageFortranTools.Anno) }) -}
916280d09000cad2a01ca3637435fe3e
  getWrittenArgs ::
    (Data.Typeable.Internal.Typeable t, Data.Data.Data a) =>
    a -> [Language.Fortran.VarName t]
  {- Arity: 3,
     Strictness: <L,1*C1(U)><S(LLLLLLLLLLC(C(S))LLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: (\ @ t
                   @ a
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   ($dData :: Data.Data.Data a)
                   (ast :: a) ->
                 let {
                   ds :: Data.Typeable.Internal.TypeRep
                   = case LanguageFortranTools.getReadArgs1 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                     let {
                       types :: [Data.Typeable.Internal.TypeRep]
                       = GHC.Base.++
                           @ Data.Typeable.Internal.TypeRep
                           trs
                           (GHC.Types.:
                              @ Data.Typeable.Internal.TypeRep
                              ($dTypeable
                                 `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <t>_N)
                                 (GHC.Prim.proxy# @ * @ t))
                              (GHC.Types.[] @ Data.Typeable.Internal.TypeRep))
                     } in
                     case Data.Typeable.Internal.typeRepFingerprints
                            ks
                            types of kt_fps { DEFAULT ->
                     case GHC.Fingerprint.fingerprintFingerprints
                            (GHC.Types.:
                               @ GHC.Fingerprint.Type.Fingerprint
                               (Data.Typeable.Internal.tyConFingerprint tc)
                               kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                     Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }
                 } in
                 Data.Generics.Schemes.everything
                   @ [Language.Fortran.VarName t]
                   (GHC.Base.++ @ (Language.Fortran.VarName t))
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) (eta :: a1)[OneShot] ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild { Data.Typeable.Internal.TypeRep dt dt1 ds2 ds3 ds4 ->
                    case ds of wild1 { Data.Typeable.Internal.TypeRep dt2 dt3 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt dt2) of wild2 {
                      GHC.Types.False -> GHC.Types.[] @ (Language.Fortran.VarName t)
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt1 dt3) of wild4 {
                           GHC.Types.False -> GHC.Types.[] @ (Language.Fortran.VarName t)
                           GHC.Types.True
                           -> LanguageFortranTools.getWrittenArgs'
                                @ t
                                eta
                                  `cast`
                                (UnsafeCo representational a1 (Language.Fortran.Fortran
                                                                 t)) } } } })
                   @ a
                   $dData
                   ast) -}
20c158aecc2e9594ac297b6c8018906b
  getWrittenArgs' ::
    Language.Fortran.Fortran t -> [Language.Fortran.VarName t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (codeSeg :: Language.Fortran.Fortran t) ->
                 case codeSeg of wild {
                   DEFAULT -> GHC.Types.[] @ (Language.Fortran.VarName t)
                   Language.Fortran.OpenCLMap ds ds1 ds2 vws ds3 ds4 ds5 -> vws
                   Language.Fortran.OpenCLReduce ds ds1 ds2 vws ds3 ds4 ds5 ds6
                   -> vws }) -}
b77d419e6a1626b5df588435a113ff03
  hasOperand ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.hasOperand1
                  `cast`
                (<Language.Fortran.Expr LanguageFortranTools.Anno>_R
                 ->_R <Language.Fortran.Expr LanguageFortranTools.Anno>_R
                 ->_R Data.Monoid.N:All[0]) -}
e575bea6b5079027beccda6b50ef4767
  hasOperand1 ::
    Language.Fortran.Expr LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> Data.Monoid.All
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (container :: Language.Fortran.Expr
                                   LanguageFortranTools.Anno)
                   (contains :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: [Language.Fortran.Expr LanguageFortranTools.Anno]
                   = LanguageFortranTools.extractOperands_$sextractOperands
                       (LanguageFortranTools.extractPrimaryReductionFunction1 container)
                 } in
                 letrec {
                   go9 :: [Language.Fortran.Expr LanguageFortranTools.Anno]
                          -> Data.Monoid.All
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Language.Fortran.Expr LanguageFortranTools.Anno]) ->
                     case ds of wild {
                       [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                       : y ys
                       -> case GHC.List.elem
                                 @ (Language.Fortran.Expr LanguageFortranTools.Anno)
                                 LanguageFortranTools.$s$fEqExpr
                                 y
                                 lvl122 of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                            GHC.Types.True -> go9 ys } }
                 } in
                 go9
                   (LanguageFortranTools.extractOperands_$sextractOperands
                      (LanguageFortranTools.extractPrimaryReductionFunction1
                         contains))) -}
eeaed690fdb27e33ac13747e43306754
  inlineDeclsFromUsedModules ::
    GHC.Types.Bool
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.IO
         ([GHC.Base.String], LanguageFortranTools.ModuleVarsTable)
  {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.inlineDeclsFromUsedModules1
                  `cast`
                (<GHC.Types.Bool>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <([GHC.Base.String], LanguageFortranTools.ModuleVarsTable)>_R)) -}
e58fe1ad5e5aa4eb749a6535b03461bd
  inlineDeclsFromUsedModules1 ::
    GHC.Types.Bool
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Base.String], LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><S,U> -}
433b3397b8109f5e232017f1ad1557f2
  inlineDeclsFromUsedModules_$sinlineDeclsFromUsedModules ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> GHC.Types.Bool
    -> [[GHC.Types.Char]]
    -> [[GHC.Types.Char]]
    -> [[GHC.Types.Char]]
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Base.String], LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 5, Strictness: <S,U><L,U><L,U><L,U><L,U> -}
4df8da79b03d896afa6efcad9a6dee9a
  isDeclOnly :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (module_content_str :: GHC.Base.String) ->
                 case LanguageFortranTools.isDeclOnly_go
                        (Data.OldList.lines module_content_str) of wild {
                   [] -> GHC.Types.True : ds1 ds2 -> GHC.Types.False }) -}
44de30d173695279100ef4befbddaef1
  isDeclOnly_go :: [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
1a5c2267770e39246687f61c15072a6c
  isImplicitNoneDecl :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (line :: [GHC.Types.Char]) ->
                 Data.OldList.isInfixOf
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   LanguageFortranTools.isImplicitNoneDecl1
                   line) -}
3a095d14060889bb97653d51fd63bdfd
  isImplicitNoneDecl1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "implicit none"#) -}
42c97b9ae329e115e673f75e95d1a945
  isRelevantModuleLine :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case Data.OldList.words line of wild {
                   [] -> GHC.Types.False
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        [] -> case GHC.List.badHead ret_ty GHC.Types.Bool of {}
                        : x ds4
                        -> case x of wild2 { GHC.Types.C# x1 ->
                           case x1 of wild3 {
                             DEFAULT
                             -> case GHC.List.elem
                                       @ GHC.Base.String
                                       GHC.Classes.$fEq[]_$s$fEq[]1
                                       wild1
                                       LanguageFortranTools.isRelevantModuleLine4 of wild4 {
                                  GHC.Types.False
                                  -> case GHC.Base.eqString
                                            wild1
                                            LanguageFortranTools.isRelevantModuleLine3 of wild5 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True
                                       -> case GHC.List.elem
                                                 @ GHC.Base.String
                                                 GHC.Classes.$fEq[]_$s$fEq[]1
                                                 (case GHC.List.$wlenAcc
                                                         @ [GHC.Types.Char]
                                                         wild
                                                         0# of ww2 { DEFAULT ->
                                                  case GHC.Prim.tagToEnum#
                                                         @ GHC.Types.Bool
                                                         (GHC.Prim.># ww2 1#) of wild6 {
                                                    GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                                                    GHC.Types.True
                                                    -> GHC.List.$w!! @ GHC.Base.String wild 1# } })
                                                 LanguageFortranTools.isRelevantModuleLine1 of wild6 {
                                            GHC.Types.False -> GHC.Types.True
                                            GHC.Types.True -> GHC.Types.False } }
                                  GHC.Types.True -> GHC.Types.False }
                             '!'# -> GHC.Types.False } } } }) -}
ccb10db92c6c5962e0b467ea8c18190e
  isRelevantModuleLine1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine2
                   (GHC.Types.[] @ GHC.Base.String)) -}
f5feb78b8d74c78995b5e871b2799d5c
  isRelevantModuleLine10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "contains"#) -}
a257b5e3b3c6a9c1f1131a3620385247
  isRelevantModuleLine2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "module"#) -}
cc1c7673a24cee76a37032256dbb21a2
  isRelevantModuleLine3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "end"#) -}
cae27fdd96e829a311bd78ed3b7f01a4
  isRelevantModuleLine4 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine2
                   LanguageFortranTools.isRelevantModuleLine5) -}
9a2ce42c22112cac8b0601ddea647d6d
  isRelevantModuleLine5 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine10
                   LanguageFortranTools.isRelevantModuleLine6) -}
2efa729286de5c2e0b8a55e2daac1dcf
  isRelevantModuleLine6 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine9
                   LanguageFortranTools.isRelevantModuleLine7) -}
e9b7946d0714aab21f480a7f18bbb111
  isRelevantModuleLine7 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   LanguageFortranTools.isRelevantModuleLine8
                   (GHC.Types.[] @ GHC.Base.String)) -}
7195b22517a74036f35561c96097cf05
  isRelevantModuleLine8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "implicit"#) -}
c4513f0329fa1dd4c999b568e355198e
  isRelevantModuleLine9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "use"#) -}
e0059c3cc5c50e90e6f01d60e94af7b3
  isUseDecl :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case Data.OldList.wordsFB
                        @ [[GHC.Types.Char]]
                        LanguageFortranTools.isUseDecl1
                        (GHC.Types.[] @ [GHC.Types.Char])
                        line of wild {
                   [] -> GHC.Types.False
                   : ds1 ds2
                   -> GHC.Base.eqString
                        ds1
                        LanguageFortranTools.isRelevantModuleLine9 }) -}
15a6187ececb9c374cfbabd1c2ddadf4
  isUseDecl1 ::
    [GHC.Types.Char] -> [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (x :: [GHC.Types.Char])
                   (r :: [[GHC.Types.Char]])[OneShot] ->
                 case x of wild {
                   [] -> r : ds1 ds2 -> GHC.Types.: @ [GHC.Types.Char] wild r }) -}
8f3347a5fcc2aec5fa7520695a0bb710
  isVar ::
    Language.Fortran.Expr LanguageFortranTools.Anno -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.Expr LanguageFortranTools.Anno) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Language.Fortran.Var ds1 ds2 ds3 -> GHC.Types.True }) -}
9e9436edc8e867af6607eff111fdf531
  isVarDeclWithMultipleVars :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 let {
                   line_no_comments :: GHC.Base.String
                   = case LanguageFortranTools.splitDelim
                            LanguageFortranTools.findDeclLineVars6
                            line of wild {
                       [] -> GHC.List.badHead @ GHC.Base.String : x ds1 -> x }
                 } in
                 case Data.OldList.isInfixOf
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        LanguageFortranTools.findDeclLine1
                        line_no_comments of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case LanguageFortranTools.$wgo1 line_no_comments of ww {
                        DEFAULT
                        -> let {
                             chunks :: [GHC.Base.String]
                             = LanguageFortranTools.splitDelim
                                 LanguageFortranTools.findDeclLine1
                                 line_no_comments
                           } in
                           case GHC.List.$wlenAcc @ [GHC.Types.Char] chunks 0# of ww2 {
                             DEFAULT -> GHC.Types.False
                             2#
                             -> Data.OldList.isInfixOf
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqChar
                                  LanguageFortranTools.findDeclLineVars1
                                  (GHC.List.$w!! @ GHC.Base.String chunks 1#) }
                        '!'# -> GHC.Types.False } }) -}
89be5712813a36fa304d1b78a451f7c2
  listCartesianProduct :: [a] -> [a] -> [(a, a)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ a (xs :: [a]) (ys :: [a]) ->
                 letrec {
                   go9 :: [a] -> [(a, a)] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (a, a)
                       : y ys1
                       -> let {
                            z :: [(a, a)] = go9 ys1
                          } in
                          letrec {
                            go10 :: [a] -> [(a, a)] {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [a]) ->
                              case ds1 of wild1 {
                                [] -> z : y1 ys2 -> GHC.Types.: @ (a, a) (y, y1) (go10 ys2) }
                          } in
                          go10 ys }
                 } in
                 go9 xs) -}
71a2194601dc95d4bf102289f5a59052
  listConcatUnique :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: [a])
                   (b :: [a]) ->
                 letrec {
                   go9 :: [a] -> [a] -> [a] {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [a]) (eta :: [a]) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case GHC.List.elem @ a $dEq y eta of wild1 {
                            GHC.Types.False
                            -> go9
                                 ys
                                 (GHC.Base.++ @ a eta (GHC.Types.: @ a y (GHC.Types.[] @ a)))
                            GHC.Types.True -> go9 ys eta } }
                 } in
                 go9 a1 b) -}
3e97d98c2988be6965bd41737badf24e
  listCountAppearances ::
    GHC.Classes.Eq a => a -> [a] -> GHC.Types.Int
  {- Arity: 3, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Classes.Eq a) (w1 :: a) (w2 :: [a]) ->
                 case LanguageFortranTools.$wlistCountAppearances
                        @ a
                        w
                        w1
                        w2 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
dec2ba3708a7fbd4b99c64274fa862f8
  listCountAppearances1 :: GHC.Types.Int
  {- Strictness: x -}
194663268e9f508ae95e45a296a560a5
  listCountAppearances_$s$wlistCountAppearances ::
    a -> [a] -> a -> GHC.Classes.Eq a => GHC.Prim.Int#
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S(C(C(S))L),U(C(C1(U)),A)> -}
d2f9bb4e425d32a030e5bcb2e8f86e7a
  listExtractSingleAppearances :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (list :: [a]) ->
                 LanguageFortranTools.listExtractSingleAppearances'
                   @ a
                   $dEq
                   list
                   list) -}
92d87006d8419931de252799aa0fa0d6
  listExtractSingleAppearances' ::
    GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U><S,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: [a])
                   (wholeList :: [a]) ->
                 case ds of wild {
                   [] -> LanguageFortranTools.listExtractSingleAppearances'1 @ a
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> case LanguageFortranTools.$wlistCountAppearances
                                  @ a
                                  $dEq
                                  x
                                  wholeList of ww {
                             DEFAULT -> GHC.Types.[] @ a
                             1# -> GHC.Types.: @ a x (GHC.Types.[] @ a) }
                        : ipv ipv1
                        -> case LanguageFortranTools.$wlistCountAppearances
                                  @ a
                                  $dEq
                                  x
                                  wholeList of ww {
                             DEFAULT
                             -> LanguageFortranTools.listExtractSingleAppearances'_$slistExtractSingleAppearances'
                                  @ a
                                  wholeList
                                  ipv
                                  ipv1
                                  $dEq
                             1#
                             -> GHC.Types.:
                                  @ a
                                  x
                                  (LanguageFortranTools.listExtractSingleAppearances'_$slistExtractSingleAppearances'
                                     @ a
                                     wholeList
                                     ipv
                                     ipv1
                                     $dEq) } } }) -}
570b268c250dc978c1168c7345d945f2
  listExtractSingleAppearances'1 :: [a]
  {- Strictness: x -}
c49ea8bcb52b9f6bc53c0b98e51972a8
  listExtractSingleAppearances'_$slistExtractSingleAppearances' ::
    [a] -> a -> [a] -> GHC.Classes.Eq a => [a]
  {- Arity: 4,
     Strictness: <S,U><L,U><L,U><S(C(C(S))L),U(C(C1(U)),A)> -}
ea4660c5c67b37d7a94bfd3c2305858a
  listIntersection :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) (b :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.List.filterFB
                         @ a
                         @ b1
                         c
                         (\ (x :: a) -> GHC.List.elem @ a $dEq x b))
                      n1
                      a1)) -}
4378f4b10536dcf8634c95685ebad55d
  listRemoveDuplications :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) ->
                 letrec {
                   go9 :: [a] -> [a] -> [a] {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [a]) (eta :: [a]) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case GHC.List.elem @ a $dEq y eta of wild1 {
                            GHC.Types.False
                            -> go9
                                 ys
                                 (GHC.Base.++ @ a eta (GHC.Types.: @ a y (GHC.Types.[] @ a)))
                            GHC.Types.True -> go9 ys eta } }
                 } in
                 go9 a1 (GHC.Types.[] @ a)) -}
b3c64f9bf63909177406c8d10e99ecef
  listSubtract :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) (b :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.List.filterFB
                         @ a
                         @ b1
                         c
                         (\ (x :: a) ->
                          case GHC.List.elem @ a $dEq x b of wild {
                            GHC.Types.False -> GHC.Types.True
                            GHC.Types.True -> GHC.Types.False }))
                      n1
                      a1)) -}
c472655611d4f6598fe30728f5bac490
  listSubtractWithExemption ::
    GHC.Classes.Eq a => [a] -> [a] -> [a] -> [a]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (exempt :: [a])
                   (a1 :: [a])
                   (b :: [a]) ->
                 GHC.List.filter
                   @ a
                   (\ (x :: a) ->
                    case GHC.List.elem @ a $dEq x exempt of wild {
                      GHC.Types.False
                      -> case GHC.List.elem @ a $dEq x b of wild1 {
                           GHC.Types.False -> GHC.Types.True
                           GHC.Types.True -> GHC.Types.False }
                      GHC.Types.True -> GHC.Types.True })
                   a1) -}
9ffb291803aa9d557d9e2af65774e97f
  listUnion :: GHC.Classes.Eq a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C(C1(U)),A)><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (a1 :: [a]) (b :: [a]) ->
                 Data.OldList.nubBy
                   @ a
                   (GHC.Classes.== @ a $dEq)
                   (GHC.Base.augment
                      @ a
                      (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                       GHC.Base.foldr @ a @ b1 c n1 a1)
                      b)) -}
1ea8d8549d90d7d1a29d50f1fe2d3f7e
  lookupValueTable ::
    GHC.Base.String
    -> LanguageFortranTools.ValueTable
    -> GHC.Base.Maybe GHC.Types.Float
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (str :: GHC.Base.String)
                   (table :: LanguageFortranTools.ValueTable) ->
                 case LanguageFortranTools.$slookup1
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                        str
                        table of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Float
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) v t ->
                      GHC.Base.Just @ GHC.Types.Float v } }) -}
d3f937e998fcdf7be3f710f60a86b61c
  lookupValueTable_type ::
    GHC.Base.String
    -> LanguageFortranTools.ValueTable
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ (str :: GHC.Base.String)
                   (table :: LanguageFortranTools.ValueTable) ->
                 LanguageFortranTools.$slookup1
                   @ (GHC.Types.Float,
                      Language.Fortran.BaseType LanguageFortranTools.Anno)
                   str
                   table) -}
511c5fed9c3f6e28bbe3adda4d901781
  maybeBinOp ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> (GHC.Types.Float -> GHC.Types.Float -> GHC.Types.Float)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: (\ (maybeFloat1 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (maybeFloat2 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (op :: GHC.Types.Float -> GHC.Types.Float -> GHC.Types.Float) ->
                 case maybeFloat1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) float1 typ1 ->
                      case maybeFloat2 of wild2 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                        GHC.Base.Just ds1
                        -> case ds1 of wild3 { (,) float2 typ2 ->
                           GHC.Base.Just
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                             (op float1 float2,
                              LanguageFortranTools.resolveType typ1 typ2) } } } }) -}
d5a5b5387bfee9884562ca25ee5a6a9a
  maybeBinOp_float ::
    GHC.Base.Maybe (t4, t3)
    -> GHC.Base.Maybe (t2, t1)
    -> (t4 -> t2 -> t)
    -> GHC.Base.Maybe
         (t, Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: (\ @ t
                   @ t1
                   @ t2
                   @ t3
                   @ t4
                   (maybeFloat1 :: GHC.Base.Maybe (t4, t3))
                   (maybeFloat2 :: GHC.Base.Maybe (t2, t1))
                   (op :: t4 -> t2 -> t) ->
                 case maybeFloat1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (t, Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) float1 typ1 ->
                      case maybeFloat2 of wild2 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (t, Language.Fortran.BaseType LanguageFortranTools.Anno)
                        GHC.Base.Just ds1
                        -> case ds1 of wild3 { (,) float2 typ2 ->
                           GHC.Base.Just
                             @ (t, Language.Fortran.BaseType LanguageFortranTools.Anno)
                             (op float1 float2,
                              LanguageFortranTools.maybeBinOp_float1) } } } }) -}
54cdb402aef5a97c12082a90b8194967
  maybeBinOp_float1 ::
    Language.Fortran.BaseType LanguageFortranTools.Anno
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Language.Fortran.Integer
                   @ LanguageFortranTools.Anno
                   (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])) -}
fd4b0fda44f686b09709dbeb2c4a6a72
  maybeBinOp_integral ::
    GHC.Real.Integral a =>
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> (a -> a -> a)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 4,
     Strictness: <L,U(U,A,A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: (\ @ a
                   ($dIntegral :: GHC.Real.Integral a)
                   (maybeFloat1 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (maybeFloat2 :: GHC.Base.Maybe
                                     (GHC.Types.Float,
                                      Language.Fortran.BaseType LanguageFortranTools.Anno))
                   (op :: a -> a -> a) ->
                 case maybeFloat1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,) float1 typ1 ->
                      case maybeFloat2 of wild2 {
                        GHC.Base.Nothing
                        -> GHC.Base.Nothing
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                        GHC.Base.Just ds1
                        -> case ds1 of wild3 { (,) float2 typ2 ->
                           GHC.Base.Just
                             @ (GHC.Types.Float,
                                Language.Fortran.BaseType LanguageFortranTools.Anno)
                             (case GHC.Integer.Type.doubleFromInteger
                                     (GHC.Real.toInteger
                                        @ a
                                        $dIntegral
                                        (op
                                           (case float1 of ww { GHC.Types.F# ww1 ->
                                            GHC.Float.$w$cround1 @ a $dIntegral ww1 })
                                           (case float2 of ww { GHC.Types.F# ww1 ->
                                            GHC.Float.$w$cround1
                                              @ a
                                              $dIntegral
                                              ww1 }))) of wild4 { DEFAULT ->
                              GHC.Types.F# (GHC.Prim.double2Float# wild4) },
                              LanguageFortranTools.maybeBinOp_float1) } } } }) -}
26a082bda8ff1eab89a3ef1fe315a296
  maybeNegative ::
    GHC.Base.Maybe
      (GHC.Types.Float,
       Language.Fortran.BaseType LanguageFortranTools.Anno)
    -> GHC.Base.Maybe
         (GHC.Types.Float,
          Language.Fortran.BaseType LanguageFortranTools.Anno)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.Maybe
                            (GHC.Types.Float,
                             Language.Fortran.BaseType LanguageFortranTools.Anno)) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 { (,) int typ ->
                      GHC.Base.Just
                        @ (GHC.Types.Float,
                           Language.Fortran.BaseType LanguageFortranTools.Anno)
                        (GHC.Float.negateFloat int, typ) } }) -}
642f3313a270cb356ac4d326f09007df
  normaliseSrcSpan ::
    (Language.Fortran.Span (a LanguageFortranTools.Anno),
     Language.Fortran.Span t,
     Data.Data.Data (a LanguageFortranTools.Anno)) =>
    t -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 5,
     Strictness: <L,1*C1(U(1*U(A,1*U(U),A),A))><L,1*C1(U(1*U(A,1*U(U),A),A))><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ (a :: * -> *)
                   @ t
                   ($dSpan :: Language.Fortran.Span (a LanguageFortranTools.Anno))
                   ($dSpan1 :: Language.Fortran.Span t)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (correctSpanned :: t)
                   (badSpanned :: a LanguageFortranTools.Anno) ->
                 LanguageFortranTools.shiftSrcSpanLineGlobal
                   @ a
                   $dData
                   (case $dSpan1 `cast` (Language.Fortran.N:Span[0] <t>_N)
                           correctSpanned of wild { (,) ds ds1 ->
                    case ds of wild1 { Language.Fortran.SrcLoc ds2 correctLine ds3 ->
                    case correctLine of wild2 { GHC.Types.I# x ->
                    case $dSpan
                           `cast`
                         (Language.Fortran.N:Span[0] <a LanguageFortranTools.Anno>_N)
                           badSpanned of wild3 { (,) ds4 ds5 ->
                    case ds4 of wild4 { Language.Fortran.SrcLoc ds6 badLine ds7 ->
                    case badLine of wild5 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.-# x y) } } } } } })
                   badSpanned) -}
028df3b401a9a7b4be22882b35b63f2d
  normaliseSrcSpan_$sshiftSrcSpanLineGlobal ::
    GHC.Types.Int
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U(U)><L,U>,
     Unfolding: (\ (inc :: GHC.Types.Int)
                   (codeSeg :: Language.Fortran.ProgUnit LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.shiftSrcSpan inc
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a ($dData :: Data.Data.Data a) ->
                    case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                    case LanguageFortranTools.applyGlobalSrcSpan4 of kt_fps1 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                    case LanguageFortranTools.applyGlobalSrcSpan1 of kt_fps2 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                    case (Data.Data.$p1Data @ a $dData)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a) of wild1 { Data.Typeable.Internal.TypeRep dt9 dt10 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt7 dt9) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt8 dt10) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a) } } } } } } } } })
                   @ (Language.Fortran.ProgUnit LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataProgUnit
                   codeSeg) -}
b912003e04465ea84ac683f7cdafb17d
  normaliseSrcSpan_$sshiftSrcSpanLineGlobal1 ::
    GHC.Types.Int
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <L,U(U)><L,U>,
     Unfolding: (\ (inc :: GHC.Types.Int)
                   (codeSeg :: Language.Fortran.Fortran LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.shiftSrcSpan inc
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a ($dData :: Data.Data.Data a) ->
                    case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                    case LanguageFortranTools.applyGlobalSrcSpan4 of kt_fps1 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                    case LanguageFortranTools.applyGlobalSrcSpan1 of kt_fps2 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                    case (Data.Data.$p1Data @ a $dData)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a) of wild1 { Data.Typeable.Internal.TypeRep dt9 dt10 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt7 dt9) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt8 dt10) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a) } } } } } } } } })
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   codeSeg) -}
e3239ac8aba218af15f945a652936cc8
  nullAnno :: LanguageFortranTools.Anno
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String]) -}
ce3c0fbb364fe2546b6c1cb8c644fe79
  nullSrcLoc :: Language.Fortran.SrcLoc
  {- Strictness: m,
     Unfolding: (Language.Fortran.SrcLoc
                   LanguageFortranTools.nullSrcLoc2
                   LanguageFortranTools.nullSrcLoc1
                   LanguageFortranTools.nullSrcLoc1) -}
a2bfa641329e43da1ae763dfc9f7d2d9
  nullSrcLoc1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# -1#) -}
97c95be20a4d2664f7e695223c6a1300
  nullSrcLoc2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "generated"#) -}
088997d0b27116160aebfa68704495fa
  nullSrcSpan :: Language.Fortran.SrcSpan
  {- Strictness: m,
     Unfolding: ((LanguageFortranTools.nullSrcLoc,
                  LanguageFortranTools.nullSrcLoc)) -}
493ee3e4b901cb8b70f3d5cc12b3888f
  oneVarDeclPerVarDeclLine :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (contentLines :: [GHC.Base.String]) ->
                 LanguageFortranTools.oneVarDeclPerVarDeclLine_go
                   contentLines
                   (GHC.Types.[] @ GHC.Base.String)) -}
6ca699a86728f35bd63530d5ea663a50
  oneVarDeclPerVarDeclLine_go ::
    [[GHC.Types.Char]] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
8adfd7d951826e88981b816de97272b1
  orElem :: GHC.Classes.Eq a => a -> [[a]] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U> -}
94304bd749d8576e2241b877c8b68b4d
  outputExprFormatting ::
    Language.Fortran.Expr LanguageFortranTools.Anno -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
7dd6e0a389efe481cc10a3751b3f709f
  outputTab :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "  "#) -}
2e680589aff909c2acbac07d296fd3f8
  parseFile ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Types.IO
         ((Language.Fortran.Program LanguageFortranTools.Anno,
           [GHC.Base.String]),
          (GHC.Base.String, LanguageFortranTools.CodeStash),
          LanguageFortranTools.ModuleVarsTable)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.parseFile1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <((Language.Fortran.Program LanguageFortranTools.Anno,
                                  [GHC.Base.String]),
                                 (GHC.Base.String, LanguageFortranTools.CodeStash),
                                 LanguageFortranTools.ModuleVarsTable)>_R)) -}
d549750a1c19f53d40fa2de46f4d530c
  parseFile1 ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ((Language.Fortran.Program LanguageFortranTools.Anno,
            [GHC.Base.String]),
           (GHC.Base.String, LanguageFortranTools.CodeStash),
           LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: (\ (cppDArgs :: [GHC.Base.String])
                   (cppXArgs :: [GHC.Base.String])
                   (fixedForm :: GHC.Types.Bool)
                   (filename :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case LanguageFortranTools.$wpreProcessingHelper
                        cppDArgs
                        cppXArgs
                        fixedForm
                        filename
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,) preproc_inp stash moduleVarTable ->
                 (# ipv,
                    ((case GHC.Magic.runRW#
                             @ 'GHC.Types.PtrRepLifted
                             @ (Language.Fortran.Program Language.Fortran.Parser.A0)
                             (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case GHC.Prim.noDuplicate# s of s' { DEFAULT ->
                              case GHC.IO.Handle.Text.hPutStr2
                                     GHC.IO.Handle.FD.stdout
                                     (GHC.CString.unpackAppendCString# "Parsing "# filename)
                                     GHC.Types.True
                                     s' of ds2 { (#,#) ipv2 ipv3 ->
                              (# ipv2,
                                 Language.Fortran.Parser.parse
                                   preproc_inp #) } }) of ds { (#,#) ipv2 ipv3 ->
                      ipv3 },
                      Data.OldList.lines preproc_inp),
                     (filename, stash), moduleVarTable) #) } }) -}
acdccb4a22413580facddc8fd259df33
  preProcessingHelper ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Types.IO
         (GHC.Base.String, LanguageFortranTools.CodeStash,
          LanguageFortranTools.ModuleVarsTable)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,A><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.preProcessingHelper1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <(GHC.Base.String, LanguageFortranTools.CodeStash,
                                 LanguageFortranTools.ModuleVarsTable)>_R)) -}
b87b581ac916d4d1a477fc744036be80
  preProcessingHelper1 ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, LanguageFortranTools.CodeStash,
           LanguageFortranTools.ModuleVarsTable) #)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,A><L,U><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, True)
                (\ (w :: [GHC.Base.String])
                   (w1 :: [GHC.Base.String])
                   (w2 :: GHC.Types.Bool)
                   (w3 :: GHC.Types.Bool)
                   (w4 :: GHC.Base.String)
                   (w5 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 LanguageFortranTools.$wpreProcessingHelper w w1 w2 w4 w5) -}
d79c1498225e9bbd4dbc97023cc29de0
  readUsedModuleDecls ::
    GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Types.IO
         ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.readUsedModuleDecls1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <([GHC.Base.String], (GHC.Base.String, [GHC.Base.String]))>_R)) -}
0ec07b718e3fbee8e634e7fec1026ea2
  readUsedModuleDecls1 ::
    GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Base.String], (GHC.Base.String, [GHC.Base.String])) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U> -}
1f35b6b8e8dd065227c320ebc22801d2
  removeAllAnnotations :: Data.Data.Data a => a -> a
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dData :: Data.Data.Data a) (original :: a) ->
                 Data.Generics.Schemes.everywhere
                   LanguageFortranTools.removeAllAnnotations1
                   @ a
                   $dData
                   original) -}
6e4c11d631c544017e53c035fa904479
  removeAllAnnotations1 :: Data.Data.Data a => a -> a
  {- Arity: 1,
     Strictness: <S(C(S(SLLLL))LLLLLLLLLLLLLL),1*U(1*C1(U(U,U,A,A,A)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a ($dData :: Data.Data.Data a) ->
                 case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case LanguageFortranTools.removeAllAnnotations2 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#34
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case (Data.Data.$p1Data @ a $dData)
                        `cast`
                      (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                        (GHC.Prim.proxy#
                           @ *
                           @ a) of wild1 { Data.Typeable.Internal.TypeRep dt6 dt7 ds5 ds6 ds7 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.eqWord# dt3 dt6) of wild2 {
                   GHC.Types.False -> GHC.Base.id @ a
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqWord# dt5 dt7) of wild4 {
                        GHC.Types.False -> GHC.Base.id @ a
                        GHC.Types.True
                        -> LanguageFortranTools.removeAnnotations
                             `cast`
                           (UnsafeCo representational (Language.Fortran.Fortran
                                                         LanguageFortranTools.Anno) a
                            ->_R UnsafeCo representational (Language.Fortran.Fortran
                                                              LanguageFortranTools.Anno) a) } } } } } } }) -}
4889fcf97f71e33a744d556db7807c13
  removeAllAnnotations2 :: [GHC.Fingerprint.Type.Fingerprint]
  {- Unfolding: (Data.Typeable.Internal.typeRepFingerprints
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.removeAllAnnotations3) -}
5305afa634a109abe5593109fac2c15e
  removeAllAnnotations3 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.removeAllAnnotations4
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
437f7608ccba1999ca989ff8ed74f330
  removeAllAnnotations4 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.removeAllAnnotations_types1 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.removeAllAnnotations_types of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.removeAllAnnotations_types } } } } } }) -}
9648146cfc3ed48030881aa3a3f7020e
  removeAllAnnotations5 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.removeAllAnnotations6
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
30b4176607dbc1ff7467d508390732ec
  removeAllAnnotations6 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.removeAllAnnotations_types1
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
d4f4478616ee5dd7522d9b5a66c113eb
  removeAllAnnotations7 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.extractAllVarNames10 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.extractAllVarNames8
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
6ab9bd863f8cef845f9629159f84ec1f
  removeAllAnnotations_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.removeAllAnnotations_types1
                   LanguageFortranTools.removeAllAnnotations5) -}
374043cef194df7b7adbd709df491e40
  removeAllAnnotations_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.removeAllAnnotations7
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
6e9a96cbeccf0455ccc9273a352536f0
  removeAnnotations ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (original :: Language.Fortran.Fortran
                                  LanguageFortranTools.Anno) ->
                 case original of wild {
                   DEFAULT -> wild
                   Language.Fortran.For anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.For
                        @ LanguageFortranTools.Anno
                        (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLMap anno f2 f3 f4 f5 f6 f7
                   -> Language.Fortran.OpenCLMap
                        @ LanguageFortranTools.Anno
                        (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                   Language.Fortran.OpenCLReduce anno f2 f3 f4 f5 f6 f7 f8
                   -> Language.Fortran.OpenCLReduce
                        @ LanguageFortranTools.Anno
                        (Data.Map.Base.Tip @ GHC.Base.String @ [GHC.Base.String])
                        f2
                        f3
                        f4
                        f5
                        f6
                        f7
                        f8 }) -}
6059b8cf19c92f3070ab070658d8959b
  removeLoopConstructs_recursive ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 1, Strictness: <S,1*U> -}
c127dbc9dbb46e9d16d1c72254041a56
  replaceAllOccurences_varname ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    a LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> a LanguageFortranTools.Anno
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U(U,U)><L,U(U,U)>,
     Unfolding: (\ @ (a :: * -> *)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (codeSeg :: a LanguageFortranTools.Anno)
                   (original :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (replacement :: Language.Fortran.VarName
                                     LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.VarName LanguageFortranTools.Anno
                             -> Language.Fortran.VarName LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceVarname original replacement
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#38
                              kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                    case LanguageFortranTools.extractPriorToFor3 of kt_fps1 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#38
                              kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild1 { Data.Typeable.Internal.TypeRep dt6 dt7 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt3 dt6) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a1
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt5 dt7) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a1
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational (Language.Fortran.VarName
                                                            LanguageFortranTools.Anno) a1
                               ->_R UnsafeCo representational (Language.Fortran.VarName
                                                                 LanguageFortranTools.Anno) a1) } } } } } } })
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   codeSeg) -}
9a1831c74d4c247eb16a05eec1ca6ee1
  replaceAllOccurences_varnamePairs ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><S,1*U><L,1*U>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno)
                   (originals :: [Language.Fortran.VarName LanguageFortranTools.Anno])
                   (replacements :: [Language.Fortran.VarName
                                       LanguageFortranTools.Anno]) ->
                 LanguageFortranTools.replaceAllOccurences_varnamePairs_go
                   originals
                   replacements
                   codeSeg) -}
259a155cf6f5bd21538019de2dbbb755
  replaceAllOccurences_varnamePairs_go ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
8d689aedfccb508ffc88cb290eb0097f
  replaceAllOccurences_varname_$sreplaceAllOccurences_varname ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><L,U(U,U)><L,U(U,U)>,
     Unfolding: (\ (codeSeg :: Language.Fortran.Fortran
                                 LanguageFortranTools.Anno)
                   (original :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (replacement :: Language.Fortran.VarName
                                     LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.VarName LanguageFortranTools.Anno
                             -> Language.Fortran.VarName LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceVarname original replacement
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a ($dData :: Data.Data.Data a) ->
                    case LanguageFortranTools.$stypeRep#37 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                    case Data.Typeable.Internal.typeRepFingerprints
                           ks
                           (GHC.Base.++
                              @ Data.Typeable.Internal.TypeRep
                              trs
                              LanguageFortranTools.extractAllVarNames3) of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              (Data.Typeable.Internal.tyConFingerprint tc)
                              kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                    case (Data.Data.$p1Data @ a $dData)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a) of wild1 { Data.Typeable.Internal.TypeRep dt7 dt8 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt3 dt7) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt4 dt8) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational (Language.Fortran.VarName
                                                            LanguageFortranTools.Anno) a
                               ->_R UnsafeCo representational (Language.Fortran.VarName
                                                                 LanguageFortranTools.Anno) a) } } } } } })
                   @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                   LanguageFortranTools.$s$fDataFortran
                   codeSeg) -}
4c12d76ec2dd7c2dec2ea9f9e624f978
  replaceFortran ::
    Data.Data.Data a =>
    a
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> a
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (progAst :: a)
                   (oldFortran :: Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (newFortran :: Language.Fortran.Fortran
                                    LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.Fortran LanguageFortranTools.Anno
                             -> Language.Fortran.Fortran LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceFortran' oldFortran newFortran
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.$stypeRep#33 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                    case Data.Typeable.Internal.typeRepFingerprints
                           ks
                           (GHC.Base.++
                              @ Data.Typeable.Internal.TypeRep
                              trs
                              LanguageFortranTools.replaceFortran1) of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              (Data.Typeable.Internal.tyConFingerprint tc)
                              kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild1 { Data.Typeable.Internal.TypeRep dt7 dt8 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt3 dt7) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a1
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt4 dt8) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a1
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational (Language.Fortran.Fortran
                                                            LanguageFortranTools.Anno) a1
                               ->_R UnsafeCo representational (Language.Fortran.Fortran
                                                                 LanguageFortranTools.Anno) a1) } } } } } })
                   @ a
                   $dData
                   progAst) -}
9f347e44f3fd31f2dd91e78f7caf30ad
  replaceFortran' ::
    Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
    -> Language.Fortran.Fortran LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Unfolding: (\ (oldFortran :: Language.Fortran.Fortran
                                    LanguageFortranTools.Anno)
                   (newFortran :: Language.Fortran.Fortran LanguageFortranTools.Anno)
                   (currentFortran :: Language.Fortran.Fortran
                                        LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.replaceFortran'1
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2
                           oldFortran)
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2
                           currentFortran) of wild {
                   GHC.Types.False -> currentFortran
                   GHC.Types.True
                   -> LanguageFortranTools.normaliseSrcSpan_$sshiftSrcSpanLineGlobal1
                        (case Language.Fortran.$fSpanFortran_$csrcSpan
                                @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                currentFortran of wild1 { (,) ds ds1 ->
                         case ds of wild2 { Language.Fortran.SrcLoc ds2 correctLine ds3 ->
                         case correctLine of wild3 { GHC.Types.I# x ->
                         case Language.Fortran.$fSpanFortran_$csrcSpan
                                @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                newFortran of wild4 { (,) ds4 ds5 ->
                         case ds4 of wild5 { Language.Fortran.SrcLoc ds6 badLine ds7 ->
                         case badLine of wild6 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.-# x y) } } } } } })
                        newFortran }) -}
88a076a60a29ad9aea11e9005c65950c
  replaceFortran'1 ::
    Language.Fortran.Fortran
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.Fortran
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Unfolding: (Language.Fortran.$fEqBlock_$c==1
                   @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fEqExpr_$s$fEqMap) -}
98765d448e186aca4ed2c4bb7194c83d
  replaceFortran1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.replaceFortran2
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
bf999f894281691ef15df66c01ba5878
  replaceFortran2 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.replaceFortran_types1 of kt_fps1 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                 case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        LanguageFortranTools.replaceFortran_types of kt_fps2 { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           LanguageFortranTools.$stypeRep#3
                           kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                 Data.Typeable.Internal.TypeRep
                   dt7
                   dt8
                   Data.Map.Base.$tcMap
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   LanguageFortranTools.replaceFortran_types } } } } } }) -}
524196010ca5b81ed4da45180bf2c2a1
  replaceFortran3 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.replaceFortran4
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
034af3d77e5d3d9bbfe0247ba09a05c2
  replaceFortran4 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#14 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.replaceFortran_types1
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
3b436c8709453ad5ac84d87811fb750c
  replaceFortran5 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case LanguageFortranTools.$stypeRep#14 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                 let {
                   types :: [Data.Typeable.Internal.TypeRep]
                   = GHC.Base.++
                       @ Data.Typeable.Internal.TypeRep
                       trs
                       LanguageFortranTools.$stypeRep#19
                 } in
                 case Data.Typeable.Internal.typeRepFingerprints
                        ks
                        types of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           (Data.Typeable.Internal.tyConFingerprint tc)
                           kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                 Data.Typeable.Internal.TypeRep dt3 dt4 tc ks types } } }) -}
093a3bd46f8899c0302bd4e3f99875d9
  replaceFortran_types :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Base.++
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.replaceFortran_types1
                   LanguageFortranTools.replaceFortran3) -}
445e4ddb8db81ae9447bb8858dd560aa
  replaceFortran_types1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.replaceFortran5
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
a10f4de19c0ea1322fd2bc5679e63be6
  replaceProgUnit ::
    Data.Data.Data a =>
    a
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> a
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (ast :: a)
                   (oldProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno)
                   (newProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.ProgUnit LanguageFortranTools.Anno
                             -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
                     {- Arity: 1 -}
                   = LanguageFortranTools.replaceProgUnit' oldProgUnit newProgUnit
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.$stypeRep#6 of wild { Data.Typeable.Internal.TypeRep dt dt1 tc ks trs ->
                    case Data.Typeable.Internal.typeRepFingerprints
                           ks
                           (GHC.Base.++
                              @ Data.Typeable.Internal.TypeRep
                              trs
                              LanguageFortranTools.replaceProgUnit1) of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              (Data.Typeable.Internal.tyConFingerprint tc)
                              kt_fps) of dt2 { GHC.Fingerprint.Type.Fingerprint dt3 dt4 ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild1 { Data.Typeable.Internal.TypeRep dt7 dt8 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt3 dt7) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a1
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt4 dt8) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a1
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational (Language.Fortran.ProgUnit
                                                            LanguageFortranTools.Anno) a1
                               ->_R UnsafeCo representational (Language.Fortran.ProgUnit
                                                                 LanguageFortranTools.Anno) a1) } } } } } })
                   @ a
                   $dData
                   ast) -}
1ff89afbf024b4aee94ba929198940b9
  replaceProgUnit' ::
    Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
    -> Language.Fortran.ProgUnit LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Unfolding: (\ (oldProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno)
                   (newProgUnit :: Language.Fortran.ProgUnit
                                     LanguageFortranTools.Anno)
                   (currentProgUnit :: Language.Fortran.ProgUnit
                                         LanguageFortranTools.Anno) ->
                 case LanguageFortranTools.replaceProgUnit'1
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1
                           oldProgUnit)
                        (LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1
                           currentProgUnit) of wild {
                   GHC.Types.False -> currentProgUnit
                   GHC.Types.True
                   -> LanguageFortranTools.normaliseSrcSpan_$sshiftSrcSpanLineGlobal
                        (case Language.Fortran.$fSpanProgUnit_$csrcSpan
                                @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                currentProgUnit of wild1 { (,) ds ds1 ->
                         case ds of wild2 { Language.Fortran.SrcLoc ds2 correctLine ds3 ->
                         case correctLine of wild3 { GHC.Types.I# x ->
                         case Language.Fortran.$fSpanProgUnit_$csrcSpan
                                @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                                newProgUnit of wild4 { (,) ds4 ds5 ->
                         case ds4 of wild5 { Language.Fortran.SrcLoc ds6 badLine ds7 ->
                         case badLine of wild6 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.-# x y) } } } } } })
                        newProgUnit }) -}
ab17e4c35ecb5f08190e1c8967e938e4
  replaceProgUnit'1 ::
    Language.Fortran.ProgUnit
      (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> Language.Fortran.ProgUnit
         (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
    -> GHC.Types.Bool
  {- Unfolding: (Language.Fortran.$fEqProgUnit_$c==
                   @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                   LanguageFortranTools.$s$fEqExpr_$s$fEqMap) -}
9c8f77bc3c246ffc89309e73c472f6e4
  replaceProgUnit1 :: [Data.Typeable.Internal.TypeRep]
  {- Unfolding: (GHC.Types.:
                   @ Data.Typeable.Internal.TypeRep
                   LanguageFortranTools.$stypeRep#29
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)) -}
cfcca07bab9d2d11ecf3d05c387bcdf3
  replaceSrSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><L,A>m,
     Unfolding: InlineRule (2, True, True)
                (\ (input :: Language.Fortran.SrcSpan)
                   (current :: Language.Fortran.SrcSpan) ->
                 input) -}
d387ea85b4014e16bac81543ec3972c0
  replaceVarname ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.VarName LanguageFortranTools.Anno
  {- Arity: 3, Strictness: <S,1*U(U,1*U)><L,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w1 :: Language.Fortran.VarName LanguageFortranTools.Anno)
                   (w2 :: Language.Fortran.VarName LanguageFortranTools.Anno) ->
                 case w of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w2 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 LanguageFortranTools.$wreplaceVarname ww1 ww2 w1 ww4 ww5 } }) -}
c3f42dc699bc0692cc25eb91c747edb0
  replaceVarname1 ::
    Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> Data.Map.Base.Map [GHC.Types.Char] [GHC.Base.String]
    -> GHC.Types.Bool
  {- Unfolding: (Data.Map.Base.$fEqMap_$c==
                   @ [GHC.Types.Char]
                   @ [GHC.Base.String]
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   GHC.Classes.$fEq[]_$s$fEq[]2) -}
ce6294923c0a19a0202e7e6b0faa5824
  resolveType ::
    Language.Fortran.BaseType LanguageFortranTools.Anno
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
    -> Language.Fortran.BaseType LanguageFortranTools.Anno
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (type1 :: Language.Fortran.BaseType LanguageFortranTools.Anno)
                   (type2 :: Language.Fortran.BaseType LanguageFortranTools.Anno) ->
                 case Language.Fortran.$fEqBaseType_$c==
                        @ (Data.Map.Base.Map GHC.Base.String [GHC.Base.String])
                        LanguageFortranTools.$s$fEqExpr_$s$fEqMap
                        type1
                        type2 of wild {
                   GHC.Types.False -> LanguageFortranTools.addToValueTable1
                   GHC.Types.True -> type1 }) -}
e6ab286fec3b727fb10dbb7d2480caa7
  runCpp ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Types.IO GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                LanguageFortranTools.runCpp1
                  `cast`
                (<[GHC.Base.String]>_R
                 ->_R <[GHC.Base.String]>_R
                 ->_R <GHC.Types.Bool>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.String>_R)) -}
295c774a63f797958e5890e88b6224d4
  runCpp1 ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,U>,
     Unfolding: InlineRule (5, True, False)
                (\ (cppDArgs :: [GHC.Base.String])
                   (cppXArgs :: [GHC.Base.String])
                   (fixedForm :: GHC.Types.Bool)
                   (filename :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case LanguageFortranTools.preProcessingHelper1
                        cppDArgs
                        cppXArgs
                        fixedForm
                        GHC.Types.False
                        filename
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,,) preproc_inp ds ds2 ->
                 (# ipv, preproc_inp #) } }) -}
658eade2ae7189fe08df03de658dd3e9
  shiftSrcSpan ::
    GHC.Types.Int
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U)><S(SS),1*U(1*U(U,1*U(U),U),1*U(U,1*U(U),U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Language.Fortran.SrcSpan) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww2 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                 (Language.Fortran.SrcLoc ww4 (GHC.Num.$fNumInt_$c+ ww5 w) ww6,
                  Language.Fortran.SrcLoc
                    ww8
                    (GHC.Num.$fNumInt_$c+ ww9 w)
                    ww10) } } }) -}
f3bb6ddad689a1082cfa412efe7c1f58
  shiftSrcSpanLineGlobal ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    GHC.Types.Int
    -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,U>,
     Unfolding: (\ @ (a :: * -> *)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (inc :: GHC.Types.Int)
                   (codeSeg :: a LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.shiftSrcSpan inc
                 } in
                 Data.Generics.Schemes.everywhere
                   (\ @ a1 ($dData1 :: Data.Data.Data a1) ->
                    case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                    case LanguageFortranTools.applyGlobalSrcSpan4 of kt_fps1 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                    case LanguageFortranTools.applyGlobalSrcSpan1 of kt_fps2 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                    case (Data.Data.$p1Data @ a1 $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <a1>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ a1) of wild1 { Data.Typeable.Internal.TypeRep dt9 dt10 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt7 dt9) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ a1
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt8 dt10) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ a1
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan a1
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan a1) } } } } } } } } })
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   codeSeg) -}
d45ed0f999da8561ce6795b7e0ff509e
  split :: GHC.Types.Char -> [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ (delim :: GHC.Types.Char)
                   (str :: [GHC.Types.Char]) ->
                 let {
                   lvl122 :: GHC.Types.Char -> GHC.Types.Char
                     {- Arity: 1, Strictness: <S(S),1*U(U)>m,
                        Unfolding: InlineRule (1, True, False)
                                   (\ (c :: GHC.Types.Char) ->
                                    case c of wild { GHC.Types.C# x ->
                                    case delim of wild1 { GHC.Types.C# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.eqChar# x y) of wild2 {
                                      GHC.Types.False -> wild
                                      GHC.Types.True -> LanguageFortranTools.split1 } } }) -}
                   = \ (c :: GHC.Types.Char) ->
                     case c of wild { GHC.Types.C# x ->
                     case delim of wild1 { GHC.Types.C# y ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.eqChar# x y) of wild2 {
                       GHC.Types.False -> wild
                       GHC.Types.True -> LanguageFortranTools.split1 } } }
                 } in
                 Data.OldList.wordsFB
                   @ [[GHC.Types.Char]]
                   (\ (x :: [GHC.Types.Char]) (ys :: [[GHC.Types.Char]])[OneShot] ->
                    GHC.Types.:
                      @ [GHC.Types.Char]
                      (GHC.Base.map @ GHC.Types.Char @ GHC.Types.Char lvl122 x)
                      ys)
                   (GHC.Types.[] @ [GHC.Types.Char])
                   (GHC.Base.map
                      @ GHC.Types.Char
                      @ GHC.Types.Char
                      (\ (c :: GHC.Types.Char) ->
                       case delim of wild { GHC.Types.C# x ->
                       case c of wild1 { GHC.Types.C# y ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.eqChar# x y) of wild2 {
                         GHC.Types.False
                         -> case y of wild3 { DEFAULT -> wild1 ' '# -> wild }
                         GHC.Types.True -> LanguageFortranTools.split1 } } })
                      str)) -}
12ee398bbbc11693268280c74b3b7141
  split1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
1eb225fd3c97d20b810aa1b830ee753f
  splitDelim ::
    GHC.Base.String -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (patt :: GHC.Base.String)
                   (line :: GHC.Base.String) ->
                 letrec {
                   $wgo8 :: [GHC.Types.Char]
                            -> [[GHC.Types.Char]]
                            -> [GHC.Types.Char]
                            -> [GHC.Types.Char]
                            -> (# [[GHC.Types.Char]], [GHC.Types.Char], [GHC.Types.Char] #)
                     {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U>, Inline: [0] -}
                   = \ (w :: [GHC.Types.Char])
                       (ww :: [[GHC.Types.Char]])
                       (ww1 :: [GHC.Types.Char])
                       (ww2 :: [GHC.Types.Char]) ->
                     case w of wild {
                       [] -> (# ww, ww1, ww2 #)
                       : y ys
                       -> case Data.OldList.isPrefixOf
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 patt
                                 ww2 of wild1 {
                            GHC.Types.False
                            -> case GHC.List.$wlenAcc
                                      @ GHC.Types.Char
                                      ww2
                                      0# of ww3 { DEFAULT ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># ww3 0#) of wild2 {
                                 GHC.Types.False -> $wgo8 ys ww ww1 ww2
                                 GHC.Types.True
                                 -> let {
                                      ds :: (GHC.Types.Char, [GHC.Types.Char])
                                      = case ww2 of wild3 {
                                          [] -> LanguageFortranTools.splitDelim1
                                          : ch' rest_of_line' -> (ch', rest_of_line') }
                                    } in
                                    $wgo8
                                      ys
                                      ww
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         ww1
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            (case ds of ds1 { (,) ch' rest_of_line' -> ch' })
                                            (GHC.Types.[] @ GHC.Types.Char)))
                                      (case ds of ds1 { (,) ch' rest_of_line' ->
                                       rest_of_line' }) } }
                            GHC.Types.True
                            -> $wgo8
                                 ys
                                 (GHC.Base.++
                                    @ [GHC.Types.Char]
                                    ww
                                    (GHC.Types.:
                                       @ [GHC.Types.Char]
                                       ww1
                                       (GHC.Types.[] @ [GHC.Types.Char])))
                                 (GHC.Types.[] @ GHC.Types.Char)
                                 (case Data.OldList.stripPrefix
                                         @ GHC.Types.Char
                                         GHC.Classes.$fEqChar
                                         patt
                                         ww2 of wild2 {
                                    GHC.Base.Nothing -> ww2 GHC.Base.Just r -> r }) } }
                 } in
                 case $wgo8
                        line
                        (GHC.Types.[] @ [GHC.Types.Char])
                        (GHC.Types.[] @ GHC.Types.Char)
                        line of ww { (#,,#) ww1 ww2 ww3 ->
                 GHC.Base.++
                   @ [GHC.Types.Char]
                   ww1
                   (GHC.Types.:
                      @ [GHC.Types.Char]
                      ww2
                      (GHC.Types.[] @ [GHC.Types.Char])) }) -}
c59fe711c7ddbb6dfb49da65f95f6f93
  splitDelim1 :: (GHC.Types.Char, [GHC.Types.Char])
  {- Strictness: x -}
35775972066b2a59aa3ce146e21d4655
  splitOutVarDecls :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (line :: GHC.Base.String) ->
                 case LanguageFortranTools.splitDelim
                        LanguageFortranTools.findDeclLineVars6
                        line of wild {
                   [] -> case GHC.List.badHead ret_ty [[GHC.Types.Char]] of {}
                   : x ds1
                   -> case LanguageFortranTools.splitDelim
                             LanguageFortranTools.findDeclLine1
                             x of wild1 {
                        []
                        -> case LanguageFortranTools.splitOutVarDecls1
                           ret_ty [[GHC.Types.Char]]
                           of {}
                        : lhs ds
                        -> case ds of wild2 {
                             []
                             -> case LanguageFortranTools.splitOutVarDecls1
                                ret_ty [[GHC.Types.Char]]
                                of {}
                             : rhs ds2
                             -> case ds2 of wild3 {
                                  []
                                  -> GHC.Base.map
                                       @ [GHC.Types.Char]
                                       @ [GHC.Types.Char]
                                       (\ (var :: [GHC.Types.Char]) ->
                                        GHC.Base.++
                                          @ GHC.Types.Char
                                          lhs
                                          (GHC.CString.unpackAppendCString# " :: "# var))
                                       (LanguageFortranTools.splitDelim
                                          LanguageFortranTools.findDeclLineVars1
                                          rhs)
                                  : ipv ipv1
                                  -> case LanguageFortranTools.splitOutVarDecls1
                                     ret_ty [[GHC.Types.Char]]
                                     of {} } } } }) -}
163f0315a6fec0681e2ae663b532f3ad
  splitOutVarDecls1 :: (GHC.Base.String, GHC.Base.String)
  {- Strictness: x -}
a76610d0bc28bdaeb5568518f1316a4d
  srcSpanInSrcSpan ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))><S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcSpan)
                   (w1 :: Language.Fortran.SrcSpan) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                 case ww5 of ww7 { GHC.Types.I# ww8 ->
                 case ww2 of ww9 { Language.Fortran.SrcLoc ww10 ww11 ww12 ->
                 case w1 of ww13 { (,) ww14 ww15 ->
                 case ww14 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                 case ww18 of ww20 { GHC.Types.I# ww21 ->
                 case ww15 of ww22 { Language.Fortran.SrcLoc ww23 ww24 ww25 ->
                 LanguageFortranTools.$wsrcSpanInSrcSpan
                   ww8
                   ww6
                   ww11
                   ww12
                   ww21
                   ww19
                   ww24
                   ww25 } } } } } } } }) -}
3a14ebe60f289e89484117d7ad3df711
  srcSpanInSrcSpanRange ::
    Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.SrcSpan
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,A)><S(LS),1*U(A,1*U)><S(S(LS(S)L)S),1*U(1*U(A,1*U(U),1*U(U)),1*U(A,1*U(U),1*U(U)))>,
     Unfolding: InlineRule (3, True, False)
                (\ (start :: Language.Fortran.SrcSpan)
                   (finish :: Language.Fortran.SrcSpan)
                   (inside :: Language.Fortran.SrcSpan) ->
                 LanguageFortranTools.srcSpanInSrcSpan
                   (Data.Tuple.fst
                      @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      start,
                    Data.Tuple.snd
                      @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      finish)
                   inside) -}
1bf200763aefcb3660c331cf450e8f6e
  srcSpanLineCount :: Language.Fortran.SrcSpan -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LS(S)L)S(LS(S)L)),1*U(1*U(A,1*U(U),A),1*U(A,1*U(U),A))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) ds1 ds2 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc fs ls cs ->
                 case ds2 of wild2 { Language.Fortran.SrcLoc fe le ce ->
                 GHC.Num.$fNumInt_$c- le ls } } }) -}
3f2b4dbb841fadc56c002babbf59eb9b
  standardiseSrcSpan ::
    Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (src :: Language.Fortran.SrcSpan) ->
                 LanguageFortranTools.nullSrcSpan) -}
d7e9d8d1099dd6b6e65bc7b37fae3214
  stretchSrc ::
    GHC.Types.Int
    -> Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(U)><S(LS),1*U(U,1*U(U,1*U(U),U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (inc :: GHC.Types.Int)
                   (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case ds of wild { (,) srcLoc ds1 ->
                 case ds1 of wild1 { Language.Fortran.SrcLoc fe le ce ->
                 (srcLoc,
                  Language.Fortran.SrcLoc
                    fe
                    (GHC.Num.$fNumInt_$c+ le inc)
                    ce) } }) -}
9c3f57ee2109620bdca12d820fe45012
  stretchSrcSpanLine ::
    Data.Data.Data (a LanguageFortranTools.Anno) =>
    GHC.Types.Int
    -> a LanguageFortranTools.Anno -> a LanguageFortranTools.Anno
  {- Arity: 3,
     Strictness: <S(LLLLLLLC(C(S))LLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A)><L,U(U)><L,U>,
     Unfolding: (\ @ (a :: * -> *)
                   ($dData :: Data.Data.Data (a LanguageFortranTools.Anno))
                   (inc :: GHC.Types.Int)
                   (codeSeg :: a LanguageFortranTools.Anno) ->
                 let {
                   lvl122 :: Language.Fortran.SrcSpan -> Language.Fortran.SrcSpan
                     {- Arity: 1 -}
                   = LanguageFortranTools.stretchSrc inc
                 } in
                 Data.Data.gmapT
                   @ (a LanguageFortranTools.Anno)
                   $dData
                   (\ @ b ($dData1 :: Data.Data.Data b) ->
                    case LanguageFortranTools.$stypeRep#59 of kt_fps { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                    case LanguageFortranTools.applyGlobalSrcSpan4 of kt_fps1 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps1) of dt4 { GHC.Fingerprint.Type.Fingerprint dt3 dt5 ->
                    case LanguageFortranTools.applyGlobalSrcSpan1 of kt_fps2 { DEFAULT ->
                    case GHC.Fingerprint.fingerprintFingerprints
                           (GHC.Types.:
                              @ GHC.Fingerprint.Type.Fingerprint
                              LanguageFortranTools.$stypeRep#46
                              kt_fps2) of dt6 { GHC.Fingerprint.Type.Fingerprint dt7 dt8 ->
                    case (Data.Data.$p1Data @ b $dData1)
                           `cast`
                         (Data.Typeable.Internal.N:Typeable[0] <*>_N <b>_N)
                           (GHC.Prim.proxy#
                              @ *
                              @ b) of wild1 { Data.Typeable.Internal.TypeRep dt9 dt10 ds5 ds6 ds7 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.eqWord# dt7 dt9) of wild2 {
                      GHC.Types.False -> GHC.Base.id @ b
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.eqWord# dt8 dt10) of wild4 {
                           GHC.Types.False -> GHC.Base.id @ b
                           GHC.Types.True
                           -> lvl122
                                `cast`
                              (UnsafeCo representational Language.Fortran.SrcSpan b
                               ->_R UnsafeCo representational Language.Fortran.SrcSpan b) } } } } } } } } })
                   codeSeg) -}
985de88de6d4578495764b5eb5c13f4c
  tabInc :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "    "#) -}
b0020daee642adf1e3f4f60a86d24ada
  takeLast :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: [a]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 LanguageFortranTools.$wtakeLast @ a ww1 w1 }) -}
16c22924edb6a445844559694a32f987
  takeLast1 :: [a]
  {- Unfolding: (\ @ a ->
                 GHC.List.reverse1 @ a (GHC.Types.[] @ a) (GHC.Types.[] @ a)) -}
02aebcdcc2fad71827313f895bc3d59d
  trimFront :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (inp :: GHC.Base.String) ->
                 GHC.Base.build
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n1 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      (GHC.List.filterFB
                         @ GHC.Types.Char
                         @ b
                         c
                         LanguageFortranTools.trimFront1)
                      n1
                      inp)) -}
f5b508d7c3546e132cc27acce601861e
  trimFront1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Char) ->
                 case x of wild { GHC.Types.C# x1 ->
                 case x1 of wild1 {
                   DEFAULT -> GHC.Types.True
                   '\t'# -> GHC.Types.False
                   ' '# -> GHC.Types.False } }) -}
261ab0ecda6d75c3794b04e5e247a511
  usesVarName ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U> -}
1a8e06494d870a68ecb9906f49497737
  usesVarName_list ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> Language.Fortran.Expr LanguageFortranTools.Anno
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
7a829054828fe94cdf107f267eb618ae
  varNameListStr ::
    [Language.Fortran.VarName LanguageFortranTools.Anno]
    -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Language.Fortran.VarName
                             LanguageFortranTools.Anno]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : var ds1
                   -> case ds1 of wild1 {
                        [] -> case var of wild2 { Language.Fortran.VarName ds2 str -> str }
                        : ipv ipv1
                        -> case var of wild2 { Language.Fortran.VarName ds2 str ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             str
                             (GHC.CString.unpackAppendCString#
                                ","#
                                (LanguageFortranTools.varNameListStr_$svarNameListStr
                                   ipv
                                   ipv1)) } } }) -}
6e073b8f1f7f625b5d6d56e4df15ef55
  varNameListStr_$svarNameListStr ::
    Language.Fortran.VarName
      (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]])
    -> [Language.Fortran.VarName
          (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]])]
    -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U> -}
95ac032c44f5687eb820ca35335877d7
  varNameStr ::
    Language.Fortran.VarName LanguageFortranTools.Anno
    -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.VarName LanguageFortranTools.Anno) ->
                 case ds of wild { Language.Fortran.VarName ds1 str -> str }) -}
"SC:$wlistCountAppearances0" [0] forall @ a
                                        (sc :: a)
                                        (sc1 :: [a])
                                        (sc2 :: a)
                                        (sc3 :: GHC.Classes.Eq a)
  LanguageFortranTools.$wlistCountAppearances @ a
                                              sc3
                                              sc2
                                              (GHC.Types.: @ a sc sc1)
  = LanguageFortranTools.listCountAppearances_$s$wlistCountAppearances
      @ a
      sc
      sc1
      sc2
      sc3
"SC:generateESeq0" [ALWAYS] forall (sc :: Language.Fortran.VarName
                                            (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]]))
                                   (sc1 :: [Language.Fortran.VarName
                                              (Data.Map.Base.Map
                                                 [GHC.Types.Char] [[GHC.Types.Char]])])
  LanguageFortranTools.generateESeq (GHC.Types.:
                                       @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                       sc
                                       sc1)
  = LanguageFortranTools.generateESeq_$sgenerateESeq sc sc1
"SC:generateFSeq0" [ALWAYS] forall (sc :: Language.Fortran.Fortran
                                            (Data.Map.Base.Map [GHC.Types.Char] [[GHC.Types.Char]]))
                                   (sc1 :: [Language.Fortran.Fortran
                                              (Data.Map.Base.Map
                                                 [GHC.Types.Char] [[GHC.Types.Char]])])
  LanguageFortranTools.generateFSeq (GHC.Types.:
                                       @ (Language.Fortran.Fortran LanguageFortranTools.Anno)
                                       sc
                                       sc1)
  = LanguageFortranTools.generateFSeq_$sgenerateFSeq sc sc1
"SC:inlineDeclsFromUsedModules0" [ALWAYS] forall (sc :: GHC.Prim.State#
                                                          GHC.Prim.RealWorld)
                                                 (sc1 :: GHC.Types.Bool)
                                                 (sc2 :: [[GHC.Types.Char]])
                                                 (sc3 :: [[GHC.Types.Char]])
                                                 (sc4 :: [[GHC.Types.Char]])
  LanguageFortranTools.inlineDeclsFromUsedModules1 GHC.Types.True
                                                   sc4
                                                   sc3
                                                   sc2
                                                   sc1
                                                   sc
  = LanguageFortranTools.inlineDeclsFromUsedModules_$sinlineDeclsFromUsedModules
      sc
      sc1
      sc2
      sc3
      sc4
"SC:listExtractSingleAppearances'0" [ALWAYS] forall @ a
                                                    (sc :: [a])
                                                    (sc1 :: a)
                                                    (sc2 :: [a])
                                                    (sc3 :: GHC.Classes.Eq a)
  LanguageFortranTools.listExtractSingleAppearances' @ a
                                                     sc3
                                                     (GHC.Types.: @ a sc1 sc2)
                                                     sc
  = LanguageFortranTools.listExtractSingleAppearances'_$slistExtractSingleAppearances'
      @ a
      sc
      sc1
      sc2
      sc3
"SC:varNameListStr0" [ALWAYS] forall (sc :: Language.Fortran.VarName
                                              (Data.Map.Base.Map
                                                 [GHC.Types.Char] [[GHC.Types.Char]]))
                                     (sc1 :: [Language.Fortran.VarName
                                                (Data.Map.Base.Map
                                                   [GHC.Types.Char] [[GHC.Types.Char]])])
  LanguageFortranTools.varNameListStr (GHC.Types.:
                                         @ (Language.Fortran.VarName LanguageFortranTools.Anno)
                                         sc
                                         sc1)
  = LanguageFortranTools.varNameListStr_$svarNameListStr sc sc1
"SPEC appendToMap @ String _" [ALWAYS] forall @ a
                                              ($dOrd :: GHC.Classes.Ord GHC.Base.String)
  LanguageFortranTools.appendToMap @ [GHC.Types.Char] @ a $dOrd
  = LanguageFortranTools.appendAnnotation_$sappendToMap @ a
"SPEC applyGeneratedSrcSpans @ Fortran" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                     (Language.Fortran.Fortran
                                                                        LanguageFortranTools.Anno))
  LanguageFortranTools.applyGeneratedSrcSpans @ Language.Fortran.Fortran
                                              $dData
  = LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans2
"SPEC applyGeneratedSrcSpans @ ProgUnit" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                      (Language.Fortran.ProgUnit
                                                                         LanguageFortranTools.Anno))
  LanguageFortranTools.applyGeneratedSrcSpans @ Language.Fortran.ProgUnit
                                              $dData
  = LanguageFortranTools.applyGeneratedSrcSpans_$sapplyGeneratedSrcSpans1
"SPEC combineMaps @ String _" [ALWAYS] forall @ a
                                              ($dOrd :: GHC.Classes.Ord GHC.Base.String)
  LanguageFortranTools.combineMaps @ [GHC.Types.Char] @ a $dOrd
  = LanguageFortranTools.appendAnnotationMap_$scombineMaps @ a
"SPEC extractOperands @ Anno" [ALWAYS] forall ($dData :: Data.Data.Data
                                                           LanguageFortranTools.Anno)
                                              ($dTypeable :: Data.Typeable.Internal.Typeable
                                                               LanguageFortranTools.Anno)
  LanguageFortranTools.extractOperands @ (Data.Map.Base.Map
                                            GHC.Base.String [GHC.Base.String])
                                       $dTypeable
                                       $dData
  = LanguageFortranTools.extractOperands_$sextractOperands
"SPEC replaceAllOccurences_varname @ Fortran" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                           (Language.Fortran.Fortran
                                                                              LanguageFortranTools.Anno))
  LanguageFortranTools.replaceAllOccurences_varname @ Language.Fortran.Fortran
                                                    $dData
  = LanguageFortranTools.replaceAllOccurences_varname_$sreplaceAllOccurences_varname
"SPEC shiftSrcSpanLineGlobal @ Fortran" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                     (Language.Fortran.Fortran
                                                                        LanguageFortranTools.Anno))
  LanguageFortranTools.shiftSrcSpanLineGlobal @ Language.Fortran.Fortran
                                              $dData
  = LanguageFortranTools.normaliseSrcSpan_$sshiftSrcSpanLineGlobal1
"SPEC shiftSrcSpanLineGlobal @ ProgUnit" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                      (Language.Fortran.ProgUnit
                                                                         LanguageFortranTools.Anno))
  LanguageFortranTools.shiftSrcSpanLineGlobal @ Language.Fortran.ProgUnit
                                              $dData
  = LanguageFortranTools.normaliseSrcSpan_$sshiftSrcSpanLineGlobal
"SPEC/LanguageFortranTools $fDataExpr @ (Map String [String])" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                            (Data.Map.Base.Map
                                                                                               GHC.Base.String
                                                                                               [GHC.Base.String]))
  Language.Fortran.$fDataExpr @ (Data.Map.Base.Map
                                   GHC.Base.String [GHC.Base.String])
                              $dData
  = LanguageFortranTools.$s$fDataExpr
"SPEC/LanguageFortranTools $fDataFortran @ (Map String [String])" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                               (Data.Map.Base.Map
                                                                                                  GHC.Base.String
                                                                                                  [GHC.Base.String]))
  Language.Fortran.$fDataFortran @ (Data.Map.Base.Map
                                      GHC.Base.String [GHC.Base.String])
                                 $dData
  = LanguageFortranTools.$s$fDataFortran
"SPEC/LanguageFortranTools $fDataMap @ [Char] @ [String]" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                                      [GHC.Types.Char])
                                                                          ($dData1 :: Data.Data.Data
                                                                                        [GHC.Base.String])
                                                                          ($dData :: Data.Data.Data
                                                                                       [GHC.Types.Char])
  Data.Map.Base.$fDataMap @ [GHC.Types.Char]
                          @ [GHC.Base.String]
                          $dData
                          $dData1
                          $dOrd
  = LanguageFortranTools.$s$fDataExpr_$s$fDataMap
"SPEC/LanguageFortranTools $fDataProgUnit @ (Map String [String])" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                                (Data.Map.Base.Map
                                                                                                   GHC.Base.String
                                                                                                   [GHC.Base.String]))
  Language.Fortran.$fDataProgUnit @ (Data.Map.Base.Map
                                       GHC.Base.String [GHC.Base.String])
                                  $dData
  = LanguageFortranTools.$s$fDataProgUnit
"SPEC/LanguageFortranTools $fData[] @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                           [GHC.Types.Char])
  Data.Data.$fData[] @ [GHC.Types.Char] $dData
  = LanguageFortranTools.$s$fDataExpr_$s$fData[]
"SPEC/LanguageFortranTools $fData[]_$cdataCast2 @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                       [GHC.Types.Char])
  Data.Data.$fData[]_$cdataCast2 @ [GHC.Types.Char] $dData
  = LanguageFortranTools.$s$fDataExpr_$s$fData[]_$cdataCast2
"SPEC/LanguageFortranTools $fData[]_$cdataTypeOf @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                        [GHC.Types.Char])
  Data.Data.$fData[]_$cdataTypeOf @ [GHC.Types.Char] $dData
  = LanguageFortranTools.$s$fDataExpr_$s$fData[]_$cdataTypeOf
"SPEC/LanguageFortranTools $fData[]_$ctoConstr @ [Char]" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                      [GHC.Types.Char])
  Data.Data.$fData[]_$ctoConstr @ [GHC.Types.Char] $dData
  = LanguageFortranTools.$s$fDataExpr_$s$fData[]_$ctoConstr
"SPEC/LanguageFortranTools $fEqExpr @ (Map String [String])" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                                        (Data.Map.Base.Map
                                                                                           GHC.Base.String
                                                                                           [GHC.Base.String]))
  Language.Fortran.$fEqExpr @ (Data.Map.Base.Map
                                 GHC.Base.String [GHC.Base.String])
                            $dEq
  = LanguageFortranTools.$s$fEqExpr
"SPEC/LanguageFortranTools $fEqExpr_$c/= @ (Map String [String])" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                                             (Data.Map.Base.Map
                                                                                                GHC.Base.String
                                                                                                [GHC.Base.String]))
  Language.Fortran.$fEqExpr_$c/= @ (Data.Map.Base.Map
                                      GHC.Base.String [GHC.Base.String])
                                 $dEq
  = LanguageFortranTools.$s$fEqExpr_$s$fEqExpr_$c/=
"SPEC/LanguageFortranTools $fEqMap @ [Char] @ [String]" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                    [GHC.Base.String])
                                                                        ($dEq :: GHC.Classes.Eq
                                                                                   [GHC.Types.Char])
  Data.Map.Base.$fEqMap @ [GHC.Types.Char]
                        @ [GHC.Base.String]
                        $dEq
                        $dEq1
  = LanguageFortranTools.$s$fEqExpr_$s$fEqMap
"SPEC/LanguageFortranTools $fEqMap_$c/= @ [Char] @ [String]" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                         [GHC.Base.String])
                                                                             ($dEq :: GHC.Classes.Eq
                                                                                        [GHC.Types.Char])
  Data.Map.Base.$fEqMap_$c/= @ [GHC.Types.Char]
                             @ [GHC.Base.String]
                             $dEq
                             $dEq1
  = LanguageFortranTools.$s$fEqExpr_$s$fEqMap_$c/=
"SPEC/LanguageFortranTools $fEqVarName @ (Map String [String])" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                                           (Data.Map.Base.Map
                                                                                              GHC.Base.String
                                                                                              [GHC.Base.String]))
  Language.Fortran.$fEqVarName @ (Data.Map.Base.Map
                                    GHC.Base.String [GHC.Base.String])
                               $dEq
  = LanguageFortranTools.$s$fEqVarName
"SPEC/LanguageFortranTools $fShowMap @ [Char] @ [String]" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                                        [GHC.Base.String])
                                                                          ($dShow :: GHC.Show.Show
                                                                                       [GHC.Types.Char])
  Data.Map.Base.$fShowMap @ [GHC.Types.Char]
                          @ [GHC.Base.String]
                          $dShow
                          $dShow1
  = LanguageFortranTools.$s$fShowExpr_$cshow_$s$fShowMap
"SPEC/LanguageFortranTools fromList @ String _" [ALWAYS] forall @ a
                                                                ($dOrd :: GHC.Classes.Ord
                                                                            GHC.Base.String)
  Data.Map.Base.fromList @ [GHC.Types.Char] @ a $dOrd
  = LanguageFortranTools.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

