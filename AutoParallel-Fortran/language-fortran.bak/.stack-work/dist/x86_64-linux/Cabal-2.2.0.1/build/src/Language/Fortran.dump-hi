
==================== FINAL INTERFACE ====================
2018-11-16 12:44:59.794531851 UTC

interface language-fortran-0.3-DnTmLOXLSgMntUzwJ6Kf9:Language.Fortran 8043
  interface hash: 4f1fd45b04b24201ee2e273c4a08373a
  ABI hash: 8dda5fb73f8158d90a18c144662e3ae6
  export-list hash: abb3ae69ae5b2b009eeb751e489171da
  orphan hash: 9df4f431df910072ca502a8d235ac9c4
  flag hash: 1498d78e0d0b7e776380b7d69d6ecd72
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.Fortran.Arg{Language.Fortran.Arg}
  Language.Fortran.ArgList{Language.Fortran.ArgList}
  Language.Fortran.ArgName{Language.Fortran.ASeq Language.Fortran.ArgName Language.Fortran.NullArg}
  Language.Fortran.Attr{Language.Fortran.Allocatable Language.Fortran.Dimension Language.Fortran.External Language.Fortran.Intent Language.Fortran.Intrinsic Language.Fortran.MeasureUnit Language.Fortran.Optional Language.Fortran.Parameter Language.Fortran.Pointer Language.Fortran.Private Language.Fortran.Public Language.Fortran.Save Language.Fortran.Sequence Language.Fortran.Target Language.Fortran.Volatile}
  Language.Fortran.BaseType{Language.Fortran.Character Language.Fortran.Complex Language.Fortran.DerivedType Language.Fortran.Elemental Language.Fortran.Integer Language.Fortran.Logical Language.Fortran.Pure Language.Fortran.Real Language.Fortran.Recursive Language.Fortran.SomeType}
  Language.Fortran.BinOp{Language.Fortran.And Language.Fortran.Concat Language.Fortran.Div Language.Fortran.Minus Language.Fortran.Mul Language.Fortran.Or Language.Fortran.Plus Language.Fortran.Power Language.Fortran.RelEQ Language.Fortran.RelGE Language.Fortran.RelGT Language.Fortran.RelLE Language.Fortran.RelLT Language.Fortran.RelNE}
  Language.Fortran.Block{Language.Fortran.Block}
  Language.Fortran.DataForm{Language.Fortran.Data}
  Language.Fortran.Decl{Language.Fortran.AccessStmt Language.Fortran.AttrStmt Language.Fortran.Common Language.Fortran.DSeq Language.Fortran.DataDecl Language.Fortran.Decl Language.Fortran.DerivedTypeDef Language.Fortran.Equivalence Language.Fortran.ExternalStmt Language.Fortran.Include Language.Fortran.Interface Language.Fortran.MeasureUnitDef Language.Fortran.Namelist Language.Fortran.NullDecl Language.Fortran.TextDecl}
  Language.Fortran.Expr{Language.Fortran.ArrayCon Language.Fortran.AssgExpr Language.Fortran.Bin Language.Fortran.Bound Language.Fortran.CallExpr Language.Fortran.Con Language.Fortran.ConL Language.Fortran.ConS Language.Fortran.ESeq Language.Fortran.Null Language.Fortran.NullExpr Language.Fortran.Sqrt Language.Fortran.Unary Language.Fortran.Var}
  Language.Fortran.Fortran{Language.Fortran.Allocate Language.Fortran.Assg Language.Fortran.Backspace Language.Fortran.Call Language.Fortran.Close Language.Fortran.Continue Language.Fortran.Cycle Language.Fortran.DataStmt Language.Fortran.Deallocate Language.Fortran.DoWhile Language.Fortran.Endfile Language.Fortran.Exit Language.Fortran.FSeq Language.Fortran.For Language.Fortran.Forall Language.Fortran.Format Language.Fortran.Goto Language.Fortran.If Language.Fortran.Inquire Language.Fortran.Label Language.Fortran.NullStmt Language.Fortran.Nullify Language.Fortran.Open Language.Fortran.OpenCLBufferRead Language.Fortran.OpenCLBufferWrite Language.Fortran.OpenCLMap Language.Fortran.OpenCLReduce Language.Fortran.OpenCLSeq Language.Fortran.Pause Language.Fortran.PointerAssg Language.Fortran.Print Language.Fortran.ReadS Language.Fortran.Return Language.Fortran.Rewind Language.Fortran.SelectStmt Language.Fortran.Stop Language.Fortran.TextStmt Language.Fortran.Where Language.Fortran.Write}
  Language.Fortran.Fraction{Language.Fortran.FractionConst Language.Fortran.IntegerConst Language.Fortran.NullFraction}
  Language.Fortran.GSpec{Language.Fortran.GAssg Language.Fortran.GName Language.Fortran.GOper}
  Language.Fortran.Implicit{Language.Fortran.ImplicitNone Language.Fortran.ImplicitNull}
  Language.Fortran.IntentAttr{Language.Fortran.In Language.Fortran.InOut Language.Fortran.Out}
  Language.Fortran.InterfaceSpec{Language.Fortran.FunctionInterface Language.Fortran.ModuleProcedure Language.Fortran.SubroutineInterface}
  Language.Fortran.MeasureUnit
  Language.Fortran.MeasureUnitSpec{Language.Fortran.UnitNone Language.Fortran.UnitProduct Language.Fortran.UnitQuotient}
  Language.Fortran.ProgName
  Language.Fortran.ProgUnit{Language.Fortran.BlockData Language.Fortran.Function Language.Fortran.IncludeProg Language.Fortran.Main Language.Fortran.Module Language.Fortran.NullProg Language.Fortran.PSeq Language.Fortran.Prog Language.Fortran.Sub}
  Language.Fortran.Program
  Language.Fortran.Renames
  Language.Fortran.Span{Language.Fortran.srcSpan}
  Language.Fortran.Spec{Language.Fortran.Access Language.Fortran.Action Language.Fortran.Advance Language.Fortran.Blank Language.Fortran.Delim Language.Fortran.Delimiter Language.Fortran.Direct Language.Fortran.End Language.Fortran.Eor Language.Fortran.Err Language.Fortran.ExFile Language.Fortran.Exist Language.Fortran.FMT Language.Fortran.File Language.Fortran.Floating Language.Fortran.Form Language.Fortran.Formatted Language.Fortran.IOLength Language.Fortran.IOStat Language.Fortran.NML Language.Fortran.Name Language.Fortran.Named Language.Fortran.NextRec Language.Fortran.NoSpec Language.Fortran.Number Language.Fortran.Opened Language.Fortran.Pad Language.Fortran.Position Language.Fortran.Read Language.Fortran.ReadWrite Language.Fortran.Rec Language.Fortran.Recl Language.Fortran.Sequential Language.Fortran.Size Language.Fortran.Status Language.Fortran.StringLit Language.Fortran.Unformatted Language.Fortran.Unit Language.Fortran.WriteSp}
  Language.Fortran.SrcLoc{Language.Fortran.SrcLoc srcColumn srcFilename srcLine}
  Language.Fortran.SrcSpan
  Language.Fortran.SubName{Language.Fortran.NullSubName Language.Fortran.SubName}
  Language.Fortran.Tagged{Language.Fortran.tag}
  Language.Fortran.Type{Language.Fortran.ArrayT Language.Fortran.BaseType}
  Language.Fortran.UnaryOp{Language.Fortran.Not Language.Fortran.UMinus}
  Language.Fortran.UseBlock{Language.Fortran.UseBlock}
  Language.Fortran.Uses{Language.Fortran.Use Language.Fortran.UseNil}
  Language.Fortran.VarName{Language.Fortran.VarName}
  Language.Fortran.Variable
module dependencies:
package dependencies: base-4.11.1.0 ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0 syb-0.7
orphans: syb-0.7:Data.Generics.Instances base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Data b150502d549600eff3202c16ff6cf22d
import  -/  base-4.11.1.0:Data.Typeable 9548bf378a98cc2492ab02d9a516a250
import  -/  base-4.11.1.0:Data.Typeable.Internal 0b0201144a992d956fd13a21fc2d4b48
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.Read b9e6d20d40da8c8a12b566d22e1160e0
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:Text.ParserCombinators.ReadPrec d0ebf984ed486435a97481288b73febb
import  -/  base-4.11.1.0:Text.Read.Lex f8ad6f9ae74ae325ba69a4fa5c82aaca
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  syb-0.7:Data.Generics 2ddc257f9ac35414fc37ff4d19b4d388
7f12191501ff3c8cedebd4810470ab3f
  $cASeq :: Data.Data.Constr
  {- Strictness: m -}
2418e2b334ea4088f07cf93f72598cf1
  $cAccess :: Data.Data.Constr
  {- Strictness: m -}
0eebcf727b8793db4150951247058e03
  $cAccessStmt :: Data.Data.Constr
  {- Strictness: m -}
af915f04a7078c32dc4dbdcaca9716f7
  $cAction :: Data.Data.Constr
  {- Strictness: m -}
a9d8232ce7b9539a7d6ef056e5071e07
  $cAdvance :: Data.Data.Constr
  {- Strictness: m -}
4b8fcc99375bed36c37206003599a068
  $cAllocatable :: Data.Data.Constr
  {- Strictness: m -}
3cf716ce11c6f7a20398ac08e89d755e
  $cAllocate :: Data.Data.Constr
  {- Strictness: m -}
b2afe92bd1e126cf9574ba79b2fd17a4
  $cAnd :: Data.Data.Constr
  {- Strictness: m -}
594ba8c9ecef8866c617be70acf5b705
  $cArg :: Data.Data.Constr
  {- Strictness: m -}
0810d70ec7b70a1cb5fedc61251d9566
  $cArgList :: Data.Data.Constr
  {- Strictness: m -}
d8c38a34e57294024562854cef982108
  $cArgName :: Data.Data.Constr
  {- Strictness: m -}
8b5da5a3619ed12ae08ab01113731704
  $cArrayCon :: Data.Data.Constr
  {- Strictness: m -}
2f13403871ec21839b0bd71d0c9b5111
  $cArrayT :: Data.Data.Constr
  {- Strictness: m -}
15e9b9086c12e7c2b84c59c3b8c59fc9
  $cAssg :: Data.Data.Constr
  {- Strictness: m -}
9417358c1dd472ebc83e0e72eb504182
  $cAssgExpr :: Data.Data.Constr
  {- Strictness: m -}
cc6aadeb0b1b3ada7b3aed3e81fab97d
  $cAttrStmt :: Data.Data.Constr
  {- Strictness: m -}
f0c034d64d9f60883992ccb52fd24b4b
  $cBackspace :: Data.Data.Constr
  {- Strictness: m -}
10cd5dc2d95d8aaed27283aa9ef1bfff
  $cBaseType :: Data.Data.Constr
  {- Strictness: m -}
138595aa2a359884b9346fac917310ee
  $cBin :: Data.Data.Constr
  {- Strictness: m -}
3514b70e4bb5be43e41e9da8821105a9
  $cBlank :: Data.Data.Constr
  {- Strictness: m -}
e9b49e960d6b9ec0203164476a393890
  $cBlock :: Data.Data.Constr
  {- Strictness: m -}
aa5e36321df12085612054a6f52e8e61
  $cBlockData :: Data.Data.Constr
  {- Strictness: m -}
4eda0b380697d25efd97ffd4a32477a4
  $cBound :: Data.Data.Constr
  {- Strictness: m -}
e432283106daefb73258c13387b95013
  $cCall :: Data.Data.Constr
  {- Strictness: m -}
fd2bcd17ed0c658cfd6d5495e30d5476
  $cCallExpr :: Data.Data.Constr
  {- Strictness: m -}
ad2f288b2eb23a78372cc1e2b2b0bae6
  $cCharacter :: Data.Data.Constr
  {- Strictness: m -}
01b261dbf12ed1c509e7e8a37a8b74ac
  $cClose :: Data.Data.Constr
  {- Strictness: m -}
ad922edec8d54014e3a061734b2555c2
  $cCommon :: Data.Data.Constr
  {- Strictness: m -}
93f0b546ac558c242b54ec1e6530ab53
  $cComplex :: Data.Data.Constr
  {- Strictness: m -}
1606fea2cd2dcd9d8c42850f8f362ae4
  $cCon :: Data.Data.Constr
  {- Strictness: m -}
9185e59f522af63a46e20bc5ac5151dc
  $cConL :: Data.Data.Constr
  {- Strictness: m -}
a46103e476020eaff7359b2d0be58223
  $cConS :: Data.Data.Constr
  {- Strictness: m -}
60f0d7c395f3afe7db46b3c825f647a9
  $cConcat :: Data.Data.Constr
  {- Strictness: m -}
376a91cb003cdb9539d755dcb552e802
  $cContinue :: Data.Data.Constr
  {- Strictness: m -}
159e9e4691615bcd4c2fe48d398b0da3
  $cCycle :: Data.Data.Constr
  {- Strictness: m -}
6e3bd8dba179a4f44b1d42b5dd8ba6d6
  $cDSeq :: Data.Data.Constr
  {- Strictness: m -}
77db6ffd0bd997f476bb415ba51885fa
  $cData :: Data.Data.Constr
  {- Strictness: m -}
1e041dd4c481ca73e2ab10f8bd2f3ec6
  $cDataDecl :: Data.Data.Constr
  {- Strictness: m -}
9d578d021d4d951009f69c18e921a4bf
  $cDataStmt :: Data.Data.Constr
  {- Strictness: m -}
11ad2740a2a6cc2d330e0dc33cd31a26
  $cDeallocate :: Data.Data.Constr
  {- Strictness: m -}
df841e7c7bf091e9c3b3d6081fc15a5b
  $cDecl :: Data.Data.Constr
  {- Strictness: m -}
7f3a2f8b28264a7c22f67cd90fd26e2b
  $cDelim :: Data.Data.Constr
  {- Strictness: m -}
9067b815652659da020999ddbf369a24
  $cDelimiter :: Data.Data.Constr
  {- Strictness: m -}
0d61c57c107ceada37070c7c931bf865
  $cDerivedType :: Data.Data.Constr
  {- Strictness: m -}
24e1d41cd8c0808b2d4a8e97538520c4
  $cDerivedTypeDef :: Data.Data.Constr
  {- Strictness: m -}
46a02ae05945055b6638984a30910ba8
  $cDimension :: Data.Data.Constr
  {- Strictness: m -}
6da27186b2d7280180b3c72b04e51e53
  $cDirect :: Data.Data.Constr
  {- Strictness: m -}
fcd0fda5244b87824cdc4a832961f63b
  $cDiv :: Data.Data.Constr
  {- Strictness: m -}
06c2b80faa2d7bc32d975b04882df969
  $cDoWhile :: Data.Data.Constr
  {- Strictness: m -}
3d6c3b4545161ee7bec81080dbddc7c0
  $cESeq :: Data.Data.Constr
  {- Strictness: m -}
11d977cbfabf20911b2c74de1cc4050e
  $cElemental :: Data.Data.Constr
  {- Strictness: m -}
1aaae291d23f6b4d4f464523cf37a5b4
  $cEnd :: Data.Data.Constr
  {- Strictness: m -}
4d5b725276af449f028b91ff0b1e358e
  $cEndfile :: Data.Data.Constr
  {- Strictness: m -}
fede827e4f294d8ff032b2c8df1c90a9
  $cEor :: Data.Data.Constr
  {- Strictness: m -}
c3457cc06c7f53ea1a36e295f76640e3
  $cEquivalence :: Data.Data.Constr
  {- Strictness: m -}
22302623919aca49f9b691f993480edb
  $cErr :: Data.Data.Constr
  {- Strictness: m -}
6ee142ef906eda879d32908abb00dcf8
  $cExFile :: Data.Data.Constr
  {- Strictness: m -}
46e205329c9b0b955f58c916e8947f47
  $cExist :: Data.Data.Constr
  {- Strictness: m -}
b810c1fe13c2253c5dd2261ba9289a8b
  $cExit :: Data.Data.Constr
  {- Strictness: m -}
e2b9c583261a1ca427c1db99805b13b4
  $cExternal :: Data.Data.Constr
  {- Strictness: m -}
260387e23507660ffe6bdd4bae9c838d
  $cExternalStmt :: Data.Data.Constr
  {- Strictness: m -}
53f67625eec676808c514a8c269cd308
  $cFMT :: Data.Data.Constr
  {- Strictness: m -}
a0d2c651e61218e598cf74fb198f8d9d
  $cFSeq :: Data.Data.Constr
  {- Strictness: m -}
bc06b228efbf47ca92a1a924d68455e7
  $cFile :: Data.Data.Constr
  {- Strictness: m -}
7fa4b0be019967ffed02870f981ac333
  $cFloating :: Data.Data.Constr
  {- Strictness: m -}
008fd04910b364392f20e6df76d13751
  $cFor :: Data.Data.Constr
  {- Strictness: m -}
c0bc3c9ce097a602ddc668955ef925eb
  $cForall :: Data.Data.Constr
  {- Strictness: m -}
47cdf94cc0e6658f4b409f2975365760
  $cForm :: Data.Data.Constr
  {- Strictness: m -}
06a6ce3e6373a72acee3ddc14a73d14b
  $cFormat :: Data.Data.Constr
  {- Strictness: m -}
b3f1153caed75cb476b7a9ebc4ef2975
  $cFormatted :: Data.Data.Constr
  {- Strictness: m -}
69d32cc83252c5e39e30a2852a120f87
  $cFractionConst :: Data.Data.Constr
  {- Strictness: m -}
d2c51636df8fa0615759f219a82ad877
  $cFunction :: Data.Data.Constr
  {- Strictness: m -}
8e7fa05fbb5b07ec24e147bddfa5e401
  $cFunctionInterface :: Data.Data.Constr
  {- Strictness: m -}
f05ebf2e9cf7fbdc84ef2d151be50351
  $cGAssg :: Data.Data.Constr
  {- Strictness: m -}
c15577099e3320d61fad058b3d6197e3
  $cGName :: Data.Data.Constr
  {- Strictness: m -}
a982abec003ee4a4b252d884aee454df
  $cGOper :: Data.Data.Constr
  {- Strictness: m -}
50cb6a619a55c39dd4f29be456a54e98
  $cGoto :: Data.Data.Constr
  {- Strictness: m -}
3d53a95a85caaac2a88910b49acc9011
  $cIOLength :: Data.Data.Constr
  {- Strictness: m -}
9d051251414a4cd906c974c61149da76
  $cIOStat :: Data.Data.Constr
  {- Strictness: m -}
1b24cca837ba9f43e790332f067b2a87
  $cIf :: Data.Data.Constr
  {- Strictness: m -}
9ac233afb19e417028f2c55671e73e58
  $cImplicitNone :: Data.Data.Constr
  {- Strictness: m -}
fcc0dee08d5263d821a0ac0bcb0da2d9
  $cImplicitNull :: Data.Data.Constr
  {- Strictness: m -}
66c090461665ccaf2f9a354a9d092d10
  $cIn :: Data.Data.Constr
  {- Strictness: m -}
778049edbce63de380e13f7bc3fa9e17
  $cInOut :: Data.Data.Constr
  {- Strictness: m -}
b29783cb18ed5cf4dcb119ccc940ced4
  $cInclude :: Data.Data.Constr
  {- Strictness: m -}
d0428eaeccf586544e58a6a1229a34f1
  $cIncludeProg :: Data.Data.Constr
  {- Strictness: m -}
1f0f62f7d06f4e398c86ba54e949024d
  $cInquire :: Data.Data.Constr
  {- Strictness: m -}
bef33c4b226e763fd98aab66587a5726
  $cInteger :: Data.Data.Constr
  {- Strictness: m -}
ec9e98b7cd10f7f64dd92c6883d86e6b
  $cIntegerConst :: Data.Data.Constr
  {- Strictness: m -}
137c93589e781e93ed62da7126da2dfc
  $cIntent :: Data.Data.Constr
  {- Strictness: m -}
5621e48e55a72b2d1ce9668d16f0c818
  $cInterface :: Data.Data.Constr
  {- Strictness: m -}
8fcc5ec0128a79123b417492ab03aec5
  $cIntrinsic :: Data.Data.Constr
  {- Strictness: m -}
d6a0362759b94544bef1d1378e187e34
  $cLabel :: Data.Data.Constr
  {- Strictness: m -}
a5ea49cf21a67e1e9d1b458ca43abf8b
  $cLogical :: Data.Data.Constr
  {- Strictness: m -}
bb8981af47d51513186800002efef380
  $cMain :: Data.Data.Constr
  {- Strictness: m -}
f38be8374464602e15eeb496dc95a6f3
  $cMeasureUnit :: Data.Data.Constr
  {- Strictness: m -}
1847b5464f53b59f289e4f8ae1d01045
  $cMeasureUnitDef :: Data.Data.Constr
  {- Strictness: m -}
ce1ef16e9dd8cd5d4e24570f161a215a
  $cMinus :: Data.Data.Constr
  {- Strictness: m -}
ca8651a37405f3cf25e039379fc017fc
  $cModule :: Data.Data.Constr
  {- Strictness: m -}
1dc801b4e6f33b116d375896cf2e01b9
  $cModuleProcedure :: Data.Data.Constr
  {- Strictness: m -}
967bad8f00da5e25befaba86f2bfe851
  $cMul :: Data.Data.Constr
  {- Strictness: m -}
a44ab49d321813db180bee95aea786ef
  $cNML :: Data.Data.Constr
  {- Strictness: m -}
8be0ce046b73873192201b20f6a83b78
  $cName :: Data.Data.Constr
  {- Strictness: m -}
3871e8cf973b73e0a68aa767255c4e27
  $cNamed :: Data.Data.Constr
  {- Strictness: m -}
76fcfa34d76285d7515d533d2ec4fb84
  $cNamelist :: Data.Data.Constr
  {- Strictness: m -}
12b303517ef8f550fb160f0a99f0dba7
  $cNextRec :: Data.Data.Constr
  {- Strictness: m -}
373bb656c72060a6ec9ac34b357882b9
  $cNoSpec :: Data.Data.Constr
  {- Strictness: m -}
4c71a4f7800eabdde84af52f51d5b6f3
  $cNot :: Data.Data.Constr
  {- Strictness: m -}
8ea96e3ad2dbc5cfd72f9876309962b0
  $cNull :: Data.Data.Constr
  {- Strictness: m -}
7f6f9fc95efa5099e7cd1951e8a5cee9
  $cNullArg :: Data.Data.Constr
  {- Strictness: m -}
2640f794383282f8beac63db8104610a
  $cNullDecl :: Data.Data.Constr
  {- Strictness: m -}
a7bd13dd413b599d99798a2dfafc22f0
  $cNullExpr :: Data.Data.Constr
  {- Strictness: m -}
675cc6e3e7c167aa56ea396c88578912
  $cNullFraction :: Data.Data.Constr
  {- Strictness: m -}
705542ebee7e59dc63295474b220ef3f
  $cNullProg :: Data.Data.Constr
  {- Strictness: m -}
2f24b80b0148670cb68568af2eaf684c
  $cNullStmt :: Data.Data.Constr
  {- Strictness: m -}
70cb2390880b47cc014f9b38fe95096c
  $cNullSubName :: Data.Data.Constr
  {- Strictness: m -}
413d49ca422903bad22f1569b36c2f4d
  $cNullify :: Data.Data.Constr
  {- Strictness: m -}
c38763b69c975da33db5a7e22cca955f
  $cNumber :: Data.Data.Constr
  {- Strictness: m -}
93d22e22bb35819108551eade4a01e3e
  $cOpen :: Data.Data.Constr
  {- Strictness: m -}
d7270215e2849a6d01cdd2a8a815f621
  $cOpenCLBufferRead :: Data.Data.Constr
  {- Strictness: m -}
37bad4e05a9d5604ddee8f210b23a5e1
  $cOpenCLBufferWrite :: Data.Data.Constr
  {- Strictness: m -}
a617c342265282b3ffd608dc5127c0eb
  $cOpenCLMap :: Data.Data.Constr
  {- Strictness: m -}
29f47a0b061fc602fb79f7a672aa07b7
  $cOpenCLReduce :: Data.Data.Constr
  {- Strictness: m -}
695b0134bab0fc80f3c67a789fe8006a
  $cOpenCLSeq :: Data.Data.Constr
  {- Strictness: m -}
f8e62cb3fe5b2a557c71a805cc1a71e8
  $cOpened :: Data.Data.Constr
  {- Strictness: m -}
fbe70086be8a941a329304704eed7970
  $cOptional :: Data.Data.Constr
  {- Strictness: m -}
c3beccb6504bee337c509db647ff166d
  $cOr :: Data.Data.Constr
  {- Strictness: m -}
ef2fe27de7ba8a0ff0d07888e8fe4e69
  $cOut :: Data.Data.Constr
  {- Strictness: m -}
f02e51293cccb371747ceeb965410d59
  $cPSeq :: Data.Data.Constr
  {- Strictness: m -}
255dc123d448d433d2b20b8370ffd549
  $cPad :: Data.Data.Constr
  {- Strictness: m -}
925298d9ff312839a67bae7bb2c1f199
  $cParameter :: Data.Data.Constr
  {- Strictness: m -}
1edd6f938df5a3d1923654b5dfc3d2a7
  $cPause :: Data.Data.Constr
  {- Strictness: m -}
2f00af4abcf018db9e7e15fd2a50893d
  $cPlus :: Data.Data.Constr
  {- Strictness: m -}
9170b51fe521e7506bd09eb41879e4dc
  $cPointer :: Data.Data.Constr
  {- Strictness: m -}
d33eaa48031b4c367dd1341c6dfeb96f
  $cPointerAssg :: Data.Data.Constr
  {- Strictness: m -}
b56596d53919c3d249da5e19ee219acb
  $cPosition :: Data.Data.Constr
  {- Strictness: m -}
68fc81f1a5c25fc231e94bdf6b23a2bb
  $cPower :: Data.Data.Constr
  {- Strictness: m -}
5b8ae86638bd1fc21968910a4bca3fb7
  $cPrint :: Data.Data.Constr
  {- Strictness: m -}
b578b4f180bb621d4d84c7fb3a8ab34b
  $cPrivate :: Data.Data.Constr
  {- Strictness: m -}
aec18073de0e96086e6f240047cb1ea4
  $cProg :: Data.Data.Constr
  {- Strictness: m -}
d10adecce4ee14528eae91429975d3d6
  $cPublic :: Data.Data.Constr
  {- Strictness: m -}
efdb20756f8bba8357bf732ce952f579
  $cPure :: Data.Data.Constr
  {- Strictness: m -}
66b22f9e6fd2a50f7e6a3404ba1b2837
  $cRead :: Data.Data.Constr
  {- Strictness: m -}
7843e618702e3632845b207e04aa0954
  $cReadS :: Data.Data.Constr
  {- Strictness: m -}
3c633e06a2dbf46e6890d5b5f3aa9862
  $cReadWrite :: Data.Data.Constr
  {- Strictness: m -}
42e33ac68ef3f2044fcf7070700579d7
  $cReal :: Data.Data.Constr
  {- Strictness: m -}
99c68e7225dfbc17286f6b1dec170762
  $cRec :: Data.Data.Constr
  {- Strictness: m -}
b02435b2bb0c785d26ad25fceac226bc
  $cRecl :: Data.Data.Constr
  {- Strictness: m -}
704ad15aac5c2ba28d15369cdfe6e0de
  $cRecursive :: Data.Data.Constr
  {- Strictness: m -}
b829fd6c6933c21d480d9a2c39ece157
  $cRelEQ :: Data.Data.Constr
  {- Strictness: m -}
61b0486b3424b8127efc32e83a6f0158
  $cRelGE :: Data.Data.Constr
  {- Strictness: m -}
27038ab44ca84e7ff5263e4a2957a56f
  $cRelGT :: Data.Data.Constr
  {- Strictness: m -}
edcd943d57351acd846e707f75740b43
  $cRelLE :: Data.Data.Constr
  {- Strictness: m -}
adf60b2f14cfe7b1e255e57c836396de
  $cRelLT :: Data.Data.Constr
  {- Strictness: m -}
119e6ec3ead3994777894974d4934433
  $cRelNE :: Data.Data.Constr
  {- Strictness: m -}
7acf87e3d18334f7b2dd78cba2167a9e
  $cReturn :: Data.Data.Constr
  {- Strictness: m -}
1808d58919d45fe89c0540a7121d0f55
  $cRewind :: Data.Data.Constr
  {- Strictness: m -}
59c87175d3c4b626e930aabf7fb48041
  $cSave :: Data.Data.Constr
  {- Strictness: m -}
bf7eeb39a96e42b50ffb4864d379855a
  $cSelectStmt :: Data.Data.Constr
  {- Strictness: m -}
9a10072670e4589a20072c70cc18bd68
  $cSequence :: Data.Data.Constr
  {- Strictness: m -}
5521071e7e5339c21435e4a835936822
  $cSequential :: Data.Data.Constr
  {- Strictness: m -}
f84499f3a758a8f92910edee87b7b387
  $cSize :: Data.Data.Constr
  {- Strictness: m -}
ba1f56bc711626853f1ee2e8084d5e9f
  $cSomeType :: Data.Data.Constr
  {- Strictness: m -}
43db3c509aed8982bb15d12bee11405f
  $cSqrt :: Data.Data.Constr
  {- Strictness: m -}
8dafcd0fd576b133b358da4e045ddb6a
  $cSrcLoc :: Data.Data.Constr
  {- Strictness: m -}
c58b5ddec62ed5c62abfd81e984fcc6d
  $cStatus :: Data.Data.Constr
  {- Strictness: m -}
4653f0aa46c17ba9dabdbb027ea810a6
  $cStop :: Data.Data.Constr
  {- Strictness: m -}
ef5149f3fab8872e8981971685c130b7
  $cStringLit :: Data.Data.Constr
  {- Strictness: m -}
f217befa8dad56bc2e8cf68b13271e1e
  $cSub :: Data.Data.Constr
  {- Strictness: m -}
b8dcdc08cfb4430582a885edf85711de
  $cSubName :: Data.Data.Constr
  {- Strictness: m -}
cf1ec3993eb0f918584fff086bf5b436
  $cSubroutineInterface :: Data.Data.Constr
  {- Strictness: m -}
57b63195d2d3b30c44e4ae6c6ec3b519
  $cTarget :: Data.Data.Constr
  {- Strictness: m -}
731a90bc46e636844d949e7fdd278aa2
  $cTextDecl :: Data.Data.Constr
  {- Strictness: m -}
ffeb953ec75d6d7c3ee5adf1d707627f
  $cTextStmt :: Data.Data.Constr
  {- Strictness: m -}
ba97badc7a3eca6e75ac1b732220f97f
  $cUMinus :: Data.Data.Constr
  {- Strictness: m -}
2d3764a629e5b31955b5a86b3451ffdf
  $cUnary :: Data.Data.Constr
  {- Strictness: m -}
7c83b39a8fc8f915c02eb93c3afe1667
  $cUnformatted :: Data.Data.Constr
  {- Strictness: m -}
2eff50b86be69a0b6efcfc8762a4a179
  $cUnit :: Data.Data.Constr
  {- Strictness: m -}
fa534b9314c84d37ce2818625583c82a
  $cUnitNone :: Data.Data.Constr
  {- Strictness: m -}
0f1e0abcec5aacd64d0d9826c416e3b9
  $cUnitProduct :: Data.Data.Constr
  {- Strictness: m -}
02b007ca901cdabf1d2e92187c1a9e36
  $cUnitQuotient :: Data.Data.Constr
  {- Strictness: m -}
f80490fbf9dfd445c6f0673cade2e763
  $cUse :: Data.Data.Constr
  {- Strictness: m -}
eee7df2883637bcaf21b506ceada019f
  $cUseBlock :: Data.Data.Constr
  {- Strictness: m -}
6bd824ee19ff8bc523ed3ba16507bca7
  $cUseNil :: Data.Data.Constr
  {- Strictness: m -}
1bd4fc997a478db7769f5ef5ff9ccc78
  $cVar :: Data.Data.Constr
  {- Strictness: m -}
fc8da3c787efca66e62f93664e3ec8ff
  $cVarName :: Data.Data.Constr
  {- Strictness: m -}
8f84892da7130933ebe60d8db6ddbab7
  $cVolatile :: Data.Data.Constr
  {- Strictness: m -}
c855d5f14ff8e30afebb4aee754214c5
  $cWhere :: Data.Data.Constr
  {- Strictness: m -}
4dcfb2ee2b549ccae1eddb46c1afc100
  $cWrite :: Data.Data.Constr
  {- Strictness: m -}
5c2ca8469314e10097581ddba9012de1
  $cWriteSp :: Data.Data.Constr
  {- Strictness: m -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fDataArg14 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Arg
                                                                       p>_N)
                  (Language.Fortran.$fDataArg_$cgfoldl @ p v)
                  (Language.Fortran.$fDataArg_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Arg p) ->
                   case ds of wild { Language.Fortran.Arg ds1 ds2 ds3 ->
                   Language.Fortran.$cArg })
                  (\ (ds :: Language.Fortran.Arg p) -> Language.Fortran.$tArg)
                  (Language.Fortran.$fDataArg_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Arg p)))
                  (Language.Fortran.$fDataArg6 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Arg p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Arg p>_R)
                  (Language.Fortran.$fDataArg_$cgmapQl @ p v)
                  (Language.Fortran.$fDataArg_$cgmapQr @ p v)
                  (Language.Fortran.$fDataArg_$cgmapQ @ p v)
                  (Language.Fortran.$fDataArg_$cgmapQi @ p v)
                  (Language.Fortran.$fDataArg_$cgmapM @ p v)
                  (Language.Fortran.$fDataArg_$cgmapMp @ p v)
                  (Language.Fortran.$fDataArg_$cgmapMo @ p v) -}
3d1296e310d054607f191106e8305ed6
  $fDataArg1 :: g -> Data.Data.Qi u g
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ u @ g (ds :: g) -> Language.Fortran.$fDataArg2 @ g @ u) -}
9dac14d4093e0e243ad9661cd110d082
  $fDataArg10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Arg"#) -}
a22cc45556ee44d5bb22595331ada61b
  $fDataArg11 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArg12) -}
f85d88d473ed918c547cb8bb672a1400
  $fDataArg12 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cArg
                   (GHC.Types.[] @ Data.Data.Constr)) -}
ce6bc664a4d2041476bd8a16aec0682d
  $fDataArg13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataArg10) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg14 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Arg p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Arg
                   @ p
                   Language.Fortran.$fDataArg15
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg15 :: Data.Typeable.Internal.TypeRep Language.Fortran.Arg
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Arg
                        7309058987875376809##
                        1503966189454270724##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArg9
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Arg
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
4b8f4ed3a431b4367a419fd4ed76de2c
  $fDataArg2 :: Data.Data.Qi u g
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ g @ u ->
                 Data.Data.Qi
                   @ *
                   @ u
                   @ g
                   Language.Fortran.$fDataArg3
                   (GHC.Base.Nothing @ u)) -}
7450a034d202475c5310be06b19882dc
  $fDataArg3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
6d50cf611acabc62d8c3f98631f8ae0e
  $fDataArg4 :: g -> [u] -> [u]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ u @ g (ds :: g) (eta :: [u]) -> eta) -}
43a3c9be218dd9406445aa0b1b7d7df1
  $fDataArg5 :: g -> r -> r
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ r @ g (ds :: g) (eta :: r) -> eta) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg6 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Arg p
    -> Data.Functor.Identity.Identity (Language.Fortran.Arg p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Arg p) ->
                 Language.Fortran.$fDataArg_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
a2ff6f6b0a64715d6ccd2be2e3e04b75
  $fDataArg7 :: g -> g
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ g (v :: g) -> v) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg8 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Arg
                        7309058987875376809##
                        1503966189454270724##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArg9
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Arg
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Arg
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
68c989c15b4562109e1f8ec8e46bc8d5
  $fDataArg9 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataArg10) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fDataArgList8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ArgList
                                                                       p>_N)
                  (Language.Fortran.$fDataArgList_$cgfoldl @ p v)
                  (Language.Fortran.$fDataArgList_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.ArgList p) ->
                   case ds of wild { Language.Fortran.ArgList ds1 ds2 ->
                   Language.Fortran.$cArgList })
                  (\ (ds :: Language.Fortran.ArgList p) ->
                   Language.Fortran.$tArgList)
                  (Language.Fortran.$fDataArgList_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.ArgList p)))
                  (Language.Fortran.$fDataArgList1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ArgList p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ArgList p>_R)
                  (Language.Fortran.$fDataArgList_$cgmapQl @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapQr @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapQ @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapQi @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapM @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapMp @ p v)
                  (Language.Fortran.$fDataArgList_$cgmapMo @ p v) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgList p
    -> Data.Functor.Identity.Identity (Language.Fortran.ArgList p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.ArgList p) ->
                 case x0 of wild { Language.Fortran.ArgList a1 a2 ->
                 (Language.Fortran.ArgList
                    @ p
                    (ds @ p $dData1 a1)
                    (ds
                       @ (Language.Fortran.Expr p)
                       (Language.Fortran.$fDataExpr @ p $dData1)
                       a2))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.ArgList p>_R)) }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgList
                        845657611358255983##
                        10794179943399875088##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgList3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.ArgList
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.ArgList
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
fd5b266aa2c9639743ccc8339eabdb7c
  $fDataArgList3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataArgList4) -}
02df7ce0ef20b97dfec53857a046384d
  $fDataArgList4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ArgList"#) -}
2688f4a34c8298fae7f3b63d90f8dde8
  $fDataArgList5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataArgList6) -}
97b7715ef2368b89feabe82eb1aa8592
  $fDataArgList6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cArgList
                   (GHC.Types.[] @ Data.Data.Constr)) -}
b8f07d7cdcb7dbbc18e29d4cc8086e50
  $fDataArgList7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataArgList4) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.ArgList p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ArgList
                   @ p
                   Language.Fortran.$fDataArgList9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.ArgList
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgList
                        845657611358255983##
                        10794179943399875088##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgList3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.ArgList
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgList p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataArgList2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgList p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ArgList p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ArgList <p>_N)) } } } }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ArgList p
    -> c (Language.Fortran.ArgList p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.ArgList p) ->
                 case ds of wild { Language.Fortran.ArgList a1 a2 ->
                 k @ (Language.Fortran.Expr p)
                   @ (Language.Fortran.ArgList p)
                   $dData2
                   (k @ p
                      @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      $dData1
                      (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                         (Language.Fortran.ArgList @ p))
                      a1)
                   a2 }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   lvl295 :: m (p
                                -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                   = GHC.Base.return
                       @ m
                       $dMonad
                       @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                       (Language.Fortran.ArgList @ p)
                 } in
                 \ (ds1 :: Language.Fortran.ArgList p) ->
                 case ds1 of wild { Language.Fortran.ArgList a1 a2 ->
                 let {
                   lvl296 :: m (Language.Fortran.Expr p)
                   = ds @ (Language.Fortran.Expr p) $dData2 a2
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                   @ (Language.Fortran.ArgList p)
                   (let {
                      lvl297 :: m p = ds @ p $dData1 a1
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      lvl295
                      (\ (c' :: p
                                -> Language.Fortran.Expr p -> Language.Fortran.ArgList p) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ p
                         @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                         lvl297
                         (\ (x' :: p) ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                            (c' x'))))
                   (\ (c' :: Language.Fortran.Expr p -> Language.Fortran.ArgList p) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Language.Fortran.Expr p)
                      @ (Language.Fortran.ArgList p)
                      lvl296
                      (\ (x' :: Language.Fortran.Expr p) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (Language.Fortran.ArgList p)
                         (c' x'))) }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgList p -> m (Language.Fortran.ArgList p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgList p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.ArgList p) ->
                 case w363 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 GHC.Types.:
                   @ u
                   (w362 @ p w ww1)
                   (GHC.Types.:
                      @ u
                      (w362
                         @ (Language.Fortran.Expr p)
                         (Language.Fortran.$fDataExpr @ p w)
                         ww2)
                      (GHC.Types.[] @ u)) }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgList p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.ArgList p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w364 of ww2 { Language.Fortran.ArgList ww3 ww4 ->
                 Language.Fortran.$w$cgmapQi1 @ p w @ u ww1 w363 ww3 ww4 } }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgList p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 (\ (ds3 :: Language.Fortran.ArgList p) ->
                  case ds3 of wild { Language.Fortran.ArgList a1 a2 ->
                  (ds
                     (ds ds1 (ds2 @ p $dData1 a1))
                     (ds2 @ (Language.Fortran.Expr p) $dData2 a2))
                    `cast`
                  (Sym (Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.ArgList p>_P)) })
                   `cast`
                 (<Language.Fortran.ArgList p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.ArgList p>_P)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgList p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.ArgList p) ->
                 case w365 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr1
                   @ p
                   w
                   @ r
                   @ r'
                   w362
                   w363
                   w364
                   ww1
                   ww2 }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataArgList_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ArgList p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ (Language.Fortran.Expr p)
                   @ (Language.Fortran.ArgList p)
                   $dData2
                   (k @ p
                      @ (Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                      $dData1
                      (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.ArgList p)
                         (Language.Fortran.ArgList @ p)))) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fDataArgName5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ArgName
                                                                       p>_N)
                  (Language.Fortran.$fDataArgName_$cgfoldl @ p v)
                  (Language.Fortran.$fDataArgName_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.ArgName p) ->
                   case ds of wild {
                     Language.Fortran.ArgName ds1 ds2 -> Language.Fortran.$cArgName
                     Language.Fortran.ASeq ds1 ds2 ds3 -> Language.Fortran.$cASeq
                     Language.Fortran.NullArg ds1 -> Language.Fortran.$cNullArg })
                  (\ (ds :: Language.Fortran.ArgName p) ->
                   Language.Fortran.$tArgName)
                  (Language.Fortran.$fDataArgName_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.ArgName p)))
                  (Language.Fortran.$fDataArgName1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ArgName p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ArgName p>_R)
                  (Language.Fortran.$fDataArgName_$cgmapQl @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapQr @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapQ @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapQi @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapM @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapMp @ p v)
                  (Language.Fortran.$fDataArgName_$cgmapMo @ p v) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ArgName p
    -> Data.Functor.Identity.Identity (Language.Fortran.ArgName p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgName
                        7419102846508284450##
                        11885307910119951682##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgName3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.ArgName
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.ArgName
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
9a079338db7a47367bf7bff84ab2d3d6
  $fDataArgName3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataArgName4) -}
0bd68daf4009e148871be7f51ada8e55
  $fDataArgName4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ArgName"#) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.ArgName p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ArgName
                   @ p
                   Language.Fortran.$fDataArgName6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.ArgName
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ArgName
                        7419102846508284450##
                        11885307910119951682##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataArgName3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.ArgName
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ArgName p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataArgName2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ArgName p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ArgName p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ArgName <p>_N)) } } } }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ArgName p
    -> c (Language.Fortran.ArgName p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ArgName p -> m (Language.Fortran.ArgName p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgName p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ArgName p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgName p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ArgName p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fDataArgName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ArgName p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Arg p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataArg8 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Arg p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Arg p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Arg p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Arg <p>_N)) } } } }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Arg p
    -> c (Language.Fortran.Arg p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.ArgName p)
                   = Language.Fortran.$fDataArgName @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Arg p) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 k @ Language.Fortran.SrcSpan
                   @ (Language.Fortran.Arg p)
                   Language.Fortran.$fDataArg_$s$fData(,)
                   (k @ (Language.Fortran.ArgName p)
                      @ (Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                      $dData2
                      (k @ p
                         @ (Language.Fortran.ArgName p
                            -> Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                         $dData1
                         (z @ (p
                               -> Language.Fortran.ArgName p
                               -> Language.Fortran.SrcSpan
                               -> Language.Fortran.Arg p)
                            (Language.Fortran.Arg @ p))
                         a1)
                      a2)
                   a3 }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataArg_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Arg p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Arg p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Arg p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Arg p, GHC.Types.Bool)
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fDataArg_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Arg p>_N)
                   (\ (ds1 :: (Language.Fortran.Arg p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Arg p)
                           x' } })) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Arg p -> m (Language.Fortran.Arg p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Arg p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Arg p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Arg p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Arg p, GHC.Types.Bool)
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fDataArg_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Arg p>_N)
                   (\ (ds1 :: (Language.Fortran.Arg p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Arg p)
                           x' } })) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Arg p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Arg p) ->
                 (Language.Fortran.$fDataArg_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Arg p>_P)
                   (GHC.Types.[] @ u)) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Arg p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Arg p) ->
                 case Language.Fortran.$fDataArg_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Arg p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Arg p
                        -> Data.Functor.Const.Const r (Language.Fortran.Arg p)
                   = Language.Fortran.$fDataArg_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Arg p) -> g x)
                   `cast`
                 (<Language.Fortran.Arg p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Arg p>_P)) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Arg p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Arg p) ->
                 (Language.Fortran.$fDataArg_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Arg p>_P)
                   ds1) -}
d3fedd88bb81c839018aa8b13497c1de
  $fDataArg_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Arg p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.ArgName p)
                   = Language.Fortran.$fDataArgName @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcSpan
                   @ (Language.Fortran.Arg p)
                   Language.Fortran.$fDataArg_$s$fData(,)
                   (k @ (Language.Fortran.ArgName p)
                      @ (Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                      $dData2
                      (k @ p
                         @ (Language.Fortran.ArgName p
                            -> Language.Fortran.SrcSpan -> Language.Fortran.Arg p)
                         $dData1
                         (z @ (p
                               -> Language.Fortran.ArgName p
                               -> Language.Fortran.SrcSpan
                               -> Language.Fortran.Arg p)
                            (Language.Fortran.Arg @ p))))) -}
b4ca799bbdda0cd863c77addddc934a7
  $fDataArg_$s$fData(,) ::
    Data.Data.Data (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ ((,) Language.Fortran.SrcLoc)
                     @ Language.Fortran.SrcLoc
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ (* -> *)
                        @ (,)
                        @ Language.Fortran.SrcLoc
                        Data.Data.$fData(,)10
                        Language.Fortran.$fDataSrcLoc7)
                     Language.Fortran.$fDataSrcLoc7)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(Language.Fortran.SrcLoc,
                                                                      Language.Fortran.SrcLoc)>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                     (z :: forall g. g -> c g)
                     (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case ds of wild { (,) a1 a2 ->
                   k @ Language.Fortran.SrcLoc
                     @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                     Language.Fortran.$fDataSrcLoc
                     (k @ Language.Fortran.SrcLoc
                        @ (Language.Fortran.SrcLoc
                           -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                        Language.Fortran.$fDataSrcLoc
                        (z @ (Language.Fortran.SrcLoc
                              -> Language.Fortran.SrcLoc
                              -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                           (GHC.Tuple.(,)
                              @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc))
                        a1)
                     a2 })
                  (\ @ c :: * -> *
                     (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                     (z :: forall r. r -> c r)
                     (ds :: Data.Data.Constr) ->
                   k @ Language.Fortran.SrcLoc
                     @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                     Language.Fortran.$fDataSrcLoc
                     (k @ Language.Fortran.SrcLoc
                        @ (Language.Fortran.SrcLoc
                           -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                        Language.Fortran.$fDataSrcLoc
                        (z @ (Language.Fortran.SrcLoc
                              -> Language.Fortran.SrcLoc
                              -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                           (GHC.Tuple.(,)
                              @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc))))
                  (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case ds of wild { (,) ds1 ds2 -> Data.Data.$c(,) })
                  (\ (ds :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   Data.Data.$t(,))
                  (\ @ t :: * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d. Data.Data.Data d => c (t d)) ->
                   GHC.Base.Nothing
                     @ (c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)))
                  (Data.Data.$fData(,)_$cdataCast2
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                     (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x0 of wild { (,) a1 a2 ->
                   (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1,
                    ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R)) })
                    `cast`
                  (<forall b1. Data.Data.Data b1 => b1 -> b1>_R
                   ->_R <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case eta of wild { (,) a1 a2 ->
                   (ds
                      (ds
                         ds1
                         (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1))
                      (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                     `cast`
                   (Sym (Data.Functor.Const.N:Const[0]
                             <*>_N
                             <r>_R
                             <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x0 of wild { (,) a1 a2 ->
                   ds
                     (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                     (ds
                        (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                        ds1) })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x0 of wild { (,) a1 a2 ->
                   GHC.Types.:
                     @ u
                     (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                     (GHC.Types.:
                        @ u
                        (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                        (GHC.Types.[] @ u)) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                   case x of wild { (,) a1 a2 ->
                   case ds of wild1 { GHC.Types.I# x1 ->
                   case x1 of wild2 {
                     DEFAULT -> Data.Maybe.fromJust1 @ u
                     0#
                     -> ds1 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1
                     1#
                     -> ds1
                          @ Language.Fortran.SrcLoc
                          Language.Fortran.$fDataSrcLoc
                          a2 } } })
                  (Data.Data.$fData(,)_$cgmapM
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (Data.Data.$fData(,)_$cgmapMp
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc)
                  (Data.Data.$fData(,)_$cgmapMo
                     @ Language.Fortran.SrcLoc
                     @ Language.Fortran.SrcLoc
                     Language.Fortran.$fDataSrcLoc
                     Language.Fortran.$fDataSrcLoc) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fDataAttr5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Attr
                                                                       p>_N)
                  (Language.Fortran.$fDataAttr_$cgfoldl @ p v)
                  (Language.Fortran.$fDataAttr_$cgunfold @ p v)
                  (Language.Fortran.$fDataAttr_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Attr p) -> Language.Fortran.$tAttr)
                  (Language.Fortran.$fDataAttr_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Attr p)))
                  (Language.Fortran.$fDataAttr1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Attr p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Attr p>_R)
                  (Language.Fortran.$fDataAttr_$cgmapQl @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapQr @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapQ @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapQi @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapM @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapMp @ p v)
                  (Language.Fortran.$fDataAttr_$cgmapMo @ p v) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Attr p
    -> Data.Functor.Identity.Identity (Language.Fortran.Attr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Attr p) ->
                 Language.Fortran.$fDataAttr_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Attr
                        2601353720516361080##
                        16493321566561608833##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataAttr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Attr
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Attr
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
160cfa915817ae9863d4943946554bf9
  $fDataAttr3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataAttr4) -}
d7e121cc37026820d4a1b935c3cd22b2
  $fDataAttr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Attr"#) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Attr p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Attr
                   @ p
                   Language.Fortran.$fDataAttr6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Attr
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Attr
                        2601353720516361080##
                        16493321566561608833##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataAttr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Attr
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Attr p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataAttr2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Attr p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Attr p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Attr p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Attr <p>_N)) } } } }) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Attr p
    -> c (Language.Fortran.Attr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataAttr_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Attr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Attr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Attr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Attr p, GHC.Types.Bool)
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fDataAttr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Attr p>_N)
                   (\ (ds1 :: (Language.Fortran.Attr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Attr p)
                           x' } })) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Attr p -> m (Language.Fortran.Attr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Attr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Attr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Attr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Attr p, GHC.Types.Bool)
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fDataAttr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Attr p>_N)
                   (\ (ds1 :: (Language.Fortran.Attr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Attr p)
                           x' } })) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Attr p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Attr p) ->
                 (Language.Fortran.$fDataAttr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Attr p>_P)
                   (GHC.Types.[] @ u)) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Attr p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Attr p) ->
                 case Language.Fortran.$fDataAttr_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Attr p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Attr p
                        -> Data.Functor.Const.Const r (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Attr p) -> g x)
                   `cast`
                 (<Language.Fortran.Attr p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Attr p>_P)) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Attr p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Attr p) ->
                 (Language.Fortran.$fDataAttr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Attr p>_P)
                   ds1) -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Attr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
02a255cfb28c667ea6da849cf85b59d6
  $fDataAttr_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Attr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Attr p) ->
                 case w362 of wild {
                   Language.Fortran.Parameter ds -> Language.Fortran.$cParameter
                   Language.Fortran.Allocatable ds -> Language.Fortran.$cAllocatable
                   Language.Fortran.External ds -> Language.Fortran.$cExternal
                   Language.Fortran.Intent ds ds1 -> Language.Fortran.$cIntent
                   Language.Fortran.Intrinsic ds -> Language.Fortran.$cIntrinsic
                   Language.Fortran.Optional ds -> Language.Fortran.$cOptional
                   Language.Fortran.Pointer ds -> Language.Fortran.$cPointer
                   Language.Fortran.Save ds -> Language.Fortran.$cSave
                   Language.Fortran.Target ds -> Language.Fortran.$cTarget
                   Language.Fortran.Volatile ds -> Language.Fortran.$cVolatile
                   Language.Fortran.Public ds -> Language.Fortran.$cPublic
                   Language.Fortran.Private ds -> Language.Fortran.$cPrivate
                   Language.Fortran.Sequence ds -> Language.Fortran.$cSequence
                   Language.Fortran.Dimension ds ds1 -> Language.Fortran.$cDimension
                   Language.Fortran.MeasureUnit ds ds1
                   -> Language.Fortran.$cMeasureUnit }) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fDataBaseType5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.BaseType
                                                                       p>_N)
                  (Language.Fortran.$fDataBaseType_$cgfoldl @ p v)
                  (Language.Fortran.$fDataBaseType_$cgunfold @ p v)
                  (Language.Fortran.$fDataBaseType_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.BaseType p) ->
                   Language.Fortran.$tBaseType)
                  (Language.Fortran.$fDataBaseType_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.BaseType p)))
                  (Language.Fortran.$fDataBaseType1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.BaseType p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.BaseType p>_R)
                  (Language.Fortran.$fDataBaseType_$cgmapQl @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapQr @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapQ @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapQi @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapM @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapMp @ p v)
                  (Language.Fortran.$fDataBaseType_$cgmapMo @ p v) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BaseType p
    -> Data.Functor.Identity.Identity (Language.Fortran.BaseType p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$fDataBaseType_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BaseType
                        4083489423235278951##
                        5800539029512072333##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBaseType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.BaseType
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.BaseType
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
7e62fe75fd2058dc0dbe9e4057d3ee09
  $fDataBaseType3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataBaseType4) -}
28b69108a54d0f82191435954ed4b617
  $fDataBaseType4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BaseType"#) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.BaseType p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.BaseType
                   @ p
                   Language.Fortran.$fDataBaseType6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.BaseType
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BaseType
                        4083489423235278951##
                        5800539029512072333##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBaseType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.BaseType
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.BaseType p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataBaseType2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BaseType p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.BaseType p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.BaseType <p>_N)) } } } }) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.BaseType p
    -> c (Language.Fortran.BaseType p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.BaseType p) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Integer @ p))
                        a1
                   Language.Fortran.Real a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Real @ p))
                        a1
                   Language.Fortran.Character a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Character @ p))
                        a1
                   Language.Fortran.SomeType a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.SomeType @ p))
                        a1
                   Language.Fortran.DerivedType a1 a2
                   -> k @ (Language.Fortran.SubName p)
                        @ (Language.Fortran.BaseType p)
                        $dData2
                        (k @ p
                           @ (Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                           $dData1
                           (z @ (p
                                 -> Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                              (Language.Fortran.DerivedType @ p))
                           a1)
                        a2
                   Language.Fortran.Recursive a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Recursive @ p))
                        a1
                   Language.Fortran.Pure a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Pure @ p))
                        a1
                   Language.Fortran.Elemental a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Elemental @ p))
                        a1
                   Language.Fortran.Logical a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Logical @ p))
                        a1
                   Language.Fortran.Complex a1
                   -> k @ p
                        @ (Language.Fortran.BaseType p)
                        $dData1
                        (z @ (p -> Language.Fortran.BaseType p)
                           (Language.Fortran.Complex @ p))
                        a1 }) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataBaseType_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BaseType p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BaseType p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BaseType p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BaseType p, GHC.Types.Bool)
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fDataBaseType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BaseType p>_N)
                   (\ (ds1 :: (Language.Fortran.BaseType p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BaseType p)
                           x' } })) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BaseType p -> m (Language.Fortran.BaseType p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BaseType p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BaseType p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BaseType p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BaseType p, GHC.Types.Bool)
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fDataBaseType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BaseType p>_N)
                   (\ (ds1 :: (Language.Fortran.BaseType p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BaseType p)
                           x' } })) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BaseType p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.BaseType p) ->
                 (Language.Fortran.$fDataBaseType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.BaseType p>_P)
                   (GHC.Types.[] @ u)) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BaseType p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.BaseType p) ->
                 case Language.Fortran.$fDataBaseType_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BaseType p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.BaseType p
                        -> Data.Functor.Const.Const r (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.BaseType p) -> g x)
                   `cast`
                 (<Language.Fortran.BaseType p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.BaseType p>_P)) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BaseType p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.BaseType p) ->
                 (Language.Fortran.$fDataBaseType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.BaseType p>_P)
                   ds1) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.BaseType p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.BaseType p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Complex @ p))
                        1#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Integer @ p))
                        2#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Real @ p))
                        3#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Character @ p))
                        4#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.SomeType @ p))
                        5#
                        -> k @ (Language.Fortran.SubName p)
                             @ (Language.Fortran.BaseType p)
                             $dData2
                             (k @ p
                                @ (Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                                $dData1
                                (z @ (p
                                      -> Language.Fortran.SubName p -> Language.Fortran.BaseType p)
                                   (Language.Fortran.DerivedType @ p)))
                        6#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Recursive @ p))
                        7#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Pure @ p))
                        8#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Elemental @ p))
                        9#
                        -> k @ p
                             @ (Language.Fortran.BaseType p)
                             $dData1
                             (z @ (p -> Language.Fortran.BaseType p)
                                (Language.Fortran.Logical @ p)) } } } }) -}
69d5dfd4df9415765a99abb747654948
  $fDataBaseType_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.BaseType p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w362 :: Language.Fortran.BaseType p) ->
                 case w362 of wild {
                   Language.Fortran.Integer ds -> Language.Fortran.$cInteger
                   Language.Fortran.Real ds -> Language.Fortran.$cReal
                   Language.Fortran.Character ds -> Language.Fortran.$cCharacter
                   Language.Fortran.SomeType ds -> Language.Fortran.$cSomeType
                   Language.Fortran.DerivedType ds ds1
                   -> Language.Fortran.$cDerivedType
                   Language.Fortran.Recursive ds -> Language.Fortran.$cRecursive
                   Language.Fortran.Pure ds -> Language.Fortran.$cPure
                   Language.Fortran.Elemental ds -> Language.Fortran.$cElemental
                   Language.Fortran.Logical ds -> Language.Fortran.$cLogical
                   Language.Fortran.Complex ds -> Language.Fortran.$cComplex }) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fDataBinOp6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.BinOp
                                                                       p>_N)
                  (Language.Fortran.$fDataBinOp_$cgfoldl @ p v)
                  (Language.Fortran.$fDataBinOp_$cgunfold @ p v)
                  (Language.Fortran.$fDataBinOp_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.BinOp p) -> Language.Fortran.$tBinOp)
                  (Language.Fortran.$fDataBinOp_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.BinOp p)))
                  (Language.Fortran.$fDataBinOp2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.BinOp p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.BinOp p>_R)
                  (Language.Fortran.$fDataBinOp1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.BinOp p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.BinOp p>_P)
                  (Language.Fortran.$fDataBinOp_$cgmapQr @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapQ @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapQi @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapM @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapMp @ p v)
                  (Language.Fortran.$fDataBinOp_$cgmapMo @ p v) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> Data.Functor.Const.Const r (Language.Fortran.BinOp p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData1
                   @ (Data.Functor.Const.Const r)
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)[OneShot]
                      (c :: Data.Functor.Const.Const r (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    ds
                      c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                      (ds2 @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Const.Const r (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                   (\ @ g1 (ds3 :: g1)[OneShot] -> ds1)
                     `cast`
                   (forall (g1 :: <*>_N).
                    <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                   eta) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.BinOp p
    -> Data.Functor.Identity.Identity (Language.Fortran.BinOp p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)[OneShot]
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BinOp
                        9536987714771015796##
                        7738095616654473121##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBinOp4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.BinOp
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.BinOp
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
daa75d82e39b2563a671085a0d4f7fc1
  $fDataBinOp4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataBinOp5) -}
33730d622807277b7d8b2b5eb5446b94
  $fDataBinOp5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BinOp"#) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.BinOp p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.BinOp
                   @ p
                   Language.Fortran.$fDataBinOp7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.BinOp
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.BinOp
                        9536987714771015796##
                        7738095616654473121##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBinOp4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.BinOp
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.BinOp p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataBinOp3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.BinOp p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.BinOp p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.BinOp <p>_N)) } } } }) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.BinOp p
    -> c (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U> -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fDataBinOp_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)[OneShot]
                      (c :: m (d -> b))[OneShot]
                      (x :: d)[OneShot] ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)
                   eta) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BinOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BinOp p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BinOp p, GHC.Types.Bool)
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fDataBinOp_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)[OneShot]
                         (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                         (y :: d)[OneShot] ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g)[OneShot] ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BinOp p>_N)
                   (\ (ds1 :: (Language.Fortran.BinOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BinOp p)
                           x' } })) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.BinOp p -> m (Language.Fortran.BinOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.BinOp p) ->
                 let {
                   lvl295 :: m (Language.Fortran.BinOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.BinOp p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.BinOp p, GHC.Types.Bool)
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fDataBinOp_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)[OneShot]
                         (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                         (y :: d)[OneShot] ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g)[OneShot] ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.BinOp p>_N)
                   (\ (ds1 :: (Language.Fortran.BinOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.BinOp p)
                           x' } })) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BinOp p -> [u]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.BinOp p) ->
                 (Language.Fortran.$fDataBinOp_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (ds1 :: Data.Data.Qr [u] (d -> b))[OneShot]
                       (x :: d)[OneShot]
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.BinOp p>_P)
                   (GHC.Types.[] @ u)) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.BinOp p
    -> u
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.BinOp p) ->
                 case Language.Fortran.$fDataBinOp_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)[OneShot]
                           (ds2 :: Data.Data.Qi u (d -> b))[OneShot]
                           (a1 :: d)[OneShot] ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.BinOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.BinOp p) ->
                 (Language.Fortran.$fDataBinOp_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (ds3 :: Data.Data.Qr r (d -> b))[OneShot]
                       (x :: d)[OneShot]
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.BinOp p>_P)
                   ds1) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.BinOp p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold2 @ p w @ c w362 w363 ww1 ww5 }) -}
896c0936a7e3480424b97ccaddc9354b
  $fDataBinOp_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.BinOp p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w362 :: Language.Fortran.BinOp p) ->
                 case w362 of wild {
                   Language.Fortran.Plus ds -> Language.Fortran.$cPlus
                   Language.Fortran.Minus ds -> Language.Fortran.$cMinus
                   Language.Fortran.Mul ds -> Language.Fortran.$cMul
                   Language.Fortran.Div ds -> Language.Fortran.$cDiv
                   Language.Fortran.Or ds -> Language.Fortran.$cOr
                   Language.Fortran.And ds -> Language.Fortran.$cAnd
                   Language.Fortran.Concat ds -> Language.Fortran.$cConcat
                   Language.Fortran.Power ds -> Language.Fortran.$cPower
                   Language.Fortran.RelEQ ds -> Language.Fortran.$cRelEQ
                   Language.Fortran.RelNE ds -> Language.Fortran.$cRelNE
                   Language.Fortran.RelLT ds -> Language.Fortran.$cRelLT
                   Language.Fortran.RelLE ds -> Language.Fortran.$cRelLE
                   Language.Fortran.RelGT ds -> Language.Fortran.$cRelGT
                   Language.Fortran.RelGE ds -> Language.Fortran.$cRelGE }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fDataBlock8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Block
                                                                       p>_N)
                  (Language.Fortran.$fDataBlock_$cgfoldl @ p v)
                  (Language.Fortran.$fDataBlock_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Block p) ->
                   case ds of wild { Language.Fortran.Block ds1 ds2 ds3 ds4 ds5 ds6 ->
                   Language.Fortran.$cBlock })
                  (\ (ds :: Language.Fortran.Block p) -> Language.Fortran.$tBlock)
                  (Language.Fortran.$fDataBlock_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Block p)))
                  (Language.Fortran.$fDataBlock1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Block p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Block p>_R)
                  (Language.Fortran.$fDataBlock_$cgmapQl @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapQr @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapQ @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapQi @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapM @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapMp @ p v)
                  (Language.Fortran.$fDataBlock_$cgmapMo @ p v) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Block p
    -> Data.Functor.Identity.Identity (Language.Fortran.Block p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Block p) ->
                 Language.Fortran.$fDataBlock_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Block
                        11104329050160090963##
                        13952174415240849570##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Block
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Block
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
c1418780f64503238c95c8bf2c8e20d9
  $fDataBlock3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataBlock4) -}
fa1727e738f120f2dd36190296f80af9
  $fDataBlock4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Block"#) -}
1ecf98c028dede81a67c8bb435fb5c3f
  $fDataBlock5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataBlock6) -}
b25dce9454364de8401ba53d27fe9b1a
  $fDataBlock6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cBlock
                   (GHC.Types.[] @ Data.Data.Constr)) -}
e84999ce2122fa5cae01cc3789a03df0
  $fDataBlock7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataBlock4) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Block p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Block
                   @ p
                   Language.Fortran.$fDataBlock9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Block
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Block
                        11104329050160090963##
                        13952174415240849570##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Block
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Block p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataBlock2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Block p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Block p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Block p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Block <p>_N)) } } } }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Block p
    -> c (Language.Fortran.Block p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.UseBlock p)
                   = Language.Fortran.$fDataUseBlock @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData1
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Block p) ->
                 case ds of wild { Language.Fortran.Block a1 a2 a3 a4 a5 a6 ->
                 k @ (Language.Fortran.Fortran p)
                   @ (Language.Fortran.Block p)
                   $dData5
                   (k @ (Language.Fortran.Decl p)
                      @ (Language.Fortran.Fortran p -> Language.Fortran.Block p)
                      $dData4
                      (k @ Language.Fortran.SrcSpan
                         @ (Language.Fortran.Decl p
                            -> Language.Fortran.Fortran p -> Language.Fortran.Block p)
                         Language.Fortran.$fDataArg_$s$fData(,)
                         (k @ (Language.Fortran.Implicit p)
                            @ (Language.Fortran.SrcSpan
                               -> Language.Fortran.Decl p
                               -> Language.Fortran.Fortran p
                               -> Language.Fortran.Block p)
                            $dData3
                            (k @ (Language.Fortran.UseBlock p)
                               @ (Language.Fortran.Implicit p
                                  -> Language.Fortran.SrcSpan
                                  -> Language.Fortran.Decl p
                                  -> Language.Fortran.Fortran p
                                  -> Language.Fortran.Block p)
                               $dData2
                               (k @ p
                                  @ (Language.Fortran.UseBlock p
                                     -> Language.Fortran.Implicit p
                                     -> Language.Fortran.SrcSpan
                                     -> Language.Fortran.Decl p
                                     -> Language.Fortran.Fortran p
                                     -> Language.Fortran.Block p)
                                  $dData1
                                  (z @ (p
                                        -> Language.Fortran.UseBlock p
                                        -> Language.Fortran.Implicit p
                                        -> Language.Fortran.SrcSpan
                                        -> Language.Fortran.Decl p
                                        -> Language.Fortran.Fortran p
                                        -> Language.Fortran.Block p)
                                     (Language.Fortran.Block @ p))
                                  a1)
                               a2)
                            a3)
                         a4)
                      a5)
                   a6 }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataBlock_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Block p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Block p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Block p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Block p, GHC.Types.Bool)
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fDataBlock_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Block p>_N)
                   (\ (ds1 :: (Language.Fortran.Block p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Block p)
                           x' } })) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Block p -> m (Language.Fortran.Block p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Block p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Block p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Block p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Block p, GHC.Types.Bool)
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fDataBlock_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Block p>_N)
                   (\ (ds1 :: (Language.Fortran.Block p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Block p)
                           x' } })) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Block p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Block p) ->
                 (Language.Fortran.$fDataBlock_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Block p>_P)
                   (GHC.Types.[] @ u)) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Block p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Block p) ->
                 case Language.Fortran.$fDataBlock_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Block p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Block p
                        -> Data.Functor.Const.Const r (Language.Fortran.Block p)
                   = Language.Fortran.$fDataBlock_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Block p) -> g x)
                   `cast`
                 (<Language.Fortran.Block p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Block p>_P)) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Block p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Block p) ->
                 (Language.Fortran.$fDataBlock_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Block p>_P)
                   ds1) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fDataBlock_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Block p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.UseBlock p)
                   = Language.Fortran.$fDataUseBlock @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData1
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ (Language.Fortran.Fortran p)
                   @ (Language.Fortran.Block p)
                   $dData5
                   (k @ (Language.Fortran.Decl p)
                      @ (Language.Fortran.Fortran p -> Language.Fortran.Block p)
                      $dData4
                      (k @ Language.Fortran.SrcSpan
                         @ (Language.Fortran.Decl p
                            -> Language.Fortran.Fortran p -> Language.Fortran.Block p)
                         Language.Fortran.$fDataArg_$s$fData(,)
                         (k @ (Language.Fortran.Implicit p)
                            @ (Language.Fortran.SrcSpan
                               -> Language.Fortran.Decl p
                               -> Language.Fortran.Fortran p
                               -> Language.Fortran.Block p)
                            $dData3
                            (k @ (Language.Fortran.UseBlock p)
                               @ (Language.Fortran.Implicit p
                                  -> Language.Fortran.SrcSpan
                                  -> Language.Fortran.Decl p
                                  -> Language.Fortran.Fortran p
                                  -> Language.Fortran.Block p)
                               $dData2
                               (k @ p
                                  @ (Language.Fortran.UseBlock p
                                     -> Language.Fortran.Implicit p
                                     -> Language.Fortran.SrcSpan
                                     -> Language.Fortran.Decl p
                                     -> Language.Fortran.Fortran p
                                     -> Language.Fortran.Block p)
                                  $dData1
                                  (z @ (p
                                        -> Language.Fortran.UseBlock p
                                        -> Language.Fortran.Implicit p
                                        -> Language.Fortran.SrcSpan
                                        -> Language.Fortran.Decl p
                                        -> Language.Fortran.Fortran p
                                        -> Language.Fortran.Block p)
                                     (Language.Fortran.Block @ p)))))))) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fDataDataForm8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.DataForm
                                                                       p>_N)
                  (Language.Fortran.$fDataDataForm_$cgfoldl @ p v)
                  (Language.Fortran.$fDataDataForm_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.DataForm p) ->
                   case ds of wild { Language.Fortran.Data ds1 ds2 ->
                   Language.Fortran.$cData })
                  (\ (ds :: Language.Fortran.DataForm p) ->
                   Language.Fortran.$tDataForm)
                  (Language.Fortran.$fDataDataForm_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.DataForm p)))
                  (Language.Fortran.$fDataDataForm1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.DataForm p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.DataForm p>_R)
                  (Language.Fortran.$fDataDataForm_$cgmapQl @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapQr @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapQ @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapQi @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapM @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapMp @ p v)
                  (Language.Fortran.$fDataDataForm_$cgmapMo @ p v) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.DataForm p
    -> Data.Functor.Identity.Identity (Language.Fortran.DataForm p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$fDataDataForm_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.DataForm
                        17013794398423112470##
                        12144596980792875097##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDataForm3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.DataForm
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.DataForm
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
07205549b33c17e5f084c24aebe51898
  $fDataDataForm3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataDataForm4) -}
035b3be7d045c1a53634bc4c37ecbef5
  $fDataDataForm4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DataForm"#) -}
26634e7b8e680517b4816fd26c27240a
  $fDataDataForm5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataDataForm6) -}
ef1ed8e6e5119430d603ab2708f9a24b
  $fDataDataForm6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cData
                   (GHC.Types.[] @ Data.Data.Constr)) -}
1e2f7dcdb7e432da5ced71e6a2559cb1
  $fDataDataForm7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataDataForm4) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.DataForm p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.DataForm
                   @ p
                   Language.Fortran.$fDataDataForm9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.DataForm
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.DataForm
                        17013794398423112470##
                        12144596980792875097##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDataForm3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.DataForm
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.DataForm p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataDataForm2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.DataForm p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.DataForm p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.DataForm <p>_N)) } } } }) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.DataForm p
    -> c (Language.Fortran.DataForm p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData2
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData3
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data a1 a2 ->
                 k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   @ (Language.Fortran.DataForm p)
                   $dData4
                   (k @ p
                      @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                         -> Language.Fortran.DataForm p)
                      $dData1
                      (z @ (p
                            -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                            -> Language.Fortran.DataForm p)
                         (Language.Fortran.Data @ p))
                      a1)
                   a2 }) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataDataForm_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.DataForm p) ->
                 let {
                   lvl295 :: m (Language.Fortran.DataForm p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.DataForm p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.DataForm p, GHC.Types.Bool)
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fDataDataForm_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.DataForm p>_N)
                   (\ (ds1 :: (Language.Fortran.DataForm p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.DataForm p)
                           x' } })) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.DataForm p -> m (Language.Fortran.DataForm p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.DataForm p) ->
                 let {
                   lvl295 :: m (Language.Fortran.DataForm p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.DataForm p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.DataForm p, GHC.Types.Bool)
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fDataDataForm_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.DataForm p>_N)
                   (\ (ds1 :: (Language.Fortran.DataForm p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.DataForm p)
                           x' } })) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.DataForm p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.DataForm p) ->
                 (Language.Fortran.$fDataDataForm_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.DataForm p>_P)
                   (GHC.Types.[] @ u)) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.DataForm p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.DataForm p) ->
                 case Language.Fortran.$fDataDataForm_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.DataForm p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.DataForm p
                        -> Data.Functor.Const.Const r (Language.Fortran.DataForm p)
                   = Language.Fortran.$fDataDataForm_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.DataForm p) -> g x)
                   `cast`
                 (<Language.Fortran.DataForm p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.DataForm p>_P)) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.DataForm p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.DataForm p) ->
                 (Language.Fortran.$fDataDataForm_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.DataForm p>_P)
                   ds1) -}
dad4d55a5cea607426e414a10b8eea45
  $fDataDataForm_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.DataForm p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData2
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData3
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   @ (Language.Fortran.DataForm p)
                   $dData4
                   (k @ p
                      @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                         -> Language.Fortran.DataForm p)
                      $dData1
                      (z @ (p
                            -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                            -> Language.Fortran.DataForm p)
                         (Language.Fortran.Data @ p)))) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fDataDecl5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Decl
                                                                       p>_N)
                  (Language.Fortran.$fDataDecl_$cgfoldl @ p v)
                  (Language.Fortran.$fDataDecl_$cgunfold @ p v)
                  (Language.Fortran.$fDataDecl_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Decl p) -> Language.Fortran.$tDecl)
                  (Language.Fortran.$fDataDecl_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Decl p)))
                  (Language.Fortran.$fDataDecl1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Decl p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Decl p>_R)
                  (Language.Fortran.$fDataDecl_$cgmapQl @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapQr @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapQ @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapQi @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapM @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapMp @ p v)
                  (Language.Fortran.$fDataDecl_$cgmapMo @ p v) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Decl p
    -> Data.Functor.Identity.Identity (Language.Fortran.Decl p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Decl p) ->
                 Language.Fortran.$fDataDecl_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Decl
                        12291791744174836530##
                        8828337267165364954##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDecl3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Decl
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Decl
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
f4eb05d51b885bf2bc6c3c18b2637af1
  $fDataDecl3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataDecl4) -}
777935c2a44692a5fdeb4361f0396571
  $fDataDecl4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Decl"#) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Decl p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Decl
                   @ p
                   Language.Fortran.$fDataDecl6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Decl
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Decl
                        12291791744174836530##
                        8828337267165364954##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataDecl3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Decl
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Decl p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataDecl2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Decl p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Decl p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Decl p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Decl <p>_N)) } } } }) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Decl p
    -> c (Language.Fortran.Decl p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataDecl_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Decl p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Decl p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Decl p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Decl p, GHC.Types.Bool)
                   @ (Language.Fortran.Decl p)
                   (Language.Fortran.$fDataDecl_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Decl p>_N)
                   (\ (ds1 :: (Language.Fortran.Decl p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Decl p)
                           x' } })) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Decl p -> m (Language.Fortran.Decl p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Decl p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Decl p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Decl p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Decl p, GHC.Types.Bool)
                   @ (Language.Fortran.Decl p)
                   (Language.Fortran.$fDataDecl_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Decl p>_N)
                   (\ (ds1 :: (Language.Fortran.Decl p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Decl p)
                           x' } })) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Decl p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Decl p) ->
                 (Language.Fortran.$fDataDecl_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Decl p>_P)
                   (GHC.Types.[] @ u)) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Decl p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Decl p) ->
                 case Language.Fortran.$fDataDecl_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Decl p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Decl p
                        -> Data.Functor.Const.Const r (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Decl p) -> g x)
                   `cast`
                 (<Language.Fortran.Decl p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Decl p>_P)) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Decl p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Decl p) ->
                 (Language.Fortran.$fDataDecl_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Decl p>_P)
                   ds1) -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Decl p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
a81776e31635bc99f5c71e8648536701
  $fDataDecl_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Decl p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Decl p) ->
                 case w362 of wild {
                   Language.Fortran.Decl ds ds1 ds2 ds3 -> Language.Fortran.$cDecl
                   Language.Fortran.Namelist ds ds1 -> Language.Fortran.$cNamelist
                   Language.Fortran.DataDecl ds ds1 -> Language.Fortran.$cDataDecl
                   Language.Fortran.Equivalence ds ds1 ds2
                   -> Language.Fortran.$cEquivalence
                   Language.Fortran.AttrStmt ds ds1 ds2 -> Language.Fortran.$cAttrStmt
                   Language.Fortran.AccessStmt ds ds1 ds2
                   -> Language.Fortran.$cAccessStmt
                   Language.Fortran.ExternalStmt ds ds1
                   -> Language.Fortran.$cExternalStmt
                   Language.Fortran.Interface ds ds1 ds2
                   -> Language.Fortran.$cInterface
                   Language.Fortran.Common ds ds1 ds2 ds3 -> Language.Fortran.$cCommon
                   Language.Fortran.DerivedTypeDef ds ds1 ds2 ds3 ds4 ds5
                   -> Language.Fortran.$cDerivedTypeDef
                   Language.Fortran.Include ds ds1 -> Language.Fortran.$cInclude
                   Language.Fortran.DSeq ds ds1 ds2 -> Language.Fortran.$cDSeq
                   Language.Fortran.TextDecl ds ds1 -> Language.Fortran.$cTextDecl
                   Language.Fortran.NullDecl ds ds1 -> Language.Fortran.$cNullDecl
                   Language.Fortran.MeasureUnitDef ds ds1 ds2
                   -> Language.Fortran.$cMeasureUnitDef }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fDataExpr5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Expr
                                                                       p>_N)
                  (Language.Fortran.$fDataExpr_$cgfoldl @ p v)
                  (Language.Fortran.$fDataExpr_$cgunfold @ p v)
                  (Language.Fortran.$fDataExpr_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Expr p) -> Language.Fortran.$tExpr)
                  (Language.Fortran.$fDataExpr_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Expr p)))
                  (Language.Fortran.$fDataExpr1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Expr p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Expr p>_R)
                  (Language.Fortran.$fDataExpr_$cgmapQl @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapQr @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapQ @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapQi @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapM @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapMp @ p v)
                  (Language.Fortran.$fDataExpr_$cgmapMo @ p v) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Expr p
    -> Data.Functor.Identity.Identity (Language.Fortran.Expr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Expr p) ->
                 Language.Fortran.$fDataExpr_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Expr
                        666290775928592730##
                        14296435139678708619##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataExpr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Expr
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Expr
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
2af6fdd8127e2e57fc72ccc08a9f04bf
  $fDataExpr3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataExpr4) -}
6cd4402c322a48602e5de7550708a1c9
  $fDataExpr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Expr"#) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Expr p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Expr
                   @ p
                   Language.Fortran.$fDataExpr6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Expr
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Expr
                        666290775928592730##
                        14296435139678708619##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataExpr3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Expr
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Expr p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataExpr2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Expr p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Expr p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Expr p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Expr <p>_N)) } } } }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Expr p
    -> c (Language.Fortran.Expr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataExpr_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Expr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Expr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Expr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Expr p, GHC.Types.Bool)
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fDataExpr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Expr p>_N)
                   (\ (ds1 :: (Language.Fortran.Expr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Expr p)
                           x' } })) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Expr p -> m (Language.Fortran.Expr p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Expr p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Expr p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Expr p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Expr p, GHC.Types.Bool)
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fDataExpr_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Expr p>_N)
                   (\ (ds1 :: (Language.Fortran.Expr p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Expr p)
                           x' } })) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Expr p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Expr p) ->
                 (Language.Fortran.$fDataExpr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Expr p>_P)
                   (GHC.Types.[] @ u)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Expr p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Expr p) ->
                 case Language.Fortran.$fDataExpr_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Expr p
                        -> Data.Functor.Const.Const r (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Expr p) -> g x)
                   `cast`
                 (<Language.Fortran.Expr p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Expr p>_P)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Expr p) ->
                 (Language.Fortran.$fDataExpr_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Expr p>_P)
                   ds1) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Expr p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
045a18871aabc3897c4cc31c5a6f6de0
  $fDataExpr_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Expr p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Expr p) ->
                 case w362 of wild {
                   Language.Fortran.Con ds ds1 ds2 -> Language.Fortran.$cCon
                   Language.Fortran.ConL ds ds1 ds2 ds3 -> Language.Fortran.$cConL
                   Language.Fortran.ConS ds ds1 ds2 -> Language.Fortran.$cConS
                   Language.Fortran.Var ds ds1 ds2 -> Language.Fortran.$cVar
                   Language.Fortran.Bin ds ds1 ds2 ds3 ds4 -> Language.Fortran.$cBin
                   Language.Fortran.Unary ds ds1 ds2 ds3 -> Language.Fortran.$cUnary
                   Language.Fortran.CallExpr ds ds1 ds2 ds3
                   -> Language.Fortran.$cCallExpr
                   Language.Fortran.NullExpr ds ds1 -> Language.Fortran.$cNullExpr
                   Language.Fortran.Null ds ds1 -> Language.Fortran.$cNull
                   Language.Fortran.ESeq ds ds1 ds2 ds3 -> Language.Fortran.$cESeq
                   Language.Fortran.Bound ds ds1 ds2 ds3 -> Language.Fortran.$cBound
                   Language.Fortran.Sqrt ds ds1 ds2 -> Language.Fortran.$cSqrt
                   Language.Fortran.ArrayCon ds ds1 ds2 -> Language.Fortran.$cArrayCon
                   Language.Fortran.AssgExpr ds ds1 ds2 ds3
                   -> Language.Fortran.$cAssgExpr }) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fDataFortran5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Fortran
                                                                       p>_N)
                  (Language.Fortran.$fDataFortran_$cgfoldl @ p v)
                  (Language.Fortran.$fDataFortran_$cgunfold @ p v)
                  (Language.Fortran.$fDataFortran_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Fortran p) ->
                   Language.Fortran.$tFortran)
                  (Language.Fortran.$fDataFortran_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Fortran p)))
                  (Language.Fortran.$fDataFortran1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Fortran p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Fortran p>_R)
                  (Language.Fortran.$fDataFortran_$cgmapQl @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapQr @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapQ @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapQi @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapM @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapMp @ p v)
                  (Language.Fortran.$fDataFortran_$cgmapMo @ p v) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fortran p
    -> Data.Functor.Identity.Identity (Language.Fortran.Fortran p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$fDataFortran_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        15050906489887366908##
                        8016429120508906433##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Fortran
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Fortran
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
56ce43f68d78763e67e4af1d7d2eddfc
  $fDataFortran3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataFortran4) -}
2c1f683bb48f641e9cec18e094365c82
  $fDataFortran4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fortran"#) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Fortran p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Fortran
                   @ p
                   Language.Fortran.$fDataFortran6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Fortran
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fortran
                        15050906489887366908##
                        8016429120508906433##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFortran3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Fortran
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Fortran p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataFortran2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fortran p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Fortran p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Fortran <p>_N)) } } } }) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Fortran p
    -> c (Language.Fortran.Fortran p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataFortran_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Fortran p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Fortran p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Fortran p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Fortran p, GHC.Types.Bool)
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fDataFortran_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Fortran p>_N)
                   (\ (ds1 :: (Language.Fortran.Fortran p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Fortran p)
                           x' } })) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fortran p -> m (Language.Fortran.Fortran p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Fortran p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Fortran p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Fortran p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Fortran p, GHC.Types.Bool)
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fDataFortran_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Fortran p>_N)
                   (\ (ds1 :: (Language.Fortran.Fortran p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Fortran p)
                           x' } })) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fortran p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Fortran p) ->
                 (Language.Fortran.$fDataFortran_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Fortran p>_P)
                   (GHC.Types.[] @ u)) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fortran p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Fortran p) ->
                 case Language.Fortran.$fDataFortran_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fortran p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Fortran p
                        -> Data.Functor.Const.Const r (Language.Fortran.Fortran p)
                   = Language.Fortran.$fDataFortran_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Fortran p) -> g x)
                   `cast`
                 (<Language.Fortran.Fortran p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Fortran p>_P)) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fortran p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Fortran p) ->
                 (Language.Fortran.$fDataFortran_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Fortran p>_P)
                   ds1) -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Fortran p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
96a246f096edd051e2860499c815ffa3
  $fDataFortran_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Fortran p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   (w362 :: Language.Fortran.Fortran p) ->
                 case w362 of wild {
                   Language.Fortran.Assg ds ds1 ds2 ds3 -> Language.Fortran.$cAssg
                   Language.Fortran.For ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cFor
                   Language.Fortran.DoWhile ds ds1 ds2 ds3
                   -> Language.Fortran.$cDoWhile
                   Language.Fortran.FSeq ds ds1 ds2 ds3 -> Language.Fortran.$cFSeq
                   Language.Fortran.If ds ds1 ds2 ds3 ds4 ds5 -> Language.Fortran.$cIf
                   Language.Fortran.Allocate ds ds1 ds2 ds3
                   -> Language.Fortran.$cAllocate
                   Language.Fortran.Backspace ds ds1 ds2
                   -> Language.Fortran.$cBackspace
                   Language.Fortran.Call ds ds1 ds2 ds3 -> Language.Fortran.$cCall
                   Language.Fortran.Open ds ds1 ds2 -> Language.Fortran.$cOpen
                   Language.Fortran.Close ds ds1 ds2 -> Language.Fortran.$cClose
                   Language.Fortran.Continue ds ds1 -> Language.Fortran.$cContinue
                   Language.Fortran.Cycle ds ds1 ds2 -> Language.Fortran.$cCycle
                   Language.Fortran.DataStmt ds ds1 ds2 -> Language.Fortran.$cDataStmt
                   Language.Fortran.Deallocate ds ds1 ds2 ds3
                   -> Language.Fortran.$cDeallocate
                   Language.Fortran.Endfile ds ds1 ds2 -> Language.Fortran.$cEndfile
                   Language.Fortran.Exit ds ds1 ds2 -> Language.Fortran.$cExit
                   Language.Fortran.Format ds ds1 ds2 -> Language.Fortran.$cFormat
                   Language.Fortran.Forall ds ds1 ds2 ds3 -> Language.Fortran.$cForall
                   Language.Fortran.Goto ds ds1 ds2 -> Language.Fortran.$cGoto
                   Language.Fortran.Nullify ds ds1 ds2 -> Language.Fortran.$cNullify
                   Language.Fortran.Inquire ds ds1 ds2 ds3
                   -> Language.Fortran.$cInquire
                   Language.Fortran.Pause ds ds1 ds2 -> Language.Fortran.$cPause
                   Language.Fortran.Rewind ds ds1 ds2 -> Language.Fortran.$cRewind
                   Language.Fortran.Stop ds ds1 ds2 -> Language.Fortran.$cStop
                   Language.Fortran.Where ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cWhere
                   Language.Fortran.Write ds ds1 ds2 ds3 -> Language.Fortran.$cWrite
                   Language.Fortran.PointerAssg ds ds1 ds2 ds3
                   -> Language.Fortran.$cPointerAssg
                   Language.Fortran.Return ds ds1 ds2 -> Language.Fortran.$cReturn
                   Language.Fortran.Label ds ds1 ds2 ds3 -> Language.Fortran.$cLabel
                   Language.Fortran.Print ds ds1 ds2 ds3 -> Language.Fortran.$cPrint
                   Language.Fortran.ReadS ds ds1 ds2 ds3 -> Language.Fortran.$cReadS
                   Language.Fortran.TextStmt ds ds1 ds2 -> Language.Fortran.$cTextStmt
                   Language.Fortran.NullStmt ds ds1 -> Language.Fortran.$cNullStmt
                   Language.Fortran.SelectStmt ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cSelectStmt
                   Language.Fortran.OpenCLMap ds ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cOpenCLMap
                   Language.Fortran.OpenCLReduce ds ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cOpenCLReduce
                   Language.Fortran.OpenCLSeq ds ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cOpenCLSeq
                   Language.Fortran.OpenCLBufferRead ds ds1 ds2
                   -> Language.Fortran.$cOpenCLBufferRead
                   Language.Fortran.OpenCLBufferWrite ds ds1 ds2
                   -> Language.Fortran.$cOpenCLBufferWrite }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fDataFraction6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Fraction
                                                                       p>_N)
                  (Language.Fortran.$fDataFraction_$cgfoldl @ p v)
                  (Language.Fortran.$fDataFraction_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Fraction p) ->
                   case ds of wild {
                     Language.Fortran.IntegerConst ds1 ds2
                     -> Language.Fortran.$cIntegerConst
                     Language.Fortran.FractionConst ds1 ds2 ds3
                     -> Language.Fortran.$cFractionConst
                     Language.Fortran.NullFraction ds1
                     -> Language.Fortran.$cNullFraction })
                  (\ (ds :: Language.Fortran.Fraction p) ->
                   Language.Fortran.$tFraction)
                  (Language.Fortran.$fDataFraction_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Fraction p)))
                  (Language.Fortran.$fDataFraction2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Fraction p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Fraction p>_R)
                  (Language.Fortran.$fDataFraction1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.Fraction p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.Fraction p>_P)
                  (Language.Fortran.$fDataFraction_$cgmapQr @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapQ @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapQi @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapM @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapMp @ p v)
                  (Language.Fortran.$fDataFraction_$cgmapMo @ p v) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fraction p
    -> Data.Functor.Const.Const r (Language.Fortran.Fraction p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Fraction p) ->
                 case eta of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> (ds
                         (ds ds1 (ds2 @ p $dData1 a1))
                         (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Fraction p>_P))
                   Language.Fortran.FractionConst a1 a2 a3
                   -> (ds
                         (ds
                            (ds ds1 (ds2 @ p $dData1 a1))
                            (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                         (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Fraction p>_P))
                   Language.Fortran.NullFraction a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Fraction p>_P)) }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Fraction p
    -> Data.Functor.Identity.Identity (Language.Fortran.Fraction p)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Fraction p) ->
                 case x0 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> (Language.Fortran.IntegerConst
                         @ p
                         (ds @ p $dData1 a1)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fraction p>_R))
                   Language.Fortran.FractionConst a1 a2 a3
                   -> (Language.Fortran.FractionConst
                         @ p
                         (ds @ p $dData1 a1)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fraction p>_R))
                   Language.Fortran.NullFraction a1
                   -> (Language.Fortran.NullFraction @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Fraction p>_R)) }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fraction
                        1889852645677985436##
                        4948538213526819213##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFraction4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Fraction
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Fraction
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
0647374775df27c207a781afabd1df4c
  $fDataFraction4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataFraction5) -}
fcedbb1a49549b7123400f0c5cdf07b2
  $fDataFraction5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fraction"#) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Fraction p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Fraction
                   @ p
                   Language.Fortran.$fDataFraction7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Fraction
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Fraction
                        1889852645677985436##
                        4948538213526819213##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataFraction4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Fraction
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Fraction p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataFraction3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Fraction p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Fraction p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Fraction <p>_N)) } } } }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Fraction p
    -> c (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           $dData1
                           (z @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                              (Language.Fortran.IntegerConst @ p))
                           a1)
                        a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.Fraction p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ GHC.Base.String
                           @ (GHC.Base.String -> Language.Fortran.Fraction p)
                           Data.Data.$fData[]_$s$fData[]
                           (k @ p
                              @ (GHC.Base.String
                                 -> GHC.Base.String -> Language.Fortran.Fraction p)
                              $dData1
                              (z @ (p
                                    -> GHC.Base.String
                                    -> GHC.Base.String
                                    -> Language.Fortran.Fraction p)
                                 (Language.Fortran.FractionConst @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.NullFraction a1
                   -> k @ p
                        @ (Language.Fortran.Fraction p)
                        $dData1
                        (z @ (p -> Language.Fortran.Fraction p)
                           (Language.Fortran.NullFraction @ p))
                        a1 }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U> -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Fraction p -> m (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u) ->
                 Language.Fortran.$fDataFraction_$cgmapQr
                   @ p
                   $dData1
                   @ [u]
                   @ u
                   (GHC.Types.: @ u)
                   (GHC.Types.[] @ u)
                   ds) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.Fraction p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi5 @ p w @ u ww1 w363 w364 }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Fraction p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Fraction p) ->
                 case x0 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> ds
                        (ds2 @ p $dData1 a1)
                        (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2) ds1)
                   Language.Fortran.FractionConst a1 a2 a3
                   -> ds
                        (ds2 @ p $dData1 a1)
                        (ds
                           (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                           (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3) ds1))
                   Language.Fortran.NullFraction a1
                   -> ds (ds2 @ p $dData1 a1) ds1 }) -}
e90c235f732876f3296896ca224d9121
  $fDataFraction_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Fraction p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold4 @ p w @ c w362 w363 ww1 ww5 }) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fDataGSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.GSpec
                                                                       p>_N)
                  (Language.Fortran.$fDataGSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataGSpec_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.GSpec p) ->
                   case ds of wild {
                     Language.Fortran.GName ds1 ds2 -> Language.Fortran.$cGName
                     Language.Fortran.GOper ds1 ds2 -> Language.Fortran.$cGOper
                     Language.Fortran.GAssg ds1 -> Language.Fortran.$cGAssg })
                  (\ (ds :: Language.Fortran.GSpec p) -> Language.Fortran.$tGSpec)
                  (Language.Fortran.$fDataGSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.GSpec p)))
                  (Language.Fortran.$fDataGSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.GSpec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.GSpec p>_R)
                  (Language.Fortran.$fDataGSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataGSpec_$cgmapMo @ p v) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.GSpec p
    -> Data.Functor.Identity.Identity (Language.Fortran.GSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$fDataGSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.GSpec
                        13649749436298333063##
                        7524181639333628935##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataGSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.GSpec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.GSpec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
32cd859a68fc4428b340fe500431d8e1
  $fDataGSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataGSpec4) -}
24b24ffd17c32e063df6d7a85ef33568
  $fDataGSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GSpec"#) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.GSpec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.GSpec
                   @ p
                   Language.Fortran.$fDataGSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.GSpec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.GSpec
                        13649749436298333063##
                        7524181639333628935##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataGSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.GSpec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.GSpec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataGSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.GSpec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.GSpec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.GSpec <p>_N)) } } } }) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.GSpec p
    -> c (Language.Fortran.GSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BinOp p)
                   = Language.Fortran.$fDataBinOp @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.GSpec p)
                        $dData3
                        (k @ p
                           @ (Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                           $dData1
                           (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                              (Language.Fortran.GName @ p))
                           a1)
                        a2
                   Language.Fortran.GOper a1 a2
                   -> k @ (Language.Fortran.BinOp p)
                        @ (Language.Fortran.GSpec p)
                        $dData2
                        (k @ p
                           @ (Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                           $dData1
                           (z @ (p -> Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                              (Language.Fortran.GOper @ p))
                           a1)
                        a2
                   Language.Fortran.GAssg a1
                   -> k @ p
                        @ (Language.Fortran.GSpec p)
                        $dData1
                        (z @ (p -> Language.Fortran.GSpec p) (Language.Fortran.GAssg @ p))
                        a1 }) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataGSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.GSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.GSpec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.GSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.GSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fDataGSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.GSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.GSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.GSpec p)
                           x' } })) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.GSpec p -> m (Language.Fortran.GSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.GSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.GSpec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.GSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.GSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fDataGSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.GSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.GSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.GSpec p)
                           x' } })) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.GSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.GSpec p) ->
                 (Language.Fortran.$fDataGSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.GSpec p>_P)
                   (GHC.Types.[] @ u)) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.GSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.GSpec p) ->
                 case Language.Fortran.$fDataGSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.GSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.GSpec p
                        -> Data.Functor.Const.Const r (Language.Fortran.GSpec p)
                   = Language.Fortran.$fDataGSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.GSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.GSpec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.GSpec p>_P)) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.GSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.GSpec p) ->
                 (Language.Fortran.$fDataGSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.GSpec p>_P)
                   ds1) -}
a074c18ee753392beb804aeb08ff8264
  $fDataGSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.GSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BinOp p)
                   = Language.Fortran.$fDataBinOp @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.GSpec p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.GSpec p)
                             $dData1
                             (z @ (p -> Language.Fortran.GSpec p) (Language.Fortran.GAssg @ p))
                        1#
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.GSpec p)
                             $dData3
                             (k @ p
                                @ (Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                                $dData1
                                (z @ (p -> Language.Fortran.Expr p -> Language.Fortran.GSpec p)
                                   (Language.Fortran.GName @ p)))
                        2#
                        -> k @ (Language.Fortran.BinOp p)
                             @ (Language.Fortran.GSpec p)
                             $dData2
                             (k @ p
                                @ (Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                                $dData1
                                (z @ (p -> Language.Fortran.BinOp p -> Language.Fortran.GSpec p)
                                   (Language.Fortran.GOper @ p))) } } } }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fDataImplicit8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Implicit
                                                                       p>_N)
                  (Language.Fortran.$fDataImplicit_$cgfoldl @ p v)
                  (Language.Fortran.$fDataImplicit_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Implicit p) ->
                   case ds of wild {
                     Language.Fortran.ImplicitNone ds1
                     -> Language.Fortran.$cImplicitNone
                     Language.Fortran.ImplicitNull ds1
                     -> Language.Fortran.$cImplicitNull })
                  (\ (ds :: Language.Fortran.Implicit p) ->
                   Language.Fortran.$tImplicit)
                  (Language.Fortran.$fDataImplicit_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Implicit p)))
                  (Language.Fortran.$fDataImplicit4 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Implicit p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Implicit p>_R)
                  (Language.Fortran.$fDataImplicit3 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.Implicit p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.Implicit p>_P)
                  (Language.Fortran.$fDataImplicit_$cgmapQr @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapQ @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapQi @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapM @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapMp @ p v)
                  (Language.Fortran.$fDataImplicit_$cgmapMo @ p v) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit1 ::
    (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.ImplicitNull @ p, GHC.Types.False)) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit2 ::
    (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.ImplicitNone @ p, GHC.Types.False)) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit3 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Implicit p
    -> Data.Functor.Const.Const r (Language.Fortran.Implicit p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.Implicit p) ->
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Implicit p>_P))
                   Language.Fortran.ImplicitNull a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.Implicit p>_P)) }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit4 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Implicit p
    -> Data.Functor.Identity.Identity (Language.Fortran.Implicit p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Implicit p) ->
                 case x0 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> (Language.Fortran.ImplicitNone @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Implicit p>_R))
                   Language.Fortran.ImplicitNull a1
                   -> (Language.Fortran.ImplicitNull @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.Implicit p>_R)) }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit5 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Implicit
                        15842512687850667938##
                        2055696988134619338##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataImplicit6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Implicit
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Implicit
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
0a9c7cf00af3f243141dd4a4260a9f61
  $fDataImplicit6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataImplicit7) -}
abed2051f69cf0f168bd97858558f17c
  $fDataImplicit7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Implicit"#) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Implicit p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Implicit
                   @ p
                   Language.Fortran.$fDataImplicit9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.Implicit
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Implicit
                        15842512687850667938##
                        2055696988134619338##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataImplicit6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Implicit
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Implicit p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataImplicit5 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Implicit p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Implicit p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Implicit <p>_N)) } } } }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Implicit p
    -> c (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (z @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNone @ p))
                        a1
                   Language.Fortran.ImplicitNull a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (z @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNull @ p))
                        a1 }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Implicit p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.ImplicitNone a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNone @ p))
                        a1
                   Language.Fortran.ImplicitNull a1
                   -> k @ p
                        @ (Language.Fortran.Implicit p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.Implicit p)
                           (Language.Fortran.ImplicitNull @ p))
                        a1 }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Implicit p -> m (Language.Fortran.Implicit p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Implicit p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Implicit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Implicit p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Implicit p, GHC.Types.Bool)
                   @ (Language.Fortran.Implicit p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)[OneShot]
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl296 :: m d = ds @ d $dData2 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl296
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.ImplicitNone a1
                      -> k @ p
                           @ (Language.Fortran.Implicit p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
                              (Language.Fortran.$fDataImplicit2 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <p -> Language.Fortran.Implicit p>_N))
                           a1
                      Language.Fortran.ImplicitNull a1
                      -> k @ p
                           @ (Language.Fortran.Implicit p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.Implicit p, GHC.Types.Bool)
                              (Language.Fortran.$fDataImplicit1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0]
                                     <m>_R <p -> Language.Fortran.Implicit p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.Implicit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Implicit p)
                           x' } })) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p -> [u]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Implicit p) ->
                 case x0 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u)
                   Language.Fortran.ImplicitNull a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u) }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.Implicit p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi3 @ p w @ u ww1 w363 w364 }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Implicit p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Implicit p) ->
                 case x0 of wild {
                   Language.Fortran.ImplicitNone a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.ImplicitNull a1
                   -> ds (ds2 @ p $dData1 a1) ds1 }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fDataImplicit_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Implicit p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold3 @ p w @ c w362 w363 ww1 ww5 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fDataIntentAttr6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.IntentAttr
                                                                       p>_N)
                  (Language.Fortran.$fDataIntentAttr_$cgfoldl @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.IntentAttr p) ->
                   case ds of wild {
                     Language.Fortran.In ds1 -> Language.Fortran.$cIn
                     Language.Fortran.Out ds1 -> Language.Fortran.$cOut
                     Language.Fortran.InOut ds1 -> Language.Fortran.$cInOut })
                  (\ (ds :: Language.Fortran.IntentAttr p) ->
                   Language.Fortran.$tIntentAttr)
                  (Language.Fortran.$fDataIntentAttr_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p)))
                  (Language.Fortran.$fDataIntentAttr2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.IntentAttr p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.IntentAttr p>_R)
                  (Language.Fortran.$fDataIntentAttr1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.IntentAttr p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.IntentAttr p>_P)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQr @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQ @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapQi @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapM @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapMp @ p v)
                  (Language.Fortran.$fDataIntentAttr_$cgmapMo @ p v) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.IntentAttr p
    -> Data.Functor.Const.Const r (Language.Fortran.IntentAttr p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.IntentAttr p) ->
                 case eta of wild {
                   Language.Fortran.In a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.IntentAttr p>_P))
                   Language.Fortran.Out a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.IntentAttr p>_P))
                   Language.Fortran.InOut a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.IntentAttr p>_P)) }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.IntentAttr p
    -> Data.Functor.Identity.Identity (Language.Fortran.IntentAttr p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.IntentAttr p) ->
                 case x0 of wild {
                   Language.Fortran.In a1
                   -> (Language.Fortran.In @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.IntentAttr p>_R))
                   Language.Fortran.Out a1
                   -> (Language.Fortran.Out @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.IntentAttr p>_R))
                   Language.Fortran.InOut a1
                   -> (Language.Fortran.InOut @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.IntentAttr p>_R)) }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.IntentAttr
                        16567170138751583230##
                        1916717445546230762##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataIntentAttr4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.IntentAttr
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.IntentAttr
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
e515d8314df5ee09f769aeb1b41715dc
  $fDataIntentAttr4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$fDataIntentAttr5) -}
6cd63b000fc0322e3f7c07ff9a5fc6ab
  $fDataIntentAttr5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IntentAttr"#) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.IntentAttr p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.IntentAttr
                   @ p
                   Language.Fortran.$fDataIntentAttr7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.IntentAttr
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.IntentAttr
                        16567170138751583230##
                        1916717445546230762##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataIntentAttr4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.IntentAttr
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.IntentAttr p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataIntentAttr3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.IntentAttr p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.IntentAttr p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.IntentAttr <p>_N)) } } } }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.IntentAttr p
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.In @ p))
                        a1
                   Language.Fortran.Out a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.Out @ p))
                        a1
                   Language.Fortran.InOut a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (z @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.InOut @ p))
                        a1 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.IntentAttr p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.In a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.In @ p))
                        a1
                   Language.Fortran.Out a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.Out @ p))
                        a1
                   Language.Fortran.InOut a1
                   -> k @ p
                        @ (Language.Fortran.IntentAttr p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.IntentAttr p)
                           (Language.Fortran.InOut @ p))
                        a1 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.IntentAttr p
    -> m (Language.Fortran.IntentAttr p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p -> [u]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u) ->
                 Language.Fortran.$fDataIntentAttr_$cgmapQr
                   @ p
                   $dData1
                   @ [u]
                   @ u
                   (GHC.Types.: @ u)
                   (GHC.Types.[] @ u)
                   ds) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.IntentAttr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi6 @ p w @ u ww1 w363 w364 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.IntentAttr p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.IntentAttr p) ->
                 case x0 of wild {
                   Language.Fortran.In a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.Out a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.InOut a1 -> ds (ds2 @ p $dData1 a1) ds1 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fDataIntentAttr_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold5 @ p w @ c w362 w363 ww1 ww5 }) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec ::
    Data.Data.Data p =>
    Data.Data.Data (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fDataInterfaceSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.InterfaceSpec
                                                                       p>_N)
                  (Language.Fortran.$fDataInterfaceSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.InterfaceSpec p) ->
                   case ds of wild {
                     Language.Fortran.FunctionInterface ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cFunctionInterface
                     Language.Fortran.SubroutineInterface ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cSubroutineInterface
                     Language.Fortran.ModuleProcedure ds1 ds2
                     -> Language.Fortran.$cModuleProcedure })
                  (\ (ds :: Language.Fortran.InterfaceSpec p) ->
                   Language.Fortran.$tInterfaceSpec)
                  (Language.Fortran.$fDataInterfaceSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p)))
                  (Language.Fortran.$fDataInterfaceSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.InterfaceSpec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.InterfaceSpec p>_R)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataInterfaceSpec_$cgmapMo @ p v) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.InterfaceSpec p
    -> Data.Functor.Identity.Identity
         (Language.Fortran.InterfaceSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.InterfaceSpec p) ->
                 Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.InterfaceSpec
                        4228692104607174657##
                        12410898481200544509##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataInterfaceSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.InterfaceSpec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.InterfaceSpec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
edf1764a2cb9f649b21ae586e325abd9
  $fDataInterfaceSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$fDataInterfaceSpec4) -}
3516fd8314c1b43bdb4719537e8161d0
  $fDataInterfaceSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InterfaceSpec"#) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.InterfaceSpec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.InterfaceSpec
                   @ p
                   Language.Fortran.$fDataInterfaceSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.InterfaceSpec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.InterfaceSpec
                        4228692104607174657##
                        12410898481200544509##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataInterfaceSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.InterfaceSpec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.InterfaceSpec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataInterfaceSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Base.Nothing @ (c (Language.Fortran.InterfaceSpec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.InterfaceSpec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.InterfaceSpec <p>_N)) } } } }) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.InterfaceSpec p
    -> c (Language.Fortran.InterfaceSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.InterfaceSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.InterfaceSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.InterfaceSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.InterfaceSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.InterfaceSpec p)
                           x' } })) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.InterfaceSpec p
    -> m (Language.Fortran.InterfaceSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.InterfaceSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.InterfaceSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.InterfaceSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.InterfaceSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.InterfaceSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.InterfaceSpec p)
                           x' } })) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.InterfaceSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.InterfaceSpec p) ->
                 (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <[u]>_R <Language.Fortran.InterfaceSpec p>_P)
                   (GHC.Types.[] @ u)) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.InterfaceSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.InterfaceSpec p) ->
                 case Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.InterfaceSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.InterfaceSpec p
                        -> Data.Functor.Const.Const r (Language.Fortran.InterfaceSpec p)
                   = Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.InterfaceSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.InterfaceSpec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.InterfaceSpec p>_P)) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.InterfaceSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.InterfaceSpec p) ->
                 (Language.Fortran.$fDataInterfaceSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <r>_R <Language.Fortran.InterfaceSpec p>_P)
                   ds1) -}
a81776e31635bc99f5c71e8648536701
  $fDataInterfaceSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.InterfaceSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.SubName p)
                   = Language.Fortran.$fDataSubName @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data [Language.Fortran.SubName p]
                   = Data.Data.$fData[] @ (Language.Fortran.SubName p) $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data (Language.Fortran.Arg p)
                   = Language.Fortran.$fDataArg @ p $dData1
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 let {
                   $dData6 :: Data.Data.Data (Language.Fortran.Implicit p)
                   = Language.Fortran.$fDataImplicit @ p $dData1
                 } in
                 let {
                   $dData7 :: Data.Data.Data (Language.Fortran.Decl p)
                   = Language.Fortran.$fDataDecl @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.InterfaceSpec p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ [Language.Fortran.SubName p]
                             @ (Language.Fortran.InterfaceSpec p)
                             $dData3
                             (k @ p
                                @ ([Language.Fortran.SubName p]
                                   -> Language.Fortran.InterfaceSpec p)
                                $dData1
                                (z @ (p
                                      -> [Language.Fortran.SubName p]
                                      -> Language.Fortran.InterfaceSpec p)
                                   (Language.Fortran.ModuleProcedure @ p)))
                        1#
                        -> k @ (Language.Fortran.Decl p)
                             @ (Language.Fortran.InterfaceSpec p)
                             $dData7
                             (k @ (Language.Fortran.Implicit p)
                                @ (Language.Fortran.Decl p -> Language.Fortran.InterfaceSpec p)
                                $dData6
                                (k @ (Language.Fortran.Uses p)
                                   @ (Language.Fortran.Implicit p
                                      -> Language.Fortran.Decl p
                                      -> Language.Fortran.InterfaceSpec p)
                                   $dData5
                                   (k @ (Language.Fortran.Arg p)
                                      @ (Language.Fortran.Uses p
                                         -> Language.Fortran.Implicit p
                                         -> Language.Fortran.Decl p
                                         -> Language.Fortran.InterfaceSpec p)
                                      $dData4
                                      (k @ (Language.Fortran.SubName p)
                                         @ (Language.Fortran.Arg p
                                            -> Language.Fortran.Uses p
                                            -> Language.Fortran.Implicit p
                                            -> Language.Fortran.Decl p
                                            -> Language.Fortran.InterfaceSpec p)
                                         $dData2
                                         (k @ p
                                            @ (Language.Fortran.SubName p
                                               -> Language.Fortran.Arg p
                                               -> Language.Fortran.Uses p
                                               -> Language.Fortran.Implicit p
                                               -> Language.Fortran.Decl p
                                               -> Language.Fortran.InterfaceSpec p)
                                            $dData1
                                            (z @ (p
                                                  -> Language.Fortran.SubName p
                                                  -> Language.Fortran.Arg p
                                                  -> Language.Fortran.Uses p
                                                  -> Language.Fortran.Implicit p
                                                  -> Language.Fortran.Decl p
                                                  -> Language.Fortran.InterfaceSpec p)
                                               (Language.Fortran.FunctionInterface @ p)))))))
                        2#
                        -> k @ (Language.Fortran.Decl p)
                             @ (Language.Fortran.InterfaceSpec p)
                             $dData7
                             (k @ (Language.Fortran.Implicit p)
                                @ (Language.Fortran.Decl p -> Language.Fortran.InterfaceSpec p)
                                $dData6
                                (k @ (Language.Fortran.Uses p)
                                   @ (Language.Fortran.Implicit p
                                      -> Language.Fortran.Decl p
                                      -> Language.Fortran.InterfaceSpec p)
                                   $dData5
                                   (k @ (Language.Fortran.Arg p)
                                      @ (Language.Fortran.Uses p
                                         -> Language.Fortran.Implicit p
                                         -> Language.Fortran.Decl p
                                         -> Language.Fortran.InterfaceSpec p)
                                      $dData4
                                      (k @ (Language.Fortran.SubName p)
                                         @ (Language.Fortran.Arg p
                                            -> Language.Fortran.Uses p
                                            -> Language.Fortran.Implicit p
                                            -> Language.Fortran.Decl p
                                            -> Language.Fortran.InterfaceSpec p)
                                         $dData2
                                         (k @ p
                                            @ (Language.Fortran.SubName p
                                               -> Language.Fortran.Arg p
                                               -> Language.Fortran.Uses p
                                               -> Language.Fortran.Implicit p
                                               -> Language.Fortran.Decl p
                                               -> Language.Fortran.InterfaceSpec p)
                                            $dData1
                                            (z @ (p
                                                  -> Language.Fortran.SubName p
                                                  -> Language.Fortran.Arg p
                                                  -> Language.Fortran.Uses p
                                                  -> Language.Fortran.Implicit p
                                                  -> Language.Fortran.Decl p
                                                  -> Language.Fortran.InterfaceSpec p)
                                               (Language.Fortran.SubroutineInterface
                                                  @ p))))))) } } } }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec ::
    Data.Data.Data p =>
    Data.Data.Data (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fDataMeasureUnitSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.MeasureUnitSpec
                                                                       p>_N)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.MeasureUnitSpec p) ->
                   case ds of wild {
                     Language.Fortran.UnitProduct ds1 ds2
                     -> Language.Fortran.$cUnitProduct
                     Language.Fortran.UnitQuotient ds1 ds2 ds3
                     -> Language.Fortran.$cUnitQuotient
                     Language.Fortran.UnitNone ds1 -> Language.Fortran.$cUnitNone })
                  (\ (ds :: Language.Fortran.MeasureUnitSpec p) ->
                   Language.Fortran.$tMeasureUnitSpec)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p)))
                  (Language.Fortran.$fDataMeasureUnitSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.MeasureUnitSpec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.MeasureUnitSpec p>_R)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataMeasureUnitSpec_$cgmapMo @ p v) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.MeasureUnitSpec p
    -> Data.Functor.Identity.Identity
         (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.MeasureUnitSpec
                        10313695227442128830##
                        1030832953143637957##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataMeasureUnitSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.MeasureUnitSpec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.MeasureUnitSpec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
49ad306c780dae60b0c65c672e8a16b6
  $fDataMeasureUnitSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$fDataMeasureUnitSpec4) -}
a3d3cb8d75b097fd79939cc33f863831
  $fDataMeasureUnitSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MeasureUnitSpec"#) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.MeasureUnitSpec
                   @ p
                   Language.Fortran.$fDataMeasureUnitSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.MeasureUnitSpec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.MeasureUnitSpec
                        10313695227442128830##
                        1030832953143637957##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataMeasureUnitSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.MeasureUnitSpec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.MeasureUnitSpec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataMeasureUnitSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT
                   -> GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT
                        -> GHC.Base.Nothing @ (c (Language.Fortran.MeasureUnitSpec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.MeasureUnitSpec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.MeasureUnitSpec <p>_N)) } } } }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.MeasureUnitSpec p
    -> c (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Fraction p)
                   = Language.Fortran.$fDataFraction @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = Data.Data.$fData(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       Data.Data.$fData[]_$s$fData[]
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                       $dData3
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> k @ [(Language.Fortran.MeasureUnit,
                            Language.Fortran.Fraction p)]
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData4
                        (k @ p
                           @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                              -> Language.Fortran.MeasureUnitSpec p)
                           $dData1
                           (z @ (p
                                 -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> Language.Fortran.MeasureUnitSpec p)
                              (Language.Fortran.UnitProduct @ p))
                           a1)
                        a2
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> k @ [(Language.Fortran.MeasureUnit,
                            Language.Fortran.Fraction p)]
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData4
                        (k @ [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                           @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                              -> Language.Fortran.MeasureUnitSpec p)
                           $dData4
                           (k @ p
                              @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                 -> Language.Fortran.MeasureUnitSpec p)
                              $dData1
                              (z @ (p
                                    -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                    -> [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                    -> Language.Fortran.MeasureUnitSpec p)
                                 (Language.Fortran.UnitQuotient @ p))
                              a1)
                           a2)
                        a3
                   Language.Fortran.UnitNone a1
                   -> k @ p
                        @ (Language.Fortran.MeasureUnitSpec p)
                        $dData1
                        (z @ (p -> Language.Fortran.MeasureUnitSpec p)
                           (Language.Fortran.UnitNone @ p))
                        a1 }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.MeasureUnitSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.MeasureUnitSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.MeasureUnitSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.MeasureUnitSpec p)
                           x' } })) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.MeasureUnitSpec p
    -> m (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.MeasureUnitSpec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.MeasureUnitSpec p)
                   = GHC.Base.mzero
                       @ m
                       $dMonadPlus
                       @ (Language.Fortran.MeasureUnitSpec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.MeasureUnitSpec p>_N)
                   (\ (ds1 :: (Language.Fortran.MeasureUnitSpec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.MeasureUnitSpec p)
                           x' } })) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.MeasureUnitSpec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.MeasureUnitSpec p) ->
                 (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <[u]>_R <Language.Fortran.MeasureUnitSpec p>_P)
                   (GHC.Types.[] @ u)) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.MeasureUnitSpec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.MeasureUnitSpec p) ->
                 case Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.MeasureUnitSpec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.MeasureUnitSpec p
                        -> Data.Functor.Const.Const r (Language.Fortran.MeasureUnitSpec p)
                   = Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.MeasureUnitSpec p) -> g x)
                   `cast`
                 (<Language.Fortran.MeasureUnitSpec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.MeasureUnitSpec p>_P)) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.MeasureUnitSpec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.MeasureUnitSpec p) ->
                 (Language.Fortran.$fDataMeasureUnitSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0]
                      <*>_N <r>_R <Language.Fortran.MeasureUnitSpec p>_P)
                   ds1) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fDataMeasureUnitSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.MeasureUnitSpec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Fraction p)
                   = Language.Fortran.$fDataFraction @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data
                                (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = Data.Data.$fData(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       Data.Data.$fData[]_$s$fData[]
                       $dData2
                 } in
                 let {
                   $dData4 :: Data.Data.Data
                                [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                       $dData3
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.MeasureUnitSpec p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ p
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData1
                             (z @ (p -> Language.Fortran.MeasureUnitSpec p)
                                (Language.Fortran.UnitNone @ p))
                        1#
                        -> k @ [(Language.Fortran.MeasureUnit,
                                 Language.Fortran.Fraction p)]
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData4
                             (k @ p
                                @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                   -> Language.Fortran.MeasureUnitSpec p)
                                $dData1
                                (z @ (p
                                      -> [(Language.Fortran.MeasureUnit,
                                           Language.Fortran.Fraction p)]
                                      -> Language.Fortran.MeasureUnitSpec p)
                                   (Language.Fortran.UnitProduct @ p)))
                        2#
                        -> k @ [(Language.Fortran.MeasureUnit,
                                 Language.Fortran.Fraction p)]
                             @ (Language.Fortran.MeasureUnitSpec p)
                             $dData4
                             (k @ [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                   -> Language.Fortran.MeasureUnitSpec p)
                                $dData4
                                (k @ p
                                   @ ([(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                                      -> [(Language.Fortran.MeasureUnit,
                                           Language.Fortran.Fraction p)]
                                      -> Language.Fortran.MeasureUnitSpec p)
                                   $dData1
                                   (z @ (p
                                         -> [(Language.Fortran.MeasureUnit,
                                              Language.Fortran.Fraction p)]
                                         -> [(Language.Fortran.MeasureUnit,
                                              Language.Fortran.Fraction p)]
                                         -> Language.Fortran.MeasureUnitSpec p)
                                      (Language.Fortran.UnitQuotient @ p)))) } } } }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fDataProgUnit5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.ProgUnit
                                                                       p>_N)
                  (Language.Fortran.$fDataProgUnit_$cgfoldl @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgunfold @ p v)
                  (Language.Fortran.$fDataProgUnit_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.ProgUnit p) ->
                   Language.Fortran.$tProgUnit)
                  (Language.Fortran.$fDataProgUnit_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p)))
                  (Language.Fortran.$fDataProgUnit1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.ProgUnit p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.ProgUnit p>_R)
                  (Language.Fortran.$fDataProgUnit_$cgmapQl @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapQr @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapQ @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapQi @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapM @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapMp @ p v)
                  (Language.Fortran.$fDataProgUnit_$cgmapMo @ p v) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.ProgUnit p
    -> Data.Functor.Identity.Identity (Language.Fortran.ProgUnit p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.ProgUnit p) ->
                 Language.Fortran.$fDataProgUnit_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ProgUnit
                        11656072102918246678##
                        4306480789967343201##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataProgUnit3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.ProgUnit
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.ProgUnit
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
531a9c8ac704d65b3d13a1b9633fee34
  $fDataProgUnit3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataProgUnit4) -}
de0dc64a3a9a9f9201ff82d640d60ddc
  $fDataProgUnit4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ProgUnit"#) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.ProgUnit p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.ProgUnit
                   @ p
                   Language.Fortran.$fDataProgUnit6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit6 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.ProgUnit
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.ProgUnit
                        11656072102918246678##
                        4306480789967343201##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataProgUnit3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.ProgUnit
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.ProgUnit p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataProgUnit2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.ProgUnit p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.ProgUnit p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.ProgUnit <p>_N)) } } } }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.ProgUnit p
    -> c (Language.Fortran.ProgUnit p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataProgUnit_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.ProgUnit p) ->
                 let {
                   lvl295 :: m (Language.Fortran.ProgUnit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.ProgUnit p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.ProgUnit p, GHC.Types.Bool)
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fDataProgUnit_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.ProgUnit p>_N)
                   (\ (ds1 :: (Language.Fortran.ProgUnit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.ProgUnit p)
                           x' } })) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.ProgUnit p -> m (Language.Fortran.ProgUnit p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.ProgUnit p) ->
                 let {
                   lvl295 :: m (Language.Fortran.ProgUnit p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.ProgUnit p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.ProgUnit p, GHC.Types.Bool)
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fDataProgUnit_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.ProgUnit p>_N)
                   (\ (ds1 :: (Language.Fortran.ProgUnit p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.ProgUnit p)
                           x' } })) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ProgUnit p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.ProgUnit p) ->
                 (Language.Fortran.$fDataProgUnit_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.ProgUnit p>_P)
                   (GHC.Types.[] @ u)) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.ProgUnit p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.ProgUnit p) ->
                 case Language.Fortran.$fDataProgUnit_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ProgUnit p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.ProgUnit p
                        -> Data.Functor.Const.Const r (Language.Fortran.ProgUnit p)
                   = Language.Fortran.$fDataProgUnit_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.ProgUnit p) -> g x)
                   `cast`
                 (<Language.Fortran.ProgUnit p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.ProgUnit p>_P)) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.ProgUnit p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.ProgUnit p) ->
                 (Language.Fortran.$fDataProgUnit_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.ProgUnit p>_P)
                   ds1) -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.ProgUnit p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
cf6f89a9a11f4455970aae08e46ad751
  $fDataProgUnit_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.ProgUnit p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: Language.Fortran.ProgUnit p) ->
                 case ds of wild {
                   Language.Fortran.Main ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cMain
                   Language.Fortran.Sub ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cSub
                   Language.Fortran.Function ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cFunction
                   Language.Fortran.Module ds1 ds2 ds3 ds4 ds5 ds6 ds7
                   -> Language.Fortran.$cModule
                   Language.Fortran.BlockData ds1 ds2 ds3 ds4 ds5 ds6
                   -> Language.Fortran.$cBlockData
                   Language.Fortran.PSeq ds1 ds2 ds3 ds4 -> Language.Fortran.$cPSeq
                   Language.Fortran.Prog ds1 ds2 ds3 -> Language.Fortran.$cProg
                   Language.Fortran.NullProg ds1 ds2 -> Language.Fortran.$cNullProg
                   Language.Fortran.IncludeProg ds1 ds2 ds3 ds4
                   -> Language.Fortran.$cIncludeProg }) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fDataSpec5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Spec
                                                                       p>_N)
                  (Language.Fortran.$fDataSpec_$cgfoldl @ p v)
                  (Language.Fortran.$fDataSpec_$cgunfold @ p v)
                  (Language.Fortran.$fDataSpec_$ctoConstr @ p v)
                  (\ (ds :: Language.Fortran.Spec p) -> Language.Fortran.$tSpec)
                  (Language.Fortran.$fDataSpec_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Spec p)))
                  (Language.Fortran.$fDataSpec1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Spec p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Spec p>_R)
                  (Language.Fortran.$fDataSpec_$cgmapQl @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapQr @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapQ @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapQi @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapM @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapMp @ p v)
                  (Language.Fortran.$fDataSpec_$cgmapMo @ p v) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Spec p
    -> Data.Functor.Identity.Identity (Language.Fortran.Spec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Spec p) ->
                 Language.Fortran.$fDataSpec_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Spec
                        13275808096239442906##
                        250083824345581740##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Spec
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Spec
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
9e0b0dd8fb619647fdfc792cd8382a28
  $fDataSpec3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataSpec4) -}
d7e898858bb4f985f58d06f6b3319cb0
  $fDataSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Spec"#) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Spec p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Spec
                   @ p
                   Language.Fortran.$fDataSpec6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Spec
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Spec
                        13275808096239442906##
                        250083824345581740##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSpec3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Spec
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Spec p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataSpec2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Spec p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Spec p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Spec p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Spec <p>_N)) } } } }) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Spec p
    -> c (Language.Fortran.Spec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataSpec_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Spec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Spec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Spec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Spec p, GHC.Types.Bool)
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fDataSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Spec p>_N)
                   (\ (ds1 :: (Language.Fortran.Spec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Spec p)
                           x' } })) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Spec p -> m (Language.Fortran.Spec p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Spec p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Spec p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Spec p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Spec p, GHC.Types.Bool)
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fDataSpec_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Spec p>_N)
                   (\ (ds1 :: (Language.Fortran.Spec p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Spec p)
                           x' } })) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Spec p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Spec p) ->
                 (Language.Fortran.$fDataSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Spec p>_P)
                   (GHC.Types.[] @ u)) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Spec p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Spec p) ->
                 case Language.Fortran.$fDataSpec_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Spec p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Spec p
                        -> Data.Functor.Const.Const r (Language.Fortran.Spec p)
                   = Language.Fortran.$fDataSpec_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Spec p) -> g x)
                   `cast`
                 (<Language.Fortran.Spec p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Spec p>_P)) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Spec p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Spec p) ->
                 (Language.Fortran.$fDataSpec_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Spec p>_P)
                   ds1) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Spec p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fDataSpec_$ctoConstr ::
    Data.Data.Data p => Language.Fortran.Spec p -> Data.Data.Constr
  {- Arity: 2, Strictness: <L,A><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ p (w :: Data.Data.Data p) (w362 :: Language.Fortran.Spec p) ->
                 case w362 of wild {
                   Language.Fortran.Access ds ds1 -> Language.Fortran.$cAccess
                   Language.Fortran.Action ds ds1 -> Language.Fortran.$cAction
                   Language.Fortran.Advance ds ds1 -> Language.Fortran.$cAdvance
                   Language.Fortran.Blank ds ds1 -> Language.Fortran.$cBlank
                   Language.Fortran.Delim ds ds1 -> Language.Fortran.$cDelim
                   Language.Fortran.Direct ds ds1 -> Language.Fortran.$cDirect
                   Language.Fortran.End ds ds1 -> Language.Fortran.$cEnd
                   Language.Fortran.Err ds ds1 -> Language.Fortran.$cErr
                   Language.Fortran.ExFile ds ds1 -> Language.Fortran.$cExFile
                   Language.Fortran.Exist ds ds1 -> Language.Fortran.$cExist
                   Language.Fortran.Eor ds ds1 -> Language.Fortran.$cEor
                   Language.Fortran.File ds ds1 -> Language.Fortran.$cFile
                   Language.Fortran.FMT ds ds1 -> Language.Fortran.$cFMT
                   Language.Fortran.Form ds ds1 -> Language.Fortran.$cForm
                   Language.Fortran.Formatted ds ds1 -> Language.Fortran.$cFormatted
                   Language.Fortran.Unformatted ds ds1
                   -> Language.Fortran.$cUnformatted
                   Language.Fortran.IOLength ds ds1 -> Language.Fortran.$cIOLength
                   Language.Fortran.IOStat ds ds1 -> Language.Fortran.$cIOStat
                   Language.Fortran.Name ds ds1 -> Language.Fortran.$cName
                   Language.Fortran.Named ds ds1 -> Language.Fortran.$cNamed
                   Language.Fortran.NoSpec ds ds1 -> Language.Fortran.$cNoSpec
                   Language.Fortran.Number ds ds1 -> Language.Fortran.$cNumber
                   Language.Fortran.Floating ds ds1 ds2 -> Language.Fortran.$cFloating
                   Language.Fortran.NextRec ds ds1 -> Language.Fortran.$cNextRec
                   Language.Fortran.NML ds ds1 -> Language.Fortran.$cNML
                   Language.Fortran.Opened ds ds1 -> Language.Fortran.$cOpened
                   Language.Fortran.Pad ds ds1 -> Language.Fortran.$cPad
                   Language.Fortran.Position ds ds1 -> Language.Fortran.$cPosition
                   Language.Fortran.Read ds ds1 -> Language.Fortran.$cRead
                   Language.Fortran.ReadWrite ds ds1 -> Language.Fortran.$cReadWrite
                   Language.Fortran.Rec ds ds1 -> Language.Fortran.$cRec
                   Language.Fortran.Recl ds ds1 -> Language.Fortran.$cRecl
                   Language.Fortran.Sequential ds ds1 -> Language.Fortran.$cSequential
                   Language.Fortran.Size ds ds1 -> Language.Fortran.$cSize
                   Language.Fortran.Status ds ds1 -> Language.Fortran.$cStatus
                   Language.Fortran.StringLit ds ds1 -> Language.Fortran.$cStringLit
                   Language.Fortran.Unit ds ds1 -> Language.Fortran.$cUnit
                   Language.Fortran.WriteSp ds ds1 -> Language.Fortran.$cWriteSp
                   Language.Fortran.Delimiter ds -> Language.Fortran.$cDelimiter }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc :: Data.Data.Data Language.Fortran.SrcLoc
  DFunId
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fDataSrcLoc7
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.SrcLoc>_N)
                  Language.Fortran.$fDataSrcLoc_$cgfoldl
                  Language.Fortran.$fDataSrcLoc_$cgunfold
                  Language.Fortran.$fDataSrcLoc_$ctoConstr
                  Language.Fortran.$fDataSrcLoc_$cdataTypeOf
                  Language.Fortran.$fDataSrcLoc_$cdataCast1
                  Language.Fortran.$fDataSrcLoc_$cdataCast2
                  Language.Fortran.$fDataSrcLoc2
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.SrcLoc>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.SrcLoc>_R)
                  Language.Fortran.$fDataSrcLoc1
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.SrcLoc>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.SrcLoc>_P)
                  Language.Fortran.$fDataSrcLoc_$cgmapQr
                  Language.Fortran.$fDataSrcLoc_$cgmapQ
                  Language.Fortran.$fDataSrcLoc_$cgmapQi
                  Language.Fortran.$fDataSrcLoc_$cgmapM
                  Language.Fortran.$fDataSrcLoc_$cgmapMp
                  Language.Fortran.$fDataSrcLoc_$cgmapMo -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc1 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SrcLoc
    -> Data.Functor.Const.Const r Language.Fortran.SrcLoc
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (w :: r -> r' -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (w364 :: Language.Fortran.SrcLoc) ->
                 case w364 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 (Language.Fortran.$w$cgmapQl @ r @ r' w w362 w363 ww1 ww2 ww3)
                   `cast`
                 (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.SrcLoc>_P)) }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc2 ::
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.SrcLoc
    -> Data.Functor.Identity.Identity Language.Fortran.SrcLoc
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: forall b. Data.Data.Data b => b -> b)
                   (w362 :: Language.Fortran.SrcLoc) ->
                 case w362 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 (Language.Fortran.SrcLoc
                    (w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1)
                    (w @ GHC.Types.Int Data.Data.$fDataInt ww2)
                    (w @ GHC.Types.Int Data.Data.$fDataInt ww3))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.SrcLoc>_R)) }) -}
d4fa2661f13ec5c977e114ed9a693ec6
  $fDataSrcLoc3 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataSrcLoc4) -}
09f753a257577fe8b4dcf1ee59293c43
  $fDataSrcLoc4 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cSrcLoc
                   (GHC.Types.[] @ Data.Data.Constr)) -}
b58d8bbe4227391d7455571ed6356127
  $fDataSrcLoc5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataSrcLoc6) -}
07e21e22259e758ce57298687e90e973
  $fDataSrcLoc6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SrcLoc"#) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.SrcLoc
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ *
                        @ Language.Fortran.SrcLoc
                        7192905692865965536##
                        6830086774534809197##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSrcLoc8
                        0#
                        GHC.Types.krep$*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ *
                   @ Language.Fortran.SrcLoc
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
65dcd6a6a9cd31be3d175859673b8f7c
  $fDataSrcLoc8 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataSrcLoc6) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cdataCast1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c Language.Fortran.SrcLoc)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing @ (c Language.Fortran.SrcLoc)) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe (c Language.Fortran.SrcLoc)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ t :: * -> * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds :: forall d e.
                          (Data.Data.Data d, Data.Data.Data e) =>
                          c (t d e)) ->
                 GHC.Base.Nothing @ (c Language.Fortran.SrcLoc)) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cdataTypeOf ::
    Language.Fortran.SrcLoc -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Language.Fortran.SrcLoc) -> Language.Fortran.$tSrcLoc) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.SrcLoc
    -> c Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (w :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (w362 :: forall g. g -> c g)
                   (w363 :: Language.Fortran.SrcLoc) ->
                 case w363 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgfoldl @ c w w362 ww1 ww2 ww3 }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w :: GHC.Base.Monad m)
                   (w362 :: forall d. Data.Data.Data d => d -> m d)
                   (w363 :: Language.Fortran.SrcLoc) ->
                 case w363 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapM @ m w w362 ww1 ww2 ww3 }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgmapMo ::
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)> -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgmapMp ::
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SrcLoc -> m Language.Fortran.SrcLoc
  {- Arity: 3,
     Strictness: <S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)> -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SrcLoc -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U,U)>m2, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (w :: forall d. Data.Data.Data d => d -> u)
                   (w362 :: Language.Fortran.SrcLoc) ->
                 case w362 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 GHC.Types.:
                   @ u
                   (w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1)
                   (GHC.Types.:
                      @ u
                      (w @ GHC.Types.Int Data.Data.$fDataInt ww2)
                      (GHC.Types.:
                         @ u
                         (w @ GHC.Types.Int Data.Data.$fDataInt ww3)
                         (GHC.Types.[] @ u))) }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SrcLoc
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (w :: GHC.Types.Int)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.SrcLoc) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.SrcLoc ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgmapQi @ u ww1 w362 ww3 ww4 ww5 } }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (w :: r' -> r -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (w364 :: Language.Fortran.SrcLoc) ->
                 case w364 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cgmapQr @ r @ r' w w362 w363 ww1 ww2 ww3 }) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c Language.Fortran.SrcLoc
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ c :: * -> *
                   (w :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w362 :: forall r. r -> c r)
                   (w363 :: Data.Data.Constr) ->
                 Language.Fortran.$w$cgunfold @ c w w362) -}
5d55b2485fd718d78674934e1c1437fb
  $fDataSrcLoc_$ctoConstr ::
    Language.Fortran.SrcLoc -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 ->
                 Language.Fortran.$cSrcLoc }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fDataSubName6 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.SubName
                                                                       p>_N)
                  (Language.Fortran.$fDataSubName_$cgfoldl @ p v)
                  (Language.Fortran.$fDataSubName_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.SubName p) ->
                   case ds of wild {
                     Language.Fortran.SubName ds1 ds2 -> Language.Fortran.$cSubName
                     Language.Fortran.NullSubName ds1
                     -> Language.Fortran.$cNullSubName })
                  (\ (ds :: Language.Fortran.SubName p) ->
                   Language.Fortran.$tSubName)
                  (Language.Fortran.$fDataSubName_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.SubName p)))
                  (Language.Fortran.$fDataSubName2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.SubName p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.SubName p>_R)
                  (Language.Fortran.$fDataSubName1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.SubName p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.SubName p>_P)
                  (Language.Fortran.$fDataSubName_$cgmapQr @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapQ @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapQi @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapM @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapMp @ p v)
                  (Language.Fortran.$fDataSubName_$cgmapMo @ p v) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SubName p
    -> Data.Functor.Const.Const r (Language.Fortran.SubName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.SubName p) ->
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> (ds
                         (ds ds1 (ds2 @ p $dData1 a1))
                         (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.SubName p>_P))
                   Language.Fortran.NullSubName a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.SubName p>_P)) }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.SubName p
    -> Data.Functor.Identity.Identity (Language.Fortran.SubName p)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.SubName p) ->
                 case x0 of wild {
                   Language.Fortran.SubName a1 a2
                   -> (Language.Fortran.SubName
                         @ p
                         (ds @ p $dData1 a1)
                         (ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.SubName p>_R))
                   Language.Fortran.NullSubName a1
                   -> (Language.Fortran.NullSubName @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.SubName p>_R)) }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.SubName
                        1348816486169742693##
                        5881755746003561474##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSubName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.SubName
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.SubName
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
5234a868c858dda7883de4140169eb86
  $fDataSubName4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataSubName5) -}
22e904e14c87cd0227c2c62e44e52246
  $fDataSubName5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SubName"#) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName6 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.SubName p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.SubName
                   @ p
                   Language.Fortran.$fDataSubName7
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName7 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.SubName
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.SubName
                        1348816486169742693##
                        5881755746003561474##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataSubName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.SubName
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.SubName p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataSubName3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.SubName p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.SubName p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.SubName p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.SubName <p>_N)) } } } }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.SubName p
    -> c (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> k @ GHC.Base.String
                        @ (Language.Fortran.SubName p)
                        Data.Data.$fData[]_$s$fData[]
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.SubName p)
                           $dData1
                           (z @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                              (Language.Fortran.SubName @ p))
                           a1)
                        a2
                   Language.Fortran.NullSubName a1
                   -> k @ p
                        @ (Language.Fortran.SubName p)
                        $dData1
                        (z @ (p -> Language.Fortran.SubName p)
                           (Language.Fortran.NullSubName @ p))
                        a1 }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.SubName p) ->
                 let {
                   $sk :: forall b. m (GHC.Base.String -> b) -> GHC.Base.String -> m b
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ @ b
                       (c :: m (GHC.Base.String -> b))[OneShot]
                       (x :: GHC.Base.String)[OneShot] ->
                     let {
                       lvl295 :: m GHC.Base.String
                       = ds @ GHC.Base.String Data.Data.$fData[]_$s$fData[] x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (GHC.Base.String -> b)
                       @ b
                       c
                       (\ (c' :: GHC.Base.String -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ GHC.Base.String
                          @ b
                          lvl295
                          (\ (x' :: GHC.Base.String) ->
                           GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.SubName a1 a2
                   -> $sk
                        @ (Language.Fortran.SubName p)
                        (k @ p
                           @ (GHC.Base.String -> Language.Fortran.SubName p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                              (Language.Fortran.SubName @ p))
                           a1)
                        a2
                   Language.Fortran.NullSubName a1
                   -> k @ p
                        @ (Language.Fortran.SubName p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.SubName p)
                           (Language.Fortran.NullSubName @ p))
                        a1 }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.SubName p -> m (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U> -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U>m2, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.SubName p) ->
                 case w363 of wild {
                   Language.Fortran.SubName a1 a2
                   -> GHC.Types.:
                        @ u
                        (w362 @ p w a1)
                        (GHC.Types.:
                           @ u
                           (w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2)
                           (GHC.Types.[] @ u))
                   Language.Fortran.NullSubName a1
                   -> GHC.Types.: @ u (w362 @ p w a1) (GHC.Types.[] @ u) }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.SubName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi2 @ p w @ u ww1 w363 w364 }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.SubName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.SubName p) ->
                 case x0 of wild {
                   Language.Fortran.SubName a1 a2
                   -> ds
                        (ds2 @ p $dData1 a1)
                        (ds (ds2 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2) ds1)
                   Language.Fortran.NullSubName a1
                   -> ds (ds2 @ p $dData1 a1) ds1 }) -}
2661346c18056b3b907f62427e1b219c
  $fDataSubName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.SubName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold1 @ p w @ c w362 w363 ww1 ww5 }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fDataType5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Type
                                                                       p>_N)
                  (Language.Fortran.$fDataType_$cgfoldl @ p v)
                  (Language.Fortran.$fDataType_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Type p) ->
                   case ds of wild {
                     Language.Fortran.BaseType ds1 ds2 ds3 ds4 ds5
                     -> Language.Fortran.$cBaseType
                     Language.Fortran.ArrayT ds1 ds2 ds3 ds4 ds5 ds6
                     -> Language.Fortran.$cArrayT })
                  (\ (ds :: Language.Fortran.Type p) -> Language.Fortran.$tType)
                  (Language.Fortran.$fDataType_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Type p)))
                  (Language.Fortran.$fDataType1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Type p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Type p>_R)
                  (Language.Fortran.$fDataType_$cgmapQl @ p v)
                  (Language.Fortran.$fDataType_$cgmapQr @ p v)
                  (Language.Fortran.$fDataType_$cgmapQ @ p v)
                  (Language.Fortran.$fDataType_$cgmapQi @ p v)
                  (Language.Fortran.$fDataType_$cgmapM @ p v)
                  (Language.Fortran.$fDataType_$cgmapMp @ p v)
                  (Language.Fortran.$fDataType_$cgmapMo @ p v) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Type p
    -> Data.Functor.Identity.Identity (Language.Fortran.Type p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.Type p) ->
                 Language.Fortran.$fDataType_$cgfoldl
                   @ p
                   $dData1
                   @ Data.Functor.Identity.Identity
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (ds1 :: Data.Functor.Identity.Identity (d -> b))
                      (x :: d) ->
                    ds1 `cast` (Data.Functor.Identity.N:Identity[0] <d -> b>_R)
                      (ds @ d $dData2 x))
                     `cast`
                   (forall (d :: <*>_N) (b :: <*>_N).
                    <Data.Data.Data d>_R
                    ->_R <Data.Functor.Identity.Identity (d -> b)>_R
                    ->_R <d>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R))
                   Language.Fortran.$fDataArg7
                     `cast`
                   (forall (g :: <*>_N).
                    <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R))
                   x0) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Type
                        3614205270264252361##
                        2736214399804263991##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Type
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Type
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
d6bb6298d86b66cdc533e02a551cf552
  $fDataType3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataType4) -}
f2f3e8f2ca7872247b0f6336b792a083
  $fDataType4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Type"#) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Type p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Type
                   @ p
                   Language.Fortran.$fDataType6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Type
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Type
                        3614205270264252361##
                        2736214399804263991##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataType3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Type
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Type p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataType2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Type p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Type p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Type p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Type <p>_N)) } } } }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Type p
    -> c (Language.Fortran.Type p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data [Language.Fortran.Attr p]
                   = Data.Data.$fData[] @ (Language.Fortran.Attr p) $dData3
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData6 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData5
                       $dData5
                 } in
                 let {
                   $dData7 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData6
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.Type p)
                        $dData5
                        (k @ (Language.Fortran.Expr p)
                           @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                           $dData5
                           (k @ [Language.Fortran.Attr p]
                              @ (Language.Fortran.Expr p
                                 -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                              $dData4
                              (k @ (Language.Fortran.BaseType p)
                                 @ ([Language.Fortran.Attr p]
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Type p)
                                 $dData2
                                 (k @ p
                                    @ (Language.Fortran.BaseType p
                                       -> [Language.Fortran.Attr p]
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Type p)
                                    $dData1
                                    (z @ (p
                                          -> Language.Fortran.BaseType p
                                          -> [Language.Fortran.Attr p]
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Type p)
                                       (Language.Fortran.BaseType @ p))
                                    a1)
                                 a2)
                              a3)
                           a4)
                        a5
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> k @ (Language.Fortran.Expr p)
                        @ (Language.Fortran.Type p)
                        $dData5
                        (k @ (Language.Fortran.Expr p)
                           @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                           $dData5
                           (k @ [Language.Fortran.Attr p]
                              @ (Language.Fortran.Expr p
                                 -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                              $dData4
                              (k @ (Language.Fortran.BaseType p)
                                 @ ([Language.Fortran.Attr p]
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Expr p
                                    -> Language.Fortran.Type p)
                                 $dData2
                                 (k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                    @ (Language.Fortran.BaseType p
                                       -> [Language.Fortran.Attr p]
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Expr p
                                       -> Language.Fortran.Type p)
                                    $dData7
                                    (k @ p
                                       @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                          -> Language.Fortran.BaseType p
                                          -> [Language.Fortran.Attr p]
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Expr p
                                          -> Language.Fortran.Type p)
                                       $dData1
                                       (z @ (p
                                             -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                             -> Language.Fortran.BaseType p
                                             -> [Language.Fortran.Attr p]
                                             -> Language.Fortran.Expr p
                                             -> Language.Fortran.Expr p
                                             -> Language.Fortran.Type p)
                                          (Language.Fortran.ArrayT @ p))
                                       a1)
                                    a2)
                                 a3)
                              a4)
                           a5)
                        a6 }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 Language.Fortran.$fDataType_$cgfoldl
                   @ p
                   $dData1
                   @ m
                   (\ @ d
                      @ b
                      ($dData2 :: Data.Data.Data d)
                      (c :: m (d -> b))
                      (x :: d) ->
                    let {
                      lvl295 :: m d = ds @ d $dData2 x
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (d -> b)
                      @ b
                      c
                      (\ (c' :: d -> b) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ d
                         @ b
                         lvl295
                         (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x'))))
                   (\ @ g -> GHC.Base.return @ m $dMonad @ g)) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Type p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Type p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Type p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Type p, GHC.Types.Bool)
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fDataType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          case b1 of wild1 {
                            GHC.Types.False
                            -> GHC.Base.mplus
                                 @ m
                                 $dMonadPlus
                                 @ (b, GHC.Types.Bool)
                                 (GHC.Base.>>=
                                    @ m
                                    $dMonad
                                    @ d
                                    @ (b, GHC.Types.Bool)
                                    lvl296
                                    (\ (y' :: d) ->
                                     GHC.Base.return
                                       @ m
                                       $dMonad
                                       @ (b, GHC.Types.Bool)
                                       (h y', GHC.Types.True)))
                                 (GHC.Base.return
                                    @ m
                                    $dMonad
                                    @ (b, GHC.Types.Bool)
                                    (h y, GHC.Types.False))
                            GHC.Types.True
                            -> GHC.Base.return
                                 @ m
                                 $dMonad
                                 @ (b, GHC.Types.Bool)
                                 (h y, GHC.Types.True) } }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Type p>_N)
                   (\ (ds1 :: (Language.Fortran.Type p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Type p)
                           x' } })) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Type p -> m (Language.Fortran.Type p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.Type p) ->
                 let {
                   lvl295 :: m (Language.Fortran.Type p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.Type p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.Type p, GHC.Types.Bool)
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fDataType_$cgfoldl
                      @ p
                      $dData1
                      @ (Data.Data.Mp m)
                      (\ @ d
                         @ b
                         ($dData2 :: Data.Data.Data d)
                         (ds1 :: Data.Data.Mp m (d -> b))
                         (y :: d) ->
                       let {
                         lvl296 :: m d = ds @ d $dData2 y
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (d -> b, GHC.Types.Bool)
                         @ (b, GHC.Types.Bool)
                         ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                         (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                          case ds2 of wild { (,) h b1 ->
                          GHC.Base.mplus
                            @ m
                            $dMonadPlus
                            @ (b, GHC.Types.Bool)
                            (GHC.Base.>>=
                               @ m
                               $dMonad
                               @ d
                               @ (b, GHC.Types.Bool)
                               lvl296
                               (\ (y' :: d) ->
                                GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (b, GHC.Types.Bool)
                                  (h y', GHC.Types.True)))
                            (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) }))
                        `cast`
                      (forall (d :: <*>_N) (b :: <*>_N).
                       <Data.Data.Data d>_R
                       ->_R <Data.Data.Mp m (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Data.N:Mp[0] <m>_R <b>_N))
                      (\ @ g (g1 :: g) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (g, GHC.Types.Bool)
                         (g1, GHC.Types.False))
                        `cast`
                      (forall (g :: <*>_N).
                       <g>_R ->_R Sym (Data.Data.N:Mp[0] <m>_R <g>_N))
                      eta)
                     `cast`
                   (Data.Data.N:Mp[0] <m>_R <Language.Fortran.Type p>_N)
                   (\ (ds1 :: (Language.Fortran.Type p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.Type p)
                           x' } })) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Type p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.Type p) ->
                 (Language.Fortran.$fDataType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr [u])
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds1 :: Data.Data.Qr [u] (d -> b))
                       (x :: d)
                       (r1 :: [u]) ->
                     ds1 `cast` (Data.Data.N:Qr[0] <*>_N <[u]>_R <d -> b>_P)
                       (GHC.Types.: @ u (ds @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr [u] (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <b>_P))
                    (Language.Fortran.$fDataArg4 @ u)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <[u]>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <[u]>_R <Language.Fortran.Type p>_P)
                   (GHC.Types.[] @ u)) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Type p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.Type p) ->
                 case Language.Fortran.$fDataType_$cgfoldl
                        @ p
                        $dData1
                        @ (Data.Data.Qi u)
                        (\ @ d
                           @ b
                           ($dData2 :: Data.Data.Data d)
                           (ds2 :: Data.Data.Qi u (d -> b))
                           (a1 :: d) ->
                         case ds2 of wild { Data.Data.Qi i' q ->
                         Data.Data.Qi
                           @ *
                           @ u
                           @ b
                           (case i' of wild1 { GHC.Types.I# x1 ->
                            GHC.Types.I# (GHC.Prim.+# x1 1#) })
                           (case ds of wild1 { GHC.Types.I# x1 ->
                            case i' of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.==# x1 y of lwild {
                              DEFAULT -> q 1# -> GHC.Base.Just @ u (ds1 @ d $dData2 a1) } } }) })
                        (Language.Fortran.$fDataArg1 @ u)
                        x of wild { Data.Data.Qi ds2 q ->
                 Data.Maybe.fromJust @ u q }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Type p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   g :: Language.Fortran.Type p
                        -> Data.Functor.Const.Const r (Language.Fortran.Type p)
                   = Language.Fortran.$fDataType_$cgfoldl
                       @ p
                       $dData1
                       @ (Data.Functor.Const.Const r)
                       (\ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)
                          (c :: Data.Functor.Const.Const r (d -> b))
                          (x :: d) ->
                        ds
                          c `cast` (Data.Functor.Const.N:Const[0] <*>_N <r>_R <d -> b>_P)
                          (ds2 @ d $dData2 x))
                         `cast`
                       (forall (d :: <*>_N) (b :: <*>_N).
                        <Data.Data.Data d>_R
                        ->_R <Data.Functor.Const.Const r (d -> b)>_R
                        ->_R <d>_R
                        ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <b>_P))
                       (\ @ g1 (ds3 :: g1) -> ds1)
                         `cast`
                       (forall (g1 :: <*>_N).
                        <g1>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r>_R <g1>_P))
                 } in
                 (\ (x :: Language.Fortran.Type p) -> g x)
                   `cast`
                 (<Language.Fortran.Type p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.Type p>_P)) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Type p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.Type p) ->
                 (Language.Fortran.$fDataType_$cgfoldl
                    @ p
                    $dData1
                    @ (Data.Data.Qr r)
                    (\ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)
                       (ds3 :: Data.Data.Qr r (d -> b))
                       (x :: d)
                       (r1 :: r) ->
                     ds3 `cast` (Data.Data.N:Qr[0] <*>_N <r>_R <d -> b>_P)
                       (ds (ds2 @ d $dData2 x) r1))
                      `cast`
                    (forall (d :: <*>_N) (b :: <*>_N).
                     <Data.Data.Data d>_R
                     ->_R <Data.Data.Qr r (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <b>_P))
                    (Language.Fortran.$fDataArg5 @ r)
                      `cast`
                    (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r>_R <g>_P))
                    x0)
                   `cast`
                 (Data.Data.N:Qr[0] <*>_N <r>_R <Language.Fortran.Type p>_P)
                   ds1) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fDataType_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Type p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.BaseType p)
                   = Language.Fortran.$fDataBaseType @ p $dData1
                 } in
                 let {
                   $dData3 :: Data.Data.Data (Language.Fortran.Attr p)
                   = Language.Fortran.$fDataAttr @ p $dData1
                 } in
                 let {
                   $dData4 :: Data.Data.Data [Language.Fortran.Attr p]
                   = Data.Data.$fData[] @ (Language.Fortran.Attr p) $dData3
                 } in
                 let {
                   $dData5 :: Data.Data.Data (Language.Fortran.Expr p)
                   = Language.Fortran.$fDataExpr @ p $dData1
                 } in
                 let {
                   $dData6 :: Data.Data.Data
                                (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = Data.Data.$fData(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dData5
                       $dData5
                 } in
                 let {
                   $dData7 :: Data.Data.Data
                                [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   = Data.Data.$fData[]
                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                       $dData6
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (c1 :: Data.Data.Constr) ->
                 case c1 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 {
                   DEFAULT
                   -> case ds4 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.Type p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild2 { GHC.Types.I# ds7 ->
                      case ds7 of ds8 {
                        DEFAULT
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.Type p)
                             $dData5
                             (k @ (Language.Fortran.Expr p)
                                @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                                $dData5
                                (k @ [Language.Fortran.Attr p]
                                   @ (Language.Fortran.Expr p
                                      -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                                   $dData4
                                   (k @ (Language.Fortran.BaseType p)
                                      @ ([Language.Fortran.Attr p]
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Type p)
                                      $dData2
                                      (k @ [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                         @ (Language.Fortran.BaseType p
                                            -> [Language.Fortran.Attr p]
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Type p)
                                         $dData7
                                         (k @ p
                                            @ ([(Language.Fortran.Expr p, Language.Fortran.Expr p)]
                                               -> Language.Fortran.BaseType p
                                               -> [Language.Fortran.Attr p]
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Type p)
                                            $dData1
                                            (z @ (p
                                                  -> [(Language.Fortran.Expr p,
                                                       Language.Fortran.Expr p)]
                                                  -> Language.Fortran.BaseType p
                                                  -> [Language.Fortran.Attr p]
                                                  -> Language.Fortran.Expr p
                                                  -> Language.Fortran.Expr p
                                                  -> Language.Fortran.Type p)
                                               (Language.Fortran.ArrayT @ p)))))))
                        1#
                        -> k @ (Language.Fortran.Expr p)
                             @ (Language.Fortran.Type p)
                             $dData5
                             (k @ (Language.Fortran.Expr p)
                                @ (Language.Fortran.Expr p -> Language.Fortran.Type p)
                                $dData5
                                (k @ [Language.Fortran.Attr p]
                                   @ (Language.Fortran.Expr p
                                      -> Language.Fortran.Expr p -> Language.Fortran.Type p)
                                   $dData4
                                   (k @ (Language.Fortran.BaseType p)
                                      @ ([Language.Fortran.Attr p]
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Expr p
                                         -> Language.Fortran.Type p)
                                      $dData2
                                      (k @ p
                                         @ (Language.Fortran.BaseType p
                                            -> [Language.Fortran.Attr p]
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Expr p
                                            -> Language.Fortran.Type p)
                                         $dData1
                                         (z @ (p
                                               -> Language.Fortran.BaseType p
                                               -> [Language.Fortran.Attr p]
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Expr p
                                               -> Language.Fortran.Type p)
                                            (Language.Fortran.BaseType @ p)))))) } } } }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fDataUnaryOp8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.UnaryOp
                                                                       p>_N)
                  (Language.Fortran.$fDataUnaryOp_$cgfoldl @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.UnaryOp p) ->
                   case ds of wild {
                     Language.Fortran.UMinus ds1 -> Language.Fortran.$cUMinus
                     Language.Fortran.Not ds1 -> Language.Fortran.$cNot })
                  (\ (ds :: Language.Fortran.UnaryOp p) ->
                   Language.Fortran.$tUnaryOp)
                  (Language.Fortran.$fDataUnaryOp_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p)))
                  (Language.Fortran.$fDataUnaryOp4 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.UnaryOp p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.UnaryOp p>_R)
                  (Language.Fortran.$fDataUnaryOp3 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.UnaryOp p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.UnaryOp p>_P)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQr @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQ @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapQi @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapM @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapMp @ p v)
                  (Language.Fortran.$fDataUnaryOp_$cgmapMo @ p v) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp1 :: (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.Not @ p, GHC.Types.False)) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp2 :: (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ p ->
                 (Language.Fortran.UMinus @ p, GHC.Types.False)) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp3 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UnaryOp p
    -> Data.Functor.Const.Const r (Language.Fortran.UnaryOp p)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: Language.Fortran.UnaryOp p) ->
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.UnaryOp p>_P))
                   Language.Fortran.Not a1
                   -> (ds ds1 (ds2 @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <Language.Fortran.UnaryOp p>_P)) }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp4 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.UnaryOp p
    -> Data.Functor.Identity.Identity (Language.Fortran.UnaryOp p)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.UnaryOp p) ->
                 case x0 of wild {
                   Language.Fortran.UMinus a1
                   -> (Language.Fortran.UMinus @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.UnaryOp p>_R))
                   Language.Fortran.Not a1
                   -> (Language.Fortran.Not @ p (ds @ p $dData1 a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Language.Fortran.UnaryOp p>_R)) }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp5 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UnaryOp
                        8773601993262595020##
                        17595838481592517464##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUnaryOp6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.UnaryOp
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.UnaryOp
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
124b15e481c4847ef64ccd1415ccf749
  $fDataUnaryOp6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataUnaryOp7) -}
50d1c9054f76495a92b1d8dee31ce90c
  $fDataUnaryOp7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UnaryOp"#) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.UnaryOp p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.UnaryOp
                   @ p
                   Language.Fortran.$fDataUnaryOp9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.UnaryOp
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UnaryOp
                        8773601993262595020##
                        17595838481592517464##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUnaryOp6
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.UnaryOp
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.UnaryOp p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataUnaryOp5 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UnaryOp p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.UnaryOp p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.UnaryOp <p>_N)) } } } }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.UnaryOp p
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (z @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.UMinus @ p))
                        a1
                   Language.Fortran.Not a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (z @ (p -> Language.Fortran.UnaryOp p) (Language.Fortran.Not @ p))
                        a1 }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 let {
                   k :: forall d b. Data.Data.Data d => m (d -> b) -> d -> m b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ @ d
                       @ b
                       ($dData2 :: Data.Data.Data d)[OneShot]
                       (c :: m (d -> b))[OneShot]
                       (x :: d)[OneShot] ->
                     let {
                       lvl295 :: m d = ds @ d $dData2 x
                     } in
                     GHC.Base.>>=
                       @ m
                       $dMonad
                       @ (d -> b)
                       @ b
                       c
                       (\ (c' :: d -> b) ->
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ d
                          @ b
                          lvl295
                          (\ (x' :: d) -> GHC.Base.return @ m $dMonad @ b (c' x')))
                 } in
                 case eta of wild {
                   Language.Fortran.UMinus a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.UMinus @ p))
                        a1
                   Language.Fortran.Not a1
                   -> k @ p
                        @ (Language.Fortran.UnaryOp p)
                        $dData1
                        (GHC.Base.return
                           @ m
                           $dMonad
                           @ (p -> Language.Fortran.UnaryOp p)
                           (Language.Fortran.Not @ p))
                        a1 }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U> -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UnaryOp p -> m (Language.Fortran.UnaryOp p)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonadPlus :: GHC.Base.MonadPlus m)
                   (ds :: forall d. Data.Data.Data d => d -> m d)
                   (eta :: Language.Fortran.UnaryOp p) ->
                 let {
                   lvl295 :: m (Language.Fortran.UnaryOp p)
                   = GHC.Base.mzero @ m $dMonadPlus @ (Language.Fortran.UnaryOp p)
                 } in
                 let {
                   $dMonad :: GHC.Base.Monad m = GHC.Base.$p2MonadPlus @ m $dMonadPlus
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.UnaryOp p, GHC.Types.Bool)
                   @ (Language.Fortran.UnaryOp p)
                   (let {
                      k :: forall d b.
                           Data.Data.Data d =>
                           Data.Data.Mp m (d -> b) -> d -> m (b, GHC.Types.Bool)
                        {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                      = \ @ d
                          @ b
                          ($dData2 :: Data.Data.Data d)[OneShot]
                          (ds1 :: Data.Data.Mp m (d -> b))[OneShot]
                          (y :: d)[OneShot] ->
                        let {
                          lvl296 :: m d = ds @ d $dData2 y
                        } in
                        GHC.Base.>>=
                          @ m
                          $dMonad
                          @ (d -> b, GHC.Types.Bool)
                          @ (b, GHC.Types.Bool)
                          ds1 `cast` (Data.Data.N:Mp[0] <m>_R <d -> b>_N)
                          (\ (ds2 :: (d -> b, GHC.Types.Bool)) ->
                           case ds2 of wild { (,) h b1 ->
                           GHC.Base.mplus
                             @ m
                             $dMonadPlus
                             @ (b, GHC.Types.Bool)
                             (GHC.Base.>>=
                                @ m
                                $dMonad
                                @ d
                                @ (b, GHC.Types.Bool)
                                lvl296
                                (\ (y' :: d) ->
                                 GHC.Base.return
                                   @ m
                                   $dMonad
                                   @ (b, GHC.Types.Bool)
                                   (h y', GHC.Types.True)))
                             (GHC.Base.return @ m $dMonad @ (b, GHC.Types.Bool) (h y, b1)) })
                    } in
                    case eta of wild {
                      Language.Fortran.UMinus a1
                      -> k @ p
                           @ (Language.Fortran.UnaryOp p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
                              (Language.Fortran.$fDataUnaryOp2 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.UnaryOp p>_N))
                           a1
                      Language.Fortran.Not a1
                      -> k @ p
                           @ (Language.Fortran.UnaryOp p)
                           $dData1
                           (GHC.Base.return
                              @ m
                              $dMonad
                              @ (p -> Language.Fortran.UnaryOp p, GHC.Types.Bool)
                              (Language.Fortran.$fDataUnaryOp1 @ p))
                             `cast`
                           (Sym (Data.Data.N:Mp[0] <m>_R <p -> Language.Fortran.UnaryOp p>_N))
                           a1 })
                   (\ (ds1 :: (Language.Fortran.UnaryOp p, GHC.Types.Bool)) ->
                    case ds1 of wild { (,) x' b ->
                    case b of wild1 {
                      GHC.Types.False -> lvl295
                      GHC.Types.True
                      -> GHC.Base.return
                           @ m
                           $dMonad
                           @ (Language.Fortran.UnaryOp p)
                           x' } })) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p -> [u]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.UnaryOp p) ->
                 case x0 of wild {
                   Language.Fortran.UMinus a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u)
                   Language.Fortran.Not a1
                   -> GHC.Types.: @ u (ds @ p $dData1 a1) (GHC.Types.[] @ u) }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.UnaryOp p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cgmapQi7 @ p w @ u ww1 w363 w364 }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UnaryOp p
    -> r
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: Language.Fortran.UnaryOp p) ->
                 case x0 of wild {
                   Language.Fortran.UMinus a1 -> ds (ds2 @ p $dData1 a1) ds1
                   Language.Fortran.Not a1 -> ds (ds2 @ p $dData1 a1) ds1 }) -}
427f27131e64ea3da026fe120bf90190
  $fDataUnaryOp_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 4,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Language.Fortran.$w$cgunfold6 @ p w @ c w362 w363 ww1 ww5 }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fDataUseBlock8 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.UseBlock
                                                                       p>_N)
                  (Language.Fortran.$fDataUseBlock_$cgfoldl @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.UseBlock p) ->
                   case ds of wild { Language.Fortran.UseBlock ds1 ds2 ->
                   Language.Fortran.$cUseBlock })
                  (\ (ds :: Language.Fortran.UseBlock p) ->
                   Language.Fortran.$tUseBlock)
                  (Language.Fortran.$fDataUseBlock_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p)))
                  (Language.Fortran.$fDataUseBlock1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.UseBlock p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.UseBlock p>_R)
                  (Language.Fortran.$fDataUseBlock_$cgmapQl @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapQr @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapQ @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapQi @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapM @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapMp @ p v)
                  (Language.Fortran.$fDataUseBlock_$cgmapMo @ p v) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.UseBlock p
    -> Data.Functor.Identity.Identity (Language.Fortran.UseBlock p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.UseBlock p) ->
                 case x0 of wild { Language.Fortran.UseBlock a1 a2 ->
                 (Language.Fortran.UseBlock
                    @ p
                    (ds
                       @ (Language.Fortran.Uses p)
                       (Language.Fortran.$fDataUses @ p $dData1)
                       a1)
                    (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.UseBlock p>_R)) }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UseBlock
                        676775438516342762##
                        8165917680911675068##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUseBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.UseBlock
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.UseBlock
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
5467f5d7ecee3ad273f417260fa4857f
  $fDataUseBlock3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataUseBlock4) -}
f057c8aa3cb671456bd01736ea65df5c
  $fDataUseBlock4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UseBlock"#) -}
36fca1fff5ad7343e7f05e680d7f63a9
  $fDataUseBlock5 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataUseBlock6) -}
c1da5576950f0380d0397a09d5de58df
  $fDataUseBlock6 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cUseBlock
                   (GHC.Types.[] @ Data.Data.Constr)) -}
9cac9a7e1e228ce402dcb59329f4c661
  $fDataUseBlock7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataUseBlock4) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock8 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.UseBlock p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.UseBlock
                   @ p
                   Language.Fortran.$fDataUseBlock9
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock9 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.UseBlock
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.UseBlock
                        676775438516342762##
                        8165917680911675068##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUseBlock3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.UseBlock
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.UseBlock p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataUseBlock2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.UseBlock p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.UseBlock p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.UseBlock <p>_N)) } } } }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.UseBlock p
    -> c (Language.Fortran.UseBlock p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 \ (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.UseBlock p) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData2
                      (z @ (Language.Fortran.Uses p
                            -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.UseBlock @ p))
                      a1)
                   a2 }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ m :: * -> *
                   ($dMonad :: GHC.Base.Monad m)
                   (ds :: forall d. Data.Data.Data d => d -> m d) ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 let {
                   lvl295 :: m (Language.Fortran.Uses p
                                -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                   = GHC.Base.return
                       @ m
                       $dMonad
                       @ (Language.Fortran.Uses p
                          -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                       (Language.Fortran.UseBlock @ p)
                 } in
                 \ (ds1 :: Language.Fortran.UseBlock p) ->
                 case ds1 of wild { Language.Fortran.UseBlock a1 a2 ->
                 let {
                   lvl296 :: m Language.Fortran.SrcLoc
                   = ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                   @ (Language.Fortran.UseBlock p)
                   (let {
                      lvl297 :: m (Language.Fortran.Uses p)
                      = ds @ (Language.Fortran.Uses p) $dData2 a1
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Language.Fortran.Uses p
                         -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      lvl295
                      (\ (c' :: Language.Fortran.Uses p
                                -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p) ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Language.Fortran.Uses p)
                         @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         lvl297
                         (\ (x' :: Language.Fortran.Uses p) ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                            (c' x'))))
                   (\ (c' :: Language.Fortran.SrcLoc
                             -> Language.Fortran.UseBlock p) ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.UseBlock p)
                      lvl296
                      (\ (x' :: Language.Fortran.SrcLoc) ->
                       GHC.Base.return
                         @ m
                         $dMonad
                         @ (Language.Fortran.UseBlock p)
                         (c' x'))) }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.UseBlock p -> m (Language.Fortran.UseBlock p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UseBlock p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.UseBlock p) ->
                 case w363 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 GHC.Types.:
                   @ u
                   (w362
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p w)
                      ww1)
                   (GHC.Types.:
                      @ u
                      (w362 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc ww2)
                      (GHC.Types.[] @ u)) }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UseBlock p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (w362 :: GHC.Types.Int)
                   (w363 :: forall d. Data.Data.Data d => d -> u)
                   (w364 :: Language.Fortran.UseBlock p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w364 of ww2 { Language.Fortran.UseBlock ww3 ww4 ->
                 Language.Fortran.$w$cgmapQi4 @ p w @ u ww1 w363 ww3 ww4 } }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UseBlock p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r') ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 (\ (ds3 :: Language.Fortran.UseBlock p) ->
                  case ds3 of wild { Language.Fortran.UseBlock a1 a2 ->
                  (ds
                     (ds ds1 (ds2 @ (Language.Fortran.Uses p) $dData2 a1))
                     (ds2 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2))
                    `cast`
                  (Sym (Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.UseBlock p>_P)) })
                   `cast`
                 (<Language.Fortran.UseBlock p>_R
                  ->_R Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.UseBlock p>_P)) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.UseBlock p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.UseBlock p) ->
                 case w365 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr2
                   @ p
                   w
                   @ r
                   @ r'
                   w362
                   w363
                   w364
                   ww1
                   ww2 }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fDataUseBlock_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.UseBlock p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ p ($dData1 :: Data.Data.Data p) @ c :: * -> * ->
                 let {
                   $dData2 :: Data.Data.Data (Language.Fortran.Uses p)
                   = Language.Fortran.$fDataUses @ p $dData1
                 } in
                 \ (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.UseBlock p)
                   Language.Fortran.$fDataSrcLoc
                   (k @ (Language.Fortran.Uses p)
                      @ (Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                      $dData2
                      (z @ (Language.Fortran.Uses p
                            -> Language.Fortran.SrcLoc -> Language.Fortran.UseBlock p)
                         (Language.Fortran.UseBlock @ p)))) -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fDataUses5 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.Uses
                                                                       p>_N)
                  (Language.Fortran.$fDataUses_$cgfoldl @ p v)
                  (Language.Fortran.$fDataUses_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.Uses p) ->
                   case ds of wild {
                     Language.Fortran.Use ds1 ds2 ds3 ds4 -> Language.Fortran.$cUse
                     Language.Fortran.UseNil ds1 -> Language.Fortran.$cUseNil })
                  (\ (ds :: Language.Fortran.Uses p) -> Language.Fortran.$tUses)
                  (Language.Fortran.$fDataUses_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.Uses p)))
                  (Language.Fortran.$fDataUses1 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.Uses p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.Uses p>_R)
                  (Language.Fortran.$fDataUses_$cgmapQl @ p v)
                  (Language.Fortran.$fDataUses_$cgmapQr @ p v)
                  (Language.Fortran.$fDataUses_$cgmapQ @ p v)
                  (Language.Fortran.$fDataUses_$cgmapQi @ p v)
                  (Language.Fortran.$fDataUses_$cgmapM @ p v)
                  (Language.Fortran.$fDataUses_$cgmapMp @ p v)
                  (Language.Fortran.$fDataUses_$cgmapMo @ p v) -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses1 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.Uses p
    -> Data.Functor.Identity.Identity (Language.Fortran.Uses p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses2 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Uses
                        12614760649755741284##
                        7231590305637869228##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUses3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.Uses
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.Uses
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
8d0a64bbaa559b29c4686d597cb9a7e4
  $fDataUses3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataUses4) -}
99e469ff82b6e104e449582d34176f60
  $fDataUses4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Uses"#) -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses5 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.Uses p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.Uses
                   @ p
                   Language.Fortran.$fDataUses6
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses6 :: Data.Typeable.Internal.TypeRep Language.Fortran.Uses
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.Uses
                        12614760649755741284##
                        7231590305637869228##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataUses3
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.Uses
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.Uses p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataUses2 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Uses p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.Uses p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.Uses p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.Uses <p>_N)) } } } }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.Uses p
    -> c (Language.Fortran.Uses p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.Uses p -> m (Language.Fortran.Uses p)
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p -> [u]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p
    -> u
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapQl ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> r
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> r
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U> -}
f37cb87c0c5362747ff382fcf7036b42
  $fDataUses_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.Uses p)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName ::
    Data.Data.Data p => Data.Data.Data (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: Data.Data.Data p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fDataVarName9 @ p v)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Language.Fortran.VarName
                                                                       p>_N)
                  (Language.Fortran.$fDataVarName_$cgfoldl @ p v)
                  (Language.Fortran.$fDataVarName_$cgunfold @ p v)
                  (\ (ds :: Language.Fortran.VarName p) ->
                   case ds of wild { Language.Fortran.VarName ds1 ds2 ->
                   Language.Fortran.$cVarName })
                  (\ (ds :: Language.Fortran.VarName p) ->
                   Language.Fortran.$tVarName)
                  (Language.Fortran.$fDataVarName_$cdataCast1 @ p v)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (Language.Fortran.VarName p)))
                  (Language.Fortran.$fDataVarName2 @ p v)
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <Language.Fortran.VarName p>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <Language.Fortran.VarName p>_R)
                  (Language.Fortran.$fDataVarName1 @ p v)
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <Language.Fortran.VarName p>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <Language.Fortran.VarName p>_P)
                  (Language.Fortran.$fDataVarName_$cgmapQr @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapQ @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapQi @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapM @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapMp @ p v)
                  (Language.Fortran.$fDataVarName_$cgmapMo @ p v) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.VarName p
    -> Data.Functor.Const.Const r (Language.Fortran.VarName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r -> r' -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.VarName p) ->
                 case w365 of ww { Language.Fortran.VarName ww1 ww2 ->
                 (Language.Fortran.$w$cgmapQl1
                    @ p
                    w
                    @ r
                    @ r'
                    w362
                    w363
                    w364
                    ww1
                    ww2)
                   `cast`
                 (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r>_R <Language.Fortran.VarName p>_P)) }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName10 ::
    Data.Typeable.Internal.TypeRep Language.Fortran.VarName
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.VarName
                        1814910915032611357##
                        15311627620831682170##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataVarName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ (* -> *)
                   @ Language.Fortran.VarName
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName2 ::
    Data.Data.Data p =>
    (forall b. Data.Data.Data b => b -> b)
    -> Language.Fortran.VarName p
    -> Data.Functor.Identity.Identity (Language.Fortran.VarName p)
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: Language.Fortran.VarName p) ->
                 case x0 of wild { Language.Fortran.VarName a1 a2 ->
                 (Language.Fortran.VarName
                    @ p
                    (ds @ p $dData1 a1)
                    (ds @ Language.Fortran.Variable Data.Data.$fData[]_$s$fData[] a2))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <Language.Fortran.VarName p>_R)) }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName3 :: GHC.Fingerprint.Type.Fingerprint
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ (* -> *)
                        @ Language.Fortran.VarName
                        1814910915032611357##
                        15311627620831682170##
                        Language.Fortran.$trModule
                        Language.Fortran.$fDataVarName4
                        0#
                        GHC.Types.krep$*Arr*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.typeRepFingerprint
                   @ (* -> *)
                   @ Language.Fortran.VarName
                   (Data.Typeable.Internal.TrTyCon
                      @ (* -> *)
                      @ Language.Fortran.VarName
                      ww8
                      ww9
                      ww10
                      ww11
                      ww12) }) -}
1aca8765e5004d8ee74ceeb00dabdb72
  $fDataVarName4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$fDataVarName5) -}
3a5f41fb8d9d226a1c514fdc64fe8797
  $fDataVarName5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VarName"#) -}
5354a9a31939fc996bfe79c693f98d2d
  $fDataVarName6 :: Data.Data.DataRep
  {- Strictness: m1,
     Unfolding: (Data.Data.AlgRep Language.Fortran.$fDataVarName7) -}
5c577a870891645f5d05e56545a2aba1
  $fDataVarName7 :: [Data.Data.Constr]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Data.Constr
                   Language.Fortran.$cVarName
                   (GHC.Types.[] @ Data.Data.Constr)) -}
9fefc3dfd6d0b13c08ed58db293f868b
  $fDataVarName8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fDataVarName5) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName9 ::
    Data.Data.Data p =>
    Data.Typeable.Internal.TypeRep (Language.Fortran.VarName p)
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dData1 :: Data.Data.Data p) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Language.Fortran.VarName
                   @ p
                   Language.Fortran.$fDataVarName10
                   (Data.Data.$p1Data @ p $dData1)
                     `cast`
                   (Data.Typeable.Internal.N:Typeable[0] <*>_N <p>_N)) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cdataCast1 ::
    Data.Data.Data p =>
    forall (t :: * -> *) (c :: * -> *).
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe (c (Language.Fortran.VarName p))
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ t :: * -> *
                   @ c :: * -> *
                   ($dTypeable :: Data.Typeable.Internal.Typeable t) ->
                 let {
                   lvl295 :: GHC.Fingerprint.Type.Fingerprint
                   = Data.Typeable.Internal.typeRepFingerprint
                       @ (* -> *)
                       @ t
                       $dTypeable
                         `cast`
                       (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t>_N)
                 } in
                 \ (f94 :: forall d. Data.Data.Data d => c (t d)) ->
                 case lvl295 of wild { GHC.Fingerprint.Type.Fingerprint dt dt1 ->
                 case Language.Fortran.$fDataVarName3 of wild1 { GHC.Fingerprint.Type.Fingerprint dt2 dt3 ->
                 case GHC.Prim.eqWord# dt dt2 of lwild {
                   DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.VarName p))
                   1#
                   -> case GHC.Prim.eqWord# dt1 dt3 of lwild1 {
                        DEFAULT -> GHC.Base.Nothing @ (c (Language.Fortran.VarName p))
                        1#
                        -> GHC.Base.Just
                             @ (c (Language.Fortran.VarName p))
                             (f94 @ p $dData1)
                               `cast`
                             (<c>_R (UnsafeCo nominal t Language.Fortran.VarName <p>_N)) } } } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgfoldl ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> Language.Fortran.VarName p
    -> c (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: Language.Fortran.VarName p) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      $dData1
                      (z @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p))
                      a1)
                   a2 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgmapM ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (w364 :: Language.Fortran.VarName p) ->
                 case w364 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapM1 @ p w @ m w362 w363 ww1 ww2 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgmapMo ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgmapMp ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.MonadPlus m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> Language.Fortran.VarName p -> m (Language.Fortran.VarName p)
  {- Arity: 4,
     Strictness: <L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)> -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgmapQ ::
    Data.Data.Data p =>
    forall u.
    (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.VarName p -> [u]
  {- Arity: 3, Strictness: <L,U><L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: Language.Fortran.VarName p) ->
                 case x0 of wild { Language.Fortran.VarName a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ p $dData1 a1)
                   (GHC.Types.:
                      @ u
                      (ds @ Language.Fortran.Variable Data.Data.$fData[]_$s$fData[] a2)
                      (GHC.Types.[] @ u)) }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgmapQi ::
    Data.Data.Data p =>
    forall u.
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.VarName p
    -> u
  {- Arity: 4,
     Strictness: <L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: Language.Fortran.VarName p) ->
                 case x of wild { Language.Fortran.VarName a1 a2 ->
                 case ds of wild1 { GHC.Types.I# x1 ->
                 case x1 of wild2 {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> ds1 @ p $dData1 a1
                   1#
                   -> ds1
                        @ Language.Fortran.Variable
                        Data.Data.$fData[]_$s$fData[]
                        a2 } } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgmapQr ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.VarName p
    -> r
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (w365 :: Language.Fortran.VarName p) ->
                 case w365 of ww { Language.Fortran.VarName ww1 ww2 ->
                 Language.Fortran.$w$cgmapQr3
                   @ p
                   w
                   @ r
                   @ r'
                   w362
                   w363
                   w364
                   ww1
                   ww2 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fDataVarName_$cgunfold ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.VarName p)
  {- Arity: 4, Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (4, True, False)
                (\ @ p
                   ($dData1 :: Data.Data.Data p)
                   @ c :: * -> *
                   (k :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.Variable
                   @ (Language.Fortran.VarName p)
                   Data.Data.$fData[]_$s$fData[]
                   (k @ p
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      $dData1
                      (z @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p)))) -}
d3fedd88bb81c839018aa8b13497c1de
  $fEqArg ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fEqArg_$c== @ p v)
                  (Language.Fortran.$fEqArg_$c/= @ p v) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fEqArgList ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fEqArgList_$c==1 @ p v)
                  (Language.Fortran.$fEqArgList_$c/= @ p v) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fEqArgList_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgList p
    -> Language.Fortran.ArgList p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.ArgList p)
                   (y :: Language.Fortran.ArgList p) ->
                 case x of wild { Language.Fortran.ArgList a1 a2 ->
                 case y of wild1 { Language.Fortran.ArgList b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArgList_$c== @ p $dEq a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fEqArgList_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Expr p
    -> Language.Fortran.Expr p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
045a18871aabc3897c4cc31c5a6f6de0
  $fEqArgList_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgList p
    -> Language.Fortran.ArgList p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.ArgList p)
                   (w363 :: Language.Fortran.ArgList p) ->
                 case w362 of ww { Language.Fortran.ArgList ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.ArgList ww4 ww5 ->
                 Language.Fortran.$w$c==2 @ p w ww1 ww2 ww4 ww5 } }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fEqArgName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fEqArg_$c==2 @ p v)
                  (Language.Fortran.$fEqArgName_$c/= @ p v) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fEqArgName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgName p
    -> Language.Fortran.ArgName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.ArgName p)
                   (y :: Language.Fortran.ArgName p) ->
                 case Language.Fortran.$fEqArg_$c==2 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fEqArg_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Arg p -> Language.Fortran.Arg p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Arg p)
                   (y :: Language.Fortran.Arg p) ->
                 case Language.Fortran.$fEqArg_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fEqArg_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Arg p -> Language.Fortran.Arg p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))><S,1*U(U,1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.Arg p)
                   (w363 :: Language.Fortran.Arg p) ->
                 case w362 of ww { Language.Fortran.Arg ww1 ww2 ww3 ->
                 case w363 of ww4 { Language.Fortran.Arg ww5 ww6 ww7 ->
                 Language.Fortran.$w$c== @ p w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
5d55b2485fd718d78674934e1c1437fb
  $fEqArg_$c==1 ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Language.Fortran.SrcLoc)
                   (w362 :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 case w362 of ww4 { Language.Fortran.SrcLoc ww5 ww6 ww7 ->
                 Language.Fortran.$w$c==1 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fEqArg_$c==2 ::
    GHC.Classes.Eq p =>
    Language.Fortran.ArgName p
    -> Language.Fortran.ArgName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
02a255cfb28c667ea6da849cf85b59d6
  $fEqAttr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fEqAttr_$c== @ p v)
                  (Language.Fortran.$fEqAttr_$c/= @ p v) -}
02a255cfb28c667ea6da849cf85b59d6
  $fEqAttr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Attr p
    -> Language.Fortran.Attr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Attr p)
                   (y :: Language.Fortran.Attr p) ->
                 case Language.Fortran.$fEqAttr_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
02a255cfb28c667ea6da849cf85b59d6
  $fEqAttr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Attr p
    -> Language.Fortran.Attr p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
69d5dfd4df9415765a99abb747654948
  $fEqBaseType ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fEqBaseType_$c== @ p v)
                  (Language.Fortran.$fEqBaseType_$c/= @ p v) -}
69d5dfd4df9415765a99abb747654948
  $fEqBaseType_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.BaseType p
    -> Language.Fortran.BaseType p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.BaseType p)
                   (y :: Language.Fortran.BaseType p) ->
                 case Language.Fortran.$fEqBaseType_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
69d5dfd4df9415765a99abb747654948
  $fEqBaseType_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.BaseType p
    -> Language.Fortran.BaseType p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.BaseType p)
                   (ds1 :: Language.Fortran.BaseType p) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Integer b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Real a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Real b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Character a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Character b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.SomeType a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.SomeType b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.DerivedType a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.DerivedType b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqBaseType_$c==1 @ p $dEq a2 b2 } }
                   Language.Fortran.Recursive a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Recursive b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Pure a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Pure b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Elemental a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Elemental b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Logical a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Logical b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Complex a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Complex b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
2661346c18056b3b907f62427e1b219c
  $fEqBaseType_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.SubName p
    -> Language.Fortran.SubName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.SubName p)
                   (ds1 :: Language.Fortran.SubName p) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> case ds1 of wild1 {
                        Language.Fortran.SubName b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 }
                        Language.Fortran.NullSubName ipv -> GHC.Types.False }
                   Language.Fortran.NullSubName a1
                   -> case ds1 of wild1 {
                        Language.Fortran.SubName ipv ipv1 -> GHC.Types.False
                        Language.Fortran.NullSubName b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
896c0936a7e3480424b97ccaddc9354b
  $fEqBinOp ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fEqBinOp_$c== @ p v)
                  (Language.Fortran.$fEqBinOp_$c/= @ p v) -}
896c0936a7e3480424b97ccaddc9354b
  $fEqBinOp_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.BinOp p
    -> Language.Fortran.BinOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.BinOp p)
                   (y :: Language.Fortran.BinOp p) ->
                 case Language.Fortran.$fEqBinOp_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
896c0936a7e3480424b97ccaddc9354b
  $fEqBinOp_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.BinOp p
    -> Language.Fortran.BinOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U> -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fEqBlock ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fEqBlock_$c== @ p v)
                  (Language.Fortran.$fEqBlock_$c/= @ p v) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fEqBlock_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Block p
    -> Language.Fortran.Block p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Block p)
                   (y :: Language.Fortran.Block p) ->
                 case Language.Fortran.$fEqBlock_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fEqBlock_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Block p
    -> Language.Fortran.Block p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)><S,1*U(U,1*U(1*U,1*U(1*U,1*U(U),1*U(U))),1*U,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U))),U,U)>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Block p)
                   (ds1 :: Language.Fortran.Block p) ->
                 case ds of wild { Language.Fortran.Block a1 a2 a3 a4 a5 a6 ->
                 case ds1 of wild1 { Language.Fortran.Block b1 b2 b3 b4 b5 b6 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case a2 of wild3 { Language.Fortran.UseBlock a7 a8 ->
                      case b2 of wild4 { Language.Fortran.UseBlock b7 b8 ->
                      case Language.Fortran.$fEqBlock_$c==4 @ p $dEq a7 b7 of wild5 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case a8 of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                           case b8 of ww4 { Language.Fortran.SrcLoc ww5 ww6 ww7 ->
                           case GHC.Base.eqString ww1 ww5 of wild6 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww2 of wild7 { GHC.Types.I# x ->
                                case ww6 of wild8 { GHC.Types.I# y ->
                                case GHC.Prim.==# x y of lwild {
                                  DEFAULT -> GHC.Types.False
                                  1#
                                  -> case ww3 of wild9 { GHC.Types.I# x1 ->
                                     case ww7 of wild10 { GHC.Types.I# y1 ->
                                     case GHC.Prim.==# x1 y1 of lwild1 {
                                       DEFAULT -> GHC.Types.False
                                       1#
                                       -> case Language.Fortran.$fEqBlock_$c==3
                                                 @ p
                                                 $dEq
                                                 a3
                                                 b3 of wild11 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case a4 of ww8 { (,) ww9 ww10 ->
                                               case b4 of ww11 { (,) ww12 ww13 ->
                                               case ww9 of ww14 { Language.Fortran.SrcLoc ww15 ww16 ww17 ->
                                               case ww12 of ww18 { Language.Fortran.SrcLoc ww19 ww20 ww21 ->
                                               case GHC.Base.eqString ww15 ww19 of wild12 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True
                                                 -> case ww16 of wild13 { GHC.Types.I# x2 ->
                                                    case ww20 of wild14 { GHC.Types.I# y2 ->
                                                    case GHC.Prim.==# x2 y2 of lwild2 {
                                                      DEFAULT -> GHC.Types.False
                                                      1#
                                                      -> case ww17 of wild15 { GHC.Types.I# x3 ->
                                                         case ww21 of wild16 { GHC.Types.I# y3 ->
                                                         case GHC.Prim.==# x3 y3 of lwild3 {
                                                           DEFAULT -> GHC.Types.False
                                                           1#
                                                           -> case ww10 of ww22 { Language.Fortran.SrcLoc ww23 ww24 ww25 ->
                                                              case ww13 of ww26 { Language.Fortran.SrcLoc ww27 ww28 ww29 ->
                                                              case GHC.Base.eqString
                                                                     ww23
                                                                     ww27 of wild17 {
                                                                GHC.Types.False -> GHC.Types.False
                                                                GHC.Types.True
                                                                -> case ww24 of wild18 { GHC.Types.I# x4 ->
                                                                   case ww28 of wild19 { GHC.Types.I# y4 ->
                                                                   case GHC.Prim.==#
                                                                          x4
                                                                          y4 of lwild4 {
                                                                     DEFAULT -> GHC.Types.False
                                                                     1#
                                                                     -> case ww25 of wild20 { GHC.Types.I# x5 ->
                                                                        case ww29 of wild21 { GHC.Types.I# y5 ->
                                                                        case GHC.Prim.==#
                                                                               x5
                                                                               y5 of lwild5 {
                                                                          DEFAULT -> GHC.Types.False
                                                                          1#
                                                                          -> case Language.Fortran.$fEqBlock_$c==2
                                                                                    @ p
                                                                                    $dEq
                                                                                    a5
                                                                                    b5 of wild22 {
                                                                               GHC.Types.False
                                                                               -> GHC.Types.False
                                                                               GHC.Types.True
                                                                               -> Language.Fortran.$fEqBlock_$c==1
                                                                                    @ p
                                                                                    $dEq
                                                                                    a6
                                                                                    b6 } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }) -}
96a246f096edd051e2860499c815ffa3
  $fEqBlock_$c==1 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fortran p
    -> Language.Fortran.Fortran p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
a81776e31635bc99f5c71e8648536701
  $fEqBlock_$c==2 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Decl p
    -> Language.Fortran.Decl p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
bb388081fb116cff17a4c3fdaa0611fe
  $fEqBlock_$c==3 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Implicit p
    -> Language.Fortran.Implicit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Implicit p)
                   (ds1 :: Language.Fortran.Implicit p) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> case ds1 of wild1 {
                        Language.Fortran.ImplicitNone b1 -> GHC.Classes.== @ p $dEq a1 b1
                        Language.Fortran.ImplicitNull ipv -> GHC.Types.False }
                   Language.Fortran.ImplicitNull a1
                   -> case ds1 of wild1 {
                        Language.Fortran.ImplicitNone ipv -> GHC.Types.False
                        Language.Fortran.ImplicitNull b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fEqBlock_$c==4 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.Uses p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
dad4d55a5cea607426e414a10b8eea45
  $fEqDataForm ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fEqDataForm_$c== @ p v)
                  (Language.Fortran.$fEqDataForm_$c/= @ p v) -}
dad4d55a5cea607426e414a10b8eea45
  $fEqDataForm_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.DataForm p
    -> Language.Fortran.DataForm p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.DataForm p)
                   (y :: Language.Fortran.DataForm p) ->
                 case Language.Fortran.$fEqDataForm_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
dad4d55a5cea607426e414a10b8eea45
  $fEqDataForm_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.DataForm p
    -> Language.Fortran.DataForm p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Expr p)
                   = Language.Fortran.$fEqExpr @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = GHC.Classes.$fEq(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dEq1
                       $dEq1
                 } in
                 \ (ds :: Language.Fortran.DataForm p)
                   (ds1 :: Language.Fortran.DataForm p) ->
                 case ds of wild { Language.Fortran.Data a1 a2 ->
                 case ds1 of wild1 { Language.Fortran.Data b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                        $dEq2
                        a2
                        b2 } } }) -}
a81776e31635bc99f5c71e8648536701
  $fEqDecl ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fEqBlock_$c==2 @ p v)
                  (Language.Fortran.$fEqDecl_$c/= @ p v) -}
a81776e31635bc99f5c71e8648536701
  $fEqDecl_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Decl p
    -> Language.Fortran.Decl p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Decl p)
                   (y :: Language.Fortran.Decl p) ->
                 case Language.Fortran.$fEqBlock_$c==2 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fEqExpr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fEqArgList_$c== @ p v)
                  (Language.Fortran.$fEqExpr_$c/= @ p v) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fEqExpr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Expr p
    -> Language.Fortran.Expr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Expr p)
                   (y :: Language.Fortran.Expr p) ->
                 case Language.Fortran.$fEqArgList_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
96a246f096edd051e2860499c815ffa3
  $fEqFortran ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fEqBlock_$c==1 @ p v)
                  (Language.Fortran.$fEqFortran_$c/= @ p v) -}
96a246f096edd051e2860499c815ffa3
  $fEqFortran_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fortran p
    -> Language.Fortran.Fortran p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Fortran p)
                   (y :: Language.Fortran.Fortran p) ->
                 case Language.Fortran.$fEqBlock_$c==1 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e90c235f732876f3296896ca224d9121
  $fEqFraction ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fEqFraction_$c== @ p v)
                  (Language.Fortran.$fEqFraction_$c/= @ p v) -}
e90c235f732876f3296896ca224d9121
  $fEqFraction_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fraction p
    -> Language.Fortran.Fraction p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Fraction p)
                   (y :: Language.Fortran.Fraction p) ->
                 case Language.Fortran.$fEqFraction_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e90c235f732876f3296896ca224d9121
  $fEqFraction_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Fraction p
    -> Language.Fortran.Fraction p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.Fraction p)
                   (ds1 :: Language.Fortran.Fraction p) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.IntegerConst b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 } }
                   Language.Fortran.FractionConst a1 a2 a3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.FractionConst b1 b2 b3
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Base.eqString a2 b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> GHC.Base.eqString a3 b3 } } }
                   Language.Fortran.NullFraction a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.NullFraction b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
a074c18ee753392beb804aeb08ff8264
  $fEqGSpec ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fEqGSpec_$c== @ p v)
                  (Language.Fortran.$fEqGSpec_$c/= @ p v) -}
a074c18ee753392beb804aeb08ff8264
  $fEqGSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.GSpec p
    -> Language.Fortran.GSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.GSpec p)
                   (y :: Language.Fortran.GSpec p) ->
                 case Language.Fortran.$fEqGSpec_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a074c18ee753392beb804aeb08ff8264
  $fEqGSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.GSpec p
    -> Language.Fortran.GSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.GSpec p)
                   (ds1 :: Language.Fortran.GSpec p) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GName b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqArgList_$c== @ p $dEq a2 b2 } }
                   Language.Fortran.GOper a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GOper b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> Language.Fortran.$fEqBinOp_$c== @ p $dEq a2 b2 } }
                   Language.Fortran.GAssg a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.GAssg b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fEqImplicit ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fEqBlock_$c==3 @ p v)
                  (Language.Fortran.$fEqImplicit_$c/= @ p v) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fEqImplicit_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Implicit p
    -> Language.Fortran.Implicit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Implicit p)
                   (y :: Language.Fortran.Implicit p) ->
                 case Language.Fortran.$fEqBlock_$c==3 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fEqIntentAttr ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fEqIntentAttr_$c== @ p v)
                  (Language.Fortran.$fEqIntentAttr_$c/= @ p v) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fEqIntentAttr_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.IntentAttr p
    -> Language.Fortran.IntentAttr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.IntentAttr p)
                   (y :: Language.Fortran.IntentAttr p) ->
                 case Language.Fortran.$fEqIntentAttr_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fEqIntentAttr_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.IntentAttr p
    -> Language.Fortran.IntentAttr p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.IntentAttr p)
                   (ds1 :: Language.Fortran.IntentAttr p) ->
                 case ds of wild {
                   Language.Fortran.In a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.In b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.Out a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.Out b1 -> GHC.Classes.== @ p $dEq a1 b1 }
                   Language.Fortran.InOut a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.InOut b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
a81776e31635bc99f5c71e8648536701
  $fEqInterfaceSpec ::
    GHC.Classes.Eq p =>
    GHC.Classes.Eq (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fEqInterfaceSpec_$c== @ p v)
                  (Language.Fortran.$fEqInterfaceSpec_$c/= @ p v) -}
a81776e31635bc99f5c71e8648536701
  $fEqInterfaceSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.InterfaceSpec p)
                   (y :: Language.Fortran.InterfaceSpec p) ->
                 case Language.Fortran.$fEqInterfaceSpec_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a81776e31635bc99f5c71e8648536701
  $fEqInterfaceSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.InterfaceSpec p
    -> Language.Fortran.InterfaceSpec p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
a4588ee68ff39c65875cdbcceadc05a6
  $fEqMeasureUnitSpec ::
    GHC.Classes.Eq p =>
    GHC.Classes.Eq (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fEqMeasureUnitSpec_$c== @ p v)
                  (Language.Fortran.$fEqMeasureUnitSpec_$c/= @ p v) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fEqMeasureUnitSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.MeasureUnitSpec p)
                   (y :: Language.Fortran.MeasureUnitSpec p) ->
                 case Language.Fortran.$fEqMeasureUnitSpec_$c==
                        @ p
                        $dEq
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fEqMeasureUnitSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.MeasureUnitSpec p
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Fraction p)
                   = Language.Fortran.$fEqFraction @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                   = GHC.Classes.$fEq(,)
                       @ [GHC.Types.Char]
                       @ (Language.Fortran.Fraction p)
                       GHC.Classes.$fEq[]_$s$fEq[]1
                       $dEq1
                 } in
                 \ (ds :: Language.Fortran.MeasureUnitSpec p)
                   (ds1 :: Language.Fortran.MeasureUnitSpec p) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitProduct b1 b2
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                  $dEq2
                                  a2
                                  b2 } }
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitQuotient b1 b2 b3
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                       $dEq2
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)
                                       $dEq2
                                       a3
                                       b3 } } }
                   Language.Fortran.UnitNone a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Language.Fortran.UnitNone b1
                        -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fEqProgUnit ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fEqProgUnit_$c== @ p v)
                  (Language.Fortran.$fEqProgUnit_$c/= @ p v) -}
cf6f89a9a11f4455970aae08e46ad751
  $fEqProgUnit_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.ProgUnit p
    -> Language.Fortran.ProgUnit p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.ProgUnit p)
                   (y :: Language.Fortran.ProgUnit p) ->
                 case Language.Fortran.$fEqProgUnit_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fEqProgUnit_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.ProgUnit p
    -> Language.Fortran.ProgUnit p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fEqSpec ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fEqSpec_$c== @ p v)
                  (Language.Fortran.$fEqSpec_$c/= @ p v) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fEqSpec_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Spec p
    -> Language.Fortran.Spec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Spec p)
                   (y :: Language.Fortran.Spec p) ->
                 case Language.Fortran.$fEqSpec_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fEqSpec_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Spec p
    -> Language.Fortran.Spec p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
5d55b2485fd718d78674934e1c1437fb
  $fEqSrcLoc :: GHC.Classes.Eq Language.Fortran.SrcLoc
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fEqArg_$c==1
                  Language.Fortran.$fEqSrcLoc_$c/= -}
5d55b2485fd718d78674934e1c1437fb
  $fEqSrcLoc_$c/= ::
    Language.Fortran.SrcLoc
    -> Language.Fortran.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Language.Fortran.SrcLoc) (y :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqArg_$c==1 x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2661346c18056b3b907f62427e1b219c
  $fEqSubName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fEqBaseType_$c==1 @ p v)
                  (Language.Fortran.$fEqSubName_$c/= @ p v) -}
2661346c18056b3b907f62427e1b219c
  $fEqSubName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.SubName p
    -> Language.Fortran.SubName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.SubName p)
                   (y :: Language.Fortran.SubName p) ->
                 case Language.Fortran.$fEqBaseType_$c==1 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fEqType ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fEqType_$c== @ p v)
                  (Language.Fortran.$fEqType_$c/= @ p v) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fEqType_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Type p
    -> Language.Fortran.Type p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Type p)
                   (y :: Language.Fortran.Type p) ->
                 case Language.Fortran.$fEqType_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fEqType_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.Type p
    -> Language.Fortran.Type p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ p ($dEq :: GHC.Classes.Eq p) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (Language.Fortran.Expr p)
                   = Language.Fortran.$fEqExpr @ p $dEq
                 } in
                 let {
                   $dEq2 :: GHC.Classes.Eq
                              (Language.Fortran.Expr p, Language.Fortran.Expr p)
                   = GHC.Classes.$fEq(,)
                       @ (Language.Fortran.Expr p)
                       @ (Language.Fortran.Expr p)
                       $dEq1
                       $dEq1
                 } in
                 let {
                   $dEq3 :: GHC.Classes.Eq (Language.Fortran.Attr p)
                   = Language.Fortran.$fEqAttr @ p $dEq
                 } in
                 let {
                   lvl295 :: Language.Fortran.Expr p
                             -> Language.Fortran.Expr p -> GHC.Types.Bool
                   = Language.Fortran.$fEqArgList_$c== @ p $dEq
                 } in
                 \ (ds :: Language.Fortran.Type p)
                   (ds1 :: Language.Fortran.Type p) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> case ds1 of wild1 {
                        Language.Fortran.BaseType b1 b2 b3 b4 b5
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case Language.Fortran.$fEqBaseType_$c==
                                       @ p
                                       $dEq
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Classes.$fEq[]_$c==
                                            @ (Language.Fortran.Attr p)
                                            $dEq3
                                            a3
                                            b3 of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case lvl295 a4 b4 of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True -> lvl295 a5 b5 } } } }
                        Language.Fortran.ArrayT ipv ipv1 ipv2 ipv3 ipv4 ipv5
                        -> GHC.Types.False }
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> case ds1 of wild1 {
                        Language.Fortran.BaseType ipv ipv1 ipv2 ipv3 ipv4
                        -> GHC.Types.False
                        Language.Fortran.ArrayT b1 b2 b3 b4 b5 b6
                        -> case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ (Language.Fortran.Expr p, Language.Fortran.Expr p)
                                       $dEq2
                                       a2
                                       b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case Language.Fortran.$fEqBaseType_$c==
                                            @ p
                                            $dEq
                                            a3
                                            b3 of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case GHC.Classes.$fEq[]_$c==
                                                 @ (Language.Fortran.Attr p)
                                                 $dEq3
                                                 a4
                                                 b4 of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case lvl295 a5 b5 of wild6 {
                                                 GHC.Types.False -> GHC.Types.False
                                                 GHC.Types.True -> lvl295 a6 b6 } } } } } } }) -}
427f27131e64ea3da026fe120bf90190
  $fEqUnaryOp ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fEqUnaryOp_$c== @ p v)
                  (Language.Fortran.$fEqUnaryOp_$c/= @ p v) -}
427f27131e64ea3da026fe120bf90190
  $fEqUnaryOp_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.UnaryOp p
    -> Language.Fortran.UnaryOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.UnaryOp p)
                   (y :: Language.Fortran.UnaryOp p) ->
                 case Language.Fortran.$fEqUnaryOp_$c== @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
427f27131e64ea3da026fe120bf90190
  $fEqUnaryOp_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.UnaryOp p
    -> Language.Fortran.UnaryOp p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (ds :: Language.Fortran.UnaryOp p)
                   (ds1 :: Language.Fortran.UnaryOp p) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1
                   -> case ds1 of wild1 {
                        Language.Fortran.UMinus b1 -> GHC.Classes.== @ p $dEq a1 b1
                        Language.Fortran.Not ipv -> GHC.Types.False }
                   Language.Fortran.Not a1
                   -> case ds1 of wild1 {
                        Language.Fortran.UMinus ipv -> GHC.Types.False
                        Language.Fortran.Not b1 -> GHC.Classes.== @ p $dEq a1 b1 } }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fEqUseBlock ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fEqUseBlock_$c== @ p v)
                  (Language.Fortran.$fEqUseBlock_$c/= @ p v) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fEqUseBlock_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.UseBlock p
    -> Language.Fortran.UseBlock p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.UseBlock p)
                   (y :: Language.Fortran.UseBlock p) ->
                 case x of wild { Language.Fortran.UseBlock a1 a2 ->
                 case y of wild1 { Language.Fortran.UseBlock b1 b2 ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArg_$c==1 a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fEqUseBlock_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.UseBlock p
    -> Language.Fortran.UseBlock p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))><S(SL),1*U(1*U,1*U(1*U,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.UseBlock p)
                   (w363 :: Language.Fortran.UseBlock p) ->
                 case w362 of ww { Language.Fortran.UseBlock ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.UseBlock ww4 ww5 ->
                 Language.Fortran.$w$c==3 @ p w ww1 ww2 ww4 ww5 } }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fEqUses ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fEqBlock_$c==4 @ p v)
                  (Language.Fortran.$fEqUses_$c/= @ p v) -}
f37cb87c0c5362747ff382fcf7036b42
  $fEqUses_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.Uses p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.Uses p)
                   (y :: Language.Fortran.Uses p) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fEqVarName ::
    GHC.Classes.Eq p => GHC.Classes.Eq (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Eq p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fEqVarName_$c== @ p v)
                  (Language.Fortran.$fEqVarName_$c/= @ p v) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fEqVarName_$c/= ::
    GHC.Classes.Eq p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ p
                   ($dEq :: GHC.Classes.Eq p)
                   (x :: Language.Fortran.VarName p)
                   (y :: Language.Fortran.VarName p) ->
                 case x of wild { Language.Fortran.VarName a1 a2 ->
                 case y of wild1 { Language.Fortran.VarName b1 b2 ->
                 case GHC.Classes.== @ p $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fEqVarName_$c== ::
    GHC.Classes.Eq p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c==4 @ p w ww1 ww2 ww4 ww5 } }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fFunctorArg :: GHC.Base.Functor Language.Fortran.Arg
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Arg
                  Language.Fortran.$fFunctorArg_$cfmap
                  Language.Fortran.$fFunctorArg_$c<$ -}
045a18871aabc3897c4cc31c5a6f6de0
  $fFunctorArgList :: GHC.Base.Functor Language.Fortran.ArgList
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ArgList
                  Language.Fortran.$fFunctorArgList_$cfmap
                  Language.Fortran.$fFunctorArgList_$c<$ -}
045a18871aabc3897c4cc31c5a6f6de0
  $fFunctorArgList_$c<$ ::
    a -> Language.Fortran.ArgList b -> Language.Fortran.ArgList a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.ArgList b) ->
                 case ds of wild { Language.Fortran.ArgList a1 a2 ->
                 Language.Fortran.ArgList
                   @ a
                   z
                   (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2) }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fFunctorArgList_$c<$1 ::
    a -> Language.Fortran.Expr b -> Language.Fortran.Expr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
045a18871aabc3897c4cc31c5a6f6de0
  $fFunctorArgList_$cfmap ::
    (a -> b)
    -> Language.Fortran.ArgList a -> Language.Fortran.ArgList b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.ArgList a) ->
                 case ds of wild { Language.Fortran.ArgList a1 a2 ->
                 Language.Fortran.ArgList
                   @ b
                   (f94 a1)
                   (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a2) }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fFunctorArgList_$cfmap1 ::
    (a -> b) -> Language.Fortran.Expr a -> Language.Fortran.Expr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fFunctorArgName :: GHC.Base.Functor Language.Fortran.ArgName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ArgName
                  Language.Fortran.$fFunctorArg_$cfmap1
                  Language.Fortran.$fFunctorArg_$c<$1 -}
d3fedd88bb81c839018aa8b13497c1de
  $fFunctorArg_$c<$ ::
    a -> Language.Fortran.Arg b -> Language.Fortran.Arg a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.Arg b) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 Language.Fortran.Arg
                   @ a
                   z
                   (Language.Fortran.$fFunctorArg_$c<$1 @ a @ b z a2)
                   a3 }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fFunctorArg_$c<$1 ::
    a -> Language.Fortran.ArgName b -> Language.Fortran.ArgName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
d3fedd88bb81c839018aa8b13497c1de
  $fFunctorArg_$cfmap ::
    (a -> b) -> Language.Fortran.Arg a -> Language.Fortran.Arg b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.Arg a) ->
                 case ds of wild { Language.Fortran.Arg a1 a2 a3 ->
                 Language.Fortran.Arg
                   @ b
                   (f94 a1)
                   (Language.Fortran.$fFunctorArg_$cfmap1 @ a @ b f94 a2)
                   a3 }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fFunctorArg_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.ArgName a -> Language.Fortran.ArgName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
02a255cfb28c667ea6da849cf85b59d6
  $fFunctorAttr :: GHC.Base.Functor Language.Fortran.Attr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Attr
                  Language.Fortran.$fFunctorAttr_$cfmap
                  Language.Fortran.$fFunctorAttr_$c<$ -}
02a255cfb28c667ea6da849cf85b59d6
  $fFunctorAttr_$c<$ ::
    a -> Language.Fortran.Attr b -> Language.Fortran.Attr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.Attr b) ->
                 case ds of wild {
                   Language.Fortran.Parameter a1 -> Language.Fortran.Parameter @ a z
                   Language.Fortran.Allocatable a1
                   -> Language.Fortran.Allocatable @ a z
                   Language.Fortran.External a1 -> Language.Fortran.External @ a z
                   Language.Fortran.Intent a1 a2
                   -> Language.Fortran.Intent
                        @ a
                        z
                        (Language.Fortran.$fFunctorAttr_$c<$3 @ a @ b z a2)
                   Language.Fortran.Intrinsic a1 -> Language.Fortran.Intrinsic @ a z
                   Language.Fortran.Optional a1 -> Language.Fortran.Optional @ a z
                   Language.Fortran.Pointer a1 -> Language.Fortran.Pointer @ a z
                   Language.Fortran.Save a1 -> Language.Fortran.Save @ a z
                   Language.Fortran.Target a1 -> Language.Fortran.Target @ a z
                   Language.Fortran.Volatile a1 -> Language.Fortran.Volatile @ a z
                   Language.Fortran.Public a1 -> Language.Fortran.Public @ a z
                   Language.Fortran.Private a1 -> Language.Fortran.Private @ a z
                   Language.Fortran.Sequence a1 -> Language.Fortran.Sequence @ a z
                   Language.Fortran.Dimension a1 a2
                   -> Language.Fortran.Dimension
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           (\ (b4 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a4,
                             Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a5) })
                           a2)
                   Language.Fortran.MeasureUnit a1 a2
                   -> Language.Fortran.MeasureUnit
                        @ a
                        z
                        (Language.Fortran.$fFunctorAttr_$c<$1 @ a @ b z a2) }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fFunctorAttr_$c<$1 ::
    a
    -> Language.Fortran.MeasureUnitSpec b
    -> Language.Fortran.MeasureUnitSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.Fortran.MeasureUnitSpec b) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> Language.Fortran.UnitProduct
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction b)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$c<$2 @ a @ b z a5) })
                           a2)
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> Language.Fortran.UnitQuotient
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction b)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$c<$2 @ a @ b z a5) })
                           a2)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           (\ (b7 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction b)) ->
                            case b7 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$c<$2 @ a @ b z a5) })
                           a3)
                   Language.Fortran.UnitNone a1
                   -> Language.Fortran.UnitNone @ a z }) -}
e90c235f732876f3296896ca224d9121
  $fFunctorAttr_$c<$2 ::
    a -> Language.Fortran.Fraction b -> Language.Fortran.Fraction a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.Fraction b) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst @ a z a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst @ a z a2 a3
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ a z }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fFunctorAttr_$c<$3 ::
    a -> Language.Fortran.IntentAttr b -> Language.Fortran.IntentAttr a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.IntentAttr b) ->
                 case ds of wild {
                   Language.Fortran.In a1 -> Language.Fortran.In @ a z
                   Language.Fortran.Out a1 -> Language.Fortran.Out @ a z
                   Language.Fortran.InOut a1 -> Language.Fortran.InOut @ a z }) -}
02a255cfb28c667ea6da849cf85b59d6
  $fFunctorAttr_$cfmap ::
    (a -> b) -> Language.Fortran.Attr a -> Language.Fortran.Attr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.Attr a) ->
                 case ds of wild {
                   Language.Fortran.Parameter a1
                   -> Language.Fortran.Parameter @ b (f94 a1)
                   Language.Fortran.Allocatable a1
                   -> Language.Fortran.Allocatable @ b (f94 a1)
                   Language.Fortran.External a1
                   -> Language.Fortran.External @ b (f94 a1)
                   Language.Fortran.Intent a1 a2
                   -> Language.Fortran.Intent
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorAttr_$cfmap3 @ a @ b f94 a2)
                   Language.Fortran.Intrinsic a1
                   -> Language.Fortran.Intrinsic @ b (f94 a1)
                   Language.Fortran.Optional a1
                   -> Language.Fortran.Optional @ b (f94 a1)
                   Language.Fortran.Pointer a1
                   -> Language.Fortran.Pointer @ b (f94 a1)
                   Language.Fortran.Save a1 -> Language.Fortran.Save @ b (f94 a1)
                   Language.Fortran.Target a1 -> Language.Fortran.Target @ b (f94 a1)
                   Language.Fortran.Volatile a1
                   -> Language.Fortran.Volatile @ b (f94 a1)
                   Language.Fortran.Public a1 -> Language.Fortran.Public @ b (f94 a1)
                   Language.Fortran.Private a1
                   -> Language.Fortran.Private @ b (f94 a1)
                   Language.Fortran.Sequence a1
                   -> Language.Fortran.Sequence @ b (f94 a1)
                   Language.Fortran.Dimension a1 a2
                   -> Language.Fortran.Dimension
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                            case b1 of wild1 { (,) a4 a5 ->
                            (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a4,
                             Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a5) })
                           a2)
                   Language.Fortran.MeasureUnit a1 a2
                   -> Language.Fortran.MeasureUnit
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorAttr_$cfmap1 @ a @ b f94 a2) }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fFunctorAttr_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.MeasureUnitSpec a
    -> Language.Fortran.MeasureUnitSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.MeasureUnitSpec a) ->
                 case ds of wild {
                   Language.Fortran.UnitProduct a1 a2
                   -> Language.Fortran.UnitProduct
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b2 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b2 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f94 a5) })
                           a2)
                   Language.Fortran.UnitQuotient a1 a2 a3
                   -> Language.Fortran.UnitQuotient
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b2 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b2 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f94 a5) })
                           a2)
                        (GHC.Base.map
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction a)
                           @ (Language.Fortran.MeasureUnit, Language.Fortran.Fraction b)
                           (\ (b4 :: (Language.Fortran.MeasureUnit,
                                      Language.Fortran.Fraction a)) ->
                            case b4 of wild1 { (,) a4 a5 ->
                            (a4, Language.Fortran.$fFunctorAttr_$cfmap2 @ a @ b f94 a5) })
                           a3)
                   Language.Fortran.UnitNone a1
                   -> Language.Fortran.UnitNone @ b (f94 a1) }) -}
e90c235f732876f3296896ca224d9121
  $fFunctorAttr_$cfmap2 ::
    (a -> b)
    -> Language.Fortran.Fraction a -> Language.Fortran.Fraction b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.Fraction a) ->
                 case ds of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> Language.Fortran.IntegerConst @ b (f94 a1) a2
                   Language.Fortran.FractionConst a1 a2 a3
                   -> Language.Fortran.FractionConst @ b (f94 a1) a2 a3
                   Language.Fortran.NullFraction a1
                   -> Language.Fortran.NullFraction @ b (f94 a1) }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fFunctorAttr_$cfmap3 ::
    (a -> b)
    -> Language.Fortran.IntentAttr a -> Language.Fortran.IntentAttr b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.IntentAttr a) ->
                 case ds of wild {
                   Language.Fortran.In a1 -> Language.Fortran.In @ b (f94 a1)
                   Language.Fortran.Out a1 -> Language.Fortran.Out @ b (f94 a1)
                   Language.Fortran.InOut a1
                   -> Language.Fortran.InOut @ b (f94 a1) }) -}
69d5dfd4df9415765a99abb747654948
  $fFunctorBaseType :: GHC.Base.Functor Language.Fortran.BaseType
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.BaseType
                  Language.Fortran.$fFunctorBaseType_$cfmap
                  Language.Fortran.$fFunctorBaseType_$c<$ -}
69d5dfd4df9415765a99abb747654948
  $fFunctorBaseType_$c<$ ::
    a -> Language.Fortran.BaseType b -> Language.Fortran.BaseType a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.Fortran.BaseType b) ->
                 case ds of wild {
                   Language.Fortran.Integer a1 -> Language.Fortran.Integer @ a z
                   Language.Fortran.Real a1 -> Language.Fortran.Real @ a z
                   Language.Fortran.Character a1 -> Language.Fortran.Character @ a z
                   Language.Fortran.SomeType a1 -> Language.Fortran.SomeType @ a z
                   Language.Fortran.DerivedType a1 a2
                   -> Language.Fortran.DerivedType
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z a2)
                   Language.Fortran.Recursive a1 -> Language.Fortran.Recursive @ a z
                   Language.Fortran.Pure a1 -> Language.Fortran.Pure @ a z
                   Language.Fortran.Elemental a1 -> Language.Fortran.Elemental @ a z
                   Language.Fortran.Logical a1 -> Language.Fortran.Logical @ a z
                   Language.Fortran.Complex a1 -> Language.Fortran.Complex @ a z }) -}
2661346c18056b3b907f62427e1b219c
  $fFunctorBaseType_$c<$1 ::
    a -> Language.Fortran.SubName b -> Language.Fortran.SubName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.SubName b) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2 -> Language.Fortran.SubName @ a z a2
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ a z }) -}
69d5dfd4df9415765a99abb747654948
  $fFunctorBaseType_$cfmap ::
    (a -> b)
    -> Language.Fortran.BaseType a -> Language.Fortran.BaseType b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.BaseType a) ->
                 case ds of wild {
                   Language.Fortran.Integer a1
                   -> Language.Fortran.Integer @ b (f94 a1)
                   Language.Fortran.Real a1 -> Language.Fortran.Real @ b (f94 a1)
                   Language.Fortran.Character a1
                   -> Language.Fortran.Character @ b (f94 a1)
                   Language.Fortran.SomeType a1
                   -> Language.Fortran.SomeType @ b (f94 a1)
                   Language.Fortran.DerivedType a1 a2
                   -> Language.Fortran.DerivedType
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94 a2)
                   Language.Fortran.Recursive a1
                   -> Language.Fortran.Recursive @ b (f94 a1)
                   Language.Fortran.Pure a1 -> Language.Fortran.Pure @ b (f94 a1)
                   Language.Fortran.Elemental a1
                   -> Language.Fortran.Elemental @ b (f94 a1)
                   Language.Fortran.Logical a1
                   -> Language.Fortran.Logical @ b (f94 a1)
                   Language.Fortran.Complex a1
                   -> Language.Fortran.Complex @ b (f94 a1) }) -}
2661346c18056b3b907f62427e1b219c
  $fFunctorBaseType_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.SubName a -> Language.Fortran.SubName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.SubName a) ->
                 case ds of wild {
                   Language.Fortran.SubName a1 a2
                   -> Language.Fortran.SubName @ b (f94 a1) a2
                   Language.Fortran.NullSubName a1
                   -> Language.Fortran.NullSubName @ b (f94 a1) }) -}
896c0936a7e3480424b97ccaddc9354b
  $fFunctorBinOp :: GHC.Base.Functor Language.Fortran.BinOp
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.BinOp
                  Language.Fortran.$fFunctorBinOp_$cfmap
                  Language.Fortran.$fFunctorBinOp_$c<$ -}
896c0936a7e3480424b97ccaddc9354b
  $fFunctorBinOp_$c<$ ::
    a -> Language.Fortran.BinOp b -> Language.Fortran.BinOp a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.BinOp b) ->
                 case ds of wild {
                   Language.Fortran.Plus a1 -> Language.Fortran.Plus @ a z
                   Language.Fortran.Minus a1 -> Language.Fortran.Minus @ a z
                   Language.Fortran.Mul a1 -> Language.Fortran.Mul @ a z
                   Language.Fortran.Div a1 -> Language.Fortran.Div @ a z
                   Language.Fortran.Or a1 -> Language.Fortran.Or @ a z
                   Language.Fortran.And a1 -> Language.Fortran.And @ a z
                   Language.Fortran.Concat a1 -> Language.Fortran.Concat @ a z
                   Language.Fortran.Power a1 -> Language.Fortran.Power @ a z
                   Language.Fortran.RelEQ a1 -> Language.Fortran.RelEQ @ a z
                   Language.Fortran.RelNE a1 -> Language.Fortran.RelNE @ a z
                   Language.Fortran.RelLT a1 -> Language.Fortran.RelLT @ a z
                   Language.Fortran.RelLE a1 -> Language.Fortran.RelLE @ a z
                   Language.Fortran.RelGT a1 -> Language.Fortran.RelGT @ a z
                   Language.Fortran.RelGE a1 -> Language.Fortran.RelGE @ a z }) -}
896c0936a7e3480424b97ccaddc9354b
  $fFunctorBinOp_$cfmap ::
    (a -> b) -> Language.Fortran.BinOp a -> Language.Fortran.BinOp b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.BinOp a) ->
                 case ds of wild {
                   Language.Fortran.Plus a1 -> Language.Fortran.Plus @ b (f94 a1)
                   Language.Fortran.Minus a1 -> Language.Fortran.Minus @ b (f94 a1)
                   Language.Fortran.Mul a1 -> Language.Fortran.Mul @ b (f94 a1)
                   Language.Fortran.Div a1 -> Language.Fortran.Div @ b (f94 a1)
                   Language.Fortran.Or a1 -> Language.Fortran.Or @ b (f94 a1)
                   Language.Fortran.And a1 -> Language.Fortran.And @ b (f94 a1)
                   Language.Fortran.Concat a1 -> Language.Fortran.Concat @ b (f94 a1)
                   Language.Fortran.Power a1 -> Language.Fortran.Power @ b (f94 a1)
                   Language.Fortran.RelEQ a1 -> Language.Fortran.RelEQ @ b (f94 a1)
                   Language.Fortran.RelNE a1 -> Language.Fortran.RelNE @ b (f94 a1)
                   Language.Fortran.RelLT a1 -> Language.Fortran.RelLT @ b (f94 a1)
                   Language.Fortran.RelLE a1 -> Language.Fortran.RelLE @ b (f94 a1)
                   Language.Fortran.RelGT a1 -> Language.Fortran.RelGT @ b (f94 a1)
                   Language.Fortran.RelGE a1
                   -> Language.Fortran.RelGE @ b (f94 a1) }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fFunctorBlock :: GHC.Base.Functor Language.Fortran.Block
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Block
                  Language.Fortran.$fFunctorBlock_$cfmap
                  Language.Fortran.$fFunctorBlock_$c<$ -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fFunctorBlock_$c<$ ::
    a -> Language.Fortran.Block b -> Language.Fortran.Block a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S,1*U(A,1*U(1*U,U),1*U,U,1*U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w362 :: Language.Fortran.Block b) ->
                 case w362 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Language.Fortran.Block
                   @ a
                   w
                   (Language.Fortran.$fFunctorBlock_$c<$4 @ a @ b w ww2)
                   (Language.Fortran.$fFunctorBlock_$c<$3 @ a @ b w ww3)
                   ww4
                   (Language.Fortran.$fFunctorBlock_$c<$2 @ a @ b w ww5)
                   (Language.Fortran.$fFunctorBlock_$c<$1 @ a @ b w ww6) }) -}
96a246f096edd051e2860499c815ffa3
  $fFunctorBlock_$c<$1 ::
    a -> Language.Fortran.Fortran b -> Language.Fortran.Fortran a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
a81776e31635bc99f5c71e8648536701
  $fFunctorBlock_$c<$2 ::
    a -> Language.Fortran.Decl b -> Language.Fortran.Decl a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
bb388081fb116cff17a4c3fdaa0611fe
  $fFunctorBlock_$c<$3 ::
    a -> Language.Fortran.Implicit b -> Language.Fortran.Implicit a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.Implicit b) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ a z
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ a z }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fFunctorBlock_$c<$4 ::
    a -> Language.Fortran.UseBlock b -> Language.Fortran.UseBlock a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.UseBlock b) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ a
                   (Language.Fortran.$fFunctorBlock_$c<$5 @ a @ b z a1)
                   a2 }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fFunctorBlock_$c<$5 ::
    a -> Language.Fortran.Uses b -> Language.Fortran.Uses a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fFunctorBlock_$cfmap ::
    (a -> b) -> Language.Fortran.Block a -> Language.Fortran.Block b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S,1*U(U,1*U(1*U,U),1*U,U,1*U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w362 :: Language.Fortran.Block a) ->
                 case w362 of ww { Language.Fortran.Block ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Language.Fortran.Block
                   @ b
                   (w ww1)
                   (Language.Fortran.$fFunctorBlock_$cfmap4 @ a @ b w ww2)
                   (Language.Fortran.$fFunctorBlock_$cfmap3 @ a @ b w ww3)
                   ww4
                   (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b w ww5)
                   (Language.Fortran.$fFunctorBlock_$cfmap1 @ a @ b w ww6) }) -}
96a246f096edd051e2860499c815ffa3
  $fFunctorBlock_$cfmap1 ::
    (a -> b)
    -> Language.Fortran.Fortran a -> Language.Fortran.Fortran b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
a81776e31635bc99f5c71e8648536701
  $fFunctorBlock_$cfmap2 ::
    (a -> b) -> Language.Fortran.Decl a -> Language.Fortran.Decl b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
bb388081fb116cff17a4c3fdaa0611fe
  $fFunctorBlock_$cfmap3 ::
    (a -> b)
    -> Language.Fortran.Implicit a -> Language.Fortran.Implicit b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.Implicit a) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone a1
                   -> Language.Fortran.ImplicitNone @ b (f94 a1)
                   Language.Fortran.ImplicitNull a1
                   -> Language.Fortran.ImplicitNull @ b (f94 a1) }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fFunctorBlock_$cfmap4 ::
    (a -> b)
    -> Language.Fortran.UseBlock a -> Language.Fortran.UseBlock b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.UseBlock a) ->
                 case ds of wild { Language.Fortran.UseBlock a1 a2 ->
                 Language.Fortran.UseBlock
                   @ b
                   (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b f94 a1)
                   a2 }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fFunctorBlock_$cfmap5 ::
    (a -> b) -> Language.Fortran.Uses a -> Language.Fortran.Uses b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
dad4d55a5cea607426e414a10b8eea45
  $fFunctorDataForm :: GHC.Base.Functor Language.Fortran.DataForm
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.DataForm
                  Language.Fortran.$fFunctorDataForm_$cfmap
                  Language.Fortran.$fFunctorDataForm_$c<$ -}
dad4d55a5cea607426e414a10b8eea45
  $fFunctorDataForm_$c<$ ::
    a -> Language.Fortran.DataForm b -> Language.Fortran.DataForm a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w362 :: Language.Fortran.DataForm b) ->
                 case w362 of ww { Language.Fortran.Data ww1 ww2 ->
                 Language.Fortran.Data
                   @ a
                   w
                   (GHC.Base.map
                      @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                      @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                      (\ (b4 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                       case b4 of wild { (,) a1 a2 ->
                       (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b w a1,
                        Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b w a2) })
                      ww2) }) -}
dad4d55a5cea607426e414a10b8eea45
  $fFunctorDataForm_$cfmap ::
    (a -> b)
    -> Language.Fortran.DataForm a -> Language.Fortran.DataForm b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w362 :: Language.Fortran.DataForm a) ->
                 case w362 of ww { Language.Fortran.Data ww1 ww2 ->
                 Language.Fortran.Data
                   @ b
                   (w ww1)
                   (GHC.Base.map
                      @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                      @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                      (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                       case b1 of wild { (,) a1 a2 ->
                       (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b w a1,
                        Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b w a2) })
                      ww2) }) -}
a81776e31635bc99f5c71e8648536701
  $fFunctorDecl :: GHC.Base.Functor Language.Fortran.Decl
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Decl
                  Language.Fortran.$fFunctorBlock_$cfmap2
                  Language.Fortran.$fFunctorBlock_$c<$2 -}
045a18871aabc3897c4cc31c5a6f6de0
  $fFunctorExpr :: GHC.Base.Functor Language.Fortran.Expr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Expr
                  Language.Fortran.$fFunctorArgList_$cfmap1
                  Language.Fortran.$fFunctorArgList_$c<$1 -}
96a246f096edd051e2860499c815ffa3
  $fFunctorFortran :: GHC.Base.Functor Language.Fortran.Fortran
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Fortran
                  Language.Fortran.$fFunctorBlock_$cfmap1
                  Language.Fortran.$fFunctorBlock_$c<$1 -}
e90c235f732876f3296896ca224d9121
  $fFunctorFraction :: GHC.Base.Functor Language.Fortran.Fraction
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Fraction
                  Language.Fortran.$fFunctorAttr_$cfmap2
                  Language.Fortran.$fFunctorAttr_$c<$2 -}
a074c18ee753392beb804aeb08ff8264
  $fFunctorGSpec :: GHC.Base.Functor Language.Fortran.GSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.GSpec
                  Language.Fortran.$fFunctorGSpec_$cfmap
                  Language.Fortran.$fFunctorGSpec_$c<$ -}
a074c18ee753392beb804aeb08ff8264
  $fFunctorGSpec_$c<$ ::
    a -> Language.Fortran.GSpec b -> Language.Fortran.GSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.GSpec b) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> Language.Fortran.GName
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.GOper a1 a2
                   -> Language.Fortran.GOper
                        @ a
                        z
                        (Language.Fortran.$fFunctorBinOp_$c<$ @ a @ b z a2)
                   Language.Fortran.GAssg a1 -> Language.Fortran.GAssg @ a z }) -}
a074c18ee753392beb804aeb08ff8264
  $fFunctorGSpec_$cfmap ::
    (a -> b) -> Language.Fortran.GSpec a -> Language.Fortran.GSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.GSpec a) ->
                 case ds of wild {
                   Language.Fortran.GName a1 a2
                   -> Language.Fortran.GName
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a2)
                   Language.Fortran.GOper a1 a2
                   -> Language.Fortran.GOper
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBinOp_$cfmap @ a @ b f94 a2)
                   Language.Fortran.GAssg a1
                   -> Language.Fortran.GAssg @ b (f94 a1) }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fFunctorImplicit :: GHC.Base.Functor Language.Fortran.Implicit
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Implicit
                  Language.Fortran.$fFunctorBlock_$cfmap3
                  Language.Fortran.$fFunctorBlock_$c<$3 -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fFunctorIntentAttr :: GHC.Base.Functor Language.Fortran.IntentAttr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.IntentAttr
                  Language.Fortran.$fFunctorAttr_$cfmap3
                  Language.Fortran.$fFunctorAttr_$c<$3 -}
a81776e31635bc99f5c71e8648536701
  $fFunctorInterfaceSpec ::
    GHC.Base.Functor Language.Fortran.InterfaceSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.InterfaceSpec
                  Language.Fortran.$fFunctorInterfaceSpec_$cfmap
                  Language.Fortran.$fFunctorInterfaceSpec_$c<$ -}
a81776e31635bc99f5c71e8648536701
  $fFunctorInterfaceSpec_$c<$ ::
    a
    -> Language.Fortran.InterfaceSpec b
    -> Language.Fortran.InterfaceSpec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Language.Fortran.InterfaceSpec b) ->
                 case ds of wild {
                   Language.Fortran.FunctionInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.FunctionInterface
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z a2)
                        (Language.Fortran.$fFunctorArg_$c<$ @ a @ b z a3)
                        (Language.Fortran.$fFunctorBlock_$c<$5 @ a @ b z a4)
                        (Language.Fortran.$fFunctorBlock_$c<$3 @ a @ b z a5)
                        (Language.Fortran.$fFunctorBlock_$c<$2 @ a @ b z a6)
                   Language.Fortran.SubroutineInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.SubroutineInterface
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z a2)
                        (Language.Fortran.$fFunctorArg_$c<$ @ a @ b z a3)
                        (Language.Fortran.$fFunctorBlock_$c<$5 @ a @ b z a4)
                        (Language.Fortran.$fFunctorBlock_$c<$3 @ a @ b z a5)
                        (Language.Fortran.$fFunctorBlock_$c<$2 @ a @ b z a6)
                   Language.Fortran.ModuleProcedure a1 a2
                   -> Language.Fortran.ModuleProcedure
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.SubName b)
                           @ (Language.Fortran.SubName a)
                           (Language.Fortran.$fFunctorBaseType_$c<$1 @ a @ b z)
                           a2) }) -}
a81776e31635bc99f5c71e8648536701
  $fFunctorInterfaceSpec_$cfmap ::
    (a -> b)
    -> Language.Fortran.InterfaceSpec a
    -> Language.Fortran.InterfaceSpec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.InterfaceSpec a) ->
                 case ds of wild {
                   Language.Fortran.FunctionInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.FunctionInterface
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94 a2)
                        (Language.Fortran.$fFunctorArg_$cfmap @ a @ b f94 a3)
                        (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b f94 a4)
                        (Language.Fortran.$fFunctorBlock_$cfmap3 @ a @ b f94 a5)
                        (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b f94 a6)
                   Language.Fortran.SubroutineInterface a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.SubroutineInterface
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94 a2)
                        (Language.Fortran.$fFunctorArg_$cfmap @ a @ b f94 a3)
                        (Language.Fortran.$fFunctorBlock_$cfmap5 @ a @ b f94 a4)
                        (Language.Fortran.$fFunctorBlock_$cfmap3 @ a @ b f94 a5)
                        (Language.Fortran.$fFunctorBlock_$cfmap2 @ a @ b f94 a6)
                   Language.Fortran.ModuleProcedure a1 a2
                   -> Language.Fortran.ModuleProcedure
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.SubName a)
                           @ (Language.Fortran.SubName b)
                           (Language.Fortran.$fFunctorBaseType_$cfmap1 @ a @ b f94)
                           a2) }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fFunctorMeasureUnitSpec ::
    GHC.Base.Functor Language.Fortran.MeasureUnitSpec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.MeasureUnitSpec
                  Language.Fortran.$fFunctorAttr_$cfmap1
                  Language.Fortran.$fFunctorAttr_$c<$1 -}
cf6f89a9a11f4455970aae08e46ad751
  $fFunctorProgUnit :: GHC.Base.Functor Language.Fortran.ProgUnit
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.ProgUnit
                  Language.Fortran.$fFunctorProgUnit_$cfmap
                  Language.Fortran.$fFunctorProgUnit_$c<$ -}
cf6f89a9a11f4455970aae08e46ad751
  $fFunctorProgUnit_$c<$ ::
    a -> Language.Fortran.ProgUnit b -> Language.Fortran.ProgUnit a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
cf6f89a9a11f4455970aae08e46ad751
  $fFunctorProgUnit_$cfmap ::
    (a -> b)
    -> Language.Fortran.ProgUnit a -> Language.Fortran.ProgUnit b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fFunctorSpec :: GHC.Base.Functor Language.Fortran.Spec
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Spec
                  Language.Fortran.$fFunctorSpec_$cfmap
                  Language.Fortran.$fFunctorSpec_$c<$ -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fFunctorSpec_$c<$ ::
    a -> Language.Fortran.Spec b -> Language.Fortran.Spec a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.Spec b) ->
                 case ds of wild {
                   Language.Fortran.Access a1 a2
                   -> Language.Fortran.Access
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Action a1 a2
                   -> Language.Fortran.Action
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Advance a1 a2
                   -> Language.Fortran.Advance
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Blank a1 a2
                   -> Language.Fortran.Blank
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Delim a1 a2
                   -> Language.Fortran.Delim
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Direct a1 a2
                   -> Language.Fortran.Direct
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.End a1 a2
                   -> Language.Fortran.End
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Err a1 a2
                   -> Language.Fortran.Err
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.ExFile a1 a2
                   -> Language.Fortran.ExFile
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Exist a1 a2
                   -> Language.Fortran.Exist
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Eor a1 a2
                   -> Language.Fortran.Eor
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.File a1 a2
                   -> Language.Fortran.File
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.FMT a1 a2
                   -> Language.Fortran.FMT
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Form a1 a2
                   -> Language.Fortran.Form
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Formatted a1 a2
                   -> Language.Fortran.Formatted
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Unformatted a1 a2
                   -> Language.Fortran.Unformatted
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.IOLength a1 a2
                   -> Language.Fortran.IOLength
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.IOStat a1 a2
                   -> Language.Fortran.IOStat
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Name a1 a2
                   -> Language.Fortran.Name
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Named a1 a2
                   -> Language.Fortran.Named
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.NoSpec a1 a2
                   -> Language.Fortran.NoSpec
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Number a1 a2
                   -> Language.Fortran.Number
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Floating a1 a2 a3
                   -> Language.Fortran.Floating
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a3)
                   Language.Fortran.NextRec a1 a2
                   -> Language.Fortran.NextRec
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.NML a1 a2
                   -> Language.Fortran.NML
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Opened a1 a2
                   -> Language.Fortran.Opened
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Pad a1 a2
                   -> Language.Fortran.Pad
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Position a1 a2
                   -> Language.Fortran.Position
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Read a1 a2
                   -> Language.Fortran.Read
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.ReadWrite a1 a2
                   -> Language.Fortran.ReadWrite
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Rec a1 a2
                   -> Language.Fortran.Rec
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Recl a1 a2
                   -> Language.Fortran.Recl
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Sequential a1 a2
                   -> Language.Fortran.Sequential
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Size a1 a2
                   -> Language.Fortran.Size
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Status a1 a2
                   -> Language.Fortran.Status
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.StringLit a1 a2
                   -> Language.Fortran.StringLit @ a z a2
                   Language.Fortran.Unit a1 a2
                   -> Language.Fortran.Unit
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.WriteSp a1 a2
                   -> Language.Fortran.WriteSp
                        @ a
                        z
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a2)
                   Language.Fortran.Delimiter a1
                   -> Language.Fortran.Delimiter @ a z }) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fFunctorSpec_$cfmap ::
    (a -> b) -> Language.Fortran.Spec a -> Language.Fortran.Spec b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
2661346c18056b3b907f62427e1b219c
  $fFunctorSubName :: GHC.Base.Functor Language.Fortran.SubName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SubName
                  Language.Fortran.$fFunctorBaseType_$cfmap1
                  Language.Fortran.$fFunctorBaseType_$c<$1 -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fFunctorType :: GHC.Base.Functor Language.Fortran.Type
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Type
                  Language.Fortran.$fFunctorType_$cfmap
                  Language.Fortran.$fFunctorType_$c<$ -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fFunctorType_$c<$ ::
    a -> Language.Fortran.Type b -> Language.Fortran.Type a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ a @ b (z :: a) (ds :: Language.Fortran.Type b) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> Language.Fortran.BaseType
                        @ a
                        z
                        (Language.Fortran.$fFunctorBaseType_$c<$ @ a @ b z a2)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr b)
                           @ (Language.Fortran.Attr a)
                           (Language.Fortran.$fFunctorAttr_$c<$ @ a @ b z)
                           a3)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a4)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a5)
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.ArrayT
                        @ a
                        z
                        (GHC.Base.map
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           (\ (b4 :: (Language.Fortran.Expr b, Language.Fortran.Expr b)) ->
                            case b4 of wild1 { (,) a7 a8 ->
                            (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a7,
                             Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a8) })
                           a2)
                        (Language.Fortran.$fFunctorBaseType_$c<$ @ a @ b z a3)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr b)
                           @ (Language.Fortran.Attr a)
                           (Language.Fortran.$fFunctorAttr_$c<$ @ a @ b z)
                           a4)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a5)
                        (Language.Fortran.$fFunctorArgList_$c<$1 @ a @ b z a6) }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fFunctorType_$cfmap ::
    (a -> b) -> Language.Fortran.Type a -> Language.Fortran.Type b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f94 :: a -> b)
                   (ds :: Language.Fortran.Type a) ->
                 case ds of wild {
                   Language.Fortran.BaseType a1 a2 a3 a4 a5
                   -> Language.Fortran.BaseType
                        @ b
                        (f94 a1)
                        (Language.Fortran.$fFunctorBaseType_$cfmap @ a @ b f94 a2)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr a)
                           @ (Language.Fortran.Attr b)
                           (Language.Fortran.$fFunctorAttr_$cfmap @ a @ b f94)
                           a3)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a4)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a5)
                   Language.Fortran.ArrayT a1 a2 a3 a4 a5 a6
                   -> Language.Fortran.ArrayT
                        @ b
                        (f94 a1)
                        (GHC.Base.map
                           @ (Language.Fortran.Expr a, Language.Fortran.Expr a)
                           @ (Language.Fortran.Expr b, Language.Fortran.Expr b)
                           (\ (b1 :: (Language.Fortran.Expr a, Language.Fortran.Expr a)) ->
                            case b1 of wild1 { (,) a7 a8 ->
                            (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a7,
                             Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a8) })
                           a2)
                        (Language.Fortran.$fFunctorBaseType_$cfmap @ a @ b f94 a3)
                        (GHC.Base.map
                           @ (Language.Fortran.Attr a)
                           @ (Language.Fortran.Attr b)
                           (Language.Fortran.$fFunctorAttr_$cfmap @ a @ b f94)
                           a4)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a5)
                        (Language.Fortran.$fFunctorArgList_$cfmap1 @ a @ b f94 a6) }) -}
427f27131e64ea3da026fe120bf90190
  $fFunctorUnaryOp :: GHC.Base.Functor Language.Fortran.UnaryOp
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.UnaryOp
                  Language.Fortran.$fFunctorUnaryOp_$cfmap
                  Language.Fortran.$fFunctorUnaryOp_$c<$ -}
427f27131e64ea3da026fe120bf90190
  $fFunctorUnaryOp_$c<$ ::
    a -> Language.Fortran.UnaryOp b -> Language.Fortran.UnaryOp a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.UnaryOp b) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1 -> Language.Fortran.UMinus @ a z
                   Language.Fortran.Not a1 -> Language.Fortran.Not @ a z }) -}
427f27131e64ea3da026fe120bf90190
  $fFunctorUnaryOp_$cfmap ::
    (a -> b)
    -> Language.Fortran.UnaryOp a -> Language.Fortran.UnaryOp b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.UnaryOp a) ->
                 case ds of wild {
                   Language.Fortran.UMinus a1 -> Language.Fortran.UMinus @ b (f94 a1)
                   Language.Fortran.Not a1 -> Language.Fortran.Not @ b (f94 a1) }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fFunctorUseBlock :: GHC.Base.Functor Language.Fortran.UseBlock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.UseBlock
                  Language.Fortran.$fFunctorBlock_$cfmap4
                  Language.Fortran.$fFunctorBlock_$c<$4 -}
f37cb87c0c5362747ff382fcf7036b42
  $fFunctorUses :: GHC.Base.Functor Language.Fortran.Uses
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.Uses
                  Language.Fortran.$fFunctorBlock_$cfmap5
                  Language.Fortran.$fFunctorBlock_$c<$5 -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fFunctorVarName :: GHC.Base.Functor Language.Fortran.VarName
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.VarName
                  Language.Fortran.$fFunctorVarName_$cfmap
                  Language.Fortran.$fFunctorVarName_$c<$ -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fFunctorVarName_$c<$ ::
    a -> Language.Fortran.VarName b -> Language.Fortran.VarName a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: Language.Fortran.VarName b) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName @ a z a2 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fFunctorVarName_$cfmap ::
    (a -> b)
    -> Language.Fortran.VarName a -> Language.Fortran.VarName b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f94 :: a -> b) (ds :: Language.Fortran.VarName a) ->
                 case ds of wild { Language.Fortran.VarName a1 a2 ->
                 Language.Fortran.VarName @ b (f94 a1) a2 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName ::
    GHC.Classes.Ord p => GHC.Classes.Ord (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Classes.Ord p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fOrdVarName_$cp1Ord @ p v)
                  (Language.Fortran.$fOrdVarName_$ccompare @ p v)
                  (Language.Fortran.$fOrdVarName_$c< @ p v)
                  (Language.Fortran.$fOrdVarName_$c<= @ p v)
                  (\ (a :: Language.Fortran.VarName p)
                     (b :: Language.Fortran.VarName p) ->
                   Language.Fortran.$fOrdVarName_$c< @ p v b a)
                  (Language.Fortran.$fOrdVarName_$c>= @ p v)
                  (Language.Fortran.$fOrdVarName_$cmax @ p v)
                  (Language.Fortran.$fOrdVarName_$cmin @ p v) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$c< ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c< @ p w ww1 ww2 ww4 ww5 } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$c<= ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c<= @ p w ww1 ww2 ww4 ww5 } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$c>= ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$c>= @ p w ww1 ww2 ww4 ww5 } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$ccompare ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 Language.Fortran.$w$ccompare @ p w ww1 ww2 ww4 ww5 } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$cmax ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.compare @ p w ww4 ww1 of wild {
                   GHC.Types.LT -> Language.Fortran.VarName @ p ww1 ww2
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww5 ww2 of wild1 {
                        DEFAULT -> Language.Fortran.VarName @ p ww4 ww5
                        GHC.Types.LT -> Language.Fortran.VarName @ p ww1 ww2 }
                   GHC.Types.GT -> Language.Fortran.VarName @ p ww4 ww5 } } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$cmin ::
    GHC.Classes.Ord p =>
    Language.Fortran.VarName p
    -> Language.Fortran.VarName p -> Language.Fortran.VarName p
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (w362 :: Language.Fortran.VarName p)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { Language.Fortran.VarName ww1 ww2 ->
                 case w363 of ww3 { Language.Fortran.VarName ww4 ww5 ->
                 case GHC.Classes.compare @ p w ww4 ww1 of wild {
                   GHC.Types.LT -> Language.Fortran.VarName @ p ww4 ww5
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww5 ww2 of wild1 {
                        DEFAULT -> Language.Fortran.VarName @ p ww1 ww2
                        GHC.Types.LT -> Language.Fortran.VarName @ p ww4 ww5 }
                   GHC.Types.GT -> Language.Fortran.VarName @ p ww1 ww2 } } }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fOrdVarName_$cp1Ord ::
    GHC.Classes.Ord p => GHC.Classes.Eq (Language.Fortran.VarName p)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dOrd :: GHC.Classes.Ord p) ->
                 Language.Fortran.$fEqVarName @ p (GHC.Classes.$p1Ord @ p $dOrd)) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fReadVarName ::
    GHC.Read.Read p => GHC.Read.Read (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Read.Read p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fReadVarName_$creadsPrec @ p v)
                  (Language.Fortran.$fReadVarName_$creadList @ p v)
                  (Language.Fortran.$fReadVarName1 @ p v)
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Language.Fortran.VarName
                                     p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <Language.Fortran.VarName p>_R))
                  (Language.Fortran.$fReadVarName_$creadListPrec @ p v) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fReadVarName1 ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Language.Fortran.VarName p -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ p
                   ($dRead :: GHC.Read.Read p)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Language.Fortran.VarName p
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$fRead()6
                   @ (Language.Fortran.VarName p)
                   (\ (c :: Text.ParserCombinators.ReadPrec.Prec)
                      @ b1
                      (eta2 :: Language.Fortran.VarName p
                               -> Text.ParserCombinators.ReadP.P b1) ->
                    case c of wild { GHC.Types.I# x ->
                    case GHC.Prim.<=# x 10# of lwild {
                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                      1#
                      -> let {
                           lvl295 :: Text.ParserCombinators.ReadP.P b1
                           = let {
                               lvl296 :: Text.ParserCombinators.ReadP.P b1
                               = ((GHC.Read.readPrec @ p $dRead)
                                    `cast`
                                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <p>_R)
                                    Language.Fortran.$fReadVarName2)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.N:ReadP[0] <p>_R)
                                   @ b1
                                   (\ (a1 :: p) ->
                                    GHC.Read.$fRead()6
                                      @ GHC.Base.String
                                      GHC.Read.$fReadChar2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <GHC.Base.String>_R))
                                      Language.Fortran.$fReadVarName2
                                      @ b1
                                      (\ (a2 :: Language.Fortran.Variable) ->
                                       eta2 (Language.Fortran.VarName @ p a1 a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b1
                               (\ (a3 :: Text.Read.Lex.Lexeme) ->
                                case a3 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                                  Text.Read.Lex.Ident a1
                                  -> case GHC.Base.eqString
                                            a1
                                            Language.Fortran.$fDataVarName8 of wild2 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                                       GHC.Types.True -> lvl296 } })
                         } in
                         let {
                           k :: () -> Text.ParserCombinators.ReadP.P b1
                             {- Arity: 1, Strictness: <L,A>,
                                Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl295) -}
                           = \ (a3 :: ()) -> lvl295
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b1
                           (\ (a :: GHC.Base.String) ->
                            Text.ParserCombinators.ReadP.skipSpaces2 a @ b1 k) } })
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Language.Fortran.VarName
                                      p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Language.Fortran.VarName p>_R))
                   eta
                   @ b
                   eta1) -}
7dc5f8c42a5fc02a867294594d28ba27
  $fReadVarName2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fReadVarName_$creadList ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadP.ReadS [Language.Fortran.VarName p]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Language.Fortran.VarName p]
                   (((GHC.Read.list
                        @ (Language.Fortran.VarName p)
                        (Language.Fortran.$fReadVarName1 @ p $dRead)
                          `cast`
                        ((<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                        <Language.Fortran.VarName
                                           p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                             <Language.Fortran.VarName p>_R)))
                       `cast`
                     (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <[Language.Fortran.VarName p]>_R)
                       GHC.Read.$fRead()8)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <[Language.Fortran.VarName p]>_R)
                      @ [Language.Fortran.VarName p]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Language.Fortran.VarName p]))) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fReadVarName_$creadListPrec ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Language.Fortran.VarName p]
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) ->
                 GHC.Read.list
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fReadVarName1 @ p $dRead)
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Language.Fortran.VarName
                                      p>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Language.Fortran.VarName p>_R))) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fReadVarName_$creadsPrec ::
    GHC.Read.Read p =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (Language.Fortran.VarName p)
  {- Arity: 2, Strictness: <L,U(A,A,C(C1(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p ($dRead :: GHC.Read.Read p) (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fReadVarName1
                      @ p
                      $dRead
                      n
                      @ (Language.Fortran.VarName p)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Language.Fortran.VarName p)))) -}
d3fedd88bb81c839018aa8b13497c1de
  $fShowArg ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Arg p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Arg p)
                  (Language.Fortran.$fShowArg_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowArg_$cshow @ p v)
                  (Language.Fortran.$fShowArg_$cshowList @ p v) -}
4f2eece5b07781a216f7036a727e31d3
  $fShowArg1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (",c"#) -}
618be97b8a65782ee42f0c2645bb903c
  $fShowArg10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Arg "#) -}
39dc3aac0c6d01ea871aaf8b65ac5131
  $fShowArg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{l"#) -}
35982ff9133c1afeb6838134f79e4c88
  $fShowArg3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowArg4) -}
f9f51e7af0612928d2d94a65c42e2bb3
  $fShowArg4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
ac86e0c8bb6551da8c15351cda322af8
  $fShowArg5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", col = "#) -}
282026d3aafb681c87df67045264af64
  $fShowArg6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", line = "#) -}
39fedeb3cdf5b0709cdb846df82dfabc
  $fShowArg7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{"#) -}
5dfe8b714567ee41aee21654893a692b
  $fShowArg8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowArg9) -}
d1b3092d24f6906b0ba86ea06c4b9566
  $fShowArg9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("compact"#) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowArgList ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ArgList p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.ArgList p)
                  (Language.Fortran.$fShowArgList_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowArgList_$cshow @ p v)
                  (Language.Fortran.$fShowArgList_$cshowList @ p v) -}
f92f833ce02bcdb11e02f34a61238627
  $fShowArgList1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ArgList "#) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowArgList_$cshow ::
    GHC.Show.Show p => Language.Fortran.ArgList p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ArgList p) ->
                 Language.Fortran.$fShowArgList_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowArgList_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ArgList p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.ArgList p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ArgList p)
                   (Language.Fortran.$fShowArgList_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowArgList_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ArgList p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.ArgList p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.ArgList ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec2 @ p w ww1 ww3 ww4 } }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fShowArgName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ArgName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.ArgName p)
                  (Language.Fortran.$fShowArgName_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowArgName_$cshow @ p v)
                  (Language.Fortran.$fShowArgName_$cshowList @ p v) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fShowArgName_$cshow ::
    GHC.Show.Show p => Language.Fortran.ArgName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ArgName p) ->
                 Language.Fortran.$fShowArgName_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fShowArgName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ArgName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.ArgName p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ArgName p)
                   (Language.Fortran.$fShowArgName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $fShowArgName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ArgName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.ArgName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec1 @ p w ww1 w363 }) -}
d3fedd88bb81c839018aa8b13497c1de
  $fShowArg_$cshow ::
    GHC.Show.Show p => Language.Fortran.Arg p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p ($dShow :: GHC.Show.Show p) (x :: Language.Fortran.Arg p) ->
                 Language.Fortran.$fShowArg_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d3fedd88bb81c839018aa8b13497c1de
  $fShowArg_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Arg p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Arg p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Arg p)
                   (Language.Fortran.$fShowArg_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
d3fedd88bb81c839018aa8b13497c1de
  $fShowArg_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Arg p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Arg p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.Arg ww3 ww4 ww5 ->
                 Language.Fortran.$w$cshowsPrec @ p w ww1 ww3 ww4 ww5 } }) -}
02a255cfb28c667ea6da849cf85b59d6
  $fShowAttr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Attr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Attr p)
                  (Language.Fortran.$fShowAttr_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowAttr_$cshow @ p v)
                  (Language.Fortran.$fShowAttr_$cshowList @ p v) -}
02a255cfb28c667ea6da849cf85b59d6
  $fShowAttr_$cshow ::
    GHC.Show.Show p => Language.Fortran.Attr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Attr p) ->
                 Language.Fortran.$fShowAttr_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
02a255cfb28c667ea6da849cf85b59d6
  $fShowAttr_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Attr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Attr p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Attr p)
                   (Language.Fortran.$fShowAttr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
02a255cfb28c667ea6da849cf85b59d6
  $fShowAttr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Attr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Attr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec4 @ p w ww1 w363 }) -}
69d5dfd4df9415765a99abb747654948
  $fShowBaseType ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.BaseType p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.BaseType p)
                  (Language.Fortran.$fShowBaseType_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowBaseType_$cshow @ p v)
                  (Language.Fortran.$fShowBaseType_$cshowList @ p v) -}
69d5dfd4df9415765a99abb747654948
  $fShowBaseType_$cshow ::
    GHC.Show.Show p => Language.Fortran.BaseType p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.BaseType p) ->
                 Language.Fortran.$fShowBaseType_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
69d5dfd4df9415765a99abb747654948
  $fShowBaseType_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.BaseType p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.BaseType p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.BaseType p)
                   (Language.Fortran.$fShowBaseType_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
69d5dfd4df9415765a99abb747654948
  $fShowBaseType_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.BaseType p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.BaseType p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec5 @ p w ww1 w363 }) -}
896c0936a7e3480424b97ccaddc9354b
  $fShowBinOp ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.BinOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.BinOp p)
                  (Language.Fortran.$fShowBinOp_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowBinOp_$cshow @ p v)
                  (Language.Fortran.$fShowBinOp_$cshowList @ p v) -}
896c0936a7e3480424b97ccaddc9354b
  $fShowBinOp_$cshow ::
    GHC.Show.Show p => Language.Fortran.BinOp p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.BinOp p) ->
                 Language.Fortran.$fShowBinOp_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
896c0936a7e3480424b97ccaddc9354b
  $fShowBinOp_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.BinOp p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.BinOp p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.BinOp p)
                   (Language.Fortran.$fShowBinOp_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
896c0936a7e3480424b97ccaddc9354b
  $fShowBinOp_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.BinOp p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.BinOp p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec6 @ p w ww1 w363 }) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fShowBlock ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Block p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Block p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowBlock_$cshow @ p v)
                  (Language.Fortran.$fShowBlock_$cshowList @ p v) -}
6d2ba2129b3e733ff2012c4c63cdb8bd
  $fShowBlock1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Block "#) -}
74c85c5bcb80fb8a88671c5c1b90c3a0
  $fShowBlock2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowBlock3) -}
80a0eb5aa2d7427b40718f29a4300f12
  $fShowBlock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ImplicitNull "#) -}
5fae40fca1083a97067f3905f2864794
  $fShowBlock4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowBlock5) -}
91bb11ee4b6abd27f1e65d0f75fb1111
  $fShowBlock5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ImplicitNone "#) -}
18413278c2c95100eeda9925fc004006
  $fShowBlock6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UseBlock "#) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fShowBlock_$cshow ::
    GHC.Show.Show p => Language.Fortran.Block p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,1*U(1*U,U(U,U(U),U(U))),1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))),U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Block p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fShowBlock_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Block p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Block p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Block p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
b0aacfbcefe95ece6fbb0f40cd37c948
  $fShowBlock_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Block p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,1*U(1*U,U(U,U(U),U(U))),1*U,U(U(U,U(U),U(U)),U(U,U(U),U(U))),U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Block p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.Block ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Language.Fortran.$w$cshowsPrec7
                   @ p
                   w
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8 } }) -}
96a246f096edd051e2860499c815ffa3
  $fShowBlock_$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Fortran p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)> -}
a81776e31635bc99f5c71e8648536701
  $fShowBlock_$cshowsPrec2 ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Decl p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)> -}
dad4d55a5cea607426e414a10b8eea45
  $fShowDataForm ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.DataForm p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.DataForm p)
                  (Language.Fortran.$fShowDataForm_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowDataForm_$cshow @ p v)
                  (Language.Fortran.$fShowDataForm_$cshowList @ p v) -}
87913ceb5ccb1c03e6b3a3eb0f109db2
  $fShowDataForm1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Data "#) -}
dad4d55a5cea607426e414a10b8eea45
  $fShowDataForm_$cshow ::
    GHC.Show.Show p => Language.Fortran.DataForm p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.DataForm p) ->
                 Language.Fortran.$fShowDataForm_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dad4d55a5cea607426e414a10b8eea45
  $fShowDataForm_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.DataForm p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.DataForm p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.DataForm p)
                   (Language.Fortran.$fShowDataForm_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
dad4d55a5cea607426e414a10b8eea45
  $fShowDataForm_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.DataForm p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.DataForm p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.Data ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec11 @ p w ww1 ww3 ww4 } }) -}
a81776e31635bc99f5c71e8648536701
  $fShowDecl ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Decl p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Decl p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec2 @ p v)
                  (Language.Fortran.$fShowDecl_$cshow @ p v)
                  (Language.Fortran.$fShowDecl_$cshowList @ p v) -}
a81776e31635bc99f5c71e8648536701
  $fShowDecl_$cshow ::
    GHC.Show.Show p => Language.Fortran.Decl p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Decl p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec2
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a81776e31635bc99f5c71e8648536701
  $fShowDecl_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Decl p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Decl p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Decl p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec2
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowExpr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Expr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Expr p)
                  (Language.Fortran.$fShowExpr_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowExpr_$cshow @ p v)
                  (Language.Fortran.$fShowExpr_$cshowList @ p v) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowExpr_$cshow ::
    GHC.Show.Show p => Language.Fortran.Expr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Expr p) ->
                 Language.Fortran.$fShowExpr_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowExpr_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Expr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Expr p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Expr p)
                   (Language.Fortran.$fShowExpr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
045a18871aabc3897c4cc31c5a6f6de0
  $fShowExpr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Expr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec3 @ p w ww1 w363 }) -}
96a246f096edd051e2860499c815ffa3
  $fShowFortran ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Fortran p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Fortran p)
                  (Language.Fortran.$fShowBlock_$cshowsPrec1 @ p v)
                  (Language.Fortran.$fShowFortran_$cshow @ p v)
                  (Language.Fortran.$fShowFortran_$cshowList @ p v) -}
96a246f096edd051e2860499c815ffa3
  $fShowFortran_$cshow ::
    GHC.Show.Show p => Language.Fortran.Fortran p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Fortran p) ->
                 Language.Fortran.$fShowBlock_$cshowsPrec1
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
96a246f096edd051e2860499c815ffa3
  $fShowFortran_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Fortran p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Fortran p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Fortran p)
                   (Language.Fortran.$fShowBlock_$cshowsPrec1
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
e90c235f732876f3296896ca224d9121
  $fShowFraction ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Fraction p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Fraction p)
                  (Language.Fortran.$fShowFraction_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowFraction_$cshow @ p v)
                  (Language.Fortran.$fShowFraction_$cshowList @ p v) -}
380de8d3b30085297a901bdc117003da
  $fShowFraction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowFraction2) -}
071cabf3cda70451f2ec76cf08e762db
  $fShowFraction2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NullFraction "#) -}
3f17a888afda46e8f7f8b2d4aa8a9666
  $fShowFraction3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("FractionConst "#) -}
e7d5ea245b13f7fd38fd665ec11eb902
  $fShowFraction4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IntegerConst "#) -}
e90c235f732876f3296896ca224d9121
  $fShowFraction_$cshow ::
    GHC.Show.Show p => Language.Fortran.Fraction p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Fraction p) ->
                 Language.Fortran.$fShowFraction_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e90c235f732876f3296896ca224d9121
  $fShowFraction_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Fraction p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Fraction p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Fraction p)
                   (Language.Fortran.$fShowFraction_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
e90c235f732876f3296896ca224d9121
  $fShowFraction_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Fraction p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Fraction p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec12 @ p w ww1 w363 }) -}
a074c18ee753392beb804aeb08ff8264
  $fShowGSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.GSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.GSpec p)
                  (Language.Fortran.$fShowGSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowGSpec_$cshow @ p v)
                  (Language.Fortran.$fShowGSpec_$cshowList @ p v) -}
fa193cf7474c76c39ce29bcbacc17454
  $fShowGSpec1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowGSpec2) -}
d9a0e77be9cffc2f927039ec1f534ec4
  $fShowGSpec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GAssg "#) -}
c103ff9a91213b8d6b2a076fca22afdf
  $fShowGSpec3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GOper "#) -}
eb660c56fc395d6c55068dd7cc9ff10e
  $fShowGSpec4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("GName "#) -}
a074c18ee753392beb804aeb08ff8264
  $fShowGSpec_$cshow ::
    GHC.Show.Show p => Language.Fortran.GSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.GSpec p) ->
                 Language.Fortran.$fShowGSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a074c18ee753392beb804aeb08ff8264
  $fShowGSpec_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.GSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.GSpec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.GSpec p)
                   (Language.Fortran.$fShowGSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
a074c18ee753392beb804aeb08ff8264
  $fShowGSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.GSpec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.GSpec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec13 @ p w ww1 w363 }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fShowImplicit ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Implicit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Implicit p)
                  (Language.Fortran.$fShowImplicit_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowImplicit_$cshow @ p v)
                  (Language.Fortran.$fShowImplicit_$cshowList @ p v) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fShowImplicit_$cshow ::
    GHC.Show.Show p => Language.Fortran.Implicit p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Implicit p) ->
                 case x of wild {
                   Language.Fortran.ImplicitNone b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowBlock4
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.ImplicitNull b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowBlock2
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fShowImplicit_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Implicit p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Implicit p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Implicit p)
                   (Language.Fortran.$fShowImplicit_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
bb388081fb116cff17a4c3fdaa0611fe
  $fShowImplicit_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Implicit p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Implicit p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec8 @ p w ww1 w363 }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fShowIntentAttr ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.IntentAttr p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.IntentAttr p)
                  (Language.Fortran.$fShowIntentAttr_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowIntentAttr_$cshow @ p v)
                  (Language.Fortran.$fShowIntentAttr_$cshowList @ p v) -}
6dc03d611410729bfbb559d2f4d82b14
  $fShowIntentAttr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowIntentAttr2) -}
eb5144fea985289b81cbf22febea8c79
  $fShowIntentAttr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InOut "#) -}
ab1cdbcbc7e369ee39bfd94749de94b5
  $fShowIntentAttr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowIntentAttr4) -}
50ad7e521d65aea547a59f8ec0e73223
  $fShowIntentAttr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Out "#) -}
696a8ddbf6ac74e3ff81e1f6c19e377a
  $fShowIntentAttr5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowIntentAttr6) -}
3ea359b9353576b4e4a279e6cd2b2092
  $fShowIntentAttr6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("In "#) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fShowIntentAttr_$cshow ::
    GHC.Show.Show p => Language.Fortran.IntentAttr p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.IntentAttr p) ->
                 case x of wild {
                   Language.Fortran.In b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr5
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.Out b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr3
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.InOut b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowIntentAttr1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fShowIntentAttr_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.IntentAttr p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.IntentAttr p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.IntentAttr p)
                   (Language.Fortran.$fShowIntentAttr_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $fShowIntentAttr_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.IntentAttr p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.IntentAttr p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec14 @ p w ww1 w363 }) -}
a81776e31635bc99f5c71e8648536701
  $fShowInterfaceSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.InterfaceSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.InterfaceSpec p)
                  (Language.Fortran.$fShowInterfaceSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowInterfaceSpec_$cshow @ p v)
                  (Language.Fortran.$fShowInterfaceSpec_$cshowList @ p v) -}
a81776e31635bc99f5c71e8648536701
  $fShowInterfaceSpec_$cshow ::
    GHC.Show.Show p =>
    Language.Fortran.InterfaceSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.InterfaceSpec p) ->
                 Language.Fortran.$fShowInterfaceSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a81776e31635bc99f5c71e8648536701
  $fShowInterfaceSpec_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.InterfaceSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.InterfaceSpec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.InterfaceSpec p)
                   (Language.Fortran.$fShowInterfaceSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
a81776e31635bc99f5c71e8648536701
  $fShowInterfaceSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.InterfaceSpec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.InterfaceSpec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec15 @ p w ww1 w363 }) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fShowMeasureUnitSpec ::
    GHC.Show.Show p =>
    GHC.Show.Show (Language.Fortran.MeasureUnitSpec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.MeasureUnitSpec p)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshow @ p v)
                  (Language.Fortran.$fShowMeasureUnitSpec_$cshowList @ p v) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fShowMeasureUnitSpec_$cshow ::
    GHC.Show.Show p =>
    Language.Fortran.MeasureUnitSpec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.MeasureUnitSpec p) ->
                 Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fShowMeasureUnitSpec_$cshowList ::
    GHC.Show.Show p =>
    [Language.Fortran.MeasureUnitSpec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.MeasureUnitSpec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.MeasureUnitSpec p)
                   (Language.Fortran.$fShowMeasureUnitSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
a4588ee68ff39c65875cdbcceadc05a6
  $fShowMeasureUnitSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.MeasureUnitSpec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec16 @ p w ww1 w363 }) -}
cf6f89a9a11f4455970aae08e46ad751
  $fShowProgUnit ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.ProgUnit p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.ProgUnit p)
                  (Language.Fortran.$fShowProgUnit_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowProgUnit_$cshow @ p v)
                  (Language.Fortran.$fShowProgUnit_$cshowList @ p v) -}
cf6f89a9a11f4455970aae08e46ad751
  $fShowProgUnit_$cshow ::
    GHC.Show.Show p => Language.Fortran.ProgUnit p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.ProgUnit p) ->
                 Language.Fortran.$fShowProgUnit_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cf6f89a9a11f4455970aae08e46ad751
  $fShowProgUnit_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.ProgUnit p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.ProgUnit p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.ProgUnit p)
                   (Language.Fortran.$fShowProgUnit_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
cf6f89a9a11f4455970aae08e46ad751
  $fShowProgUnit_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.ProgUnit p -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)> -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fShowSpec ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Spec p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Spec p)
                  (Language.Fortran.$fShowSpec_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowSpec_$cshow @ p v)
                  (Language.Fortran.$fShowSpec_$cshowList @ p v) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fShowSpec_$cshow ::
    GHC.Show.Show p => Language.Fortran.Spec p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Spec p) ->
                 Language.Fortran.$fShowSpec_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fShowSpec_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Spec p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Spec p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Spec p)
                   (Language.Fortran.$fShowSpec_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $fShowSpec_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Spec p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Spec p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec17 @ p w ww1 w363 }) -}
5d55b2485fd718d78674934e1c1437fb
  $fShowSrcLoc :: GHC.Show.Show Language.Fortran.SrcLoc
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Language.Fortran.SrcLoc
                  Language.Fortran.$fShowSrcLoc_$cshowsPrec
                  Language.Fortran.$fShowSrcLoc_$cshow
                  Language.Fortran.$fShowSrcLoc_$cshowList -}
5d55b2485fd718d78674934e1c1437fb
  $fShowSrcLoc1 ::
    Language.Fortran.SrcLoc -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SLL),1*U(U,1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Language.Fortran.SrcLoc)
                   (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Language.Fortran.$fShowSrcLoc_$cshow x))
                   s) -}
5d55b2485fd718d78674934e1c1437fb
  $fShowSrcLoc_$cshow :: Language.Fortran.SrcLoc -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SLL),1*U(U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Language.Fortran.SrcLoc) ->
                 case w of ww { Language.Fortran.SrcLoc ww1 ww2 ww3 ->
                 Language.Fortran.$w$cshow ww1 ww2 ww3 }) -}
5d55b2485fd718d78674934e1c1437fb
  $fShowSrcLoc_$cshowList ::
    [Language.Fortran.SrcLoc] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Language.Fortran.SrcLoc]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Language.Fortran.SrcLoc
                   Language.Fortran.$fShowSrcLoc1
                   ls
                   s) -}
5d55b2485fd718d78674934e1c1437fb
  $fShowSrcLoc_$cshowsPrec ::
    GHC.Types.Int -> Language.Fortran.SrcLoc -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SLL),1*U(U,1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Language.Fortran.SrcLoc)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Language.Fortran.$fShowSrcLoc_$cshow x))
                   s) -}
2661346c18056b3b907f62427e1b219c
  $fShowSubName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.SubName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.SubName p)
                  (Language.Fortran.$fShowSubName_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowSubName_$cshow @ p v)
                  (Language.Fortran.$fShowSubName_$cshowList @ p v) -}
3aab07f5161385b2b31be6811c48a6cc
  $fShowSubName1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowSubName2) -}
ccf668f106fc1ba0beec3b6bbd537089
  $fShowSubName2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NullSubName "#) -}
49166dea77ef64bb0334c987548225ce
  $fShowSubName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SubName "#) -}
2661346c18056b3b907f62427e1b219c
  $fShowSubName_$cshow ::
    GHC.Show.Show p => Language.Fortran.SubName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.SubName p) ->
                 Language.Fortran.$fShowSubName_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2661346c18056b3b907f62427e1b219c
  $fShowSubName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.SubName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.SubName p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.SubName p)
                   (Language.Fortran.$fShowSubName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
2661346c18056b3b907f62427e1b219c
  $fShowSubName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.SubName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.SubName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec18 @ p w ww1 w363 }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fShowType ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Type p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Type p)
                  (Language.Fortran.$fShowType_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowType_$cshow @ p v)
                  (Language.Fortran.$fShowType_$cshowList @ p v) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fShowType_$cshow ::
    GHC.Show.Show p => Language.Fortran.Type p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Type p) ->
                 Language.Fortran.$fShowType_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fShowType_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Type p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Type p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Type p)
                   (Language.Fortran.$fShowType_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $fShowType_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Type p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Type p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec19 @ p w ww1 w363 }) -}
427f27131e64ea3da026fe120bf90190
  $fShowUnaryOp ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.UnaryOp p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.UnaryOp p)
                  (Language.Fortran.$fShowUnaryOp_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowUnaryOp_$cshow @ p v)
                  (Language.Fortran.$fShowUnaryOp_$cshowList @ p v) -}
a6520fb9f545aeeeea423e9ae3fe8f98
  $fShowUnaryOp1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowUnaryOp2) -}
25d355b419b77d42f4969facf3090e5f
  $fShowUnaryOp2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Not "#) -}
d410d63ba1c523635da9a9132c208c0e
  $fShowUnaryOp3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Language.Fortran.$fShowUnaryOp4) -}
36bc8167d600ae3b17bd46d213707989
  $fShowUnaryOp4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UMinus "#) -}
427f27131e64ea3da026fe120bf90190
  $fShowUnaryOp_$cshow ::
    GHC.Show.Show p => Language.Fortran.UnaryOp p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.UnaryOp p) ->
                 case x of wild {
                   Language.Fortran.UMinus b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowUnaryOp3
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Language.Fortran.Not b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Language.Fortran.$fShowUnaryOp1
                        (GHC.Show.showsPrec
                           @ p
                           $dShow
                           Language.Fortran.$fReadVarName2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
427f27131e64ea3da026fe120bf90190
  $fShowUnaryOp_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.UnaryOp p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.UnaryOp p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.UnaryOp p)
                   (Language.Fortran.$fShowUnaryOp_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
427f27131e64ea3da026fe120bf90190
  $fShowUnaryOp_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.UnaryOp p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.UnaryOp p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec20 @ p w ww1 w363 }) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fShowUseBlock ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.UseBlock p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.UseBlock p)
                  (Language.Fortran.$fShowUseBlock_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowUseBlock_$cshow @ p v)
                  (Language.Fortran.$fShowUseBlock_$cshowList @ p v) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fShowUseBlock_$cshow ::
    GHC.Show.Show p => Language.Fortran.UseBlock p -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(1*U,U(U,U(U),U(U)))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.UseBlock p) ->
                 Language.Fortran.$fShowUseBlock_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fShowUseBlock_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.UseBlock p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.UseBlock p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.UseBlock p)
                   (Language.Fortran.$fShowUseBlock_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
b15343402b457d38480c3fa7b3ee4ce7
  $fShowUseBlock_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.UseBlock p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(1*U,U(U,U(U),U(U)))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.UseBlock p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.UseBlock ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec9 @ p w ww1 ww3 ww4 } }) -}
f37cb87c0c5362747ff382fcf7036b42
  $fShowUses ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.Uses p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.Uses p)
                  (Language.Fortran.$fShowUses_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowUses_$cshow @ p v)
                  (Language.Fortran.$fShowUses_$cshowList @ p v) -}
f37cb87c0c5362747ff382fcf7036b42
  $fShowUses_$cshow ::
    GHC.Show.Show p => Language.Fortran.Uses p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.Uses p) ->
                 Language.Fortran.$fShowUses_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f37cb87c0c5362747ff382fcf7036b42
  $fShowUses_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.Uses p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.Uses p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.Uses p)
                   (Language.Fortran.$fShowUses_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
f37cb87c0c5362747ff382fcf7036b42
  $fShowUses_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.Uses p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.Uses p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 Language.Fortran.$w$cshowsPrec10 @ p w ww1 w363 }) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fShowVarName ::
    GHC.Show.Show p => GHC.Show.Show (Language.Fortran.VarName p)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ p (v :: GHC.Show.Show p).
                  @ (Language.Fortran.VarName p)
                  (Language.Fortran.$fShowVarName_$cshowsPrec @ p v)
                  (Language.Fortran.$fShowVarName_$cshow @ p v)
                  (Language.Fortran.$fShowVarName_$cshowList @ p v) -}
220456099662d15e40046e6dec40d556
  $fShowVarName1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("VarName "#) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fShowVarName_$cshow ::
    GHC.Show.Show p => Language.Fortran.VarName p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (x :: Language.Fortran.VarName p) ->
                 Language.Fortran.$fShowVarName_$cshowsPrec
                   @ p
                   $dShow
                   Language.Fortran.$fDataArg3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fShowVarName_$cshowList ::
    GHC.Show.Show p => [Language.Fortran.VarName p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   ($dShow :: GHC.Show.Show p)
                   (ls :: [Language.Fortran.VarName p])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Language.Fortran.VarName p)
                   (Language.Fortran.$fShowVarName_$cshowsPrec
                      @ p
                      $dShow
                      Language.Fortran.$fDataArg3)
                   ls
                   s) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $fShowVarName_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> Language.Fortran.VarName p -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   (w :: GHC.Show.Show p)
                   (w362 :: GHC.Types.Int)
                   (w363 :: Language.Fortran.VarName p) ->
                 case w362 of ww { GHC.Types.I# ww1 ->
                 case w363 of ww2 { Language.Fortran.VarName ww3 ww4 ->
                 Language.Fortran.$w$cshowsPrec21 @ p w ww1 ww3 ww4 } }) -}
f57ed7b26ba9d8272d17d6f7cd74766e
  $fSpanBlock :: Language.Fortran.Span (Language.Fortran.Block a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U,U),A,A)>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanBlock_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Block a>_N)) -}
c3e7fd3f669023a1bc740e1bf99f83fc
  $fSpanBlock_$csrcSpan ::
    Language.Fortran.Block a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLL),1*U(A,A,A,1*U(U,U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Block a) ->
                 case ds of wild { Language.Fortran.Block ds1 ds2 ds3 sp ds4 ds5 ->
                 sp }) -}
f57ed7b26ba9d8272d17d6f7cd74766e
  $fSpanDecl :: Language.Fortran.Span (Language.Fortran.Decl a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanDecl_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Decl a>_N)) -}
a17387076e877c280e43c7eefba05c52
  $fSpanDecl1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
b0b97d4e2a23370cf81e4afa31c613e5
  $fSpanDecl_$csrcSpan ::
    Language.Fortran.Decl a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Decl a) ->
                 case ds of wild {
                   DEFAULT -> Language.Fortran.$fSpanDecl1
                   Language.Fortran.Decl ds1 sp ds2 ds3 -> sp
                   Language.Fortran.Equivalence x sp ds1 -> sp
                   Language.Fortran.Common ds1 sp ds2 ds3 -> sp
                   Language.Fortran.DerivedTypeDef x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.NullDecl ds1 sp -> sp
                   Language.Fortran.MeasureUnitDef x sp ds1 -> sp }) -}
f57ed7b26ba9d8272d17d6f7cd74766e
  $fSpanExpr :: Language.Fortran.Span (Language.Fortran.Expr a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanExpr_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Expr a>_N)) -}
c17a9d6092f8b621dd20709efead56d8
  $fSpanExpr1 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
1cef001153f759c1d533cdc9357406d1
  $fSpanExpr_$csrcSpan ::
    Language.Fortran.Expr a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Expr a) ->
                 case ds of wild {
                   Language.Fortran.Con x sp ds1 -> sp
                   Language.Fortran.ConL ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fSpanExpr1
                   Language.Fortran.ConS x sp ds1 -> sp
                   Language.Fortran.Var x sp ds1 -> sp
                   Language.Fortran.Bin x sp ds1 ds2 ds3 -> sp
                   Language.Fortran.Unary x sp ds1 ds2 -> sp
                   Language.Fortran.CallExpr x sp ds1 ds2 -> sp
                   Language.Fortran.NullExpr x sp -> sp
                   Language.Fortran.Null x sp -> sp
                   Language.Fortran.ESeq x sp ds1 ds2 -> sp
                   Language.Fortran.Bound x sp ds1 ds2 -> sp
                   Language.Fortran.Sqrt x sp ds1 -> sp
                   Language.Fortran.ArrayCon x sp ds1 -> sp
                   Language.Fortran.AssgExpr x sp ds1 ds2 -> sp }) -}
f57ed7b26ba9d8272d17d6f7cd74766e
  $fSpanFortran :: Language.Fortran.Span (Language.Fortran.Fortran a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanFortran_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0] <Language.Fortran.Fortran a>_N)) -}
5daebb5688d99c24b778b62ea48d2fc0
  $fSpanFortran1 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
40bdfeb92deecf8aa58787c21ba2f756
  $fSpanFortran_$csrcSpan ::
    Language.Fortran.Fortran a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Fortran a) ->
                 case ds of wild {
                   Language.Fortran.Assg x sp e1 e2 -> sp
                   Language.Fortran.For x sp v e1 e2 e3 fs -> sp
                   Language.Fortran.DoWhile x sp e fs -> sp
                   Language.Fortran.FSeq x sp f94 f95 -> sp
                   Language.Fortran.If x sp e f94 fes f95 -> sp
                   Language.Fortran.Allocate x sp e1 e2 -> sp
                   Language.Fortran.Backspace x sp ds1 -> sp
                   Language.Fortran.Call x sp e as -> sp
                   Language.Fortran.Open x sp s -> sp
                   Language.Fortran.Close x sp s -> sp
                   Language.Fortran.Continue x sp -> sp
                   Language.Fortran.Cycle x sp s -> sp
                   Language.Fortran.DataStmt x sp ds1 -> sp
                   Language.Fortran.Deallocate x sp es e -> sp
                   Language.Fortran.Endfile x sp s -> sp
                   Language.Fortran.Exit x sp s -> sp
                   Language.Fortran.Format x sp ds1 -> sp
                   Language.Fortran.Forall x sp es f94 -> sp
                   Language.Fortran.Goto x sp s -> sp
                   Language.Fortran.Nullify x sp e -> sp
                   Language.Fortran.Inquire x sp s e -> sp
                   Language.Fortran.Pause x sp ds1 -> sp
                   Language.Fortran.Rewind x sp s -> sp
                   Language.Fortran.Stop x sp e -> sp
                   Language.Fortran.Where x sp e f94 ds1 -> sp
                   Language.Fortran.Write x sp s e -> sp
                   Language.Fortran.PointerAssg x sp e1 e2 -> sp
                   Language.Fortran.Return x sp e -> sp
                   Language.Fortran.Label x sp s f94 -> sp
                   Language.Fortran.Print x sp e es -> sp
                   Language.Fortran.ReadS x sp s e -> sp
                   Language.Fortran.TextStmt x sp s -> sp
                   Language.Fortran.NullStmt x sp -> sp
                   Language.Fortran.SelectStmt x sp e fes ds1 -> sp
                   Language.Fortran.OpenCLMap x sp e1 e2 ds1 ds2 f94 -> sp
                   Language.Fortran.OpenCLReduce x sp e1 e2 ds1 ds2 e3 f94 -> sp
                   Language.Fortran.OpenCLSeq ipv ipv1 ipv2 ipv3 ipv4
                   -> Language.Fortran.$fSpanFortran1
                   Language.Fortran.OpenCLBufferRead ds1 sp ds2 -> sp
                   Language.Fortran.OpenCLBufferWrite ds1 sp ds2 -> sp }) -}
f57ed7b26ba9d8272d17d6f7cd74766e
  $fSpanProgUnit ::
    Language.Fortran.Span (Language.Fortran.ProgUnit a)
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fSpanProgUnit_$csrcSpan
                  `cast`
                (forall (a :: <*>_N).
                 Sym (Language.Fortran.N:Span[0]
                          <Language.Fortran.ProgUnit a>_N)) -}
bec3c8549a5ff4616b66830aca5fceda
  $fSpanProgUnit1 ::
    (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Strictness: x -}
6fd7198f4a58a4b0ba15f61ca6d745c7
  $fSpanProgUnit_$csrcSpan ::
    Language.Fortran.ProgUnit a
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.ProgUnit a) ->
                 case ds of wild {
                   Language.Fortran.Main x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.Sub x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.Function x sp ds1 ds2 ds3 ds4 ds5 -> sp
                   Language.Fortran.Module x sp ds1 ds2 ds3 ds4 ds5 -> sp
                   Language.Fortran.BlockData x sp ds1 ds2 ds3 ds4 -> sp
                   Language.Fortran.PSeq x sp ds1 ds2 -> sp
                   Language.Fortran.Prog x sp ds1 -> sp
                   Language.Fortran.NullProg x sp -> sp
                   Language.Fortran.IncludeProg ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fSpanProgUnit1 }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedArg :: Language.Fortran.Tagged Language.Fortran.Arg
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArg_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Arg>_N)) -}
b27a965319b651630462b426dfdadbca
  $fTaggedArgList :: Language.Fortran.Tagged Language.Fortran.ArgList
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArgList_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ArgList>_N)) -}
3b367684113e275cad7a47fa69755872
  $fTaggedArgList_$ctag :: Language.Fortran.ArgList a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.ArgList a) ->
                 case ds of wild { Language.Fortran.ArgList x ds1 -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedArgName :: Language.Fortran.Tagged Language.Fortran.ArgName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedArgName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ArgName>_N)) -}
ffa2dcf9df7335c52bdfd3de38e38adc
  $fTaggedArgName_$ctag :: Language.Fortran.ArgName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.ArgName a) ->
                 case ds of wild {
                   Language.Fortran.ArgName x ds1 -> x
                   Language.Fortran.ASeq x ds1 ds2 -> x
                   Language.Fortran.NullArg x -> x }) -}
1902a73d776f37b3840db527c347c4e1
  $fTaggedArg_$ctag :: Language.Fortran.Arg a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Arg a) ->
                 case ds of wild { Language.Fortran.Arg x ds1 ds2 -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedAttr :: Language.Fortran.Tagged Language.Fortran.Attr
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedAttr_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Attr>_N)) -}
1193ddb083c5f0fdd8edf36898944fd6
  $fTaggedAttr1 :: a
  {- Strictness: x -}
21540494ed57867a36fbc40f5b5a0ba4
  $fTaggedAttr_$ctag :: Language.Fortran.Attr a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Attr a) ->
                 case ds of wild {
                   Language.Fortran.Parameter x -> x
                   Language.Fortran.Allocatable x -> x
                   Language.Fortran.External x -> x
                   Language.Fortran.Intent x ds1 -> x
                   Language.Fortran.Intrinsic x -> x
                   Language.Fortran.Optional x -> x
                   Language.Fortran.Pointer x -> x
                   Language.Fortran.Save x -> x
                   Language.Fortran.Target x -> x
                   Language.Fortran.Volatile x -> x
                   Language.Fortran.Public x -> x
                   Language.Fortran.Private x -> x
                   Language.Fortran.Sequence x -> x
                   Language.Fortran.Dimension x ds1 -> x
                   Language.Fortran.MeasureUnit ipv ipv1
                   -> Language.Fortran.$fTaggedAttr1 @ a }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedBaseType ::
    Language.Fortran.Tagged Language.Fortran.BaseType
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedBaseType_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.BaseType>_N)) -}
fe9a5727ad6b663f23103ac9260c18b6
  $fTaggedBaseType_$ctag :: Language.Fortran.BaseType a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.BaseType a) ->
                 case ds of wild {
                   Language.Fortran.Integer x -> x
                   Language.Fortran.Real x -> x
                   Language.Fortran.Character x -> x
                   Language.Fortran.SomeType x -> x
                   Language.Fortran.DerivedType x ds1 -> x
                   Language.Fortran.Recursive x -> x
                   Language.Fortran.Pure x -> x
                   Language.Fortran.Elemental x -> x
                   Language.Fortran.Logical x -> x
                   Language.Fortran.Complex x -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedDataForm ::
    Language.Fortran.Tagged Language.Fortran.DataForm
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedDataForm_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.DataForm>_N)) -}
77accfdf80dfac8409463d01e87ce7d7
  $fTaggedDataForm_$ctag :: Language.Fortran.DataForm a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.DataForm a) ->
                 case ds of wild { Language.Fortran.Data x ds1 -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedDecl :: Language.Fortran.Tagged Language.Fortran.Decl
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedDecl_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Decl>_N)) -}
14436517e4c34a8dd2c5348062f94ffd
  $fTaggedDecl_$ctag :: Language.Fortran.Decl a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Decl a) ->
                 case ds of wild {
                   Language.Fortran.Decl x ds1 ds2 ds3 -> x
                   Language.Fortran.Namelist x ds1 -> x
                   Language.Fortran.DataDecl x ds1 -> x
                   Language.Fortran.Equivalence x sp ds1 -> x
                   Language.Fortran.AttrStmt x ds1 ds2 -> x
                   Language.Fortran.AccessStmt x ds1 ds2 -> x
                   Language.Fortran.ExternalStmt x ds1 -> x
                   Language.Fortran.Interface x ds1 ds2 -> x
                   Language.Fortran.Common x ds1 ds2 ds3 -> x
                   Language.Fortran.DerivedTypeDef x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Include x ds1 -> x
                   Language.Fortran.DSeq x ds1 ds2 -> x
                   Language.Fortran.TextDecl x ds1 -> x
                   Language.Fortran.NullDecl x ds1 -> x
                   Language.Fortran.MeasureUnitDef x ds1 ds2 -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedExpr :: Language.Fortran.Tagged Language.Fortran.Expr
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedExpr_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Expr>_N)) -}
c9dd3eed1d768f383677f114afefcea8
  $fTaggedExpr_$ctag :: Language.Fortran.Expr a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Expr a) ->
                 case ds of wild {
                   Language.Fortran.Con x sp ds1 -> x
                   Language.Fortran.ConL x sp ds1 ds2 -> x
                   Language.Fortran.ConS x sp ds1 -> x
                   Language.Fortran.Var x sp ds1 -> x
                   Language.Fortran.Bin x sp ds1 ds2 ds3 -> x
                   Language.Fortran.Unary x sp ds1 ds2 -> x
                   Language.Fortran.CallExpr x sp ds1 ds2 -> x
                   Language.Fortran.NullExpr x ds1 -> x
                   Language.Fortran.Null x ds1 -> x
                   Language.Fortran.ESeq x sp ds1 ds2 -> x
                   Language.Fortran.Bound x sp ds1 ds2 -> x
                   Language.Fortran.Sqrt x sp ds1 -> x
                   Language.Fortran.ArrayCon x sp ds1 -> x
                   Language.Fortran.AssgExpr x sp ds1 ds2 -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedFortran :: Language.Fortran.Tagged Language.Fortran.Fortran
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedFortran_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.Fortran>_N)) -}
b63cac5692a9557b4da498e5864d953d
  $fTaggedFortran1 :: a
  {- Strictness: x -}
209ba1a3765127d9b7f04cc5f93ee61e
  $fTaggedFortran_$ctag :: Language.Fortran.Fortran a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.Fortran a) ->
                 case ds of wild {
                   DEFAULT -> Language.Fortran.$fTaggedFortran1 @ a
                   Language.Fortran.Assg x s e1 e2 -> x
                   Language.Fortran.For x s v e1 e2 e3 fs -> x
                   Language.Fortran.DoWhile x sp e fs -> x
                   Language.Fortran.FSeq x sp f94 f95 -> x
                   Language.Fortran.If x sp e f94 fes f95 -> x
                   Language.Fortran.Allocate x sp e1 e2 -> x
                   Language.Fortran.Backspace x sp ds1 -> x
                   Language.Fortran.Call x sp e as -> x
                   Language.Fortran.Open x sp s -> x
                   Language.Fortran.Close x sp s -> x
                   Language.Fortran.Continue x sp -> x
                   Language.Fortran.Cycle x sp s -> x
                   Language.Fortran.DataStmt x sp ds1 -> x
                   Language.Fortran.Deallocate x sp es e -> x
                   Language.Fortran.Endfile x sp s -> x
                   Language.Fortran.Exit x sp s -> x
                   Language.Fortran.Format x sp ds1 -> x
                   Language.Fortran.Forall x sp es f94 -> x
                   Language.Fortran.Goto x sp s -> x
                   Language.Fortran.Nullify x sp e -> x
                   Language.Fortran.Inquire x sp s e -> x
                   Language.Fortran.Pause x sp ds1 -> x
                   Language.Fortran.Rewind x sp s -> x
                   Language.Fortran.Stop x sp e -> x
                   Language.Fortran.Where x sp e f94 ds1 -> x
                   Language.Fortran.Write x sp s e -> x
                   Language.Fortran.PointerAssg x sp e1 e2 -> x
                   Language.Fortran.Return x sp e -> x
                   Language.Fortran.Label x sp s f94 -> x
                   Language.Fortran.Print x sp e es -> x
                   Language.Fortran.ReadS x sp s e -> x
                   Language.Fortran.TextStmt x sp s -> x
                   Language.Fortran.NullStmt x sp -> x
                   Language.Fortran.SelectStmt x sp e fes ds1 -> x
                   Language.Fortran.OpenCLMap x sp e1 e2 ds1 ds2 f94 -> x
                   Language.Fortran.OpenCLReduce x sp e1 e2 ds1 ds2 e3 f94 -> x
                   Language.Fortran.OpenCLBufferRead x ds1 ds2 -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedGSpec :: Language.Fortran.Tagged Language.Fortran.GSpec
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedGSpec_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.GSpec>_N)) -}
5aa8810dc0699572724b3a8174dfd3d6
  $fTaggedGSpec_$ctag :: Language.Fortran.GSpec a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.GSpec a) ->
                 case ds of wild {
                   Language.Fortran.GName x ds1 -> x
                   Language.Fortran.GOper x ds1 -> x
                   Language.Fortran.GAssg x -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedImplicit ::
    Language.Fortran.Tagged Language.Fortran.Implicit
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedImplicit_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.Implicit>_N)) -}
303517dcbe15a7af82cf1ac3f3dd60f6
  $fTaggedImplicit_$ctag :: Language.Fortran.Implicit a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Implicit a) ->
                 case ds of wild {
                   Language.Fortran.ImplicitNone x -> x
                   Language.Fortran.ImplicitNull x -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedProgUnit ::
    Language.Fortran.Tagged Language.Fortran.ProgUnit
  DFunId
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedProgUnit_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.ProgUnit>_N)) -}
66fddd790b04dc56513581bd72ee495f
  $fTaggedProgUnit1 :: a
  {- Strictness: x -}
96c20fbcfbf71d15bea100d17a3f95de
  $fTaggedProgUnit_$ctag :: Language.Fortran.ProgUnit a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: Language.Fortran.ProgUnit a) ->
                 case ds of wild {
                   Language.Fortran.Main x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Sub x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.Function x sp ds1 ds2 ds3 ds4 ds5 -> x
                   Language.Fortran.Module x sp ds1 ds2 ds3 ds4 ds5 -> x
                   Language.Fortran.BlockData x sp ds1 ds2 ds3 ds4 -> x
                   Language.Fortran.PSeq x sp ds1 ds2 -> x
                   Language.Fortran.Prog x sp ds1 -> x
                   Language.Fortran.NullProg x sp -> x
                   Language.Fortran.IncludeProg ipv ipv1 ipv2 ipv3
                   -> Language.Fortran.$fTaggedProgUnit1 @ a }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedSubName :: Language.Fortran.Tagged Language.Fortran.SubName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedSubName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.SubName>_N)) -}
4d105c85298a78229ab64eb2912f4833
  $fTaggedSubName_$ctag :: Language.Fortran.SubName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.SubName a) ->
                 case ds of wild {
                   Language.Fortran.SubName x ds1 -> x
                   Language.Fortran.NullSubName x -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedUses :: Language.Fortran.Tagged Language.Fortran.Uses
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedUses_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0] <Language.Fortran.Uses>_N)) -}
a7680beb2ea8d9f3b19611ab49751d73
  $fTaggedUses_$ctag :: Language.Fortran.Uses a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.Uses a) ->
                 case ds of wild {
                   Language.Fortran.Use x ds1 ds2 ds3 -> x
                   Language.Fortran.UseNil x -> x }) -}
b27a965319b651630462b426dfdadbca
  $fTaggedVarName :: Language.Fortran.Tagged Language.Fortran.VarName
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Language.Fortran.$fTaggedVarName_$ctag
                  `cast`
                (Sym (Language.Fortran.N:Tagged[0]
                          <Language.Fortran.VarName>_N)) -}
81fef28aab60b4cf9ed632e34b467f4b
  $fTaggedVarName_$ctag :: Language.Fortran.VarName a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Language.Fortran.VarName a) ->
                 case ds of wild { Language.Fortran.VarName x ds1 -> x }) -}
515d3f6ad6393c2736eb0e52a4870e16
  $s$fData(,) :: Data.Data.Data ([GHC.Types.Char], [GHC.Types.Char])
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char])
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ ((,) [GHC.Types.Char])
                     @ [GHC.Types.Char]
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ (* -> *)
                        @ (,)
                        @ [GHC.Types.Char]
                        Data.Data.$fData(,)10
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7))
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <([GHC.Types.Char],
                                                                      [GHC.Types.Char])>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
                     (z :: forall g. g -> c g)
                     (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case ds of wild { (,) a1 a2 ->
                   k @ [GHC.Types.Char]
                     @ ([GHC.Types.Char], [GHC.Types.Char])
                     Data.Data.$fData[]_$s$fData[]
                     (k @ [GHC.Types.Char]
                        @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char]
                              -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                           (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char]))
                        a1)
                     a2 })
                  (\ @ c :: * -> *
                     (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                     (z :: forall r. r -> c r)
                     (ds :: Data.Data.Constr) ->
                   k @ [GHC.Types.Char]
                     @ ([GHC.Types.Char], [GHC.Types.Char])
                     Data.Data.$fData[]_$s$fData[]
                     (k @ [GHC.Types.Char]
                        @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char]
                              -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                           (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char]))))
                  (\ (ds :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case ds of wild { (,) ds1 ds2 -> Data.Data.$c(,) })
                  (\ (ds :: ([GHC.Types.Char], [GHC.Types.Char])) -> Data.Data.$t(,))
                  (\ @ t :: * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d. Data.Data.Data d => c (t d)) ->
                   GHC.Base.Nothing @ (c ([GHC.Types.Char], [GHC.Types.Char])))
                  (Data.Data.$fData(,)_$cdataCast2
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                     (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x0 of wild { (,) a1 a2 ->
                   (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1,
                    ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <([GHC.Types.Char], [GHC.Types.Char])>_R)) })
                    `cast`
                  (<forall b1. Data.Data.Data b1 => b1 -> b1>_R
                   ->_R <([GHC.Types.Char], [GHC.Types.Char])>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <([GHC.Types.Char], [GHC.Types.Char])>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case eta of wild { (,) a1 a2 ->
                   (ds
                      (ds ds1 (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                      (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2))
                     `cast`
                   (Sym (Data.Functor.Const.N:Const[0]
                             <*>_N <r>_R <([GHC.Types.Char], [GHC.Types.Char])>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <([GHC.Types.Char], [GHC.Types.Char])>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <([GHC.Types.Char], [GHC.Types.Char])>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x0 of wild { (,) a1 a2 ->
                   ds
                     (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                     (ds
                        (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                        ds1) })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x0 of wild { (,) a1 a2 ->
                   GHC.Types.:
                     @ u
                     (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                     (GHC.Types.:
                        @ u
                        (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                        (GHC.Types.[] @ u)) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                   case x of wild { (,) a1 a2 ->
                   case ds of wild1 { GHC.Types.I# x1 ->
                   case x1 of wild2 {
                     DEFAULT -> Data.Maybe.fromJust1 @ u
                     0# -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1
                     1#
                     -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2 } } })
                  (Data.Data.$fData(,)_$cgmapM
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData(,)_$cgmapMp
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData(,)_$cgmapMo
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]
                     Data.Data.$fData[]_$s$fData[]) -}
e6fb4ff038057b8a35b0ff50fd937c1a
  $s$fData(,)3 ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> Data.Functor.Identity.Identity
         (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 a2 ->
                 (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1,
                  ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)>_R)) }) -}
11b9ea1368ad18a307850efe8b21ad00
  $s$fData(,)5 ::
    (forall b1. Data.Data.Data b1 => b1 -> b1)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> Data.Functor.Identity.Identity
         ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b1. Data.Data.Data b1 => b1 -> b1)
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 a2 ->
                 (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1,
                  ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([GHC.Types.Char], [GHC.Types.Char])>_R)) }) -}
4f90178f2969339a02fa15b27278f3c3
  $s$fData(,)_$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    -> m (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (w364 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case w364 of ww { (,) ww1 ww2 ->
                 Data.Data.$w$cgmapM
                   @ Language.Fortran.SrcLoc
                   @ Language.Fortran.SrcLoc
                   Language.Fortran.$fDataSrcLoc
                   Language.Fortran.$fDataSrcLoc
                   @ m
                   w362
                   w363
                   ww1
                   ww2 }) -}
ebb90f96c9b1aadade269f650024393b
  $s$fData(,)_$cgmapM1 ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> ([GHC.Types.Char], [GHC.Types.Char])
    -> m ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 3,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (w364 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case w364 of ww { (,) ww1 ww2 ->
                 Data.Data.$w$cgmapM
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]_$s$fData[]
                   Data.Data.$fData[]_$s$fData[]
                   @ m
                   w362
                   w363
                   ww1
                   ww2 }) -}
6d23d733fa34877b84f7404775ebf2c6
  $s$fData(,)_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc) -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)) ->
                 case x0 of wild { (,) a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a1)
                   (GHC.Types.:
                      @ u
                      (ds @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc a2)
                      (GHC.Types.[] @ u)) }) -}
45a2183ef4c256df85e15365e87243a6
  $s$fData(,)_$cgmapQ1 ::
    (forall d. Data.Data.Data d => d -> u)
    -> ([GHC.Types.Char], [GHC.Types.Char]) -> [u]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U(U,U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x0 of wild { (,) a1 a2 ->
                 GHC.Types.:
                   @ u
                   (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                   (GHC.Types.:
                      @ u
                      (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a2)
                      (GHC.Types.[] @ u)) }) -}
e608ca102628119be20043d1d6740700
  $s$fData(,)_$cgunfold ::
    (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ Language.Fortran.SrcLoc
                   @ (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
                   Language.Fortran.$fDataSrcLoc
                   (k @ Language.Fortran.SrcLoc
                      @ (Language.Fortran.SrcLoc
                         -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                      Language.Fortran.$fDataSrcLoc
                      (z @ (Language.Fortran.SrcLoc
                            -> Language.Fortran.SrcLoc
                            -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc))
                         (GHC.Tuple.(,)
                            @ Language.Fortran.SrcLoc
                            @ Language.Fortran.SrcLoc)))) -}
cea847a6f48daf17c530b1654ef13a6d
  $s$fData(,)_$cgunfold1 ::
    (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 3, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
                   (z :: forall r. r -> c r)
                   (ds :: Data.Data.Constr) ->
                 k @ [GHC.Types.Char]
                   @ ([GHC.Types.Char], [GHC.Types.Char])
                   Data.Data.$fData[]_$s$fData[]
                   (k @ [GHC.Types.Char]
                      @ ([GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                      Data.Data.$fData[]_$s$fData[]
                      (z @ ([GHC.Types.Char]
                            -> [GHC.Types.Char] -> ([GHC.Types.Char], [GHC.Types.Char]))
                         (GHC.Tuple.(,) @ [GHC.Types.Char] @ [GHC.Types.Char])))) -}
8361e466e26396f466ccf2e3de892b52
  $s$fDataMaybe :: Data.Data.Data (GHC.Base.Maybe [GHC.Types.Char])
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe [GHC.Types.Char])
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ GHC.Base.Maybe
                     @ [GHC.Types.Char]
                     Data.Data.$fDataMaybe7
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <GHC.Base.Maybe
                                                                       [GHC.Types.Char]>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                     (z :: forall g. g -> c g)
                     (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> z @ (GHC.Base.Maybe [GHC.Types.Char])
                          (GHC.Base.Nothing @ [GHC.Types.Char])
                     GHC.Base.Just a1
                     -> k @ [GHC.Types.Char]
                          @ (GHC.Base.Maybe [GHC.Types.Char])
                          Data.Data.$fData[]_$s$fData[]
                          (z @ ([GHC.Types.Char] -> GHC.Base.Maybe [GHC.Types.Char])
                             (GHC.Base.Just @ [GHC.Types.Char]))
                          a1 })
                  (Data.Data.$fDataMaybe_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case ds of wild {
                     GHC.Base.Nothing -> Data.Data.$cNothing
                     GHC.Base.Just ds1 -> Data.Data.$cJust })
                  (\ (ds :: GHC.Base.Maybe [GHC.Types.Char]) -> Data.Data.$tMaybe)
                  (Data.Data.$fDataMaybe_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (GHC.Base.Maybe [GHC.Types.Char])))
                  (\ (ds :: forall b. Data.Data.Data b => b -> b)
                     (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x0 of wild {
                     GHC.Base.Nothing
                     -> (GHC.Base.Nothing @ [GHC.Types.Char])
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe [GHC.Types.Char]>_R))
                     GHC.Base.Just a1
                     -> (GHC.Base.Just
                           @ [GHC.Types.Char]
                           (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe [GHC.Types.Char]>_R)) })
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <GHC.Base.Maybe [GHC.Types.Char]>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <GHC.Base.Maybe [GHC.Types.Char]>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case eta of wild {
                     GHC.Base.Nothing
                     -> ds1
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P))
                     GHC.Base.Just a1
                     -> (ds
                           ds1
                           (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <GHC.Base.Maybe [GHC.Types.Char]>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> ds1
                     GHC.Base.Just a1
                     -> ds
                          (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                          ds1 })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> GHC.Types.[] @ u
                     GHC.Base.Just a1
                     -> GHC.Types.:
                          @ u
                          (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                          (GHC.Types.[] @ u) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: GHC.Base.Maybe [GHC.Types.Char]) ->
                   case x of wild {
                     GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                     GHC.Base.Just a1
                     -> case ds of wild1 { GHC.Types.I# x1 ->
                        case x1 of wild2 {
                          DEFAULT -> Data.Maybe.fromJust1 @ u
                          0#
                          -> ds1 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1 } } })
                  (Data.Data.$fDataMaybe_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fDataMaybe_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fDataMaybe_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
61a32814e5c9cebbd36acff376bfce5b
  $s$fDataMaybe1 :: Data.Data.Data (GHC.Base.Maybe GHC.Types.Int)
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ GHC.Base.Maybe
                     @ GHC.Types.Int
                     Data.Data.$fDataMaybe7
                     Data.Data.$fDataInt4)
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <GHC.Base.Maybe
                                                                       GHC.Types.Int>_N)
                  (\ @ c :: * -> *
                     (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                     (z :: forall g. g -> c g)
                     (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> z @ (GHC.Base.Maybe GHC.Types.Int)
                          (GHC.Base.Nothing @ GHC.Types.Int)
                     GHC.Base.Just a1
                     -> k @ GHC.Types.Int
                          @ (GHC.Base.Maybe GHC.Types.Int)
                          Data.Data.$fDataInt
                          (z @ (GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int)
                             (GHC.Base.Just @ GHC.Types.Int))
                          a1 })
                  (Data.Data.$fDataMaybe_$cgunfold
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                   case ds of wild {
                     GHC.Base.Nothing -> Data.Data.$cNothing
                     GHC.Base.Just ds1 -> Data.Data.$cJust })
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Int) -> Data.Data.$tMaybe)
                  (Data.Data.$fDataMaybe_$cdataCast1
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c (GHC.Base.Maybe GHC.Types.Int)))
                  (\ (ds :: forall b. Data.Data.Data b => b -> b)
                     (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x0 of wild {
                     GHC.Base.Nothing
                     -> (GHC.Base.Nothing @ GHC.Types.Int)
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe GHC.Types.Int>_R))
                     GHC.Base.Just a1
                     -> (GHC.Base.Just
                           @ GHC.Types.Int
                           (ds @ GHC.Types.Int Data.Data.$fDataInt a1))
                          `cast`
                        (Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Base.Maybe GHC.Types.Int>_R)) })
                    `cast`
                  (<forall b. Data.Data.Data b => b -> b>_R
                   ->_R <GHC.Base.Maybe GHC.Types.Int>_R
                   ->_R Data.Functor.Identity.N:Identity[0]
                            <GHC.Base.Maybe GHC.Types.Int>_R)
                  (\ @ r
                     @ r'
                     (ds :: r -> r' -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (eta :: GHC.Base.Maybe GHC.Types.Int) ->
                   case eta of wild {
                     GHC.Base.Nothing
                     -> ds1
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P))
                     GHC.Base.Just a1
                     -> (ds ds1 (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1))
                          `cast`
                        (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P)) })
                    `cast`
                  (forall (r :: <*>_N) (r' :: <*>_N).
                   <r -> r' -> r>_R
                   ->_R <r>_R
                   ->_R <forall d. Data.Data.Data d => d -> r'>_R
                   ->_R <GHC.Base.Maybe GHC.Types.Int>_R
                   ->_R Data.Functor.Const.N:Const[0]
                            <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P)
                  (\ @ r
                     @ r'
                     (ds :: r' -> r -> r)
                     (ds1 :: r)
                     (ds2 :: forall d. Data.Data.Data d => d -> r')
                     (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> ds1
                     GHC.Base.Just a1
                     -> ds (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1) ds1 })
                  (\ @ u
                     (ds :: forall d. Data.Data.Data d => d -> u)
                     (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x0 of wild {
                     GHC.Base.Nothing -> GHC.Types.[] @ u
                     GHC.Base.Just a1
                     -> GHC.Types.:
                          @ u
                          (ds @ GHC.Types.Int Data.Data.$fDataInt a1)
                          (GHC.Types.[] @ u) })
                  (\ @ u
                     (ds :: GHC.Types.Int)
                     (ds1 :: forall d. Data.Data.Data d => d -> u)
                     (x :: GHC.Base.Maybe GHC.Types.Int) ->
                   case x of wild {
                     GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                     GHC.Base.Just a1
                     -> case ds of wild1 { GHC.Types.I# x1 ->
                        case x1 of wild2 {
                          DEFAULT -> Data.Maybe.fromJust1 @ u
                          0# -> ds1 @ GHC.Types.Int Data.Data.$fDataInt a1 } } })
                  (Data.Data.$fDataMaybe_$cgmapM @ GHC.Types.Int Data.Data.$fDataInt)
                  (Data.Data.$fDataMaybe_$cgmapMp
                     @ GHC.Types.Int
                     Data.Data.$fDataInt)
                  (Data.Data.$fDataMaybe_$cgmapMo
                     @ GHC.Types.Int
                     Data.Data.$fDataInt) -}
008d57439a954d97082d27d2a6f32bfa
  $s$fDataMaybe2 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe GHC.Types.Int
    -> Data.Functor.Const.Const r (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: GHC.Base.Maybe GHC.Types.Int) ->
                 case eta of wild {
                   GHC.Base.Nothing
                   -> ds1
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P))
                   GHC.Base.Just a1
                   -> (ds ds1 (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe GHC.Types.Int>_P)) }) -}
9df9bfe9d877a5fd5d2fe9a1b4af5cd3
  $s$fDataMaybe3 ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> Data.Functor.Const.Const r (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r -> r' -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (eta :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case eta of wild {
                   GHC.Base.Nothing
                   -> ds1
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P))
                   GHC.Base.Just a1
                   -> (ds
                         ds1
                         (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                        `cast`
                      (Sym (Data.Functor.Const.N:Const[0]
                                <*>_N <r>_R <GHC.Base.Maybe [GHC.Types.Char]>_P)) }) -}
6d15e53e886575377d3b461c86d213b2
  $s$fDataMaybe4 ::
    (forall b. Data.Data.Data b => b -> b)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing
                   -> (GHC.Base.Nothing @ [GHC.Types.Char])
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe [GHC.Types.Char]>_R))
                   GHC.Base.Just a1
                   -> (GHC.Base.Just
                         @ [GHC.Types.Char]
                         (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe [GHC.Types.Char]>_R)) }) -}
cbcdcee38e650baf4f39a4c11556af8d
  $s$fDataMaybe6 ::
    (forall b. Data.Data.Data b => b -> b)
    -> GHC.Base.Maybe GHC.Types.Int
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: forall b. Data.Data.Data b => b -> b)
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing
                   -> (GHC.Base.Nothing @ GHC.Types.Int)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe GHC.Types.Int>_R))
                   GHC.Base.Just a1
                   -> (GHC.Base.Just
                         @ GHC.Types.Int
                         (ds @ GHC.Types.Int Data.Data.$fDataInt a1))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <GHC.Base.Maybe GHC.Types.Int>_R)) }) -}
d702af3b24b2c2465c022dd44a264984
  $s$fDataMaybe7 ::
    Data.Typeable.Internal.TypeRep (GHC.Base.Maybe [GHC.Types.Char])
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ GHC.Base.Maybe
                   @ [GHC.Types.Char]
                   Data.Data.$fDataMaybe7
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Types.Char
                      Data.Data.$fData[]3
                      Data.Data.$fDataChar7)) -}
93abb01e0d1d406afc828161be9a0f3d
  $s$fDataMaybe8 ::
    Data.Typeable.Internal.TypeRep (GHC.Base.Maybe GHC.Types.Int)
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ GHC.Base.Maybe
                   @ GHC.Types.Int
                   Data.Data.$fDataMaybe7
                   Data.Data.$fDataInt4) -}
a16859d97e8bb094f9dfd71608d8f44f
  $s$fDataMaybe_$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> c (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 3, Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> z @ (GHC.Base.Maybe [GHC.Types.Char])
                        (GHC.Base.Nothing @ [GHC.Types.Char])
                   GHC.Base.Just a1
                   -> k @ [GHC.Types.Char]
                        @ (GHC.Base.Maybe [GHC.Types.Char])
                        Data.Data.$fData[]_$s$fData[]
                        (z @ ([GHC.Types.Char] -> GHC.Base.Maybe [GHC.Types.Char])
                           (GHC.Base.Just @ [GHC.Types.Char]))
                        a1 }) -}
676c62be28cae25255c3660efe201e87
  $s$fDataMaybe_$cgfoldl1 ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.Maybe GHC.Types.Int
    -> c (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 3, Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (k :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (z :: forall g. g -> c g)
                   (ds :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> z @ (GHC.Base.Maybe GHC.Types.Int)
                        (GHC.Base.Nothing @ GHC.Types.Int)
                   GHC.Base.Just a1
                   -> k @ GHC.Types.Int
                        @ (GHC.Base.Maybe GHC.Types.Int)
                        Data.Data.$fDataInt
                        (z @ (GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int)
                           (GHC.Base.Just @ GHC.Types.Int))
                        a1 }) -}
719f4a63e85708c802eeef4c2c94d9f3
  $s$fDataMaybe_$cgmapQ ::
    (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe [GHC.Types.Char] -> [u]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ u
                   GHC.Base.Just a1
                   -> GHC.Types.:
                        @ u
                        (ds @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                        (GHC.Types.[] @ u) }) -}
d1da014e771ae8f3baa875518babf0ce
  $s$fDataMaybe_$cgmapQ1 ::
    (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe GHC.Types.Int -> [u]
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ u
                   (ds :: forall d. Data.Data.Data d => d -> u)
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ u
                   GHC.Base.Just a1
                   -> GHC.Types.:
                        @ u
                        (ds @ GHC.Types.Int Data.Data.$fDataInt a1)
                        (GHC.Types.[] @ u) }) -}
45848ae2806e92a429e7ae80f213a591
  $s$fDataMaybe_$cgmapQi ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                   GHC.Base.Just a1
                   -> case ds of wild1 { GHC.Types.I# x1 ->
                      case x1 of wild2 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0#
                        -> ds1
                             @ [GHC.Types.Char]
                             Data.Data.$fData[]_$s$fData[]
                             a1 } } }) -}
15380265ce26736879c7f9d27cc539f5
  $s$fDataMaybe_$cgmapQi1 ::
    GHC.Types.Int
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.Maybe GHC.Types.Int
    -> u
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ u
                   (ds :: GHC.Types.Int)
                   (ds1 :: forall d. Data.Data.Data d => d -> u)
                   (x :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ u
                   GHC.Base.Just a1
                   -> case ds of wild1 { GHC.Types.I# x1 ->
                      case x1 of wild2 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> ds1 @ GHC.Types.Int Data.Data.$fDataInt a1 } } }) -}
c039d730cdd8d1c6781edcb43ecd227a
  $s$fDataMaybe_$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe [GHC.Types.Char]
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: GHC.Base.Maybe [GHC.Types.Char]) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just a1
                   -> ds
                        (ds2 @ [GHC.Types.Char] Data.Data.$fData[]_$s$fData[] a1)
                        ds1 }) -}
f1cd264ad713dbb3e780820efe2b0845
  $s$fDataMaybe_$cgmapQr1 ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.Maybe GHC.Types.Int
    -> r
  {- Arity: 4,
     Strictness: <L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ r
                   @ r'
                   (ds :: r' -> r -> r)
                   (ds1 :: r)
                   (ds2 :: forall d. Data.Data.Data d => d -> r')
                   (x0 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x0 of wild {
                   GHC.Base.Nothing -> ds1
                   GHC.Base.Just a1
                   -> ds (ds2 @ GHC.Types.Int Data.Data.$fDataInt a1) ds1 }) -}
ab1218177065d7700a31f67fcf233a9c
  $s$fDataMaybe_$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (GHC.Base.Maybe [GHC.Types.Char])
  {- Arity: 3,
     Strictness: <L,1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Data.Data.$w$cgunfold10
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]_$s$fData[]
                   @ c
                   w362
                   w363
                   ww1
                   ww5 }) -}
6176b752ec60a0008751c1b5003d3d6d
  $s$fDataMaybe_$cgunfold1 ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.Constr
    -> c (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 3,
     Strictness: <L,1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (w364 :: Data.Data.Constr) ->
                 case w364 of ww { Data.Data.Constr ww1 ww2 ww3 ww4 ww5 ->
                 Data.Data.$w$cgunfold10
                   @ GHC.Types.Int
                   Data.Data.$fDataInt
                   @ c
                   w362
                   w363
                   ww1
                   ww5 }) -}
3d13aaab9eb16c43bc3e0960b6ec3db4
  $s$fData[] :: Data.Data.Data [[GHC.Types.Char]]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [[GHC.Types.Char]]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ []
                        @ GHC.Types.Char
                        Data.Data.$fData[]3
                        Data.Data.$fDataChar7))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[[GHC.Types.Char]]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgunfold
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ (ds :: [[GHC.Types.Char]]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [[GHC.Types.Char]]) -> Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing @ (c [[GHC.Types.Char]]))
                  (Data.Data.$fData[]_$cgmapT
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQl
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQr
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQ
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapQi
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapM
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMp
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[])
                  (Data.Data.$fData[]_$cgmapMo
                     @ [GHC.Types.Char]
                     Data.Data.$fData[]_$s$fData[]) -}
a9003189a731241baf2913f1da0b24e8
  $s$fData[]1 ::
    Data.Data.Data
      [(Language.Fortran.Variable, Language.Fortran.Variable)]
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [(Language.Fortran.Variable, Language.Fortran.Variable)]
                  (Data.Typeable.Internal.mkTrApp
                     @ *
                     @ *
                     @ []
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Data.Data.$fData[]3
                     (Data.Typeable.Internal.mkTrApp
                        @ *
                        @ *
                        @ ((,) [GHC.Types.Char])
                        @ [GHC.Types.Char]
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ (* -> *)
                           @ (,)
                           @ [GHC.Types.Char]
                           Data.Data.$fData(,)10
                           (Data.Typeable.Internal.mkTrApp
                              @ *
                              @ *
                              @ []
                              @ GHC.Types.Char
                              Data.Data.$fData[]3
                              Data.Data.$fDataChar7))
                        (Data.Typeable.Internal.mkTrApp
                           @ *
                           @ *
                           @ []
                           @ GHC.Types.Char
                           Data.Data.$fData[]3
                           Data.Data.$fDataChar7)))
                    `cast`
                  (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[(Language.Fortran.Variable,
                                                                       Language.Fortran.Variable)]>_N)
                  (Data.Data.$fData[]_$cgfoldl
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgunfold
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (\ (ds :: [(Language.Fortran.Variable,
                              Language.Fortran.Variable)]) ->
                   case ds of wild {
                     [] -> Data.Data.nilConstr : ds1 ds2 -> Data.Data.consConstr })
                  (\ (ds :: [(Language.Fortran.Variable,
                              Language.Fortran.Variable)]) ->
                   Data.Data.listDataType)
                  (Data.Data.$fData[]_$cdataCast1
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (\ @ t :: * -> * -> *
                     @ c :: * -> *
                     ($dTypeable :: Data.Typeable.Internal.Typeable t)
                     (ds :: forall d e.
                            (Data.Data.Data d, Data.Data.Data e) =>
                            c (t d e)) ->
                   GHC.Base.Nothing
                     @ (c [(Language.Fortran.Variable, Language.Fortran.Variable)]))
                  (Data.Data.$fData[]_$cgmapT
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQl
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQr
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQ
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapQi
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapM
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapMp
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,))
                  (Data.Data.$fData[]_$cgmapMo
                     @ (Language.Fortran.Variable, Language.Fortran.Variable)
                     Language.Fortran.$s$fData(,)) -}
52d015202fabb3058187dfd5c9358d74
  $s$fData[]7 :: Data.Typeable.Internal.TypeRep [[GHC.Types.Char]]
  {- Unfolding: InlineRule (0, True, False)
                (Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ [GHC.Types.Char]
                   Data.Data.$fData[]3
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ *
                      @ []
                      @ GHC.Types.Char
                      Data.Data.$fData[]3
                      Data.Data.$fDataChar7)) -}
1519e201f39be83cf5a267ac4f6d3f44
  $s$fEq(,) :: GHC.Classes.Eq ([GHC.Types.Char], [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char])
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]1)
                  Language.Fortran.$s$fEq(,)_$s$fEq(,)_$c/= -}
5a35ca1cac30a238652fb0c0511a1ade
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    ([GHC.Types.Char], [GHC.Types.Char])
    -> ([GHC.Types.Char], [GHC.Types.Char]) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: ([GHC.Types.Char], [GHC.Types.Char]))
                   (y :: ([GHC.Types.Char], [GHC.Types.Char])) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Base.eqString a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Base.eqString a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
399c4ab8ceb2a8ba1f1fed2745597c04
  $s$fEqMaybe :: GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (\ (ds :: GHC.Base.Maybe GHC.Types.Int)
                     (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1 -> GHC.Classes.eqInt a1 b1 } })
                  Language.Fortran.$s$fEqMaybe_$s$fEqMaybe_$c/= -}
2822569149745ce92b1c05f3ef459ad2
  $s$fEqMaybe_$c== ::
    GHC.Base.Maybe GHC.Types.Int
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Int)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Int) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.eqInt a1 b1 } }) -}
245ca1aa81d62a4fb68c3064b516a3dc
  $s$fEqMaybe_$s$fEqMaybe_$c/= ::
    GHC.Base.Maybe GHC.Types.Int
    -> GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: GHC.Base.Maybe GHC.Types.Int)
                   (y :: GHC.Base.Maybe GHC.Types.Int) ->
                 case x of wild {
                   GHC.Base.Nothing
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case GHC.Classes.eqInt a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
ff18b6562bd762fc54b255579c0345ee
  $tArg :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArg13
                   Language.Fortran.$fDataArg11) -}
639786a1f8ad5b13309352f297160100
  $tArgList :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataArgList7
                   Language.Fortran.$fDataArgList5) -}
e28324a333f5ce4069e97b1604cf965c
  $tArgName :: Data.Data.DataType
  {- Strictness: m -}
61b5dddfd1b03f6fca01e3a8544ab2f2
  $tAttr :: Data.Data.DataType
  {- Strictness: m -}
29d2cfe82d2ac171af50b07f81b39015
  $tBaseType :: Data.Data.DataType
  {- Strictness: m -}
3caa0421da0815f3ada94dbad27de4b0
  $tBinOp :: Data.Data.DataType
  {- Strictness: m -}
9624622e30cce6040be194538e40a845
  $tBlock :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataBlock7
                   Language.Fortran.$fDataBlock5) -}
af8ebca95c7ca1d19ba16ce53a138cc8
  $tDataForm :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataDataForm7
                   Language.Fortran.$fDataDataForm5) -}
5aef85bbf2733240b8164c8d16adbc5d
  $tDecl :: Data.Data.DataType
  {- Strictness: m -}
8985dd8fc8659d8ea7d0081f9bc96bef
  $tExpr :: Data.Data.DataType
  {- Strictness: m -}
b80c3ccc30f6f636fafe3e2bdb25698f
  $tFortran :: Data.Data.DataType
  {- Strictness: m -}
0150b0afd9710dafd79299005c4aa727
  $tFraction :: Data.Data.DataType
  {- Strictness: m -}
83342e9fe967c0329e027cee0ed48e9a
  $tGSpec :: Data.Data.DataType
  {- Strictness: m -}
2dae45ffe07b08a9c1c572d5f705d83d
  $tImplicit :: Data.Data.DataType
  {- Strictness: m -}
c3fc65aa62ddb622cce0d1d084543a24
  $tIntentAttr :: Data.Data.DataType
  {- Strictness: m -}
12b3368bce9b59fac894475daba80d9b
  $tInterfaceSpec :: Data.Data.DataType
  {- Strictness: m -}
cdaccd5cf69ee29d02a21c0604130a06
  $tMeasureUnitSpec :: Data.Data.DataType
  {- Strictness: m -}
8bcf64b54d70e7893f610c9c7856b3bd
  $tProgUnit :: Data.Data.DataType
  {- Strictness: m -}
b01b29d24acb12fbffcca8b2858332a4
  $tSpec :: Data.Data.DataType
  {- Strictness: m -}
c2b51ea0b9caa9aded61b557128bec51
  $tSrcLoc :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataSrcLoc5
                   Language.Fortran.$fDataSrcLoc3) -}
2c2bfbe481e49cdec684f70a87fdb33a
  $tSubName :: Data.Data.DataType
  {- Strictness: m -}
125f3e7f7ae1291953ae494ef938786b
  $tType :: Data.Data.DataType
  {- Strictness: m -}
0895ce4f1dfbd802383d9563defc83a2
  $tUnaryOp :: Data.Data.DataType
  {- Strictness: m -}
80950f322f1a6926b484f4310cd36701
  $tUseBlock :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataUseBlock7
                   Language.Fortran.$fDataUseBlock5) -}
e21a6c7ddc82e87137a9ed46f35d89e0
  $tUses :: Data.Data.DataType
  {- Strictness: m -}
d4f834bbcd22d630ccf55f8de73a0366
  $tVarName :: Data.Data.DataType
  {- Strictness: m,
     Unfolding: (Data.Data.DataType
                   Language.Fortran.$fDataVarName8
                   Language.Fortran.$fDataVarName6) -}
52b2d298dcfabd399ff3187a6c693f6c
  $tc'ASeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17878098176449512780##
                   553113840616459488##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ASeq2
                   1#
                   Language.Fortran.$tc'ASeq1) -}
08458ab4bb9edda8d13829d1fbccfa19
  $tc'ASeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1e972f7ebcc78ed184dbae1eeaf65c10
  $tc'ASeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ASeq3) -}
978d383445c95fc6dfaf1dc5654b665c
  $tc'ASeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ASeq"#) -}
d7901e38e00f377b0db2f01305c9e062
  $tc'Access :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6023156605425447563##
                   3355537303439562314##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Access2
                   1#
                   Language.Fortran.$tc'Access1) -}
6cb86c96708b2c59da92711c30caf361
  $tc'Access1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
967c54ecceba1fb9a21287e6138786d2
  $tc'Access2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Access3) -}
f23983a5d8efc180d51edb7b0549de4d
  $tc'Access3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Access"#) -}
9a3de49142f1aeca4d3bce26992a8b51
  $tc'AccessStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10583550567691602973##
                   15008162494620420127##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AccessStmt2
                   1#
                   Language.Fortran.$tc'AccessStmt1) -}
0b041ebcb11278decbdb1e697daec9ca
  $tc'AccessStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
39975e81c44f4c80d99bb09f3e73cf86
  $tc'AccessStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'AccessStmt3) -}
a1a2f08944586fe5e7ee06a4f5a744b6
  $tc'AccessStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AccessStmt"#) -}
a9a4c06403069e7024dfe3be86ab03a0
  $tc'Action :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9248651493578343329##
                   4692016069200967791##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Action1
                   1#
                   Language.Fortran.$tc'Access1) -}
8a218fedc8e82a4dfbf7e899f14a6659
  $tc'Action1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Action2) -}
f8ba051eaf52074a5ee4ed73701455ec
  $tc'Action2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Action"#) -}
bc77d465bc9f2b8e4f06618d630e6a21
  $tc'Advance :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1268153813758130827##
                   7507174167205915045##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Advance1
                   1#
                   Language.Fortran.$tc'Access1) -}
c1bf959ad12bbbf6bfe94f52dca1faab
  $tc'Advance1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Advance2) -}
a7b915e11652cef5a05a9dc98682f3e5
  $tc'Advance2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Advance"#) -}
475394f5afe336f9e96df216e2de9e8b
  $tc'Allocatable :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13816536635255686871##
                   12387360782661274746##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Allocatable2
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
65630405d77f5d232b120dbb85407576
  $tc'Allocatable1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f0c6b5e4ef3e8eec2c4753a7208fcf83
  $tc'Allocatable2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Allocatable3) -}
ab0ecae46d09a8f50860d2a139184bff
  $tc'Allocatable3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Allocatable"#) -}
695abfa835077a16b28030f6c1f30df2
  $tc'Allocate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11424466036600695003##
                   14689948836402426577##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Allocate2
                   1#
                   Language.Fortran.$tc'Allocate1) -}
4d451d982d5a0a18b45229c2daa9c869
  $tc'Allocate1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8abb94397ad9d80e836ac9ff847142c0
  $tc'Allocate2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Allocate3) -}
1aaa01c89e262c48f358b4683e7c8115
  $tc'Allocate3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Allocate"#) -}
326385e935bbb2879f860bb6e484b24f
  $tc'And :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8285554974842422900##
                   4141314415112901296##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'And2
                   1#
                   Language.Fortran.$tc'And1) -}
65657fe55b092f9ed4bf43e46b3d5500
  $tc'And1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2b704ccaec6188943b5b98ec77c3595f
  $tc'And2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'And3) -}
bb7c31f8f2330add940ab419772a7eb7
  $tc'And3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'And"#) -}
c7803efd537bc687664057254cfe966c
  $tc'Arg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8934020831714569867##
                   14439608301798569584##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Arg2
                   1#
                   Language.Fortran.$tc'Arg1) -}
e67b10c9c85347cd030d101eb0001835
  $tc'Arg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
91d0946593150d6710fa83bf6a2f4092
  $tc'Arg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Arg3) -}
80cec2e1ec69502a36ed565048fc250b
  $tc'Arg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Arg"#) -}
436c4407ae081cddf72cebb63d982253
  $tc'ArgList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16851441464165403582##
                   11574141443620985600##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArgList2
                   1#
                   Language.Fortran.$tc'ArgList1) -}
71b6f7f209f016efd51baf2838fdefe8
  $tc'ArgList1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7da677aa6d63057103a1e8f7c94262c3
  $tc'ArgList2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArgList3) -}
030fb844e4b3cfd2930f049cd9660931
  $tc'ArgList3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArgList"#) -}
3496ec6c1c048b7adbbbf220d5c86df0
  $tc'ArgName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10869050459546834973##
                   4032384020014429753##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArgName2
                   1#
                   Language.Fortran.$tc'ArgName1) -}
9298aac544f50ca8f76401ab64382fab
  $tc'ArgName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
52ead1b272c6d97e270d6cad8390d09d
  $tc'ArgName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArgName3) -}
fe85571bfe34fe9859d1baa888399b0f
  $tc'ArgName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArgName"#) -}
40a2b31c874e84da18dd66d5507d1a40
  $tc'ArrayCon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   575626348668537844##
                   17655595403790752852##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArrayCon2
                   1#
                   Language.Fortran.$tc'ArrayCon1) -}
25cec2632bfdba8b23427140f0762bd1
  $tc'ArrayCon1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6b1726897dd658d939768e2538ed2e9a
  $tc'ArrayCon2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArrayCon3) -}
84f06d2ea8c41ed2a1eb31c576eb6442
  $tc'ArrayCon3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArrayCon"#) -}
9c9edb7d46d52b0069b8bf3d483b063e
  $tc'ArrayT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8964873250442873453##
                   14014551614197700065##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ArrayT2
                   1#
                   Language.Fortran.$tc'ArrayT1) -}
ca37a3307795eccaeb30f6c201010380
  $tc'ArrayT1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
702476bb01862f2ed99350bca79bb431
  $tc'ArrayT2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ArrayT3) -}
fe65c7de1dd76ad3e9d9d15672bd061d
  $tc'ArrayT3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ArrayT"#) -}
695ee1c4958101fecd51a9a7f81433d3
  $tc'Assg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15914252908265092314##
                   7955378002686870547##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Assg1
                   1#
                   Language.Fortran.$tc'Allocate1) -}
f55dfcdcb67bc5f38607841f238cf1d0
  $tc'Assg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Assg2) -}
2c57b4687435c5860cfbac54d6d64e3d
  $tc'Assg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Assg"#) -}
319ed6e668a4062f0e5d280d8fa012b3
  $tc'AssgExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5218881154675476036##
                   4606212421568930909##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AssgExpr2
                   1#
                   Language.Fortran.$tc'AssgExpr1) -}
8e36e0846380a9c81a29bfb8fdf7e656
  $tc'AssgExpr1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a7e2a3e81bb8fb4513a2eba4b9567af4
  $tc'AssgExpr2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'AssgExpr3) -}
df4212906a95156f058bbe9b079f7de2
  $tc'AssgExpr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AssgExpr"#) -}
181b30530b4275877bfbee1456313bc1
  $tc'AttrStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3303435940039232822##
                   16953890483536061916##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'AttrStmt2
                   1#
                   Language.Fortran.$tc'AttrStmt1) -}
84ead00600affc867c55b56178541ffd
  $tc'AttrStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
36964f949325e0901d094ddbfe788bf5
  $tc'AttrStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'AttrStmt3) -}
6d8ef2874bf161454968fb228d49c630
  $tc'AttrStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AttrStmt"#) -}
31d4ab461e6735a1ef14a74c31e5a7a5
  $tc'Backspace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16382287389464146984##
                   9830540976838756791##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Backspace2
                   1#
                   Language.Fortran.$tc'Backspace1) -}
1124a68e4dbd883bba0f8efb96c69c85
  $tc'Backspace1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c29020f92583be3ff69274cc1bbc215e
  $tc'Backspace2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Backspace3) -}
122c7d0a2feb9ce7e5535eca383e56c8
  $tc'Backspace3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Backspace"#) -}
96777d24c83f2bf00ef22d18d8af38a9
  $tc'BaseType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8774994487901113027##
                   2798562882635758887##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'BaseType2
                   1#
                   Language.Fortran.$tc'BaseType1) -}
b31396fa617abeeeb810eb53a40c6a26
  $tc'BaseType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e3c87c9f59007c8285f5b3bcbfcab725
  $tc'BaseType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'BaseType3) -}
3510ddcce63dd402704b2657f34f1da8
  $tc'BaseType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BaseType"#) -}
b1e7c3bb6d365c79dcc766185d67ba89
  $tc'Bin :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11165052385293591394##
                   10669274964231655849##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Bin2
                   1#
                   Language.Fortran.$tc'Bin1) -}
a8bdb0113bb979397e1eb0fead596957
  $tc'Bin1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
dff9e73388eedbc1d1e8384021277810
  $tc'Bin2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Bin3) -}
e230ef06db98f2f6975368e4eac5f014
  $tc'Bin3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bin"#) -}
7eb7877d9b66794cb732096dc0092f11
  $tc'Blank :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1484023214638278707##
                   2983663293812487870##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Blank1
                   1#
                   Language.Fortran.$tc'Access1) -}
bdff0a90583d4ec78716ef7a3950aa03
  $tc'Blank1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Blank2) -}
6b82a8c5b45061dfdb7c9b17c12cd28d
  $tc'Blank2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Blank"#) -}
54da7ebdd87bb791792fe185cf963d1b
  $tc'Block :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9628368509093720585##
                   11608378244313493963##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Block2
                   1#
                   Language.Fortran.$tc'Block1) -}
3cbcb0ab4e6c2c38ca74fe23ea45dc22
  $tc'Block1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8603ec4639b933249d5f75016b0adbbc
  $tc'Block2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Block3) -}
6b04ec455e226b264b57f27e3ce7819e
  $tc'Block3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Block"#) -}
11ce7ec7a89a0e7faab5a605898642b1
  $tc'BlockData :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2731575415531285777##
                   9227550155522891599##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'BlockData2
                   1#
                   Language.Fortran.$tc'BlockData1) -}
3ad8eb8f2d2bfafbbe1cc1a49360e30f
  $tc'BlockData1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
721aba9d92135ef80cb99a3bb41fb1a9
  $tc'BlockData2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'BlockData3) -}
88039980c972118ad8e2fb51ea270431
  $tc'BlockData3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BlockData"#) -}
38ffc6fe4b1886265fb0af6ab2b201d7
  $tc'Bound :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2475017828839769673##
                   6772703385186664291##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Bound2
                   1#
                   Language.Fortran.$tc'Bound1) -}
a289c37a1a470ff43200596951237f79
  $tc'Bound1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
342bde47243b53abe8fa5640b6f77c98
  $tc'Bound2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Bound3) -}
bdfab104f32c5720d57f3f0db9afc027
  $tc'Bound3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Bound"#) -}
c6cc86f7eebb693b749ddbefd59cbc0f
  $tc'C:Span :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16296701428427870731##
                   13749265001185410749##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'C:Span2
                   1#
                   Language.Fortran.$tc'C:Span1) -}
611cba8921eb95c34725aff641f982c8
  $tc'C:Span1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
143443ff3c59de6883ad3912b5960aea
  $tc'C:Span2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'C:Span3) -}
b77c9c6237f9b178f923ebbff9727e88
  $tc'C:Span3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:Span"#) -}
8eebb0f5532d9d3bf1f60aad3e087be3
  $tc'Call :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16652566219465327087##
                   13998873152443050047##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Call2
                   1#
                   Language.Fortran.$tc'Call1) -}
64756b85684f154acda0075e63240620
  $tc'Call1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3940e182e9df90337b56bbc84ee5313d
  $tc'Call2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Call3) -}
2c7f00271932029258223ea809b85140
  $tc'Call3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Call"#) -}
6871534cde22a253846d3a0b6a9c0bb0
  $tc'CallExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17387360601792045641##
                   233548616592725279##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'CallExpr2
                   1#
                   Language.Fortran.$tc'CallExpr1) -}
8a6dc2f5ac84e11577e8b385e703fd73
  $tc'CallExpr1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7c7254d6e4064b7c3c5b7d2147e3e646
  $tc'CallExpr2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'CallExpr3) -}
dfb047b143eee91f614840ca26ea8982
  $tc'CallExpr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CallExpr"#) -}
b2bff1f3e4ba4dc2202481dd331c1723
  $tc'Character :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1654956844808084864##
                   11007036718608564991##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Character2
                   1#
                   Language.Fortran.$tc'Character1) -}
11bf0607d095335024586c99f95b0d8e
  $tc'Character1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2a7ecfbdebb50772859317fff97b8de9
  $tc'Character2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Character3) -}
3e13d2ff041b5f2e2e4657bf889d0f80
  $tc'Character3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Character"#) -}
c6aa19dcd431ebb83bc4cd714a6905cb
  $tc'Close :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2476821750709600433##
                   16191886084367517135##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Close1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
793fecea1d4f70d46ec1074400da4e16
  $tc'Close1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Close2) -}
03dff1b4ee40d2199f271e915fbe652e
  $tc'Close2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Close"#) -}
99ae306274521e550b34212675f329d1
  $tc'Common :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12276623769161748560##
                   11549049810322806200##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Common2
                   1#
                   Language.Fortran.$tc'Common1) -}
226dccd845e9724e6e5a1c80fdda69ba
  $tc'Common1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4ccd2c910bdd327dd47a5bb527883320
  $tc'Common2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Common3) -}
eab9e05bd83e99e71e458f8a405412e5
  $tc'Common3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Common"#) -}
3a9e7834cf9ca36ff05e47e7298c6576
  $tc'Complex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4837064116592927307##
                   11331973882636710706##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Complex1
                   1#
                   Language.Fortran.$tc'Character1) -}
35a0d1abcee16765604bf5630c5200ae
  $tc'Complex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Complex2) -}
94f86eb6d4dfd67978b43157571fd804
  $tc'Complex2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Complex"#) -}
7acb1a9b08c9dee071fd9817a4006812
  $tc'Con :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6883453987654934880##
                   6494571913207724572##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Con2
                   1#
                   Language.Fortran.$tc'Con1) -}
b5cbee632adbb7f5a07b8c8f571d4a15
  $tc'Con1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
97b748a755e6f034c742936ce3317f99
  $tc'Con2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Con3) -}
6e0b730c50172c82bc941e37edd80010
  $tc'Con3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Con"#) -}
696b72f71fb5e18c821279669fe26563
  $tc'ConL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4486147205858390468##
                   6284202953298490808##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ConL2
                   1#
                   Language.Fortran.$tc'ConL1) -}
7a74492be63ee41bbe7988d6640e6774
  $tc'ConL1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c5db0112aba25b08baeb99613925799e
  $tc'ConL2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ConL3) -}
8781c2fc6778ef61b0f61ba5d9dc15c0
  $tc'ConL3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ConL"#) -}
32f3bfb768b82299eeccab8700c3840d
  $tc'ConS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10363810723619423623##
                   16994326893239881530##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ConS1
                   1#
                   Language.Fortran.$tc'Con1) -}
bb19dd25e0a4a82f1e3985b297ff9aea
  $tc'ConS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ConS2) -}
b25d468286113fde71d6e21d5527fd1d
  $tc'ConS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ConS"#) -}
411a2275b2c5f4ac3a7fd0ebefcd61fa
  $tc'Concat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4551656433673061659##
                   1551509396345338418##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Concat1
                   1#
                   Language.Fortran.$tc'And1) -}
109d5321342f756908539a6aab03a2a8
  $tc'Concat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Concat2) -}
5cd496d60eb1772f3a1d43a2b7290b56
  $tc'Concat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Concat"#) -}
bb1960d4ac5778f004aaef43946a6090
  $tc'Continue :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3674212588136182796##
                   3173077106589623374##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Continue2
                   1#
                   Language.Fortran.$tc'Continue1) -}
8688995a91a9234898987536e79a6ba1
  $tc'Continue1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
436362a0a6e452209ffff72418156ff9
  $tc'Continue2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Continue3) -}
8b18139590ad73b6832b5565537590c6
  $tc'Continue3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Continue"#) -}
d839c39e436631eca87c8102e62d7580
  $tc'Cycle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15441618173857669048##
                   5986125076870210455##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Cycle2
                   1#
                   Language.Fortran.$tc'Cycle1) -}
db919274bf61d667dab01b145040e2bb
  $tc'Cycle1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c5f483b80de764cf462abfe24f24deaf
  $tc'Cycle2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Cycle3) -}
e2c121b863d152d669c4d632365eaefa
  $tc'Cycle3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Cycle"#) -}
55ecc5270498897f0be8a8b22407532e
  $tc'DSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14207230656939750798##
                   13196561363245017033##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DSeq2
                   1#
                   Language.Fortran.$tc'DSeq1) -}
57ee5cff5cfc0db4767af9eccc4395a9
  $tc'DSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
221985cad80a01ffe9662168345fa5f4
  $tc'DSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DSeq3) -}
ba111024f2265e44314e5b6d7af45db3
  $tc'DSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DSeq"#) -}
7eb45125425526fb39161d82ddda2815
  $tc'Data :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8891190932453087675##
                   12430180790535450983##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Data2
                   1#
                   Language.Fortran.$tc'Data1) -}
f8b1e4e3d62956a18199b6aa82341f29
  $tc'Data1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
161faa335469646ce7508022a95c345c
  $tc'Data2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Data3) -}
9149794d54ffa22922c638708ed1b356
  $tc'Data3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Data"#) -}
da9a58fb403984725aedeccab38b8133
  $tc'DataDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3209856786162149067##
                   3537040510077277128##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DataDecl2
                   1#
                   Language.Fortran.$tc'DataDecl1) -}
42f74d609387b641ef64ce3029210516
  $tc'DataDecl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
679f2085251134a1273219956e275e67
  $tc'DataDecl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DataDecl3) -}
275976f7655cddc7645b570bfb9f14e5
  $tc'DataDecl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DataDecl"#) -}
f6a456bdc0d3d4ea415199475ad5d929
  $tc'DataStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12480846175320528522##
                   17088185622046522677##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DataStmt2
                   1#
                   Language.Fortran.$tc'DataStmt1) -}
7214efe94d13d2d7840b3dc8442cf4fc
  $tc'DataStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
612325f01ab3c28d70f0f5f500b7906f
  $tc'DataStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DataStmt3) -}
2c887aa948d00a0b0808fd7c41f5783c
  $tc'DataStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DataStmt"#) -}
b3a5f58d1574d41451cc72f46708b1c2
  $tc'Deallocate :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5482894604309158406##
                   9488952589309272972##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Deallocate2
                   1#
                   Language.Fortran.$tc'Deallocate1) -}
c489743ca065141eb9f552dcb038263d
  $tc'Deallocate1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4d8429fa51eff33f8fbf497668afca0b
  $tc'Deallocate2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Deallocate3) -}
bda4833af98dd0e66d21410c7b3e20e0
  $tc'Deallocate3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Deallocate"#) -}
51fae55361df0eb2eb4d0016856256df
  $tc'Decl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2121592585705907547##
                   5788443960755463634##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Decl2
                   1#
                   Language.Fortran.$tc'Decl1) -}
f2174d686c7c44bf23a0eb8b2fd0bb8c
  $tc'Decl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bbeca16133b81fb4c598eed80ebd0e13
  $tc'Decl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Decl3) -}
bc8ee3beba37104177915ef4b03b4a3e
  $tc'Decl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Decl"#) -}
34a39a1666cccc61db2772759b82241c
  $tc'Delim :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17613739137060458526##
                   8371568547596301418##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Delim1
                   1#
                   Language.Fortran.$tc'Access1) -}
c1e73ead3555d90596884afdd6aefaa0
  $tc'Delim1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Delim2) -}
44a77dfd21744b935fe0889503bd374b
  $tc'Delim2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Delim"#) -}
f59cd5b5c6644c0c83c995f0c2747777
  $tc'Delimiter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16797046461700982828##
                   14142798362306011074##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Delimiter2
                   1#
                   Language.Fortran.$tc'Delimiter1) -}
998f4c2f5ae0ead07e8574f0b31b4d70
  $tc'Delimiter1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
707979dae22c77d4261d8a025795b872
  $tc'Delimiter2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Delimiter3) -}
ca75357b7e55be9728df969a651cfda2
  $tc'Delimiter3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Delimiter"#) -}
9b46f3ca310447501bd2f01014f8e29b
  $tc'DerivedType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4572404851977824868##
                   1539616018588448523##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DerivedType2
                   1#
                   Language.Fortran.$tc'DerivedType1) -}
e65838adcb129a04fa11747a306a9b0c
  $tc'DerivedType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8c3c2488e525c3f56c98a0ce4ec8ec01
  $tc'DerivedType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DerivedType3) -}
88eff462728271925abf24301dcacab8
  $tc'DerivedType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DerivedType"#) -}
d1cbbcb52ed763582d63bd81afdbdf4e
  $tc'DerivedTypeDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10770291738849802475##
                   15896024748849745126##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DerivedTypeDef2
                   1#
                   Language.Fortran.$tc'DerivedTypeDef1) -}
d2a96208ea74f4c13b5566afed5be9cd
  $tc'DerivedTypeDef1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
80d172ffde0c99aeac685034c9166e6c
  $tc'DerivedTypeDef2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'DerivedTypeDef3) -}
a6fd0df3f7eeda26775cc8a72b5020e9
  $tc'DerivedTypeDef3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DerivedTypeDef"#) -}
63fafb273f4b20deb77bd82c093c5f89
  $tc'Dimension :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10251931478553471549##
                   11151449194282671324##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Dimension2
                   1#
                   Language.Fortran.$tc'Dimension1) -}
d2fbecf6129c2d182e6a90e377f2f264
  $tc'Dimension1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
620db9b2f3d90eb447cf18170a8c76c6
  $tc'Dimension2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Dimension3) -}
7e80b41ba23aae75a482480c4f0c68c4
  $tc'Dimension3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Dimension"#) -}
bf9910b07a51b690cb1732dae258d7b0
  $tc'Direct :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6132930395770838563##
                   8659715654318342087##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Direct1
                   1#
                   Language.Fortran.$tc'Access1) -}
8ff6690f62b696dc1eb3569be3123e61
  $tc'Direct1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Direct2) -}
85ecd712402255dd1fa7ced96a5af5d6
  $tc'Direct2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Direct"#) -}
6eaf14959bda444b54f5ce29ae978389
  $tc'Div :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15192632699998951977##
                   12355637958259320002##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Div1
                   1#
                   Language.Fortran.$tc'And1) -}
07dddbaa9f91863c6b867894b807edd7
  $tc'Div1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Div2) -}
2d3f18e602ca6fbde2fd18a3cc9e43d4
  $tc'Div2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Div"#) -}
61b9cab7f521dccfce578db1d66cc9b6
  $tc'DoWhile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1540764816802265829##
                   10052246421911507487##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'DoWhile2
                   1#
                   Language.Fortran.$tc'DoWhile1) -}
65bc3146e106661c90790c9cccfdbd24
  $tc'DoWhile1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
055db09a5311900185fe9f090b9059a4
  $tc'DoWhile2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'DoWhile3) -}
f911467ad56dfc439d6267367419e598
  $tc'DoWhile3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DoWhile"#) -}
dff79c4b53005abefcd612ff136612c8
  $tc'ESeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2345890990835741811##
                   16876710341776865806##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ESeq1
                   1#
                   Language.Fortran.$tc'Bound1) -}
38d3cd6f0ddb9e11f077bc042fb77a99
  $tc'ESeq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ESeq2) -}
1ed34628775abd126113e34d85fa8b07
  $tc'ESeq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ESeq"#) -}
772d40bcfda93a06f19d09fece01b13b
  $tc'Elemental :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18158056448545532080##
                   7643694741822006565##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Elemental1
                   1#
                   Language.Fortran.$tc'Character1) -}
275984e2d748e536318a836f9c2a4cd4
  $tc'Elemental1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Elemental2) -}
a76dd7b333dbd75c4cbd6c23b7eb17ac
  $tc'Elemental2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Elemental"#) -}
a6b68b9828874ec70f2f2dfbb58ffe71
  $tc'End :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3554614442193337958##
                   9937294760324555546##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'End1
                   1#
                   Language.Fortran.$tc'Access1) -}
2c78939cbb4653ab2a7b458a68c8e426
  $tc'End1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'End2) -}
68ed742ae34b5bd1e5d7d83c629469c9
  $tc'End2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'End"#) -}
d2d097b7368680fbd65069171ef10133
  $tc'Endfile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10977444584500374463##
                   18150272270165933680##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Endfile1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
6b7a4e335fc2d53426af184f6bddc16c
  $tc'Endfile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Endfile2) -}
6870ab4d501fec81e427513dbfa65057
  $tc'Endfile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Endfile"#) -}
0a5612ebb67938893a3f6f9bf2d9ed12
  $tc'Eor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17428165116647264919##
                   10802583821107994978##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Eor1
                   1#
                   Language.Fortran.$tc'Access1) -}
88b16ba6b3c66d227fdc4be22d51632f
  $tc'Eor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Eor2) -}
618acad5186af29044cd8c4173da0f86
  $tc'Eor2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Eor"#) -}
90939733794cca02670bbd57e9b6d9f0
  $tc'Equivalence :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   669199761681321550##
                   17959960631238057549##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Equivalence2
                   1#
                   Language.Fortran.$tc'Equivalence1) -}
59bd3a561152ed77f74287646fcecdde
  $tc'Equivalence1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
635181859e0207955c8b8e708269d3c4
  $tc'Equivalence2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Equivalence3) -}
b8d7427c76754cc8b858e6212a7b7254
  $tc'Equivalence3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Equivalence"#) -}
89431455182729aba124a43ed55a299b
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5298887205989268651##
                   953421439634107268##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Err1
                   1#
                   Language.Fortran.$tc'Access1) -}
989666ce9ed72cb747c1e37d6bacf01c
  $tc'Err1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Err2) -}
fee8fa1d98069e283d10a9310edb2f5f
  $tc'Err2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Err"#) -}
6971587263029eb0aae63b0f659b152c
  $tc'ExFile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10506864157184088485##
                   11218599507608946355##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ExFile1
                   1#
                   Language.Fortran.$tc'Access1) -}
0b76cb892fbe9882931bdcc2976a953e
  $tc'ExFile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ExFile2) -}
00e520f34a0e6f28533025dc767186ae
  $tc'ExFile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ExFile"#) -}
4380a3cde0967d9feb33b1593975d45d
  $tc'Exist :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8347875013690527334##
                   6955535326061399789##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Exist1
                   1#
                   Language.Fortran.$tc'Access1) -}
a8a81b7a6e2f51e8f2cbfc866c1ecc89
  $tc'Exist1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Exist2) -}
019b03ef61678bcf1e5355b9f630487d
  $tc'Exist2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Exist"#) -}
04438e721f9981a7dd647cc1bb2460f6
  $tc'Exit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8957291959503656046##
                   10000097450859125567##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Exit1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
79b9fa5c52116fa276f29037558b1781
  $tc'Exit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Exit2) -}
c6e452e6c109ee1a54c0faccb332919c
  $tc'Exit2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Exit"#) -}
f3a8da199e242f0368cb42027468ba93
  $tc'External :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7467434446645482979##
                   9362864924889204397##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'External1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
52e469c59347abd3011bec270d3edd56
  $tc'External1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'External2) -}
0a5d785c1e8f16ccae945fd71855e56a
  $tc'External2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'External"#) -}
00f1867d9d77e7f9806c5eb191447be6
  $tc'ExternalStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7958538260182272378##
                   152739620969188400##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ExternalStmt2
                   1#
                   Language.Fortran.$tc'ExternalStmt1) -}
16f21db0fb2fca0a9f6caa6f3d0e5a28
  $tc'ExternalStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7f8283f02f8bd504e5eb130f819526a5
  $tc'ExternalStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ExternalStmt3) -}
66336b7932c50d88c3fb86a54e580833
  $tc'ExternalStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ExternalStmt"#) -}
cc3cf07ab2d7387060d4984282768aef
  $tc'FMT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15748586238398566597##
                   5823489643309618489##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FMT1
                   1#
                   Language.Fortran.$tc'Access1) -}
3305050248d44c1c23cf24434f5d5b81
  $tc'FMT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'FMT2) -}
ca61d4034122eba079e64944af6b1ce2
  $tc'FMT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FMT"#) -}
e9027ee429f801e7aaaa775741287829
  $tc'FSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13069131101718797532##
                   16482241046001938825##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FSeq2
                   1#
                   Language.Fortran.$tc'FSeq1) -}
fe506eb67d7d13d08836d22d5ceaec0c
  $tc'FSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
89cd61bff8d7d1e744cb34630d861a3a
  $tc'FSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'FSeq3) -}
0c60a7f9081a2a581d3e332c1a319793
  $tc'FSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FSeq"#) -}
40eaa8827438534a96a075137a8f4ddf
  $tc'File :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11770304848302152300##
                   13532331780013150565##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'File1
                   1#
                   Language.Fortran.$tc'Access1) -}
bc8995f0349c44b012a87389ab1dcef0
  $tc'File1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'File2) -}
ce174d491e0139cfb63d4286b86b8165
  $tc'File2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'File"#) -}
dff9ee58435497a123138f67337b94a7
  $tc'Floating :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7450993198945152979##
                   14855706715645843187##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Floating2
                   1#
                   Language.Fortran.$tc'Floating1) -}
aa7699e2416e5706b86e2fa12e1483b9
  $tc'Floating1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9fdd0fd0b1cc162e6e50f6423ad2055b
  $tc'Floating2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Floating3) -}
8f29165839d4a1940bd856a380e8093b
  $tc'Floating3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Floating"#) -}
2c3af67f3e63027674fc2e8bc9a5204b
  $tc'For :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9802254308702613016##
                   6829509077785952932##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'For2
                   1#
                   Language.Fortran.$tc'For1) -}
4074c4e929d5fcd35dfcfc73e39361cf
  $tc'For1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
35418aafaab7a277d90c0c626696242b
  $tc'For2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'For3) -}
8ccbe90b9a80534f3657a1a6dd51fae4
  $tc'For3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'For"#) -}
aade226319e65a35417b676f49bc16ae
  $tc'Forall :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10368618261159300831##
                   10438263834748101570##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Forall2
                   1#
                   Language.Fortran.$tc'Forall1) -}
5d8234bd4b9eca86f093f013a9a4339f
  $tc'Forall1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
58673b8975a29b5b944d708d4bd8302a
  $tc'Forall2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Forall3) -}
b91539704f5ed2af8aed4ec3cded6eb2
  $tc'Forall3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Forall"#) -}
547227e186c50b668d3803bd92779d47
  $tc'Form :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   724363532995546270##
                   15839832534016568506##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Form1
                   1#
                   Language.Fortran.$tc'Access1) -}
466483641959bd50eae69f89c0a2536b
  $tc'Form1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Form2) -}
a4da0b58c6b7288a50808c58cafec673
  $tc'Form2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Form"#) -}
9c38fefcefecddb049d5a2e02d9daf41
  $tc'Format :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16986307215135087159##
                   18440165950960430901##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Format1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
53f44a554a8f1795627ac09bcce66f47
  $tc'Format1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Format2) -}
614a945ff0d6a743fe7c52e61183bf2d
  $tc'Format2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Format"#) -}
f3970b2543f26301a506d4e1cf0270c1
  $tc'Formatted :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8779743414366515282##
                   17777934400101090594##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Formatted1
                   1#
                   Language.Fortran.$tc'Access1) -}
7429f3889f5c11b5780099add1f78e7d
  $tc'Formatted1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Formatted2) -}
c6c5a1a8c0759d45147f822d0280cb75
  $tc'Formatted2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Formatted"#) -}
2ccf603c8fde898413d4b4139c897595
  $tc'FractionConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9742603349666706761##
                   4808684621944545373##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FractionConst2
                   1#
                   Language.Fortran.$tc'FractionConst1) -}
b918ee1940b10a46bf01f94201be4158
  $tc'FractionConst1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d61ea0e7e7f8cb555159afec18055e19
  $tc'FractionConst2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'FractionConst3) -}
7116cff4052b1117b65684d0ddbde33d
  $tc'FractionConst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FractionConst"#) -}
df2713964545c602c7f9ccade7c8cc44
  $tc'Function :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14195237093590399959##
                   10972936958357477736##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Function2
                   1#
                   Language.Fortran.$tc'Function1) -}
c2c6229fa2d795ed84d505364761e4f6
  $tc'Function1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c964c0ababa14a58f92aaa092613e9da
  $tc'Function2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Function3) -}
31c2454e825d51395ddf92f0e84096cf
  $tc'Function3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Function"#) -}
88ff1f07c1ea35b9f1f9d73d24cb0555
  $tc'FunctionInterface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   305225790717689063##
                   7979664900855100492##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'FunctionInterface2
                   1#
                   Language.Fortran.$tc'FunctionInterface1) -}
3a464cff0e8ad78a30579f994bfa2fca
  $tc'FunctionInterface1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c8d51857b3159b1d83f90f819994dd02
  $tc'FunctionInterface2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'FunctionInterface3) -}
4118dfeefbc7451e1896c5aac9003370
  $tc'FunctionInterface3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'FunctionInterface"#) -}
700a5d961511abc373ecea1519448c86
  $tc'GAssg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5170685994438843530##
                   1821178991608259861##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GAssg2
                   1#
                   Language.Fortran.$tc'GAssg1) -}
ab51e0023349863ea43ce87c0d4c744a
  $tc'GAssg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7eb75f1c9dc12454a43720501ab1ed00
  $tc'GAssg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'GAssg3) -}
dfd47f2d397e73b37871b105962a1959
  $tc'GAssg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GAssg"#) -}
bb877ce0517e80094151592926835ae6
  $tc'GName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17135275298192810995##
                   14082272666901229746##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GName2
                   1#
                   Language.Fortran.$tc'GName1) -}
0241825f3a6e41c7ec0fc9eb883f7cf1
  $tc'GName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e20d2c7568749a814bed7b299ced18f3
  $tc'GName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'GName3) -}
4d7c8df56c8338f48339e5b08926798d
  $tc'GName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GName"#) -}
e4323cf75bfcbeeb210694c942ec544c
  $tc'GOper :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5787645732889089541##
                   17783073733206208864##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'GOper2
                   1#
                   Language.Fortran.$tc'GOper1) -}
4a30e04bd24be67adcfe914c6afcd575
  $tc'GOper1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
dd6700969930ff450ac8ecaf51d6b15a
  $tc'GOper2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'GOper3) -}
3f2a4cb2979f90d28b731416f2d68819
  $tc'GOper3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'GOper"#) -}
1cfd646c3d007a0f6de5cf6da557186d
  $tc'Goto :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11513900032764942271##
                   7311940997554387775##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Goto1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
b84c8d0e304e9e9e8adeffb6f701230c
  $tc'Goto1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Goto2) -}
9274138c2c78306826eccab585fe3b83
  $tc'Goto2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Goto"#) -}
76ab99bbcbf480cccb3bc693402d0be4
  $tc'IOLength :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11205473156405413309##
                   11098054642684133981##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IOLength1
                   1#
                   Language.Fortran.$tc'Access1) -}
e7775fa61358a0a161a8c70d57ff6591
  $tc'IOLength1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'IOLength2) -}
4a4fae4405e40813bc489daafce8fbef
  $tc'IOLength2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IOLength"#) -}
8cd7063eb62970d075ed63b30554dc5a
  $tc'IOStat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3370041713312675160##
                   5185877233961188358##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IOStat1
                   1#
                   Language.Fortran.$tc'Access1) -}
68ac48815af2e53bcd5110dcc37559bf
  $tc'IOStat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'IOStat2) -}
1f78a4b93b7f17feb2e4db27eed3f24c
  $tc'IOStat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IOStat"#) -}
60dd2c86c1525afc6ffb7133b0352c23
  $tc'If :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6096788238347221750##
                   5366482290980162729##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'If2
                   1#
                   Language.Fortran.$tc'If1) -}
d469f06a977dcc342332fcf71bbed90c
  $tc'If1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b0ac76457a33f7b601b943314ee1e52b
  $tc'If2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'If3) -}
23dea51a115c6d0274d110b41f838bbe
  $tc'If3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'If"#) -}
c8be743423dd8bf50aa09941d4e6adfc
  $tc'ImplicitNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17469568709642825960##
                   5338820960976198407##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ImplicitNone2
                   1#
                   Language.Fortran.$tc'ImplicitNone1) -}
ef997459f0a9796a0500e4f4545cd6e6
  $tc'ImplicitNone1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
637a75b47088c8f604ef6e2cae8a073f
  $tc'ImplicitNone2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ImplicitNone3) -}
014b82fd0855470105f5e660a16df762
  $tc'ImplicitNone3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ImplicitNone"#) -}
b13c3a8c3c7b971f4d83896a40c39116
  $tc'ImplicitNull :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4734420412227314985##
                   14780230511524472263##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ImplicitNull1
                   1#
                   Language.Fortran.$tc'ImplicitNone1) -}
f734a16a75542484f4173ff3e0ff04fe
  $tc'ImplicitNull1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ImplicitNull2) -}
3b41eae7660e7affbbaddfd25218aa1f
  $tc'ImplicitNull2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ImplicitNull"#) -}
f904762d8757bd8fddd67502c1a4628d
  $tc'In :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13788974463803022993##
                   2123338053242467750##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'In2
                   1#
                   Language.Fortran.$tc'In1) -}
b242e015a9d6bc99bf6de2b0bba75daf
  $tc'In1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9526afb354a1501ffc024d9e95678e65
  $tc'In2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'In3) -}
d8e5c8bac7ff739a23d13a9ffd81c155
  $tc'In3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'In"#) -}
88df11f118e7400086894f4b598fa0dd
  $tc'InOut :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15044770874535226503##
                   3698633566430417192##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'InOut1
                   1#
                   Language.Fortran.$tc'In1) -}
ad4a87fc01514d0eab089968897a66f2
  $tc'InOut1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'InOut2) -}
df9e8f7b67e14e55e78853b0097debc3
  $tc'InOut2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'InOut"#) -}
0bbfdc72ec9e3c335ac476f3b3a193ce
  $tc'Include :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7156736056396505156##
                   192273752186265787##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Include2
                   1#
                   Language.Fortran.$tc'Include1) -}
84d29450e7ff7c4196a57e7ba0aafe25
  $tc'Include1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2203b763c2bfe2431690e9ec06ee6509
  $tc'Include2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Include3) -}
99c4d8e712d926db7e75697c3a6edfd2
  $tc'Include3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Include"#) -}
7768c12b306c1e46b3d130817f3891e3
  $tc'IncludeProg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8834613552538472990##
                   15237173092734630736##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IncludeProg2
                   1#
                   Language.Fortran.$tc'IncludeProg1) -}
6d51df95ee527d5b2e3442b42d6ccec1
  $tc'IncludeProg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
50f967bb0f6202c467d6dbf6e2f70e6c
  $tc'IncludeProg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'IncludeProg3) -}
57fa9809e07fbd716dd27e7ae83a6382
  $tc'IncludeProg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IncludeProg"#) -}
41fe6cdb042194b5da4c879601d767a7
  $tc'Inquire :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16745017358153071422##
                   13016828002076646335##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Inquire2
                   1#
                   Language.Fortran.$tc'Inquire1) -}
26444d5b683b90f5a0fb81dd9e995092
  $tc'Inquire1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7615337342ca36421fe3020419362dc4
  $tc'Inquire2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Inquire3) -}
125e216d6d9ce64e60e6b525c9cc7485
  $tc'Inquire3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Inquire"#) -}
b3b01078e1a422f8a150c5fa0a2f1273
  $tc'Integer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14678799731522727027##
                   5321592046174644452##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Integer1
                   1#
                   Language.Fortran.$tc'Character1) -}
3ed8fc8277034dc7b206fc0e69650118
  $tc'Integer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Integer2) -}
d589014545f6d16947dac54082f92803
  $tc'Integer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Integer"#) -}
5804afad315b194932dc2d6b8534c0c5
  $tc'IntegerConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18169659410186348737##
                   13407473979447472795##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'IntegerConst2
                   1#
                   Language.Fortran.$tc'IntegerConst1) -}
c5053d85787519a53f06afd1f1a37f34
  $tc'IntegerConst1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cb571cce3445f5598c91c2df31087abd
  $tc'IntegerConst2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'IntegerConst3) -}
e8d801dc414aa78e8b045d4c4f09fb2e
  $tc'IntegerConst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IntegerConst"#) -}
d2c3fb4b625d177651af2efe790d9931
  $tc'Intent :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12227339318982776683##
                   17643971424270250757##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Intent2
                   1#
                   Language.Fortran.$tc'Intent1) -}
5fc36aba018e6636ed657776656dcac5
  $tc'Intent1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5d543f559fc4ca2306cfd4916d00d28e
  $tc'Intent2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Intent3) -}
3e2363c2cc789c015b51da2753bd9197
  $tc'Intent3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Intent"#) -}
706da83948aebf2c0b30e9533e453b70
  $tc'Interface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1031906217255468592##
                   12344873096390928314##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Interface2
                   1#
                   Language.Fortran.$tc'Interface1) -}
4329ebb195ba1460155c34cf2ff2e782
  $tc'Interface1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6f884c0756c73106e6f1cd27930b9e23
  $tc'Interface2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Interface3) -}
a867a314c6e9583b83c2814ebc0e1f36
  $tc'Interface3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Interface"#) -}
983b8254a6925aa167bac70f8dce1624
  $tc'Intrinsic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15335749572938870274##
                   8863925640991719434##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Intrinsic1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
b6b40fa425341152b2858e9d7d747957
  $tc'Intrinsic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Intrinsic2) -}
f575f1afb9a72d90fd2bf3b723cfaa0f
  $tc'Intrinsic2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Intrinsic"#) -}
d207492bdfcbe4ee1c4bfa5034b03b4d
  $tc'Label :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7618885485563309003##
                   9279562609137468114##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Label2
                   1#
                   Language.Fortran.$tc'Label1) -}
0d8602ee01ab2b610aa0ccee61c043b8
  $tc'Label1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3617030a77d2720d9434d161b5cc59a8
  $tc'Label2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Label3) -}
40a14555035019b4eec9e8bead17e017
  $tc'Label3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Label"#) -}
7ad7978bf64cac44835ca3eba025000d
  $tc'Logical :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11734847837259923746##
                   11229714920389810692##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Logical1
                   1#
                   Language.Fortran.$tc'Character1) -}
af1ec48b0630b1bb1e367952f0672fd1
  $tc'Logical1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Logical2) -}
0da101b52eb4be09d9ddef8fe02950f4
  $tc'Logical2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Logical"#) -}
86e260de8b272d88df0ca58dc1795769
  $tc'Main :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4946244222179486719##
                   15519760446661853326##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Main2
                   1#
                   Language.Fortran.$tc'Main1) -}
be725f71f55f46412655647e2399c37f
  $tc'Main1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8273abcce36c111ba5ab2171cbdb686f
  $tc'Main2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Main3) -}
d4b393b319d1f523edfa3d855b073641
  $tc'Main3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Main"#) -}
13444eb8585343632147577b0b413871
  $tc'MeasureUnit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18147772273724588013##
                   9808462387280549969##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'MeasureUnit2
                   1#
                   Language.Fortran.$tc'MeasureUnit1) -}
b1df5ff859dc153373c83b75c9821eca
  $tc'MeasureUnit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ca2501dde5e500ada86d82eaa8522818
  $tc'MeasureUnit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'MeasureUnit3) -}
e88655e835b9a9fe5493acde64b594af
  $tc'MeasureUnit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'MeasureUnit"#) -}
e69d89cde7175e528dc1fada1346b01c
  $tc'MeasureUnitDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3803614861464497606##
                   8189406372123537795##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'MeasureUnitDef2
                   1#
                   Language.Fortran.$tc'MeasureUnitDef1) -}
925e38d14c235b003a9fa3c10ed2b6ab
  $tc'MeasureUnitDef1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
38a691064035f5ed72c4e690a36550d9
  $tc'MeasureUnitDef2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'MeasureUnitDef3) -}
e692f6eb40d1c7a3e4486605a5b51284
  $tc'MeasureUnitDef3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'MeasureUnitDef"#) -}
1555ec79f32f459c9fbb35145985331d
  $tc'Minus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11773354485450560132##
                   39833129223720780##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Minus1
                   1#
                   Language.Fortran.$tc'And1) -}
2835f16162c0b27928b7d1afc3d0a026
  $tc'Minus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Minus2) -}
c84bce66a9e5c6648607d66e4b44597f
  $tc'Minus2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Minus"#) -}
d49ee4aee02e6fae7db3c9887b8decff
  $tc'Module :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6966299312582761130##
                   11511362842342550801##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Module2
                   1#
                   Language.Fortran.$tc'Module1) -}
009f5bde1c2effa33afe0aaf878ac08c
  $tc'Module1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b9ac9807c96935ad261bb357b6922880
  $tc'Module2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Module3) -}
d239373fcc36c5e59718f4c743579406
  $tc'Module3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Module"#) -}
9a6554913a0922de7f7ae79f79b6ed94
  $tc'ModuleProcedure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2676750391146560556##
                   7432863885515979008##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ModuleProcedure2
                   1#
                   Language.Fortran.$tc'ModuleProcedure1) -}
8ac96762e37878d0e1e97253bf51691d
  $tc'ModuleProcedure1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bd5414a3c1a44810ec1dc77b69f89e1e
  $tc'ModuleProcedure2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'ModuleProcedure3) -}
3ce3fb36a63d8d4dbf2ff346647921e4
  $tc'ModuleProcedure3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ModuleProcedure"#) -}
b19f568d9d4b55f81a499f0cd6bda338
  $tc'Mul :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1604084189353523990##
                   6314300852568386006##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Mul1
                   1#
                   Language.Fortran.$tc'And1) -}
7273e56bec400398a2fffde4e7c60aa6
  $tc'Mul1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Mul2) -}
196a726f2c17ebca654f5a7eb18b2883
  $tc'Mul2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Mul"#) -}
6483e4b38baa65f90de4aff5357c40ea
  $tc'NML :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14149288561735842216##
                   16277763375272802129##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NML1
                   1#
                   Language.Fortran.$tc'Access1) -}
986164b8860fc17c3f8f6de5e32a22d0
  $tc'NML1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NML2) -}
e4c63f4fa1a6a90c182ff4f6f761eb49
  $tc'NML2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NML"#) -}
2b3beb89b0091f31034ed634142656a4
  $tc'Name :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16941688065325332716##
                   7591364498525849440##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Name1
                   1#
                   Language.Fortran.$tc'Access1) -}
7a78f908d1b3b9c73031427b2ac853fe
  $tc'Name1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Name2) -}
ad4adb205feaaea2174f2f12fa75c10d
  $tc'Name2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Name"#) -}
543fa490f25d3c70239c69bcbd3f8ff6
  $tc'Named :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5027965702284558882##
                   1567369439900841045##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Named1
                   1#
                   Language.Fortran.$tc'Access1) -}
853c01163ea57322522c41adee00699e
  $tc'Named1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Named2) -}
9c9be1bdd484be7727afee0f8063237b
  $tc'Named2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Named"#) -}
ee7717bc6420ca3a3cdf5276759b34ce
  $tc'Namelist :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15587514960633116291##
                   14663139255754444017##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Namelist2
                   1#
                   Language.Fortran.$tc'Namelist1) -}
2ffdb6b7c450839e53696fb7c114893a
  $tc'Namelist1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4b091d1f3d1407d967c5b4e451ae891b
  $tc'Namelist2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Namelist3) -}
a7a58ea68e4f3d8c3b1d920ea20155ea
  $tc'Namelist3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Namelist"#) -}
bc677ed0de8b8ed35257f5f3908947db
  $tc'NextRec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6637271412422171129##
                   11116712532130635997##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NextRec1
                   1#
                   Language.Fortran.$tc'Access1) -}
37b8c66a5ca44eee4953d4af84bbea93
  $tc'NextRec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NextRec2) -}
efb54ff9285a02a3a503bc60f543c6c7
  $tc'NextRec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NextRec"#) -}
b275a65067cd1590551d0aa049760c51
  $tc'NoSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11091090812026241629##
                   6309970865359684783##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NoSpec1
                   1#
                   Language.Fortran.$tc'Access1) -}
c27c06f888b90351bff463d6b492b2ef
  $tc'NoSpec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NoSpec2) -}
34541a5d672c018377606c6b6f8b87c8
  $tc'NoSpec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NoSpec"#) -}
958c25825c9bf74aae884838d640c89a
  $tc'Not :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5012835299273218130##
                   628934986157653059##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Not2
                   1#
                   Language.Fortran.$tc'Not1) -}
4387eb669db134954b8d2db0eee0b9b3
  $tc'Not1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f6c1458483c2ef63e9e44549be06b223
  $tc'Not2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Not3) -}
49b5b284d21ea148bff5e9a2be859db5
  $tc'Not3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Not"#) -}
30de89440c221f27e99b0733d6c6c3f9
  $tc'Null :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12584008651876121002##
                   9810307502437142462##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Null2
                   1#
                   Language.Fortran.$tc'Null1) -}
427c775cac849a4eeb3acbfcd7651713
  $tc'Null1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7ae5930638b053d9b0bdb3ef356a334c
  $tc'Null2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Null3) -}
942aff36c728612c2c8d91fe95563dc6
  $tc'Null3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Null"#) -}
4d39194939017a9e3f580b03cfb2b20d
  $tc'NullArg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14128827172302513584##
                   14105522532944572356##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullArg2
                   1#
                   Language.Fortran.$tc'NullArg1) -}
c39972bae8c5d254220f817b77d89122
  $tc'NullArg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c8f014573646c25b325bb6f60188b12e
  $tc'NullArg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullArg3) -}
3e455135ed1f3e12c699f4631ac4f7cc
  $tc'NullArg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullArg"#) -}
00bf87e99a072c26176426a79a001b48
  $tc'NullDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12233696636613300972##
                   5591676959168544425##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullDecl2
                   1#
                   Language.Fortran.$tc'NullDecl1) -}
702e80591b4f1f69443e38c05c6ccdec
  $tc'NullDecl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
38676c56ddc097677573665a08114780
  $tc'NullDecl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullDecl3) -}
e025cdacdef951c420f89d6faf23e49f
  $tc'NullDecl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullDecl"#) -}
422b8babafda35e6bf485bbfd2a0b0b1
  $tc'NullExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1013366119595756095##
                   14029813384869955077##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullExpr1
                   1#
                   Language.Fortran.$tc'Null1) -}
8e6152985d4f904b9e4bb6ef103b634a
  $tc'NullExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullExpr2) -}
16c39b63214b3b00a5ff1e8d89128f49
  $tc'NullExpr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullExpr"#) -}
96c2b3e08ae932732b4fcb12ec88afa1
  $tc'NullFraction :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11783184407874556768##
                   10052832917871545555##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullFraction2
                   1#
                   Language.Fortran.$tc'NullFraction1) -}
405b951ec77acdffc10ff42446c86718
  $tc'NullFraction1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a29da79aa61cd264771baa9b4ccf8cd5
  $tc'NullFraction2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'NullFraction3) -}
d67e91ba29d166d97fa97f213cbb7c29
  $tc'NullFraction3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullFraction"#) -}
e19eafe8cac54bb32adfe72b92c1ccc8
  $tc'NullProg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16177345346052273213##
                   12712456954795274821##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullProg2
                   1#
                   Language.Fortran.$tc'NullProg1) -}
6c7448f9732fe3b00b67bb137476614a
  $tc'NullProg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e54cd906321cbe223d2a41898e11aec5
  $tc'NullProg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullProg3) -}
c4c388a45994ebbdd36588570ea8e1b7
  $tc'NullProg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullProg"#) -}
0e2ae1346d398f188636038c32b756a3
  $tc'NullStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6076696353332396427##
                   14177705827663390549##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullStmt1
                   1#
                   Language.Fortran.$tc'Continue1) -}
6045331bdb4f065d5b50eac64aeccaff
  $tc'NullStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullStmt2) -}
e3bcfc0eb70afb5c01a22ad1eb5f4f6b
  $tc'NullStmt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullStmt"#) -}
2558c5ebd461e076e9858b434466910d
  $tc'NullSubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4086295267028822060##
                   11861506226124248378##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'NullSubName2
                   1#
                   Language.Fortran.$tc'NullSubName1) -}
96402bc424a934b9e1e2cf1b0b4e536a
  $tc'NullSubName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
09b53e4ceafc053a0f6c7a96ba68a51e
  $tc'NullSubName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'NullSubName3) -}
682b22370bc3e4c80ba5fde4c56d4691
  $tc'NullSubName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NullSubName"#) -}
af3280bc048c10bb39c96ee8ff7199c1
  $tc'Nullify :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14408422158345658572##
                   15138878099710459813##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Nullify2
                   1#
                   Language.Fortran.$tc'Nullify1) -}
7332051fe010dc4c89ad7eadc4195a63
  $tc'Nullify1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ea58cd45ae2f92946fcbb6e2c182f665
  $tc'Nullify2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Nullify3) -}
e442e05c90db6c30de37ef0a00dd32dd
  $tc'Nullify3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Nullify"#) -}
e8b685047d60e2101ddc18450b7d6cd0
  $tc'Number :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7750839953824045481##
                   3735293466966788468##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Number1
                   1#
                   Language.Fortran.$tc'Access1) -}
8b4315a216cd26ff3597db9b787e237f
  $tc'Number1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Number2) -}
de6fcba0178c8849f4d195993a86716f
  $tc'Number2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Number"#) -}
5c8a2ce7329b8b87b1cdcf93cb285667
  $tc'Open :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13115826238507675212##
                   484453627546988466##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Open1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
c730205ea4c981cdac2da29691a3860b
  $tc'Open1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Open2) -}
d1aba3507c530bf148ed6724c200472d
  $tc'Open2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Open"#) -}
0ea2286d5d4cfd3fe61129a1faf6c24c
  $tc'OpenCLBufferRead :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16307191047315588911##
                   8990972159856428306##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLBufferRead2
                   1#
                   Language.Fortran.$tc'OpenCLBufferRead1) -}
149c22c08c235f813307b0ef7decfafe
  $tc'OpenCLBufferRead1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ccf7773ab33ac4368f2fc9389d5b0145
  $tc'OpenCLBufferRead2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'OpenCLBufferRead3) -}
1190ee8b7afdae73fb03cd2990aee40b
  $tc'OpenCLBufferRead3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLBufferRead"#) -}
d20365699c26984780710f35de296924
  $tc'OpenCLBufferWrite :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12584919451346457597##
                   11035582010080639728##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLBufferWrite1
                   1#
                   Language.Fortran.$tc'OpenCLBufferRead1) -}
303268a7013e1129a120d418338e1321
  $tc'OpenCLBufferWrite1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'OpenCLBufferWrite2) -}
a1d4e2304b9b65d14edc8f60d1f74928
  $tc'OpenCLBufferWrite2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLBufferWrite"#) -}
fffba9c67805ca73ef916495effe7063
  $tc'OpenCLMap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3028371282460016599##
                   4080802768880584340##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLMap2
                   1#
                   Language.Fortran.$tc'OpenCLMap1) -}
5fdab8bbdf53c34657b4194c10efe8a3
  $tc'OpenCLMap1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cc7f3442ea1013358666938d998a0e51
  $tc'OpenCLMap2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'OpenCLMap3) -}
aa096c0920165adf37fac00585ef11bb
  $tc'OpenCLMap3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLMap"#) -}
ac541dde0cfcc06493f017e637ee6a22
  $tc'OpenCLReduce :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12147065404118019660##
                   14074768612682980266##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLReduce2
                   1#
                   Language.Fortran.$tc'OpenCLReduce1) -}
015d14c8b4be86a78bdfc0e8403075bd
  $tc'OpenCLReduce1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
adf00ac73ed25688a15a72fba4363895
  $tc'OpenCLReduce2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'OpenCLReduce3) -}
a842a7611ddbc962fda6b581b761d0c2
  $tc'OpenCLReduce3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLReduce"#) -}
2d1679f69a5cf2f3fef98a01c1fdb2b8
  $tc'OpenCLSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2423641511523786920##
                   14692612736443916063##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'OpenCLSeq2
                   1#
                   Language.Fortran.$tc'OpenCLSeq1) -}
8e100eeaacb972f32d0f4feef84516db
  $tc'OpenCLSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5eea4ca53d274b891b58c9b3edbd2453
  $tc'OpenCLSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'OpenCLSeq3) -}
3d63f755c772b029d858b9c60da68602
  $tc'OpenCLSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OpenCLSeq"#) -}
70ac85fbf256d77c1be04a440a192e54
  $tc'Opened :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1259791986946022674##
                   4752075114864638276##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Opened1
                   1#
                   Language.Fortran.$tc'Access1) -}
a2f6b6270172e0841ccdf4282551340a
  $tc'Opened1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Opened2) -}
2a236e7f125fa0a1eab89d81e673c375
  $tc'Opened2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Opened"#) -}
7f3f2e2dac232d649850dd3e13ff504e
  $tc'Optional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9334510655496892003##
                   14386517156037798073##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Optional1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
8ac890267e716f3f2b822cd63b6ad3b1
  $tc'Optional1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Optional2) -}
b8ae213f772653429ac204ea693f76ce
  $tc'Optional2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Optional"#) -}
0c83a427443706a31d0df5db84fc1cdb
  $tc'Or :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17264363623045031516##
                   3274180718445983006##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Or1
                   1#
                   Language.Fortran.$tc'And1) -}
d8bc81fbcb71254a7688a35c53b0756d
  $tc'Or1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Or2) -}
b041d2ba80ea7b2a9fc3fb28c39168c0
  $tc'Or2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Or"#) -}
9a532d1c6d2ad46dfdd5d7a2e991f430
  $tc'Out :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6784894835719821850##
                   2288333408185699159##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Out1
                   1#
                   Language.Fortran.$tc'In1) -}
216906e541110c87c69643229a5ee91c
  $tc'Out1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Out2) -}
5c75b62ea920ef6138237eb78235d4de
  $tc'Out2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Out"#) -}
119162e127d9abe251218019bf4b57fa
  $tc'PSeq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7264208580464888738##
                   4035155608771154062##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'PSeq2
                   1#
                   Language.Fortran.$tc'PSeq1) -}
1e43a160ad8cd098fec55f26d664adce
  $tc'PSeq1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c631b2d3b56faf93a8d7a7fc26cf3683
  $tc'PSeq2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'PSeq3) -}
b82596ee775242534a1fc6e270617f87
  $tc'PSeq3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PSeq"#) -}
a91b329190088992d813dff423fd0a0e
  $tc'Pad :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13603954777321505598##
                   14393068035085586637##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pad1
                   1#
                   Language.Fortran.$tc'Access1) -}
247570268e9a0c9764abebc4037ed877
  $tc'Pad1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pad2) -}
ab3ea5b80463e50cd118df80df3aa95c
  $tc'Pad2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pad"#) -}
7887007427ffd5c306170acbb5564ece
  $tc'Parameter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12872736425951526362##
                   938458754570511786##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Parameter1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
4eda254c5d5ed0fc2197a6512f302390
  $tc'Parameter1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Parameter2) -}
066c0371a19f9e0fc6ea3755a667efbf
  $tc'Parameter2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Parameter"#) -}
ad3e298b29b76cab6b146e92dc7d6e44
  $tc'Pause :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10739053694374974608##
                   18428484287552972596##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pause1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
54cd9f9f49429adbb420032d81a267f4
  $tc'Pause1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pause2) -}
8d5d1fea0736fa9caaf9231e084e635b
  $tc'Pause2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pause"#) -}
0256230b51bea02c760a4c713f41b374
  $tc'Plus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6091037181039752020##
                   7080791487337046783##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Plus1
                   1#
                   Language.Fortran.$tc'And1) -}
2d77f4f6b9d6458031d8f111d21270fa
  $tc'Plus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Plus2) -}
8416ecf200272236e0aa85afaa620386
  $tc'Plus2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Plus"#) -}
c4ad5ab7350c9a587e73ef8f25ed3340
  $tc'Pointer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2350572425553561717##
                   4886777469664639676##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pointer1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
b9d7947d12067c2e4655a247b436b4e0
  $tc'Pointer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pointer2) -}
ff8e093a22817c79145158cbef3b2e21
  $tc'Pointer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pointer"#) -}
b3a54382755a1ca21ec091f65ce6f5a3
  $tc'PointerAssg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8302361928470574936##
                   6774501750955301225##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'PointerAssg1
                   1#
                   Language.Fortran.$tc'Allocate1) -}
01b68eb32b1cf4f07f03d1d2429792cc
  $tc'PointerAssg1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'PointerAssg2) -}
4a170ed4d214ae5bc9a671b56e481243
  $tc'PointerAssg2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PointerAssg"#) -}
80b52b6fea866ac383dd70e1eee9b560
  $tc'Position :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13143565998391238736##
                   16744699831472643594##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Position1
                   1#
                   Language.Fortran.$tc'Access1) -}
7ded98a886d547e32ae0a5ae3833364c
  $tc'Position1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Position2) -}
f2c70ad55f30b583caff36c0d34b0dd3
  $tc'Position2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Position"#) -}
8c2486590e1c9eec9b882b54f2d56daf
  $tc'Power :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17286251170241447750##
                   17533889753441842691##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Power1
                   1#
                   Language.Fortran.$tc'And1) -}
5fb05e20337f691047aa26271b1a58e7
  $tc'Power1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Power2) -}
48b050fa89db03b99666fd04d0d00814
  $tc'Power2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Power"#) -}
68929f645c32c0707e8c0075f9b4e603
  $tc'Print :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3435900230475397083##
                   10251277560466040887##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Print2
                   1#
                   Language.Fortran.$tc'Print1) -}
e88b9abe989839a0cd37663d2818039c
  $tc'Print1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f55f40c5bf2f6a19d22487e7539e7c29
  $tc'Print2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Print3) -}
d74ee892cd9ab96d1e5c3363c7a8f93e
  $tc'Print3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Print"#) -}
a8ca11443b75537ad99dd9ced2dc8ad8
  $tc'Private :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   476970771812613667##
                   3477877022946281424##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Private1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
2aac380a5d3994a06396c048efccf00d
  $tc'Private1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Private2) -}
9ca7299733258f2c5bc1be54374af546
  $tc'Private2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Private"#) -}
c3e71233e4dd2d0a07004ac61f871dac
  $tc'Prog :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13414727599511975571##
                   2490781389013250743##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Prog2
                   1#
                   Language.Fortran.$tc'Prog1) -}
7dd39c624a6612a062bebd2eb9744c84
  $tc'Prog1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
264a1c0e0b94bad166373d77730dbc6b
  $tc'Prog2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Prog3) -}
31852475488bb27ba9ecf2056beb4b9a
  $tc'Prog3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Prog"#) -}
d9a1531c818aacb829ed0b68f7d9a9d0
  $tc'Public :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   283070934594542835##
                   2759337629581925047##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Public1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
60b944ec396f4661d243b46a4dc0b655
  $tc'Public1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Public2) -}
4435bbbe53fd6bda6e60ec5dc10bd1fe
  $tc'Public2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Public"#) -}
778a96e52326db95f9cbdd89be22b9b7
  $tc'Pure :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11478188573053641614##
                   1347980050942663290##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Pure1
                   1#
                   Language.Fortran.$tc'Character1) -}
927adb0d843c807f5a608a0e400e02a3
  $tc'Pure1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Pure2) -}
80e938643bfc0afb5ab0683a30d93352
  $tc'Pure2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pure"#) -}
493cf2f26b9832d3bc0aed11bbf4c42b
  $tc'Read :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11220116211045246692##
                   14997802619941190211##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Read1
                   1#
                   Language.Fortran.$tc'Access1) -}
7f02da757d4fed72554591702448f60e
  $tc'Read1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Read2) -}
6cf568d10ca64a1fe49f45df63759ea3
  $tc'Read2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Read"#) -}
97ee7a96e1e8107a9bc615b2db87c6c8
  $tc'ReadS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7431601550230302229##
                   3762756739691116927##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ReadS1
                   1#
                   Language.Fortran.$tc'Inquire1) -}
20a618cf1edad94182a3d61fec0b4925
  $tc'ReadS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ReadS2) -}
d0c7186a5430263e3757df72f84bcb4d
  $tc'ReadS2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ReadS"#) -}
3ded2a952a16a26090c52e1bfa11e0d8
  $tc'ReadWrite :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1229958044878398526##
                   1992907525976947322##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'ReadWrite1
                   1#
                   Language.Fortran.$tc'Access1) -}
ab47447b45892225a9a331f5a3d675e6
  $tc'ReadWrite1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'ReadWrite2) -}
7975cd215260795ecaa74d65cdeb3a48
  $tc'ReadWrite2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ReadWrite"#) -}
73238b91cd52296f4f6235775d71e571
  $tc'Real :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6553180535192103125##
                   3919596033237241349##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Real1
                   1#
                   Language.Fortran.$tc'Character1) -}
3c1575aba0bfefc6c4584ba6243d2012
  $tc'Real1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Real2) -}
4cb8f6c95c69b478d322ea75d40ce947
  $tc'Real2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Real"#) -}
9cc16c53c08ce0ebf552e5e23e1eda0c
  $tc'Rec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13430403128732172965##
                   14501972841695522325##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Rec1
                   1#
                   Language.Fortran.$tc'Access1) -}
c01b3bdd812fda65b10001f1f6571e09
  $tc'Rec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Rec2) -}
632c3d851683bc44f46564170d62b404
  $tc'Rec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rec"#) -}
9e407c90a106cabf43e64a7caced50fa
  $tc'Recl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12563344638604706200##
                   4158351686733703482##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Recl1
                   1#
                   Language.Fortran.$tc'Access1) -}
64df7cf89bbe7f4c75c89c5adee29019
  $tc'Recl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Recl2) -}
8f679b3dc3ac899eb02d32db5eaa79d7
  $tc'Recl2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Recl"#) -}
96f8a1aa441bddc968903e672316b144
  $tc'Recursive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9147255043954089214##
                   7133011160274633035##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Recursive1
                   1#
                   Language.Fortran.$tc'Character1) -}
1118bf05f1e5be4760ffc4e638250143
  $tc'Recursive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Recursive2) -}
d18e83a52b8407c239d840d1a0f91afb
  $tc'Recursive2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Recursive"#) -}
9cd7a34e8fd03a482dcf5c5c16a41628
  $tc'RelEQ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3306774432348124051##
                   11933483786022589141##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelEQ1
                   1#
                   Language.Fortran.$tc'And1) -}
bb0cc540b3bb752316f0c46e65c12fbc
  $tc'RelEQ1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelEQ2) -}
555e80a4ac3aff277dbabdce256555ff
  $tc'RelEQ2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelEQ"#) -}
5c54fe26d3f514c21d8a15c69f9a8c94
  $tc'RelGE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9015198730694035628##
                   18268326180816110286##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelGE1
                   1#
                   Language.Fortran.$tc'And1) -}
5b8f4eff91bfd827db643ff4e4096fb8
  $tc'RelGE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelGE2) -}
03affb2c3dec9dc6e0dd018cc51e4d61
  $tc'RelGE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelGE"#) -}
80ba642a82457a1d7ca2082dc4285d60
  $tc'RelGT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   183426322015600330##
                   3916227032729468794##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelGT1
                   1#
                   Language.Fortran.$tc'And1) -}
c4a235f7bb9521b078ba417c22be847e
  $tc'RelGT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelGT2) -}
c1d63ad4cbd98d6109390d4bcf0a1db1
  $tc'RelGT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelGT"#) -}
3c0e7928909476f7f470fbcfb51c7687
  $tc'RelLE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4244439592810013729##
                   16699317271089129585##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelLE1
                   1#
                   Language.Fortran.$tc'And1) -}
012ab90583fcc66635a09f67fa517511
  $tc'RelLE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelLE2) -}
35f804cf6d50956ee6a555ad2f1cd005
  $tc'RelLE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelLE"#) -}
85439dac462e0367beb1dd6b13fb736e
  $tc'RelLT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15519015794911916484##
                   13050906341591761751##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelLT1
                   1#
                   Language.Fortran.$tc'And1) -}
5ff4e4367a7a0d149bb1fe9a20c59d6e
  $tc'RelLT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelLT2) -}
a51249373927861521cc15d96ea9a7de
  $tc'RelLT2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelLT"#) -}
2a65872ad489bdac293c35476f146d35
  $tc'RelNE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17216739235166247217##
                   15298707468365252358##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'RelNE1
                   1#
                   Language.Fortran.$tc'And1) -}
74f771d5a40d2d103dc50a62a39ad4f4
  $tc'RelNE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'RelNE2) -}
65ee8aba048820b1c5f527536187d594
  $tc'RelNE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'RelNE"#) -}
802059e904cda21efe8c2f5105afc4e4
  $tc'Return :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17680925171929660800##
                   7442341734549975477##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Return2
                   1#
                   Language.Fortran.$tc'Return1) -}
2a419ca3d4eab626903e6368ed049ed8
  $tc'Return1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7252741ba2207bf6756d5c4a8cbd7a1b
  $tc'Return2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Return3) -}
284dc2b220cf2ba3e57ca075ed0e69cd
  $tc'Return3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Return"#) -}
85a06cb4a135b742dcf27c100a715c08
  $tc'Rewind :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13131244236266164210##
                   8075945569552493290##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Rewind1
                   1#
                   Language.Fortran.$tc'Backspace1) -}
e91152c96378ccbbecd7b9a5049942a1
  $tc'Rewind1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Rewind2) -}
43501fe7bd95a59e7ec59f8a27778221
  $tc'Rewind2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Rewind"#) -}
79351ae921d580aa196c07ab310dcf5e
  $tc'Save :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14943898813889276610##
                   2438191608245991834##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Save1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
740b3eb306a97b2c75b1641474acf62d
  $tc'Save1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Save2) -}
9f1f0f89f4a3bed03d71ad18350e291f
  $tc'Save2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Save"#) -}
ffaf69dfc652f665c93d28f22cf7bc7c
  $tc'SelectStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17232153766253382506##
                   12235901004562535888##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SelectStmt2
                   1#
                   Language.Fortran.$tc'SelectStmt1) -}
8bc03f3431d7cb44c786c8df069d9f04
  $tc'SelectStmt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2784813c69ee446932fc1a6dee122fe2
  $tc'SelectStmt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SelectStmt3) -}
506f317d200d75c44ebe6ceb5db8ff33
  $tc'SelectStmt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SelectStmt"#) -}
900ecf2f1bfe276e94f9f95d53a92270
  $tc'Sequence :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6903572141088170868##
                   7081403553694459672##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sequence1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
d3bf827d8695fca7347ed4a44d48b8a2
  $tc'Sequence1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sequence2) -}
de41fb8af40bf41c137f1578aa9d499c
  $tc'Sequence2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sequence"#) -}
9bdd5f878677b0d73e4306c3cf55e98e
  $tc'Sequential :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1698519331831130588##
                   2840113553467912532##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sequential1
                   1#
                   Language.Fortran.$tc'Access1) -}
147c61104f566270367aeede6f51fbc5
  $tc'Sequential1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sequential2) -}
c686be796d411e9f45c6b66e9c01efd0
  $tc'Sequential2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sequential"#) -}
5c7488cc355202199b8a272945e0923c
  $tc'Size :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   898337637732606896##
                   7890175630718525476##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Size1
                   1#
                   Language.Fortran.$tc'Access1) -}
2f0595bbe07f68a38fc4847a1cead3b2
  $tc'Size1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Size2) -}
99f9dc869820bc49da4bc3c719e607f3
  $tc'Size2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Size"#) -}
2018957d49dd632e32c7a69456b1dedf
  $tc'SomeType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13845186837248049630##
                   7314889756440845134##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SomeType1
                   1#
                   Language.Fortran.$tc'Character1) -}
6883751d77e6fd85f6eaac635d69880f
  $tc'SomeType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SomeType2) -}
3793be9757a8dbf3553d3a9bffc3bcf3
  $tc'SomeType2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SomeType"#) -}
f6989256a4a8082eb2ff5933132e2c3f
  $tc'Sqrt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16976588821235028232##
                   2169408212367369305##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sqrt2
                   1#
                   Language.Fortran.$tc'Sqrt1) -}
cecdd1d0c64ac030981c120ba23874a6
  $tc'Sqrt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ea27780b3a5f7d5675b0f023039810a0
  $tc'Sqrt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sqrt3) -}
04cbae148585be35ecc416546334cbf1
  $tc'Sqrt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sqrt"#) -}
d204322db52842e6c810c858c871a333
  $tc'SrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13646493499320172866##
                   14516675898588777123##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SrcLoc2
                   0#
                   Language.Fortran.$tc'SrcLoc1) -}
22a093b5c75a6bda42f31c25ef5f6157
  $tc'SrcLoc1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5ada762b46b60b837f796a33bc81f724
  $tc'SrcLoc2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SrcLoc3) -}
b6e5f3178c3fa96399730e74d9d5d19c
  $tc'SrcLoc3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SrcLoc"#) -}
3564d617978961939d85c7f397e4a87b
  $tc'Status :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14080722925012281991##
                   5813510752136124692##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Status1
                   1#
                   Language.Fortran.$tc'Access1) -}
6593c3cb75c059cf4e6fb19e221f6fb7
  $tc'Status1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Status2) -}
0fd17d6a4e4f863b494a382938ee6c22
  $tc'Status2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Status"#) -}
935d90a622151a6d474c2965ef7c553c
  $tc'Stop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2665557732804519696##
                   13988074094904552144##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Stop1
                   1#
                   Language.Fortran.$tc'Return1) -}
f6f6737c40405e58e57153e32f16614f
  $tc'Stop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Stop2) -}
70dfe2190695a1e21e94bb41f4ac8bcb
  $tc'Stop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Stop"#) -}
04187b7bfe1ef226d9b010638a8fb003
  $tc'StringLit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13110966043260369138##
                   14789900026662296554##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'StringLit2
                   1#
                   Language.Fortran.$tc'StringLit1) -}
3be918e7690bbd713ba1c4e596b0380e
  $tc'StringLit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
dbd9fff936af7a9c30b209145dc30298
  $tc'StringLit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'StringLit3) -}
a2ec82edc3242d34d406d0a5e2dbcba6
  $tc'StringLit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringLit"#) -}
31aad262f03f22f4bec16adc149de9fa
  $tc'Sub :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1040525182721208575##
                   4000226672628969455##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Sub2
                   1#
                   Language.Fortran.$tc'Sub1) -}
05c356879547a1407fd88a518d41b0c4
  $tc'Sub1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
07214e21e965c21c1d2655c7466b5605
  $tc'Sub2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Sub3) -}
923cccc426696c6280290ecb59f5c643
  $tc'Sub3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sub"#) -}
811c8405c5b770c540cc24a9654f5307
  $tc'SubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6970661941236483264##
                   14244565985904516532##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SubName2
                   1#
                   Language.Fortran.$tc'SubName1) -}
d88bbbedd8899dcdd5e34f751aade9f1
  $tc'SubName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
650c8f1bccc58a6451264f62d280243a
  $tc'SubName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'SubName3) -}
1685bcba00ee2aa3243524db00b8c39a
  $tc'SubName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SubName"#) -}
8d5607c7e53fe5fbf1b9a8e2d0868f85
  $tc'SubroutineInterface :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2877932453960043361##
                   3045133722170392484##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'SubroutineInterface1
                   1#
                   Language.Fortran.$tc'FunctionInterface1) -}
7a3605030076a97ff34699fa2f8cb4e7
  $tc'SubroutineInterface1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'SubroutineInterface2) -}
ed7be6100f41fa63e41a500915eefc29
  $tc'SubroutineInterface2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SubroutineInterface"#) -}
e17b7d70327515c0781c1c96257066ec
  $tc'Target :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3233817694055365344##
                   17606372669834513348##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Target1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
12ae78255d661df98c67ac92d21ad1ae
  $tc'Target1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Target2) -}
042a4281bd851dd63d7eaf45b32225d8
  $tc'Target2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Target"#) -}
56cb2647dfef7e8b037e568d2f7fa471
  $tc'TextDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   225303041055072127##
                   7057154689389632273##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'TextDecl2
                   1#
                   Language.Fortran.$tc'TextDecl1) -}
62ae1163545374d152ab6f81852c26a6
  $tc'TextDecl1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4c890854c8d1aef31b6dbd151888948c
  $tc'TextDecl2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'TextDecl3) -}
1a118e5f2a517da5f2f665875455db36
  $tc'TextDecl3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TextDecl"#) -}
26734126fe30521cba07597a34550510
  $tc'TextStmt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5872186602561212460##
                   805091587728933147##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'TextStmt1
                   1#
                   Language.Fortran.$tc'Cycle1) -}
3e806b5529e6457aaa6904d0e9055711
  $tc'TextStmt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'TextStmt2) -}
291670c3b6ff40eebab7a14df856ec47
  $tc'TextStmt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TextStmt"#) -}
cf11f747b63a5f9e71f0c8e3055a1d2c
  $tc'UMinus :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16869713655253378572##
                   18012037925958036818##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UMinus1
                   1#
                   Language.Fortran.$tc'Not1) -}
b0538dfcef9f70fa7d02b9c366bd511a
  $tc'UMinus1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UMinus2) -}
396c13c3f1ba597d3d515391f642fe98
  $tc'UMinus2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UMinus"#) -}
ef07a4b9815d7643c4612ce49eaf9876
  $tc'Unary :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14538236728104637145##
                   8070402866064843935##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unary2
                   1#
                   Language.Fortran.$tc'Unary1) -}
c63dae2f4937281dfe099d3b6d58bf50
  $tc'Unary1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
71f2a01836d6c6a47cc1069bde9c9126
  $tc'Unary2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Unary3) -}
3da5d36aab300ce490b0ab77b5e0194d
  $tc'Unary3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unary"#) -}
6c7d9cca7d5510e688fac340df1ca59b
  $tc'Unformatted :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11017106772727090515##
                   8704249682361690395##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unformatted1
                   1#
                   Language.Fortran.$tc'Access1) -}
1ed3a1bb2c8326ca93a3e3e7b8b7f9c8
  $tc'Unformatted1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Unformatted2) -}
aeedf23c1371bc2be727efb917582eb6
  $tc'Unformatted2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unformatted"#) -}
a3374c261376ef0f0d26c6e75d4f3d2a
  $tc'Unit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17047340235762662186##
                   5940602945340876479##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Unit1
                   1#
                   Language.Fortran.$tc'Access1) -}
1144dd8c75df73742b56933d1886d3e7
  $tc'Unit1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Unit2) -}
f7f38480d02cddb15c9c8d11ea490fe5
  $tc'Unit2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Unit"#) -}
3b46ba0c540764d91376300c09965f98
  $tc'UnitNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5508473149827023495##
                   6147691687601015496##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitNone2
                   1#
                   Language.Fortran.$tc'UnitNone1) -}
a4c8c522b120bd07b55b00d4a7c811ed
  $tc'UnitNone1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
22b4f81da506ec294f2a4dd2f109ddfa
  $tc'UnitNone2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UnitNone3) -}
1b388d76d24064590fe79edce5373bbd
  $tc'UnitNone3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnitNone"#) -}
e967398578061c1f67b2aed3c7e3b029
  $tc'UnitProduct :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16740586458989445618##
                   2878721760467620232##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitProduct2
                   1#
                   Language.Fortran.$tc'UnitProduct1) -}
b94067e06fb96155a25c1888e4b101fa
  $tc'UnitProduct1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e81c76c90378c08942ef0f63bfbe3f00
  $tc'UnitProduct2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UnitProduct3) -}
4c282f74c8f86148a3c1a6ba418e93c3
  $tc'UnitProduct3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnitProduct"#) -}
4ba337ba96d6092a589bfc79d7a6ccb7
  $tc'UnitQuotient :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12946555355991503495##
                   15216643449032007037##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UnitQuotient2
                   1#
                   Language.Fortran.$tc'UnitQuotient1) -}
0a584ea62816a23c8d72fbce0edcb679
  $tc'UnitQuotient1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
28dc978d8405c3e2dabeb019f47bb5fc
  $tc'UnitQuotient2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Language.Fortran.$tc'UnitQuotient3) -}
97dc5662d9c84148c2db2b58b56d345b
  $tc'UnitQuotient3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnitQuotient"#) -}
c46bb3270d45cef2b26306b4d02bc0c7
  $tc'Use :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12749555581649234559##
                   2245992778548851646##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Use2
                   1#
                   Language.Fortran.$tc'Use1) -}
57ec29f56efc147bce4c0f237e34f530
  $tc'Use1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bd4ba1b40d72894c2b91785e018d80d2
  $tc'Use2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Use3) -}
3235490f8f593f202ce1ccbfc159408b
  $tc'Use3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Use"#) -}
1e0ca8429c54dfdc2cab4808268b8f97
  $tc'UseBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4696538290811973981##
                   17729436968481782573##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UseBlock2
                   1#
                   Language.Fortran.$tc'UseBlock1) -}
cc8a8bf1118a2f30fe500bb07bc3c7df
  $tc'UseBlock1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b1c9b55ea123f30e0fd0063a74186e46
  $tc'UseBlock2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UseBlock3) -}
f50dffc6d98548981080981e7f558268
  $tc'UseBlock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UseBlock"#) -}
f49e4e017f2d986c070f0509a309e761
  $tc'UseNil :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5429280477803661774##
                   5067155543058970441##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'UseNil2
                   1#
                   Language.Fortran.$tc'UseNil1) -}
bb30884da1494995caedbfa0c91c1aa7
  $tc'UseNil1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
eea68542157b296f098172edbb75a47a
  $tc'UseNil2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'UseNil3) -}
8de73737f97dc0835db86faf3c2ea5d1
  $tc'UseNil3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UseNil"#) -}
206897d35ade1118ea3edc20a38de476
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7273875983454349078##
                   18010754426962006426##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Var2
                   1#
                   Language.Fortran.$tc'Var1) -}
829211503dbb45c862d57e513d9349f5
  $tc'Var1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5c2827de6ccf6b693c76031edd3dce4b
  $tc'Var2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Var3) -}
47b5a4f7150754b7da7f03ae8a00b748
  $tc'Var3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Var"#) -}
d2941c46913192bda8373ebd0e2e4c31
  $tc'VarName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   584592108131573754##
                   15217694802029551390##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'VarName2
                   1#
                   Language.Fortran.$tc'VarName1) -}
1ecb73c31e72cbee9abde2ebf7e35900
  $tc'VarName1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
658ac1276bb469eada1c71a888386f82
  $tc'VarName2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'VarName3) -}
8c6f0230e05baf749635ebf2275e1a0e
  $tc'VarName3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'VarName"#) -}
a9a1ae49711f86dcf2dfa364225febb0
  $tc'Volatile :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1225265513603592728##
                   7826133619320814960##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Volatile1
                   1#
                   Language.Fortran.$tc'Allocatable1) -}
611cf34079ed87a3b0d195ce2907736e
  $tc'Volatile1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Volatile2) -}
7148ae0e69f78b06e829d31758eaa57c
  $tc'Volatile2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Volatile"#) -}
1b4b7406b53b68a1bafb4c2ab49edf8e
  $tc'Where :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18352313681399322630##
                   9514959011317546426##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Where2
                   1#
                   Language.Fortran.$tc'Where1) -}
8aa4bf737f91db4ba2e1841183893ef5
  $tc'Where1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
af83eb0f7b15cdddce362e030c47b520
  $tc'Where2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Where3) -}
f2ab5e94a56a4070d544a652a5b27dc9
  $tc'Where3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Where"#) -}
47b9f77d5c3361daf69e4027534abb01
  $tc'Write :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3181212907771029451##
                   15377423736781209722##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'Write1
                   1#
                   Language.Fortran.$tc'Inquire1) -}
a2305b14e7284f3061e70dead20ce157
  $tc'Write1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'Write2) -}
5e4c5bae5632d0dad887fd0c3c5edf93
  $tc'Write2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Write"#) -}
a379592a6abf313993f94f49e291a809
  $tc'WriteSp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1455987176484308201##
                   6925656600492831980##
                   Language.Fortran.$trModule
                   Language.Fortran.$tc'WriteSp1
                   1#
                   Language.Fortran.$tc'Access1) -}
838033fa17bde6833cf4efb77553290a
  $tc'WriteSp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tc'WriteSp2) -}
3feb9a3b300f2d49186b6139d4ee9ded
  $tc'WriteSp2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'WriteSp"#) -}
9cd04711854627f9e73aebcd7ad098ca
  $tcArg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7309058987875376809##
                   1503966189454270724##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataArg9
                   0#
                   GHC.Types.krep$*Arr*) -}
ab2c0aae51125b14f1483dd89ae11b72
  $tcArgList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   845657611358255983##
                   10794179943399875088##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataArgList3
                   0#
                   GHC.Types.krep$*Arr*) -}
d64180de9a574c94f577eae0574e2090
  $tcArgName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7419102846508284450##
                   11885307910119951682##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataArgName3
                   0#
                   GHC.Types.krep$*Arr*) -}
0a4ca44fddfa273780d6fed429a47ceb
  $tcAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2601353720516361080##
                   16493321566561608833##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataAttr3
                   0#
                   GHC.Types.krep$*Arr*) -}
9760e22ff5018fb45ade9654edd9999f
  $tcBaseType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4083489423235278951##
                   5800539029512072333##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataBaseType3
                   0#
                   GHC.Types.krep$*Arr*) -}
cc3142652a45027b05d3330f8f328dff
  $tcBinOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9536987714771015796##
                   7738095616654473121##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataBinOp4
                   0#
                   GHC.Types.krep$*Arr*) -}
bda1ab84f33c04e1505e500191c1c156
  $tcBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11104329050160090963##
                   13952174415240849570##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataBlock3
                   0#
                   GHC.Types.krep$*Arr*) -}
7806a9f624787d7719b32c379f1f713f
  $tcDataForm :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17013794398423112470##
                   12144596980792875097##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataDataForm3
                   0#
                   GHC.Types.krep$*Arr*) -}
1368576d6fc54352673e23b7049f1df3
  $tcDecl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12291791744174836530##
                   8828337267165364954##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataDecl3
                   0#
                   GHC.Types.krep$*Arr*) -}
e23866c4503bd491cd967c3285c69ddb
  $tcExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   666290775928592730##
                   14296435139678708619##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataExpr3
                   0#
                   GHC.Types.krep$*Arr*) -}
cf44064163d9662ce942cd1e1bd692a0
  $tcFortran :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15050906489887366908##
                   8016429120508906433##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataFortran3
                   0#
                   GHC.Types.krep$*Arr*) -}
70c6571de1e1cb5578daf6bbe2575b2e
  $tcFraction :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1889852645677985436##
                   4948538213526819213##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataFraction4
                   0#
                   GHC.Types.krep$*Arr*) -}
2faa2f8a66626cd07541a9e46da25638
  $tcGSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13649749436298333063##
                   7524181639333628935##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataGSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
3a2e9ecf0a6179a6595b928550196bf8
  $tcImplicit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15842512687850667938##
                   2055696988134619338##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataImplicit6
                   0#
                   GHC.Types.krep$*Arr*) -}
13102f1ad622570dc89e1801cef5a357
  $tcIntentAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16567170138751583230##
                   1916717445546230762##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataIntentAttr4
                   0#
                   GHC.Types.krep$*Arr*) -}
583f8673b40b717e31a2e726361b6bb9
  $tcInterfaceSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4228692104607174657##
                   12410898481200544509##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataInterfaceSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
9bd44b3bfbd52669bfcaaf5c24fb901e
  $tcMeasureUnitSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10313695227442128830##
                   1030832953143637957##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataMeasureUnitSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
479a68e64b09664428989c23f92db073
  $tcProgUnit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11656072102918246678##
                   4306480789967343201##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataProgUnit3
                   0#
                   GHC.Types.krep$*Arr*) -}
2b47d563b3d63cc84ade72ec0b0113d5
  $tcSpan :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9944132828335676479##
                   12175036026866565947##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcSpan2
                   0#
                   Language.Fortran.$tcSpan1) -}
aeeecdf50c9a1de7d81ed5bad782ef86
  $tcSpan1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
251749a629c80c97460ac011d9696678
  $tcSpan2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tcSpan3) -}
52a0811950dce311996a7aac676da792
  $tcSpan3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Span"#) -}
5a32654d7e3fa3dc47fb595731ddf18a
  $tcSpec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13275808096239442906##
                   250083824345581740##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataSpec3
                   0#
                   GHC.Types.krep$*Arr*) -}
035f477127f21819f149b4a8ef0ea56b
  $tcSrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7192905692865965536##
                   6830086774534809197##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataSrcLoc8
                   0#
                   GHC.Types.krep$*) -}
7972b3a37e32583adbb465c33d177658
  $tcSubName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1348816486169742693##
                   5881755746003561474##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataSubName4
                   0#
                   GHC.Types.krep$*Arr*) -}
03bd0829e916ebb9e2eeec1acf4f9205
  $tcTagged :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13560472430031144602##
                   8594414849564800699##
                   Language.Fortran.$trModule
                   Language.Fortran.$tcTagged2
                   0#
                   Language.Fortran.$tcTagged1) -}
5deca82154d523ef4736ac0dcba4862b
  $tcTagged1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
855e1fad63461f84b101e024f0eea0eb
  $tcTagged2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$tcTagged3) -}
81e8582a46d266c8239b857c2b2b5ec6
  $tcTagged3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tagged"#) -}
dde4e4dc4c081cae529373b02a0e26ce
  $tcType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3614205270264252361##
                   2736214399804263991##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataType3
                   0#
                   GHC.Types.krep$*Arr*) -}
f9bdeedb18726724731b18f322f60bbf
  $tcUnaryOp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8773601993262595020##
                   17595838481592517464##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataUnaryOp6
                   0#
                   GHC.Types.krep$*Arr*) -}
3e20cf831bf745375b21bf0e144a52a0
  $tcUseBlock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   676775438516342762##
                   8165917680911675068##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataUseBlock3
                   0#
                   GHC.Types.krep$*Arr*) -}
4260c59d0b6d92a43b7cd7f5defab098
  $tcUses :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12614760649755741284##
                   7231590305637869228##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataUses3
                   0#
                   GHC.Types.krep$*Arr*) -}
db1d15d38432070f3a6fb78f859e82cb
  $tcVarName :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1814910915032611357##
                   15311627620831682170##
                   Language.Fortran.$trModule
                   Language.Fortran.$fDataVarName4
                   0#
                   GHC.Types.krep$*Arr*) -}
5bed100e3c0849e0bfcb4b12a958b3ed
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Language.Fortran.$trModule3
                   Language.Fortran.$trModule1) -}
856067a718444c72274b47c4f1c4840c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$trModule2) -}
84175d4e32a10910bc91f6b7a6a065bf
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Language.Fortran"#) -}
f28e2694dbc4938cd1ff5c119345f691
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Language.Fortran.$trModule4) -}
6851ab8b3d75194938a6b58789b2dd92
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("language-fortran-0.3-DnTmLOXLSgMntUzwJ6Kf9"#) -}
0784cc3fb6fe0a147752dfb6f906b42c
  $w$c< ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.True
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$c<1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.False }) -}
ea1b303f03292a62d4f14f025127a73d
  $w$c<= ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww2 ww of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww3 ww1 of wild1 {
                        DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.GT -> GHC.Types.True }) -}
8781c76814d3da0084efa615b252acc3
  $w$c== ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> GHC.Types.Bool
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))><L,U><L,1*U><L,1*U(1*U(1*U,1*U(U),1*U(U)),1*U(1*U,1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.ArgName p)
                   (ww2 :: Language.Fortran.SrcSpan)
                   (ww3 :: p)
                   (ww4 :: Language.Fortran.ArgName p)
                   (ww5 :: Language.Fortran.SrcSpan) ->
                 case GHC.Classes.== @ p w ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case Language.Fortran.$fEqArg_$c==2 @ p w ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww2 of ww6 { (,) ww7 ww8 ->
                           case ww5 of ww9 { (,) ww10 ww11 ->
                           case ww7 of ww12 { Language.Fortran.SrcLoc ww13 ww14 ww15 ->
                           case ww10 of ww16 { Language.Fortran.SrcLoc ww17 ww18 ww19 ->
                           case GHC.Base.eqString ww13 ww17 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case ww14 of wild3 { GHC.Types.I# x ->
                                case ww18 of wild4 { GHC.Types.I# y ->
                                case GHC.Prim.==# x y of lwild {
                                  DEFAULT -> GHC.Types.False
                                  1#
                                  -> case ww15 of wild5 { GHC.Types.I# x1 ->
                                     case ww19 of wild6 { GHC.Types.I# y1 ->
                                     case GHC.Prim.==# x1 y1 of lwild1 {
                                       DEFAULT -> GHC.Types.False
                                       1#
                                       -> Language.Fortran.$fEqArg_$c==1
                                            ww8
                                            ww11 } } } } } } } } } } } } }) -}
3bd8265d7db5a56446d5fbd2f372e2fa
  $w$c==1 ::
    GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U(U)><S,1*U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: GHC.Types.Int) ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.==# x y of lwild {
                        DEFAULT -> GHC.Types.False
                        1# -> GHC.Classes.eqInt ww2 ww5 } } } }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $w$c==2 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Expr p
    -> p
    -> Language.Fortran.Expr p
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Expr p)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Expr p) ->
                 case GHC.Classes.== @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> Language.Fortran.$fEqArgList_$c== @ p w ww1 ww3 }) -}
6b493b99f6444e62a4f7acf6ccad5a6e
  $w$c==3 ::
    GHC.Classes.Eq p =>
    Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U(1*U,1*U(U),1*U(U))><S,1*U><L,1*U(1*U,1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc)
                   (ww2 :: Language.Fortran.Uses p)
                   (ww3 :: Language.Fortran.SrcLoc) ->
                 case Language.Fortran.$fEqBlock_$c==4 @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> Language.Fortran.$fEqArg_$c==1 ww1 ww3 }) -}
8771af06d991b7707b552bad8e03741a
  $w$c==4 ::
    GHC.Classes.Eq p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Eq p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.== @ p w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Base.eqString ww1 ww3 }) -}
3c99adcd8c91623df68f1b37cb1856fd
  $w$c>= ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ
                   -> case GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3 of wild1 {
                        DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.GT -> GHC.Types.True }) -}
70c98b5a07a92e73bf3d4ab4a0cff580
  $w$ccompare ::
    GHC.Classes.Ord p =>
    p
    -> Language.Fortran.Variable
    -> p
    -> Language.Fortran.Variable
    -> GHC.Types.Ordering
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Classes.Ord p)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable)
                   (ww2 :: p)
                   (ww3 :: Language.Fortran.Variable) ->
                 case GHC.Classes.compare @ p w ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ -> GHC.Classes.$fOrd[]_$s$ccompare1 ww1 ww3
                   GHC.Types.GT -> GHC.Types.GT }) -}
5d55b2485fd718d78674934e1c1437fb
  $w$cgfoldl ::
    (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
    -> (forall g. g -> c g)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> c Language.Fortran.SrcLoc
  {- Arity: 5,
     Strictness: <C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ c :: * -> *
                   (w :: forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
                   (w362 :: forall g. g -> c g)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (w @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (w @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (w362
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)
                         ww)
                      ww1)
                   ww2) -}
5d55b2485fd718d78674934e1c1437fb
  $w$cgmapM ::
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> m Language.Fortran.SrcLoc
  {- Arity: 5,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ m :: * -> *
                   (w :: GHC.Base.Monad m)
                   (w362 :: forall d. Data.Data.Data d => d -> m d)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 let {
                   $sk :: forall b. m (GHC.Types.Int -> b) -> GHC.Types.Int -> m b
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ @ b
                       (c :: m (GHC.Types.Int -> b))
                       (x :: GHC.Types.Int)[OneShot] ->
                     let {
                       lvl295 :: m GHC.Types.Int
                       = w362 @ GHC.Types.Int Data.Data.$fDataInt x
                     } in
                     GHC.Base.>>=
                       @ m
                       w
                       @ (GHC.Types.Int -> b)
                       @ b
                       c
                       (\ (c' :: GHC.Types.Int -> b) ->
                        GHC.Base.>>=
                          @ m
                          w
                          @ GHC.Types.Int
                          @ b
                          lvl295
                          (\ (x' :: GHC.Types.Int) -> GHC.Base.return @ m w @ b (c' x')))
                 } in
                 $sk
                   @ Language.Fortran.SrcLoc
                   ($sk
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      (let {
                         lvl295 :: m GHC.Base.String
                         = w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww
                       } in
                       GHC.Base.>>=
                         @ m
                         w
                         @ (GHC.Base.String
                            -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         (GHC.Base.return
                            @ m
                            w
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)
                         (\ (c' :: GHC.Base.String
                                   -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc) ->
                          GHC.Base.>>=
                            @ m
                            w
                            @ GHC.Base.String
                            @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            lvl295
                            (\ (x' :: GHC.Base.String) ->
                             GHC.Base.return
                               @ m
                               w
                               @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                               (c' x'))))
                      ww1)
                   ww2) -}
8fc44fa42aa6f0f3254ca020bcf3cb0f
  $w$cgmapM1 ::
    Data.Data.Data p =>
    forall (m :: * -> *).
    GHC.Base.Monad m =>
    (forall d. Data.Data.Data d => d -> m d)
    -> p -> Language.Fortran.Variable -> m (Language.Fortran.VarName p)
  {- Arity: 5,
     Strictness: <L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ m :: * -> *
                   (w362 :: GHC.Base.Monad m)
                   (w363 :: forall d. Data.Data.Data d => d -> m d)
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 let {
                   lvl295 :: m Language.Fortran.Variable
                   = w363
                       @ Language.Fortran.Variable
                       Data.Data.$fData[]_$s$fData[]
                       ww1
                 } in
                 GHC.Base.>>=
                   @ m
                   w362
                   @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                   @ (Language.Fortran.VarName p)
                   (let {
                      lvl296 :: m p = w363 @ p w ww
                    } in
                    GHC.Base.>>=
                      @ m
                      w362
                      @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                      @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                      (GHC.Base.return
                         @ m
                         w362
                         @ (p -> Language.Fortran.Variable -> Language.Fortran.VarName p)
                         (Language.Fortran.VarName @ p))
                      (\ (c' :: p
                                -> Language.Fortran.Variable -> Language.Fortran.VarName p) ->
                       GHC.Base.>>=
                         @ m
                         w362
                         @ p
                         @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                         lvl296
                         (\ (x' :: p) ->
                          GHC.Base.return
                            @ m
                            w362
                            @ (Language.Fortran.Variable -> Language.Fortran.VarName p)
                            (c' x'))))
                   (\ (c' :: Language.Fortran.Variable
                             -> Language.Fortran.VarName p) ->
                    GHC.Base.>>=
                      @ m
                      w362
                      @ Language.Fortran.Variable
                      @ (Language.Fortran.VarName p)
                      lvl295
                      (\ (x' :: Language.Fortran.Variable) ->
                       GHC.Base.return
                         @ m
                         w362
                         @ (Language.Fortran.VarName p)
                         (c' x')))) -}
14f8992b1c25444e683257f3244413cb
  $w$cgmapQi ::
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> u
  {- Arity: 5,
     Strictness: <S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ u
                   (ww :: GHC.Prim.Int#)
                   (w :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> w @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww1
                   1# -> w @ GHC.Types.Int Data.Data.$fDataInt ww2
                   2# -> w @ GHC.Types.Int Data.Data.$fDataInt ww3 }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $w$cgmapQi1 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> p
    -> Language.Fortran.Expr p
    -> u
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Expr p) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0# -> w362 @ p w ww1
                   1#
                   -> w362
                        @ (Language.Fortran.Expr p)
                        (Language.Fortran.$fDataExpr @ p w)
                        ww2 }) -}
2661346c18056b3b907f62427e1b219c
  $w$cgmapQi2 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.SubName p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.SubName p) ->
                 case w363 of wild {
                   Language.Fortran.SubName a1 a2
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w362 @ p w a1
                        1# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2 }
                   Language.Fortran.NullSubName a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $w$cgmapQi3 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Implicit p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.Implicit p) ->
                 case w363 of wild {
                   Language.Fortran.ImplicitNone a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.ImplicitNull a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
68345fd7f5e34ad0320b6f7410ac4d6d
  $w$cgmapQi4 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> u
  {- Arity: 5,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (ww1 :: Language.Fortran.Uses p)
                   (ww2 :: Language.Fortran.SrcLoc) ->
                 case ww of wild {
                   DEFAULT -> Data.Maybe.fromJust1 @ u
                   0#
                   -> w362
                        @ (Language.Fortran.Uses p)
                        (Language.Fortran.$fDataUses @ p w)
                        ww1
                   1#
                   -> w362
                        @ Language.Fortran.SrcLoc
                        Language.Fortran.$fDataSrcLoc
                        ww2 }) -}
e90c235f732876f3296896ca224d9121
  $w$cgmapQi5 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.Fraction p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.Fraction p) ->
                 case w363 of wild {
                   Language.Fortran.IntegerConst a1 a2
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w362 @ p w a1
                        1# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2 }
                   Language.Fortran.FractionConst a1 a2 a3
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u
                        0# -> w362 @ p w a1
                        1# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a2
                        2# -> w362 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] a3 }
                   Language.Fortran.NullFraction a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $w$cgmapQi6 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.IntentAttr p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.IntentAttr p) ->
                 case w363 of wild {
                   Language.Fortran.In a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.Out a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.InOut a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
427f27131e64ea3da026fe120bf90190
  $w$cgmapQi7 ::
    Data.Data.Data p =>
    forall u.
    GHC.Prim.Int#
    -> (forall d. Data.Data.Data d => d -> u)
    -> Language.Fortran.UnaryOp p
    -> u
  {- Arity: 4, Strictness: <L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ u
                   (ww :: GHC.Prim.Int#)
                   (w362 :: forall d. Data.Data.Data d => d -> u)
                   (w363 :: Language.Fortran.UnaryOp p) ->
                 case w363 of wild {
                   Language.Fortran.UMinus a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 }
                   Language.Fortran.Not a1
                   -> case ww of wild1 {
                        DEFAULT -> Data.Maybe.fromJust1 @ u 0# -> w362 @ p w a1 } }) -}
c6e723b4947fd3d1f6010ebfa8c7a92e
  $w$cgmapQl ::
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 6,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
     Unfolding: (\ @ r
                   @ r'
                   (w :: r -> r' -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w (w (w w362
                         (w363 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww))
                      (w363 @ GHC.Types.Int Data.Data.$fDataInt ww1))
                   (w363 @ GHC.Types.Int Data.Data.$fDataInt ww2)) -}
900a39951fabdd0b42bed879b713e7e1
  $w$cgmapQl1 ::
    Data.Data.Data p =>
    forall r r'.
    (r -> r' -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Variable
    -> r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r -> r' -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 w362
                   (w362 w363 (w364 @ p w ww))
                   (w364
                      @ Language.Fortran.Variable
                      Data.Data.$fData[]_$s$fData[]
                      ww1)) -}
6e55370ec4c7c6e14b2d75e4796db6db
  $w$cgmapQr ::
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 6,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ r
                   @ r'
                   (w :: r' -> r -> r)
                   (w362 :: r)
                   (w363 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 w (w363 @ GHC.Base.String Data.Data.$fData[]_$s$fData[] ww)
                   (w (w363 @ GHC.Types.Int Data.Data.$fDataInt ww1)
                      (w (w363 @ GHC.Types.Int Data.Data.$fDataInt ww2) w362))) -}
045a18871aabc3897c4cc31c5a6f6de0
  $w$cgmapQr1 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Expr p
    -> r
  {- Arity: 6,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Expr p) ->
                 w362
                   (w364 @ p w ww)
                   (w362
                      (w364
                         @ (Language.Fortran.Expr p)
                         (Language.Fortran.$fDataExpr @ p w)
                         ww1)
                      w363)) -}
3c5a9f8d0093b9603b9c18c36fd960a9
  $w$cgmapQr2 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> r
  {- Arity: 6,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: Language.Fortran.Uses p)
                   (ww1 :: Language.Fortran.SrcLoc) ->
                 w362
                   (w364
                      @ (Language.Fortran.Uses p)
                      (Language.Fortran.$fDataUses @ p w)
                      ww)
                   (w362
                      (w364 @ Language.Fortran.SrcLoc Language.Fortran.$fDataSrcLoc ww1)
                      w363)) -}
31a4cb1faab1632cb3d7dc33118758bc
  $w$cgmapQr3 ::
    Data.Data.Data p =>
    forall r r'.
    (r' -> r -> r)
    -> r
    -> (forall d. Data.Data.Data d => d -> r')
    -> p
    -> Language.Fortran.Variable
    -> r
  {- Arity: 6,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ r
                   @ r'
                   (w362 :: r' -> r -> r)
                   (w363 :: r)
                   (w364 :: forall d. Data.Data.Data d => d -> r')
                   (ww :: p)
                   (ww1 :: Language.Fortran.Variable) ->
                 w362
                   (w364 @ p w ww)
                   (w362
                      (w364
                         @ Language.Fortran.Variable
                         Data.Data.$fData[]_$s$fData[]
                         ww1)
                      w363)) -}
5d55b2485fd718d78674934e1c1437fb
  $w$cgunfold ::
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r) -> c Language.Fortran.SrcLoc
  {- Arity: 2, Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)>,
     Inline: [0],
     Unfolding: (\ @ c :: * -> *
                   (w :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w362 :: forall r. r -> c r) ->
                 w @ GHC.Types.Int
                   @ Language.Fortran.SrcLoc
                   Data.Data.$fDataInt
                   (w @ GHC.Types.Int
                      @ (GHC.Types.Int -> Language.Fortran.SrcLoc)
                      Data.Data.$fDataInt
                      (w @ GHC.Base.String
                         @ (GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                         Data.Data.$fData[]_$s$fData[]
                         (w362
                            @ (GHC.Base.String
                               -> GHC.Types.Int -> GHC.Types.Int -> Language.Fortran.SrcLoc)
                            Language.Fortran.SrcLoc)))) -}
2661346c18056b3b907f62427e1b219c
  $w$cgunfold1 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.SubName p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.SubName p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.SubName p)
                             w
                             (w363
                                @ (p -> Language.Fortran.SubName p)
                                (Language.Fortran.NullSubName @ p))
                        1#
                        -> w362
                             @ GHC.Base.String
                             @ (Language.Fortran.SubName p)
                             Data.Data.$fData[]_$s$fData[]
                             (w362
                                @ p
                                @ (GHC.Base.String -> Language.Fortran.SubName p)
                                w
                                (w363
                                   @ (p -> GHC.Base.String -> Language.Fortran.SubName p)
                                   (Language.Fortran.SubName @ p))) } } }) -}
896c0936a7e3480424b97ccaddc9354b
  $w$cgunfold2 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.BinOp p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0] -}
bb388081fb116cff17a4c3fdaa0611fe
  $w$cgunfold3 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.Implicit p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.Implicit p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.Implicit p)
                             w
                             (w363
                                @ (p -> Language.Fortran.Implicit p)
                                (Language.Fortran.ImplicitNull @ p))
                        1#
                        -> w362
                             @ p
                             @ (Language.Fortran.Implicit p)
                             w
                             (w363
                                @ (p -> Language.Fortran.Implicit p)
                                (Language.Fortran.ImplicitNone @ p)) } } }) -}
e90c235f732876f3296896ca224d9121
  $w$cgunfold4 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.Fraction p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.Fraction p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.Fraction p)
                             w
                             (w363
                                @ (p -> Language.Fortran.Fraction p)
                                (Language.Fortran.NullFraction @ p))
                        1#
                        -> w362
                             @ GHC.Base.String
                             @ (Language.Fortran.Fraction p)
                             Data.Data.$fData[]_$s$fData[]
                             (w362
                                @ p
                                @ (GHC.Base.String -> Language.Fortran.Fraction p)
                                w
                                (w363
                                   @ (p -> GHC.Base.String -> Language.Fortran.Fraction p)
                                   (Language.Fortran.IntegerConst @ p)))
                        2#
                        -> w362
                             @ GHC.Base.String
                             @ (Language.Fortran.Fraction p)
                             Data.Data.$fData[]_$s$fData[]
                             (w362
                                @ GHC.Base.String
                                @ (GHC.Base.String -> Language.Fortran.Fraction p)
                                Data.Data.$fData[]_$s$fData[]
                                (w362
                                   @ p
                                   @ (GHC.Base.String
                                      -> GHC.Base.String -> Language.Fortran.Fraction p)
                                   w
                                   (w363
                                      @ (p
                                         -> GHC.Base.String
                                         -> GHC.Base.String
                                         -> Language.Fortran.Fraction p)
                                      (Language.Fortran.FractionConst @ p)))) } } }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $w$cgunfold5 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.IntentAttr p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.IntentAttr p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w363
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.InOut @ p))
                        1#
                        -> w362
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w363
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.In @ p))
                        2#
                        -> w362
                             @ p
                             @ (Language.Fortran.IntentAttr p)
                             w
                             (w363
                                @ (p -> Language.Fortran.IntentAttr p)
                                (Language.Fortran.Out @ p)) } } }) -}
427f27131e64ea3da026fe120bf90190
  $w$cgunfold6 ::
    Data.Data.Data p =>
    forall (c :: * -> *).
    (forall b r. Data.Data.Data b => c (b -> r) -> c r)
    -> (forall r. r -> c r)
    -> Data.Data.ConstrRep
    -> Data.Data.DataType
    -> c (Language.Fortran.UnaryOp p)
  {- Arity: 5,
     Strictness: <L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: Data.Data.Data p)
                   @ c :: * -> *
                   (w362 :: forall b r. Data.Data.Data b => c (b -> r) -> c r)
                   (w363 :: forall r. r -> c r)
                   (ww :: Data.Data.ConstrRep)
                   (ww1 :: Data.Data.DataType) ->
                 case ww of wild1 {
                   DEFAULT
                   -> case ww1 of ww6 { Data.Data.DataType ww7 ww8 ->
                      case Data.Data.$wlvl ww7
                      ret_ty (c (Language.Fortran.UnaryOp p))
                      of {} }
                   Data.Data.AlgConstr idx
                   -> case idx of wild { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT
                        -> w362
                             @ p
                             @ (Language.Fortran.UnaryOp p)
                             w
                             (w363
                                @ (p -> Language.Fortran.UnaryOp p)
                                (Language.Fortran.Not @ p))
                        1#
                        -> w362
                             @ p
                             @ (Language.Fortran.UnaryOp p)
                             w
                             (w363
                                @ (p -> Language.Fortran.UnaryOp p)
                                (Language.Fortran.UMinus @ p)) } } }) -}
3506e05db6b822afecc4c01e9293f0aa
  $w$cshow ::
    GHC.Base.String
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U(U)><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 case GHC.Base.eqString ww Language.Fortran.$fShowArg8 of wild {
                   GHC.Types.False
                   -> GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowArg7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           ww
                           (GHC.CString.unpackAppendCString#
                              Language.Fortran.$fShowArg6
                              (case ww1 of ww3 { GHC.Types.I# ww4 ->
                               case GHC.Show.$wshowSignedInt
                                      0#
                                      ww4
                                      (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                               GHC.Base.++_$s++
                                 @ GHC.Types.Char
                                 (GHC.CString.unpackAppendCString#
                                    Language.Fortran.$fShowArg5
                                    (case ww2 of ww8 { GHC.Types.I# ww9 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww9
                                            (GHC.Types.[]
                                               @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                                     GHC.Base.++_$s++
                                       @ GHC.Types.Char
                                       Language.Fortran.$fShowArg3
                                       ww11
                                       ww12 } }))
                                 ww6
                                 ww7 } })))
                   GHC.Types.True
                   -> GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowArg2
                        (case ww1 of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++_$s++
                           @ GHC.Types.Char
                           (GHC.CString.unpackAppendCString#
                              Language.Fortran.$fShowArg1
                              (case ww2 of ww8 { GHC.Types.I# ww9 ->
                               case GHC.Show.$wshowSignedInt
                                      0#
                                      ww9
                                      (GHC.Types.[] @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                               GHC.Base.++_$s++
                                 @ GHC.Types.Char
                                 Language.Fortran.$fShowArg3
                                 ww11
                                 ww12 } }))
                           ww6
                           ww7 } }) }) -}
f53ed146cc8f751423367d22669c94eb
  $w$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> Language.Fortran.ArgName p
    -> Language.Fortran.SrcSpan
    -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U><L,U(U(U,U(U),U(U)),U(U,U(U),U(U)))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.ArgName p)
                   (ww3 :: Language.Fortran.SrcSpan) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   f95 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec1 @ p w 11# ww2
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Language.Fortran.$fShowArg10
                       (f94
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f95
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (case ww3 of ww4 { (,) ww5 ww6 ->
                                    GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)4
                                      (case ww5 of ww7 { Language.Fortran.SrcLoc ww8 ww9 ww10 ->
                                       GHC.Base.++
                                         @ GHC.Types.Char
                                         (Language.Fortran.$w$cshow ww8 ww9 ww10)
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.showList__1
                                            (GHC.Show.$fShow(,)_$sgo1
                                               (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)
                                               (\ (s :: GHC.Base.String)[OneShot] ->
                                                case ww6 of ww11 { Language.Fortran.SrcLoc ww12 ww13 ww14 ->
                                                GHC.Base.++
                                                  @ GHC.Types.Char
                                                  (Language.Fortran.$w$cshow ww12 ww13 ww14)
                                                  s })
                                               (GHC.Types.[] @ GHC.Show.ShowS))) }) })))))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p1
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
8e85d4b8f2d7c2425f994f4a2454e404
  $w$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.ArgName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
f37cb87c0c5362747ff382fcf7036b42
  $w$cshowsPrec10 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Uses p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
e455b76098976efc9cb6b4dcbf1e7537
  $w$cshowsPrec11 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: [(Language.Fortran.Expr p, Language.Fortran.Expr p)]) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Language.Fortran.$fShowDataForm1
                       (f94
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (case ww2 of wild {
                                [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 x
                                : x1 xs
                                -> GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showList__3
                                     (case x1 of ww3 { (,) ww4 ww5 ->
                                      GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.$fShow(,)4
                                        (Language.Fortran.$w$cshowsPrec3
                                           @ p
                                           w
                                           0#
                                           ww4
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showList__1
                                              (GHC.Show.$fShow(,)_$sgo1
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.$fShow(,)2
                                                    (let {
                                                       lvl295 :: [GHC.Types.Char]
                                                       = GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.showList__2
                                                           x
                                                     } in
                                                     letrec {
                                                       showl :: [(Language.Fortran.Expr p,
                                                                  Language.Fortran.Expr p)]
                                                                -> GHC.Base.String
                                                         {- Arity: 1, Strictness: <S,1*U> -}
                                                       = \ (ds2 :: [(Language.Fortran.Expr p,
                                                                     Language.Fortran.Expr p)]) ->
                                                         case ds2 of wild1 {
                                                           [] -> lvl295
                                                           : y ys
                                                           -> GHC.Types.:
                                                                @ GHC.Types.Char
                                                                GHC.Show.showList__1
                                                                (case y of ww6 { (,) ww7 ww8 ->
                                                                 GHC.Types.:
                                                                   @ GHC.Types.Char
                                                                   GHC.Show.$fShow(,)4
                                                                   (Language.Fortran.$w$cshowsPrec3
                                                                      @ p
                                                                      w
                                                                      0#
                                                                      ww7
                                                                      (GHC.Types.:
                                                                         @ GHC.Types.Char
                                                                         GHC.Show.showList__1
                                                                         (GHC.Show.$fShow(,)_$sgo1
                                                                            (GHC.Types.:
                                                                               @ GHC.Types.Char
                                                                               GHC.Show.$fShow(,)2
                                                                               (showl ys))
                                                                            (Language.Fortran.$w$cshowsPrec3
                                                                               @ p
                                                                               w
                                                                               0#
                                                                               ww8)
                                                                            (GHC.Types.[]
                                                                               @ GHC.Show.ShowS)))) }) }
                                                     } in
                                                     showl xs))
                                                 (Language.Fortran.$w$cshowsPrec3 @ p w 0# ww5)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))) }) })))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p1
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
e90c235f732876f3296896ca224d9121
  $w$cshowsPrec12 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Fraction p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.Fraction p) ->
                 case w362 of wild {
                   Language.Fortran.IntegerConst b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowFraction4
                             (f94
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b2
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowFraction4
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Show.showLitString
                                            b2
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.$fShow(,)3
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.$fShow(,)2
                                                  x))))))) }
                   Language.Fortran.FractionConst b1 b2 b3
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      let {
                        p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.CString.unpackAppendCString#
                            Language.Fortran.$fShowFraction3
                            (f94
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.$fShow(,)3
                                     (GHC.Show.showLitString
                                        b2
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.$fShow(,)3
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showSpace1
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.$fShow(,)3
                                                 (GHC.Show.showLitString
                                                    b3
                                                    (GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.$fShow(,)3
                                                       x)))))))))
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT -> p1
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }
                   Language.Fortran.NullFraction b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowFraction1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowFraction1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
a074c18ee753392beb804aeb08ff8264
  $w$cshowsPrec13 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.GSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.GSpec p) ->
                 case w362 of wild {
                   Language.Fortran.GName b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Fortran.$w$cshowsPrec3 @ p w 11# b2
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowGSpec4
                             (f94 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowGSpec4
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }
                   Language.Fortran.GOper b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Fortran.$w$cshowsPrec6 @ p w 11# b2
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowGSpec3
                             (f94 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowGSpec3
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }
                   Language.Fortran.GAssg b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowGSpec1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowGSpec1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
4d3b0df77e964eb2c9be90f07a78d3b1
  $w$cshowsPrec14 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.IntentAttr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.IntentAttr p) ->
                 case w362 of wild {
                   Language.Fortran.In b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr5
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr5
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.Out b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr3
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.InOut b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Language.Fortran.$fShowIntentAttr1
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowIntentAttr1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
a81776e31635bc99f5c71e8648536701
  $w$cshowsPrec15 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.InterfaceSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
a4588ee68ff39c65875cdbcceadc05a6
  $w$cshowsPrec16 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> Language.Fortran.MeasureUnitSpec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
66b1069c4f9f43ca84bb38e2e3b8a071
  $w$cshowsPrec17 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Spec p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
2661346c18056b3b907f62427e1b219c
  $w$cshowsPrec18 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.SubName p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.SubName p) ->
                 case w362 of wild {
                   Language.Fortran.SubName b1 b2
                   -> let {
                        f94 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             Language.Fortran.$fShowSubName3
                             (f94
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b2
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Language.Fortran.$fShowSubName3
                                (f94
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Show.showLitString
                                            b2
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.$fShow(,)3
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.$fShow(,)2
                                                  x))))))) }
                   Language.Fortran.NullSubName b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowSubName1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowSubName1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
b96ba407eb7f4a3ee0ca0e49936e95dc
  $w$cshowsPrec19 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Type p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
045a18871aabc3897c4cc31c5a6f6de0
  $w$cshowsPrec2 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> p -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Expr p) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec3 @ p w 11# ww2
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowArgList1
                        (f94 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Language.Fortran.$fShowArgList1
                           (f94
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }) -}
427f27131e64ea3da026fe120bf90190
  $w$cshowsPrec20 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.UnaryOp p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.UnaryOp p) ->
                 case w362 of wild {
                   Language.Fortran.UMinus b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowUnaryOp3 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowUnaryOp3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.Not b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowUnaryOp1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowUnaryOp1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
3ccf6798e93a53876d1e84093dc60ed8
  $w$cshowsPrec21 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> p -> Language.Fortran.Variable -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.Variable) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowVarName1
                        (f94
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.$fShow(,)3
                                 (GHC.Show.showLitString
                                    ww2
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Language.Fortran.$fShowVarName1
                           (f94
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.$fShow(,)3
                                    (GHC.Show.showLitString
                                       ww2
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          GHC.Show.$fShow(,)3
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.$fShow(,)2
                                             x))))))) }) -}
045a18871aabc3897c4cc31c5a6f6de0
  $w$cshowsPrec3 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Expr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
02a255cfb28c667ea6da849cf85b59d6
  $w$cshowsPrec4 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Attr p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
69d5dfd4df9415765a99abb747654948
  $w$cshowsPrec5 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.BaseType p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
896c0936a7e3480424b97ccaddc9354b
  $w$cshowsPrec6 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.BinOp p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
a8e0797a855f515048eec2c3c7cf1848
  $w$cshowsPrec7 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> p
    -> Language.Fortran.UseBlock p
    -> Language.Fortran.Implicit p
    -> Language.Fortran.SrcSpan
    -> Language.Fortran.Decl p
    -> Language.Fortran.Fortran p
    -> GHC.Show.ShowS
  {- Arity: 8,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,1*U(1*U,U(U,U(U),U(U)))><L,1*U><L,U(U(U,U(U),U(U)),U(U,U(U),U(U)))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: p)
                   (ww2 :: Language.Fortran.UseBlock p)
                   (ww3 :: Language.Fortran.Implicit p)
                   (ww4 :: Language.Fortran.SrcSpan)
                   (ww5 :: Language.Fortran.Decl p)
                   (ww6 :: Language.Fortran.Fortran p) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 ww1
                 } in
                 let {
                   f95 :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww7 { Language.Fortran.UseBlock ww8 ww9 ->
                     Language.Fortran.$w$cshowsPrec9 @ p w 11# ww8 ww9 }
                 } in
                 let {
                   f96 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec8 @ p w 11# ww3
                 } in
                 let {
                   f97 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$fShowBlock_$cshowsPrec2
                       @ p
                       w
                       Language.Fortran.$fReadVarName2
                       ww5
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$fShowBlock_$cshowsPrec1
                       @ p
                       w
                       Language.Fortran.$fReadVarName2
                       ww6
                 } in
                 let {
                   p1 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Language.Fortran.$fShowBlock1
                       (f94
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f95
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (f96
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (case ww4 of ww7 { (,) ww8 ww9 ->
                                          GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)4
                                            (case ww8 of ww10 { Language.Fortran.SrcLoc ww11 ww12 ww13 ->
                                             GHC.Base.++
                                               @ GHC.Types.Char
                                               (Language.Fortran.$w$cshow ww11 ww12 ww13)
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.showList__1
                                                  (GHC.Show.$fShow(,)_$sgo1
                                                     (GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.$fShow(,)2
                                                        (GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.showSpace1
                                                           (f97
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Char
                                                                 GHC.Show.showSpace1
                                                                 (g x)))))
                                                     (\ (s :: GHC.Base.String)[OneShot] ->
                                                      case ww9 of ww14 { Language.Fortran.SrcLoc ww15 ww16 ww17 ->
                                                      GHC.Base.++
                                                        @ GHC.Types.Char
                                                        (Language.Fortran.$w$cshow ww15 ww16 ww17)
                                                        s })
                                                     (GHC.Types.[] @ GHC.Show.ShowS))) }) })))))))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p1
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p1 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
bb388081fb116cff17a4c3fdaa0611fe
  $w$cshowsPrec8 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> Language.Fortran.Implicit p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (w362 :: Language.Fortran.Implicit p) ->
                 case w362 of wild {
                   Language.Fortran.ImplicitNone b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowBlock4 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowBlock4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Language.Fortran.ImplicitNull b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ p w Language.Fortran.$fReadVarName2 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Language.Fortran.$fShowBlock2 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Language.Fortran.$fShowBlock2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
cf7f821ba931c5b39c28509ba6d6b499
  $w$cshowsPrec9 ::
    GHC.Show.Show p =>
    GHC.Prim.Int#
    -> Language.Fortran.Uses p
    -> Language.Fortran.SrcLoc
    -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,1*U><L,U(U,U(U),U(U))>,
     Inline: [0],
     Unfolding: (\ @ p
                   (w :: GHC.Show.Show p)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: Language.Fortran.Uses p)
                   (ww2 :: Language.Fortran.SrcLoc) ->
                 let {
                   f94 :: GHC.Base.String -> GHC.Base.String
                   = Language.Fortran.$w$cshowsPrec10 @ p w 11# ww1
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Language.Fortran.$fShowBlock6
                        (f94
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                               GHC.Base.++
                                 @ GHC.Types.Char
                                 (Language.Fortran.$w$cshow ww4 ww5 ww6)
                                 x })))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Language.Fortran.$fShowBlock6
                           (f94
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (case ww2 of ww3 { Language.Fortran.SrcLoc ww4 ww5 ww6 ->
                                  GHC.Base.++
                                    @ GHC.Types.Char
                                    (Language.Fortran.$w$cshow ww4 ww5 ww6)
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x) })))) }) -}
d3fedd88bb81c839018aa8b13497c1de
  data Arg p
    = Arg p (Language.Fortran.ArgName p) Language.Fortran.SrcSpan
045a18871aabc3897c4cc31c5a6f6de0
  data ArgList p = ArgList p (Language.Fortran.Expr p)
8e85d4b8f2d7c2425f994f4a2454e404
  data ArgName p
    = ArgName p GHC.Base.String
    | ASeq p (Language.Fortran.ArgName p) (Language.Fortran.ArgName p)
    | NullArg p
02a255cfb28c667ea6da849cf85b59d6
  data Attr p
    = Parameter p
    | Allocatable p
    | External p
    | Intent p (Language.Fortran.IntentAttr p)
    | Intrinsic p
    | Optional p
    | Pointer p
    | Save p
    | Target p
    | Volatile p
    | Public p
    | Private p
    | Sequence p
    | Dimension p [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
    | MeasureUnit p (Language.Fortran.MeasureUnitSpec p)
69d5dfd4df9415765a99abb747654948
  data BaseType p
    = Integer p
    | Real p
    | Character p
    | SomeType p
    | DerivedType p (Language.Fortran.SubName p)
    | Recursive p
    | Pure p
    | Elemental p
    | Logical p
    | Complex p
896c0936a7e3480424b97ccaddc9354b
  data BinOp p
    = Plus p
    | Minus p
    | Mul p
    | Div p
    | Or p
    | And p
    | Concat p
    | Power p
    | RelEQ p
    | RelNE p
    | RelLT p
    | RelLE p
    | RelGT p
    | RelGE p
b0aacfbcefe95ece6fbb0f40cd37c948
  data Block p
    = Block p
            (Language.Fortran.UseBlock p)
            (Language.Fortran.Implicit p)
            Language.Fortran.SrcSpan
            (Language.Fortran.Decl p)
            (Language.Fortran.Fortran p)
dad4d55a5cea607426e414a10b8eea45
  data DataForm p
    = Data p [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
a81776e31635bc99f5c71e8648536701
  data Decl p
    = Decl p
           Language.Fortran.SrcSpan
           [(Language.Fortran.Expr p, Language.Fortran.Expr p,
             GHC.Base.Maybe GHC.Types.Int)]
           (Language.Fortran.Type p)
    | Namelist p [(Language.Fortran.Expr p, [Language.Fortran.Expr p])]
    | DataDecl p (Language.Fortran.DataForm p)
    | Equivalence p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | AttrStmt p
               (Language.Fortran.Attr p)
               [(Language.Fortran.Expr p, Language.Fortran.Expr p,
                 GHC.Base.Maybe GHC.Types.Int)]
    | AccessStmt p (Language.Fortran.Attr p) [Language.Fortran.GSpec p]
    | ExternalStmt p [GHC.Base.String]
    | Interface p
                (GHC.Base.Maybe (Language.Fortran.GSpec p))
                [Language.Fortran.InterfaceSpec p]
    | Common p
             Language.Fortran.SrcSpan
             (GHC.Base.Maybe GHC.Base.String)
             [Language.Fortran.Expr p]
    | DerivedTypeDef p
                     Language.Fortran.SrcSpan
                     (Language.Fortran.SubName p)
                     [Language.Fortran.Attr p]
                     [Language.Fortran.Attr p]
                     [Language.Fortran.Decl p]
    | Include p (Language.Fortran.Expr p)
    | DSeq p (Language.Fortran.Decl p) (Language.Fortran.Decl p)
    | TextDecl p GHC.Base.String
    | NullDecl p Language.Fortran.SrcSpan
    | MeasureUnitDef p
                     Language.Fortran.SrcSpan
                     [(Language.Fortran.MeasureUnit,
                       Language.Fortran.MeasureUnitSpec p)]
045a18871aabc3897c4cc31c5a6f6de0
  data Expr p
    = Con p Language.Fortran.SrcSpan GHC.Base.String
    | ConL p Language.Fortran.SrcSpan GHC.Types.Char GHC.Base.String
    | ConS p Language.Fortran.SrcSpan GHC.Base.String
    | Var p
          Language.Fortran.SrcSpan
          [(Language.Fortran.VarName p, [Language.Fortran.Expr p])]
    | Bin p
          Language.Fortran.SrcSpan
          (Language.Fortran.BinOp p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
    | Unary p
            Language.Fortran.SrcSpan
            (Language.Fortran.UnaryOp p)
            (Language.Fortran.Expr p)
    | CallExpr p
               Language.Fortran.SrcSpan
               (Language.Fortran.Expr p)
               (Language.Fortran.ArgList p)
    | NullExpr p Language.Fortran.SrcSpan
    | Null p Language.Fortran.SrcSpan
    | ESeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.Expr p)
    | Bound p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            (Language.Fortran.Expr p)
    | Sqrt p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | ArrayCon p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | AssgExpr p
               Language.Fortran.SrcSpan
               GHC.Base.String
               (Language.Fortran.Expr p)
96a246f096edd051e2860499c815ffa3
  data Fortran p
    = Assg p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.Expr p)
    | For p
          Language.Fortran.SrcSpan
          (Language.Fortran.VarName p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Expr p)
          (Language.Fortran.Fortran p)
    | DoWhile p
              Language.Fortran.SrcSpan
              (Language.Fortran.Expr p)
              (Language.Fortran.Fortran p)
    | FSeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.Fortran p)
           (Language.Fortran.Fortran p)
    | If p
         Language.Fortran.SrcSpan
         (Language.Fortran.Expr p)
         (Language.Fortran.Fortran p)
         [(Language.Fortran.Expr p, Language.Fortran.Fortran p)]
         (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | Allocate p
               Language.Fortran.SrcSpan
               (Language.Fortran.Expr p)
               (Language.Fortran.Expr p)
    | Backspace p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Call p
           Language.Fortran.SrcSpan
           (Language.Fortran.Expr p)
           (Language.Fortran.ArgList p)
    | Open p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Close p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Continue p Language.Fortran.SrcSpan
    | Cycle p Language.Fortran.SrcSpan GHC.Base.String
    | DataStmt p Language.Fortran.SrcSpan (Language.Fortran.DataForm p)
    | Deallocate p
                 Language.Fortran.SrcSpan
                 [Language.Fortran.Expr p]
                 (Language.Fortran.Expr p)
    | Endfile p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Exit p Language.Fortran.SrcSpan GHC.Base.String
    | Format p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Forall p
             Language.Fortran.SrcSpan
             ([(GHC.Base.String, Language.Fortran.Expr p,
                Language.Fortran.Expr p, Language.Fortran.Expr p)],
              Language.Fortran.Expr p)
             (Language.Fortran.Fortran p)
    | Goto p Language.Fortran.SrcSpan GHC.Base.String
    | Nullify p Language.Fortran.SrcSpan [Language.Fortran.Expr p]
    | Inquire p
              Language.Fortran.SrcSpan
              [Language.Fortran.Spec p]
              [Language.Fortran.Expr p]
    | Pause p Language.Fortran.SrcSpan GHC.Base.String
    | Rewind p Language.Fortran.SrcSpan [Language.Fortran.Spec p]
    | Stop p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | Where p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            (Language.Fortran.Fortran p)
            (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | Write p
            Language.Fortran.SrcSpan
            [Language.Fortran.Spec p]
            [Language.Fortran.Expr p]
    | PointerAssg p
                  Language.Fortran.SrcSpan
                  (Language.Fortran.Expr p)
                  (Language.Fortran.Expr p)
    | Return p Language.Fortran.SrcSpan (Language.Fortran.Expr p)
    | Label p
            Language.Fortran.SrcSpan
            GHC.Base.String
            (Language.Fortran.Fortran p)
    | Print p
            Language.Fortran.SrcSpan
            (Language.Fortran.Expr p)
            [Language.Fortran.Expr p]
    | ReadS p
            Language.Fortran.SrcSpan
            [Language.Fortran.Spec p]
            [Language.Fortran.Expr p]
    | TextStmt p Language.Fortran.SrcSpan GHC.Base.String
    | NullStmt p Language.Fortran.SrcSpan
    | SelectStmt p
                 Language.Fortran.SrcSpan
                 (Language.Fortran.Expr p)
                 [(Language.Fortran.Expr p, Language.Fortran.Fortran p)]
                 (GHC.Base.Maybe (Language.Fortran.Fortran p))
    | OpenCLMap p
                Language.Fortran.SrcSpan
                [Language.Fortran.VarName p]
                [Language.Fortran.VarName p]
                [(Language.Fortran.VarName p, Language.Fortran.Expr p,
                  Language.Fortran.Expr p, Language.Fortran.Expr p)]
                [Language.Fortran.VarName p]
                (Language.Fortran.Fortran p)
    | OpenCLReduce p
                   Language.Fortran.SrcSpan
                   [Language.Fortran.VarName p]
                   [Language.Fortran.VarName p]
                   [(Language.Fortran.VarName p, Language.Fortran.Expr p,
                     Language.Fortran.Expr p, Language.Fortran.Expr p)]
                   [Language.Fortran.VarName p]
                   [(Language.Fortran.VarName p, Language.Fortran.Expr p)]
                   (Language.Fortran.Fortran p)
    | OpenCLSeq p
                Language.Fortran.SrcSpan
                [Language.Fortran.VarName p]
                [Language.Fortran.VarName p]
                (Language.Fortran.Fortran p)
    | OpenCLBufferRead p
                       Language.Fortran.SrcSpan
                       (Language.Fortran.VarName p)
    | OpenCLBufferWrite p
                        Language.Fortran.SrcSpan
                        (Language.Fortran.VarName p)
e90c235f732876f3296896ca224d9121
  data Fraction p
    = IntegerConst p GHC.Base.String
    | FractionConst p GHC.Base.String GHC.Base.String
    | NullFraction p
a074c18ee753392beb804aeb08ff8264
  data GSpec p
    = GName p (Language.Fortran.Expr p)
    | GOper p (Language.Fortran.BinOp p)
    | GAssg p
bb388081fb116cff17a4c3fdaa0611fe
  data Implicit p = ImplicitNone p | ImplicitNull p
4d3b0df77e964eb2c9be90f07a78d3b1
  data IntentAttr p = In p | Out p | InOut p
a81776e31635bc99f5c71e8648536701
  data InterfaceSpec p
    = FunctionInterface p
                        (Language.Fortran.SubName p)
                        (Language.Fortran.Arg p)
                        (Language.Fortran.Uses p)
                        (Language.Fortran.Implicit p)
                        (Language.Fortran.Decl p)
    | SubroutineInterface p
                          (Language.Fortran.SubName p)
                          (Language.Fortran.Arg p)
                          (Language.Fortran.Uses p)
                          (Language.Fortran.Implicit p)
                          (Language.Fortran.Decl p)
    | ModuleProcedure p [Language.Fortran.SubName p]
5699565f5f448bb936900abdc739855a
  type MeasureUnit = GHC.Base.String
a4588ee68ff39c65875cdbcceadc05a6
  data MeasureUnitSpec p
    = UnitProduct p
                  [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
    | UnitQuotient p
                   [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
                   [(Language.Fortran.MeasureUnit, Language.Fortran.Fraction p)]
    | UnitNone p
f882fa0d1a1284f52fc6bca92aa97305
  type ProgName = GHC.Base.String
cf6f89a9a11f4455970aae08e46ad751
  data ProgUnit p
    = Main p
           Language.Fortran.SrcSpan
           (Language.Fortran.SubName p)
           (Language.Fortran.Arg p)
           (Language.Fortran.Block p)
           [Language.Fortran.ProgUnit p]
    | Sub p
          Language.Fortran.SrcSpan
          (GHC.Base.Maybe (Language.Fortran.BaseType p))
          (Language.Fortran.SubName p)
          (Language.Fortran.Arg p)
          (Language.Fortran.Block p)
    | Function p
               Language.Fortran.SrcSpan
               (GHC.Base.Maybe (Language.Fortran.BaseType p))
               (Language.Fortran.SubName p)
               (Language.Fortran.Arg p)
               (GHC.Base.Maybe (Language.Fortran.VarName p))
               (Language.Fortran.Block p)
    | Module p
             Language.Fortran.SrcSpan
             (Language.Fortran.SubName p)
             (Language.Fortran.Uses p)
             (Language.Fortran.Implicit p)
             (Language.Fortran.Decl p)
             [Language.Fortran.ProgUnit p]
    | BlockData p
                Language.Fortran.SrcSpan
                (Language.Fortran.SubName p)
                (Language.Fortran.Uses p)
                (Language.Fortran.Implicit p)
                (Language.Fortran.Decl p)
    | PSeq p
           Language.Fortran.SrcSpan
           (Language.Fortran.ProgUnit p)
           (Language.Fortran.ProgUnit p)
    | Prog p Language.Fortran.SrcSpan (Language.Fortran.ProgUnit p)
    | NullProg p Language.Fortran.SrcSpan
    | IncludeProg p
                  Language.Fortran.SrcSpan
                  (Language.Fortran.Decl p)
                  (GHC.Base.Maybe (Language.Fortran.Fortran p))
0d9c421f7253460446b42c45c51774d0
  type Program p = [Language.Fortran.ProgUnit p]
b3d56ed0dce90d4125dd487071ae5799
  type Renames =
    [(Language.Fortran.Variable, Language.Fortran.Variable)]
f57ed7b26ba9d8272d17d6f7cd74766e
  class Span t where
    srcSpan :: t -> (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
    {-# MINIMAL srcSpan #-}
66b1069c4f9f43ca84bb38e2e3b8a071
  data Spec p
    = Access p (Language.Fortran.Expr p)
    | Action p (Language.Fortran.Expr p)
    | Advance p (Language.Fortran.Expr p)
    | Blank p (Language.Fortran.Expr p)
    | Delim p (Language.Fortran.Expr p)
    | Direct p (Language.Fortran.Expr p)
    | End p (Language.Fortran.Expr p)
    | Err p (Language.Fortran.Expr p)
    | ExFile p (Language.Fortran.Expr p)
    | Exist p (Language.Fortran.Expr p)
    | Eor p (Language.Fortran.Expr p)
    | File p (Language.Fortran.Expr p)
    | FMT p (Language.Fortran.Expr p)
    | Form p (Language.Fortran.Expr p)
    | Formatted p (Language.Fortran.Expr p)
    | Unformatted p (Language.Fortran.Expr p)
    | IOLength p (Language.Fortran.Expr p)
    | IOStat p (Language.Fortran.Expr p)
    | Name p (Language.Fortran.Expr p)
    | Named p (Language.Fortran.Expr p)
    | NoSpec p (Language.Fortran.Expr p)
    | Number p (Language.Fortran.Expr p)
    | Floating p (Language.Fortran.Expr p) (Language.Fortran.Expr p)
    | NextRec p (Language.Fortran.Expr p)
    | NML p (Language.Fortran.Expr p)
    | Opened p (Language.Fortran.Expr p)
    | Pad p (Language.Fortran.Expr p)
    | Position p (Language.Fortran.Expr p)
    | Read p (Language.Fortran.Expr p)
    | ReadWrite p (Language.Fortran.Expr p)
    | Rec p (Language.Fortran.Expr p)
    | Recl p (Language.Fortran.Expr p)
    | Sequential p (Language.Fortran.Expr p)
    | Size p (Language.Fortran.Expr p)
    | Status p (Language.Fortran.Expr p)
    | StringLit p GHC.Base.String
    | Unit p (Language.Fortran.Expr p)
    | WriteSp p (Language.Fortran.Expr p)
    | Delimiter p
5d55b2485fd718d78674934e1c1437fb
  data SrcLoc
    = SrcLoc {srcFilename :: GHC.Base.String,
              srcLine :: GHC.Types.Int,
              srcColumn :: GHC.Types.Int}
166b0e73c5ce00e3d10178d7576b0d58
  type SrcSpan = (Language.Fortran.SrcLoc, Language.Fortran.SrcLoc)
2661346c18056b3b907f62427e1b219c
  data SubName p = SubName p GHC.Base.String | NullSubName p
b27a965319b651630462b426dfdadbca
  class Tagged (d :: * -> *) where
    tag :: d a -> a
    {-# MINIMAL tag #-}
b96ba407eb7f4a3ee0ca0e49936e95dc
  data Type p
    = BaseType p
               (Language.Fortran.BaseType p)
               [Language.Fortran.Attr p]
               (Language.Fortran.Expr p)
               (Language.Fortran.Expr p)
    | ArrayT p
             [(Language.Fortran.Expr p, Language.Fortran.Expr p)]
             (Language.Fortran.BaseType p)
             [Language.Fortran.Attr p]
             (Language.Fortran.Expr p)
             (Language.Fortran.Expr p)
427f27131e64ea3da026fe120bf90190
  data UnaryOp p = UMinus p | Not p
b15343402b457d38480c3fa7b3ee4ce7
  data UseBlock p
    = UseBlock (Language.Fortran.Uses p) Language.Fortran.SrcLoc
f37cb87c0c5362747ff382fcf7036b42
  data Uses p
    = Use p
          (GHC.Base.String, Language.Fortran.Renames)
          (Language.Fortran.Uses p)
          p
    | UseNil p
8fc44fa42aa6f0f3254ca020bcf3cb0f
  data VarName p = VarName p Language.Fortran.Variable
c70925c2105fe5462903fb2ce340f326
  type Variable = GHC.Base.String
5d55b2485fd718d78674934e1c1437fb
  srcColumn :: Language.Fortran.SrcLoc -> GHC.Types.Int
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds3 }) -}
5d55b2485fd718d78674934e1c1437fb
  srcFilename :: Language.Fortran.SrcLoc -> GHC.Base.String
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds1 }) -}
5d55b2485fd718d78674934e1c1437fb
  srcLine :: Language.Fortran.SrcLoc -> GHC.Types.Int
  RecSel Left Language.Fortran.SrcLoc
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Language.Fortran.SrcLoc) ->
                 case ds of wild { Language.Fortran.SrcLoc ds1 ds2 ds3 -> ds2 }) -}
instance Data.Data.Data [Language.Fortran.Arg]
  = Language.Fortran.$fDataArg
instance Data.Data.Data [Language.Fortran.ArgList]
  = Language.Fortran.$fDataArgList
instance Data.Data.Data [Language.Fortran.ArgName]
  = Language.Fortran.$fDataArgName
instance Data.Data.Data [Language.Fortran.Attr]
  = Language.Fortran.$fDataAttr
instance Data.Data.Data [Language.Fortran.BaseType]
  = Language.Fortran.$fDataBaseType
instance Data.Data.Data [Language.Fortran.BinOp]
  = Language.Fortran.$fDataBinOp
instance Data.Data.Data [Language.Fortran.Block]
  = Language.Fortran.$fDataBlock
instance Data.Data.Data [Language.Fortran.DataForm]
  = Language.Fortran.$fDataDataForm
instance Data.Data.Data [Language.Fortran.Decl]
  = Language.Fortran.$fDataDecl
instance Data.Data.Data [Language.Fortran.Expr]
  = Language.Fortran.$fDataExpr
instance Data.Data.Data [Language.Fortran.Fortran]
  = Language.Fortran.$fDataFortran
instance Data.Data.Data [Language.Fortran.Fraction]
  = Language.Fortran.$fDataFraction
instance Data.Data.Data [Language.Fortran.GSpec]
  = Language.Fortran.$fDataGSpec
instance Data.Data.Data [Language.Fortran.Implicit]
  = Language.Fortran.$fDataImplicit
instance Data.Data.Data [Language.Fortran.IntentAttr]
  = Language.Fortran.$fDataIntentAttr
instance Data.Data.Data [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fDataInterfaceSpec
instance Data.Data.Data [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fDataMeasureUnitSpec
instance Data.Data.Data [Language.Fortran.ProgUnit]
  = Language.Fortran.$fDataProgUnit
instance Data.Data.Data [Language.Fortran.Spec]
  = Language.Fortran.$fDataSpec
instance Data.Data.Data [Language.Fortran.SrcLoc]
  = Language.Fortran.$fDataSrcLoc
instance Data.Data.Data [Language.Fortran.SubName]
  = Language.Fortran.$fDataSubName
instance Data.Data.Data [Language.Fortran.Type]
  = Language.Fortran.$fDataType
instance Data.Data.Data [Language.Fortran.UnaryOp]
  = Language.Fortran.$fDataUnaryOp
instance Data.Data.Data [Language.Fortran.UseBlock]
  = Language.Fortran.$fDataUseBlock
instance Data.Data.Data [Language.Fortran.Uses]
  = Language.Fortran.$fDataUses
instance Data.Data.Data [Language.Fortran.VarName]
  = Language.Fortran.$fDataVarName
instance GHC.Classes.Eq [Language.Fortran.Arg]
  = Language.Fortran.$fEqArg
instance GHC.Classes.Eq [Language.Fortran.ArgList]
  = Language.Fortran.$fEqArgList
instance GHC.Classes.Eq [Language.Fortran.ArgName]
  = Language.Fortran.$fEqArgName
instance GHC.Classes.Eq [Language.Fortran.Attr]
  = Language.Fortran.$fEqAttr
instance GHC.Classes.Eq [Language.Fortran.BaseType]
  = Language.Fortran.$fEqBaseType
instance GHC.Classes.Eq [Language.Fortran.BinOp]
  = Language.Fortran.$fEqBinOp
instance GHC.Classes.Eq [Language.Fortran.Block]
  = Language.Fortran.$fEqBlock
instance GHC.Classes.Eq [Language.Fortran.DataForm]
  = Language.Fortran.$fEqDataForm
instance GHC.Classes.Eq [Language.Fortran.Decl]
  = Language.Fortran.$fEqDecl
instance GHC.Classes.Eq [Language.Fortran.Expr]
  = Language.Fortran.$fEqExpr
instance GHC.Classes.Eq [Language.Fortran.Fortran]
  = Language.Fortran.$fEqFortran
instance GHC.Classes.Eq [Language.Fortran.Fraction]
  = Language.Fortran.$fEqFraction
instance GHC.Classes.Eq [Language.Fortran.GSpec]
  = Language.Fortran.$fEqGSpec
instance GHC.Classes.Eq [Language.Fortran.Implicit]
  = Language.Fortran.$fEqImplicit
instance GHC.Classes.Eq [Language.Fortran.IntentAttr]
  = Language.Fortran.$fEqIntentAttr
instance GHC.Classes.Eq [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fEqInterfaceSpec
instance GHC.Classes.Eq [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fEqMeasureUnitSpec
instance GHC.Classes.Eq [Language.Fortran.ProgUnit]
  = Language.Fortran.$fEqProgUnit
instance GHC.Classes.Eq [Language.Fortran.Spec]
  = Language.Fortran.$fEqSpec
instance GHC.Classes.Eq [Language.Fortran.SrcLoc]
  = Language.Fortran.$fEqSrcLoc
instance GHC.Classes.Eq [Language.Fortran.SubName]
  = Language.Fortran.$fEqSubName
instance GHC.Classes.Eq [Language.Fortran.Type]
  = Language.Fortran.$fEqType
instance GHC.Classes.Eq [Language.Fortran.UnaryOp]
  = Language.Fortran.$fEqUnaryOp
instance GHC.Classes.Eq [Language.Fortran.UseBlock]
  = Language.Fortran.$fEqUseBlock
instance GHC.Classes.Eq [Language.Fortran.Uses]
  = Language.Fortran.$fEqUses
instance GHC.Classes.Eq [Language.Fortran.VarName]
  = Language.Fortran.$fEqVarName
instance GHC.Base.Functor [Language.Fortran.Arg]
  = Language.Fortran.$fFunctorArg
instance GHC.Base.Functor [Language.Fortran.ArgList]
  = Language.Fortran.$fFunctorArgList
instance GHC.Base.Functor [Language.Fortran.ArgName]
  = Language.Fortran.$fFunctorArgName
instance GHC.Base.Functor [Language.Fortran.Attr]
  = Language.Fortran.$fFunctorAttr
instance GHC.Base.Functor [Language.Fortran.BaseType]
  = Language.Fortran.$fFunctorBaseType
instance GHC.Base.Functor [Language.Fortran.BinOp]
  = Language.Fortran.$fFunctorBinOp
instance GHC.Base.Functor [Language.Fortran.Block]
  = Language.Fortran.$fFunctorBlock
instance GHC.Base.Functor [Language.Fortran.DataForm]
  = Language.Fortran.$fFunctorDataForm
instance GHC.Base.Functor [Language.Fortran.Decl]
  = Language.Fortran.$fFunctorDecl
instance GHC.Base.Functor [Language.Fortran.Expr]
  = Language.Fortran.$fFunctorExpr
instance GHC.Base.Functor [Language.Fortran.Fortran]
  = Language.Fortran.$fFunctorFortran
instance GHC.Base.Functor [Language.Fortran.Fraction]
  = Language.Fortran.$fFunctorFraction
instance GHC.Base.Functor [Language.Fortran.GSpec]
  = Language.Fortran.$fFunctorGSpec
instance GHC.Base.Functor [Language.Fortran.Implicit]
  = Language.Fortran.$fFunctorImplicit
instance GHC.Base.Functor [Language.Fortran.IntentAttr]
  = Language.Fortran.$fFunctorIntentAttr
instance GHC.Base.Functor [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fFunctorInterfaceSpec
instance GHC.Base.Functor [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fFunctorMeasureUnitSpec
instance GHC.Base.Functor [Language.Fortran.ProgUnit]
  = Language.Fortran.$fFunctorProgUnit
instance GHC.Base.Functor [Language.Fortran.Spec]
  = Language.Fortran.$fFunctorSpec
instance GHC.Base.Functor [Language.Fortran.SubName]
  = Language.Fortran.$fFunctorSubName
instance GHC.Base.Functor [Language.Fortran.Type]
  = Language.Fortran.$fFunctorType
instance GHC.Base.Functor [Language.Fortran.UnaryOp]
  = Language.Fortran.$fFunctorUnaryOp
instance GHC.Base.Functor [Language.Fortran.UseBlock]
  = Language.Fortran.$fFunctorUseBlock
instance GHC.Base.Functor [Language.Fortran.Uses]
  = Language.Fortran.$fFunctorUses
instance GHC.Base.Functor [Language.Fortran.VarName]
  = Language.Fortran.$fFunctorVarName
instance GHC.Classes.Ord [Language.Fortran.VarName]
  = Language.Fortran.$fOrdVarName
instance GHC.Read.Read [Language.Fortran.VarName]
  = Language.Fortran.$fReadVarName
instance GHC.Show.Show [Language.Fortran.Arg]
  = Language.Fortran.$fShowArg
instance GHC.Show.Show [Language.Fortran.ArgList]
  = Language.Fortran.$fShowArgList
instance GHC.Show.Show [Language.Fortran.ArgName]
  = Language.Fortran.$fShowArgName
instance GHC.Show.Show [Language.Fortran.Attr]
  = Language.Fortran.$fShowAttr
instance GHC.Show.Show [Language.Fortran.BaseType]
  = Language.Fortran.$fShowBaseType
instance GHC.Show.Show [Language.Fortran.BinOp]
  = Language.Fortran.$fShowBinOp
instance GHC.Show.Show [Language.Fortran.Block]
  = Language.Fortran.$fShowBlock
instance GHC.Show.Show [Language.Fortran.DataForm]
  = Language.Fortran.$fShowDataForm
instance GHC.Show.Show [Language.Fortran.Decl]
  = Language.Fortran.$fShowDecl
instance GHC.Show.Show [Language.Fortran.Expr]
  = Language.Fortran.$fShowExpr
instance GHC.Show.Show [Language.Fortran.Fortran]
  = Language.Fortran.$fShowFortran
instance GHC.Show.Show [Language.Fortran.Fraction]
  = Language.Fortran.$fShowFraction
instance GHC.Show.Show [Language.Fortran.GSpec]
  = Language.Fortran.$fShowGSpec
instance GHC.Show.Show [Language.Fortran.Implicit]
  = Language.Fortran.$fShowImplicit
instance GHC.Show.Show [Language.Fortran.IntentAttr]
  = Language.Fortran.$fShowIntentAttr
instance GHC.Show.Show [Language.Fortran.InterfaceSpec]
  = Language.Fortran.$fShowInterfaceSpec
instance GHC.Show.Show [Language.Fortran.MeasureUnitSpec]
  = Language.Fortran.$fShowMeasureUnitSpec
instance GHC.Show.Show [Language.Fortran.ProgUnit]
  = Language.Fortran.$fShowProgUnit
instance GHC.Show.Show [Language.Fortran.Spec]
  = Language.Fortran.$fShowSpec
instance GHC.Show.Show [Language.Fortran.SrcLoc]
  = Language.Fortran.$fShowSrcLoc
instance GHC.Show.Show [Language.Fortran.SubName]
  = Language.Fortran.$fShowSubName
instance GHC.Show.Show [Language.Fortran.Type]
  = Language.Fortran.$fShowType
instance GHC.Show.Show [Language.Fortran.UnaryOp]
  = Language.Fortran.$fShowUnaryOp
instance GHC.Show.Show [Language.Fortran.UseBlock]
  = Language.Fortran.$fShowUseBlock
instance GHC.Show.Show [Language.Fortran.Uses]
  = Language.Fortran.$fShowUses
instance GHC.Show.Show [Language.Fortran.VarName]
  = Language.Fortran.$fShowVarName
instance Language.Fortran.Span [Language.Fortran.Block]
  = Language.Fortran.$fSpanBlock
instance Language.Fortran.Span [Language.Fortran.Decl]
  = Language.Fortran.$fSpanDecl
instance Language.Fortran.Span [Language.Fortran.Expr]
  = Language.Fortran.$fSpanExpr
instance Language.Fortran.Span [Language.Fortran.Fortran]
  = Language.Fortran.$fSpanFortran
instance Language.Fortran.Span [Language.Fortran.ProgUnit]
  = Language.Fortran.$fSpanProgUnit
instance Language.Fortran.Tagged [Language.Fortran.Arg]
  = Language.Fortran.$fTaggedArg
instance Language.Fortran.Tagged [Language.Fortran.ArgList]
  = Language.Fortran.$fTaggedArgList
instance Language.Fortran.Tagged [Language.Fortran.ArgName]
  = Language.Fortran.$fTaggedArgName
instance Language.Fortran.Tagged [Language.Fortran.Attr]
  = Language.Fortran.$fTaggedAttr
instance Language.Fortran.Tagged [Language.Fortran.BaseType]
  = Language.Fortran.$fTaggedBaseType
instance Language.Fortran.Tagged [Language.Fortran.DataForm]
  = Language.Fortran.$fTaggedDataForm
instance Language.Fortran.Tagged [Language.Fortran.Decl]
  = Language.Fortran.$fTaggedDecl
instance Language.Fortran.Tagged [Language.Fortran.Expr]
  = Language.Fortran.$fTaggedExpr
instance Language.Fortran.Tagged [Language.Fortran.Fortran]
  = Language.Fortran.$fTaggedFortran
instance Language.Fortran.Tagged [Language.Fortran.GSpec]
  = Language.Fortran.$fTaggedGSpec
instance Language.Fortran.Tagged [Language.Fortran.Implicit]
  = Language.Fortran.$fTaggedImplicit
instance Language.Fortran.Tagged [Language.Fortran.ProgUnit]
  = Language.Fortran.$fTaggedProgUnit
instance Language.Fortran.Tagged [Language.Fortran.SubName]
  = Language.Fortran.$fTaggedSubName
instance Language.Fortran.Tagged [Language.Fortran.Uses]
  = Language.Fortran.$fTaggedUses
instance Language.Fortran.Tagged [Language.Fortran.VarName]
  = Language.Fortran.$fTaggedVarName
"SPEC/Language.Fortran $fData(,) @ SrcLoc @ SrcLoc" forall (v1 :: Data.Data.Data
                                                                    Language.Fortran.SrcLoc)
                                                           (v :: Data.Data.Data
                                                                   Language.Fortran.SrcLoc)
  Data.Data.$fData(,) @ Language.Fortran.SrcLoc
                      @ Language.Fortran.SrcLoc
                      v
                      v1
  = Language.Fortran.$fDataArg_$s$fData(,)
"SPEC/Language.Fortran $fData(,) @ [Char] @ [Char]" [orphan] forall (v1 :: Data.Data.Data
                                                                             [GHC.Types.Char])
                                                                    (v :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fData(,) @ [GHC.Types.Char] @ [GHC.Types.Char] v v1
  = Language.Fortran.$s$fData(,)
"SPEC/Language.Fortran $fData(,)3 @ SrcLoc @ SrcLoc" forall ($dData1 :: Data.Data.Data
                                                                          Language.Fortran.SrcLoc)
                                                            ($dData2 :: Data.Data.Data
                                                                          Language.Fortran.SrcLoc)
  Data.Data.$fData(,)3 @ Language.Fortran.SrcLoc
                       @ Language.Fortran.SrcLoc
                       $dData2
                       $dData1
  = Language.Fortran.$s$fData(,)3
"SPEC/Language.Fortran $fData(,)3 @ [Char] @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                   [GHC.Types.Char])
                                                                     ($dData2 :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fData(,)3 @ [GHC.Types.Char]
                       @ [GHC.Types.Char]
                       $dData2
                       $dData1
  = Language.Fortran.$s$fData(,)5
"SPEC/Language.Fortran $fData(,)_$cgmapM @ SrcLoc @ SrcLoc" [0] forall (w362 :: Data.Data.Data
                                                                                  Language.Fortran.SrcLoc)
                                                                       (w :: Data.Data.Data
                                                                               Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapM @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc
                              w
                              w362
  = Language.Fortran.$s$fData(,)_$cgmapM
"SPEC/Language.Fortran $fData(,)_$cgmapM @ [Char] @ [Char]" [orphan] [0] forall (w362 :: Data.Data.Data
                                                                                           [GHC.Types.Char])
                                                                                (w :: Data.Data.Data
                                                                                        [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapM @ [GHC.Types.Char]
                              @ [GHC.Types.Char]
                              w
                              w362
  = Language.Fortran.$s$fData(,)_$cgmapM1
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ SrcLoc @ SrcLoc" forall ($dData1 :: Data.Data.Data
                                                                                 Language.Fortran.SrcLoc)
                                                                   ($dData2 :: Data.Data.Data
                                                                                 Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgmapQ @ Language.Fortran.SrcLoc
                              @ Language.Fortran.SrcLoc
                              $dData2
                              $dData1
  = Language.Fortran.$s$fData(,)_$cgmapQ
"SPEC/Language.Fortran $fData(,)_$cgmapQ @ [Char] @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                          [GHC.Types.Char])
                                                                            ($dData2 :: Data.Data.Data
                                                                                          [GHC.Types.Char])
  Data.Data.$fData(,)_$cgmapQ @ [GHC.Types.Char]
                              @ [GHC.Types.Char]
                              $dData2
                              $dData1
  = Language.Fortran.$s$fData(,)_$cgmapQ1
"SPEC/Language.Fortran $fData(,)_$cgunfold @ SrcLoc @ SrcLoc" forall ($dData1 :: Data.Data.Data
                                                                                   Language.Fortran.SrcLoc)
                                                                     ($dData2 :: Data.Data.Data
                                                                                   Language.Fortran.SrcLoc)
  Data.Data.$fData(,)_$cgunfold @ Language.Fortran.SrcLoc
                                @ Language.Fortran.SrcLoc
                                $dData2
                                $dData1
  = Language.Fortran.$s$fData(,)_$cgunfold
"SPEC/Language.Fortran $fData(,)_$cgunfold @ [Char] @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                            [GHC.Types.Char])
                                                                              ($dData2 :: Data.Data.Data
                                                                                            [GHC.Types.Char])
  Data.Data.$fData(,)_$cgunfold @ [GHC.Types.Char]
                                @ [GHC.Types.Char]
                                $dData2
                                $dData1
  = Language.Fortran.$s$fData(,)_$cgunfold1
"SPEC/Language.Fortran $fDataMaybe @ Int" [orphan] forall (v :: Data.Data.Data
                                                                  GHC.Types.Int)
  Data.Data.$fDataMaybe @ GHC.Types.Int v
  = Language.Fortran.$s$fDataMaybe1
"SPEC/Language.Fortran $fDataMaybe @ [Char]" [orphan] forall (v :: Data.Data.Data
                                                                     [GHC.Types.Char])
  Data.Data.$fDataMaybe @ [GHC.Types.Char] v
  = Language.Fortran.$s$fDataMaybe
"SPEC/Language.Fortran $fDataMaybe3 @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         GHC.Types.Int)
  Data.Data.$fDataMaybe3 @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe2
"SPEC/Language.Fortran $fDataMaybe3 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fDataMaybe3 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe3
"SPEC/Language.Fortran $fDataMaybe4 @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         GHC.Types.Int)
  Data.Data.$fDataMaybe4 @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe6
"SPEC/Language.Fortran $fDataMaybe4 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fDataMaybe4 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe4
"SPEC/Language.Fortran $fDataMaybe6 @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         GHC.Types.Int)
  Data.Data.$fDataMaybe6 @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe8
"SPEC/Language.Fortran $fDataMaybe6 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                            [GHC.Types.Char])
  Data.Data.$fDataMaybe6 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe7
"SPEC/Language.Fortran $fDataMaybe_$cgfoldl @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                 GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgfoldl @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgfoldl1
"SPEC/Language.Fortran $fDataMaybe_$cgfoldl @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgfoldl @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgfoldl
"SPEC/Language.Fortran $fDataMaybe_$cgmapQ @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQ @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQ1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQ @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQ @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQ
"SPEC/Language.Fortran $fDataMaybe_$cgmapQi @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                 GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQi @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQi1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQi @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQi @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQi
"SPEC/Language.Fortran $fDataMaybe_$cgmapQr @ Int" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                 GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgmapQr @ GHC.Types.Int $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQr1
"SPEC/Language.Fortran $fDataMaybe_$cgmapQr @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                                    [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgmapQr @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fDataMaybe_$cgmapQr
"SPEC/Language.Fortran $fDataMaybe_$cgunfold @ Int" [orphan] [0] forall (w :: Data.Data.Data
                                                                                GHC.Types.Int)
  Data.Data.$fDataMaybe_$cgunfold @ GHC.Types.Int w
  = Language.Fortran.$s$fDataMaybe_$cgunfold1
"SPEC/Language.Fortran $fDataMaybe_$cgunfold @ [Char]" [orphan] [0] forall (w :: Data.Data.Data
                                                                                   [GHC.Types.Char])
  Data.Data.$fDataMaybe_$cgunfold @ [GHC.Types.Char] w
  = Language.Fortran.$s$fDataMaybe_$cgunfold
"SPEC/Language.Fortran $fData[] @ (Variable, Variable)" [orphan] forall (v :: Data.Data.Data
                                                                                (Language.Fortran.Variable,
                                                                                 Language.Fortran.Variable))
  Data.Data.$fData[] @ (Language.Fortran.Variable,
                        Language.Fortran.Variable)
                     v
  = Language.Fortran.$s$fData[]1
"SPEC/Language.Fortran $fData[] @ [Char]" [orphan] forall (v :: Data.Data.Data
                                                                  [GHC.Types.Char])
  Data.Data.$fData[] @ [GHC.Types.Char] v
  = Language.Fortran.$s$fData[]
"SPEC/Language.Fortran $fData[]7 @ [Char]" [orphan] forall ($dData1 :: Data.Data.Data
                                                                         [GHC.Types.Char])
  Data.Data.$fData[]7 @ [GHC.Types.Char] $dData1
  = Language.Fortran.$s$fData[]7
"SPEC/Language.Fortran $fEq(,) @ [Char] @ [Char]" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                           [GHC.Types.Char])
                                                                  (v :: GHC.Classes.Eq
                                                                          [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char] @ [GHC.Types.Char] v v1
  = Language.Fortran.$s$fEq(,)
"SPEC/Language.Fortran $fEq(,)_$c/= @ [Char] @ [Char]" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                                   [GHC.Types.Char])
                                                                       ($dEq :: GHC.Classes.Eq
                                                                                  [GHC.Types.Char])
  GHC.Classes.$fEq(,)_$c/= @ [GHC.Types.Char]
                           @ [GHC.Types.Char]
                           $dEq
                           $dEq1
  = Language.Fortran.$s$fEq(,)_$s$fEq(,)_$c/=
"SPEC/Language.Fortran $fEqMaybe @ Int" [orphan] forall (v :: GHC.Classes.Eq
                                                                GHC.Types.Int)
  GHC.Base.$fEqMaybe @ GHC.Types.Int v = Language.Fortran.$s$fEqMaybe
"SPEC/Language.Fortran $fEqMaybe_$c/= @ Int" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                        GHC.Types.Int)
  GHC.Base.$fEqMaybe_$c/= @ GHC.Types.Int $dEq
  = Language.Fortran.$s$fEqMaybe_$s$fEqMaybe_$c/=
"SPEC/Language.Fortran $fEqMaybe_$c== @ Int" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                        GHC.Types.Int)
  GHC.Base.$fEqMaybe_$c== @ GHC.Types.Int $dEq
  = Language.Fortran.$s$fEqMaybe_$c==
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

