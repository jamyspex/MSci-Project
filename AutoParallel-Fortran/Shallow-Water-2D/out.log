Parsing ./shapiro.f95
Parsing ./dyn.f95
Parsing ./vernieuw.f95


--------------------------------------------------------------------------------
dyn
--------------------------------------------------------------------------------
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["dt","g","dx","dy"],["du","dv"],["(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    }
    }
! OpenCLMap ( ["u","du","wet","v","dv"],["un","vn"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["j","u","du","wet","v","dv"],["un","vn"],["(k,1,500.0,1)"],[]) {
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    }
    }
! OpenCLMap ( ["h","eta","dt","dx","dy"],["etan"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["j","h","eta","dt","dx","dy"],["etan"],["(k,1,500.0,1)"],[]) {
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
    }
end subroutine dyn

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
shapiro
--------------------------------------------------------------------------------
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
! OpenCLMap ( ["wet","etan","eps"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
! OpenCLMap ( ["wet","j","etan","eps"],["eta"],["(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
    }
end subroutine shapiro

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
vernieuw
--------------------------------------------------------------------------------
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
! OpenCLMap ( ["j","hzero","eta","h","hmin","un","vn"],["h","wet","u","v"],["(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
    }
end subroutine vernieuw

--------------------------------------------------------------------------------


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Combined 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



--------------------------------------------------------------------------------
dyn
--------------------------------------------------------------------------------
subroutine dyn(j,k,dx,g,eta,dt,dy,un,u,wet,v,vn,h,etan)
      integer(4), parameter :: ny = 500 
      integer(4), parameter :: nx = 500 
      integer :: j
      integer :: k
      real, intent(In) :: dx
      real, intent(In) :: g
      real, dimension(0:ny+1,0:nx+1) :: eta
      real, intent(In) :: dt
      real, intent(In) :: dy
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: un
      real, dimension(0:ny+1,0:nx+1), intent(In) :: u
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: v
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: vn
      real, dimension(0:ny+1,0:nx+1), intent(In) :: h
      real, dimension(0:ny+1,0:nx+1) :: etan
      real, dimension(0:ny+1,0:nx+1) :: du
      real, dimension(0:ny+1,0:nx+1) :: dv
      real :: uu
      real :: vv
      real :: duu
      real :: dvv
      real :: hue
      real :: huw
      real :: hwp
      real :: hwn
      real :: hen
      real :: hep
      real :: hvn
      real :: hvs
      real :: hsp
      real :: hsn
      real :: hnn
      real :: hnp
! OpenCLMap ( ["dt","g","dx","dy","u","du","wet","v","dv","j","h","eta"],["du","dv","un","vn","etan"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
    du(j,k) = -dt*g*(eta(j,k+1)-eta(j,k))/dx
    dv(j,k) = -dt*g*(eta(j+1,k)-eta(j,k))/dy
    un(j,k) = 0.0
    uu = u(j,k)
    duu = du(j,k)
    if (wet(j,k)==1) then
        if ((wet(j,k+1)==1) .or. (duu>0.0)) then
                un(j,k) = uu+duu
        end if
    else
        if ((wet(j,k+1)==1) .and. (duu<0.0)) then
                un(j,k) = uu+duu
        end if
    end if
    vv = v(j,k)
    dvv = dv(j,k)
    vn(j,k) = 0.0
    if (wet(j,k)==1) then
        if ((wet(j+1,k)==1) .or. (dvv>0.0)) then
                vn(j,k) = vv+dvv
        end if
    else
        if ((wet(j+1,k)==1) .and. (dvv<0.0)) then
                vn(j,k) = vv+dvv
        end if
    end if
    hep = 0.5*(un(j,k)+abs(un(j,k)))*h(j,k)
    hen = 0.5*(un(j,k)-abs(un(j,k)))*h(j,k+1)
    hue = hep+hen
    hwp = 0.5*(un(j,k-1)+abs(un(j,k-1)))*h(j,k-1)
    hwn = 0.5*(un(j,k-1)-abs(un(j,k-1)))*h(j,k)
    huw = hwp+hwn
    hnp = 0.5*(vn(j,k)+abs(vn(j,k)))*h(j,k)
    hnn = 0.5*(vn(j,k)-abs(vn(j,k)))*h(j+1,k)
    hvn = hnp+hnn
    hsp = 0.5*(vn(j-1,k)+abs(vn(j-1,k)))*h(j-1,k)
    hsn = 0.5*(vn(j-1,k)-abs(vn(j-1,k)))*h(j,k)
    hvs = hsp+hsn
    etan(j,k) = eta(j,k)-dt*(hue-huw)/dx-dt*(hvn-hvs)/dy
    }
end subroutine dyn

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
shapiro
--------------------------------------------------------------------------------
subroutine shapiro(j,k,wet,etan,eps,eta)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      integer, intent(InOut) :: j
      integer, intent(InOut) :: k
      integer, dimension(0:ny+1,0:nx+1), intent(In) :: wet
      real, dimension(0:ny+1,0:nx+1), intent(In) :: etan
      real, intent(In) :: eps
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: eta
      real :: term1
      real :: term2
      real :: term3
! OpenCLMap ( ["wet","etan","eps","j"],["eta"],["(j,1,500.0,1)","(k,1,500.0,1)"],[]) {
    if (wet(j,k)==1) then
        term1 = (1.0-0.25*eps*(wet(j,k+1)+wet(j,k-1)+wet(j+1,k)+wet(j-1,k)))*etan(j,k)
        term2 = 0.25*eps*(wet(j,k+1)*etan(j,k+1)+wet(j,k-1)*etan(j,k-1))
        term3 = 0.25*eps*(wet(j+1,k)*etan(j+1,k)+wet(j-1,k)*etan(j-1,k))
        eta(j,k) = term1+term2+term3
    else
        eta(j,k) = etan(j,k)
    end if
    }
end subroutine shapiro

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
vernieuw
--------------------------------------------------------------------------------
subroutine vernieuw(dt,dx,dy,eps,eta,etan,g,h,hmin,hzero,j,k,u,un,v,vn,wet)
      integer(4), parameter :: nx = 500 
      integer(4), parameter :: ny = 500 
      real :: dt
      real :: dx
      real :: dy
      real :: eps
      real, dimension(0:ny+1,0:nx+1), intent(In) :: eta
      real, dimension(0:ny+1,0:nx+1) :: etan
      real :: g
      real, dimension(0:ny+1,0:nx+1), intent(InOut) :: h
      real, intent(In) :: hmin
      real, dimension(0:ny+1,0:nx+1), intent(In) :: hzero
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: u
      real, dimension(0:ny+1,0:nx+1), intent(In) :: un
      real, dimension(0:ny+1,0:nx+1), intent(Out) :: v
      real, dimension(0:ny+1,0:nx+1), intent(In) :: vn
      integer, dimension(0:ny+1,0:nx+1), intent(Out) :: wet
      integer, intent(InOut) :: k
      integer, intent(InOut) :: j
! OpenCLMap ( ["hzero","eta","h","hmin","un","vn","j"],["h","wet","u","v"],["(j,0,500.0+1,1)","(k,0,500.0+1,1)"],[]) {
    h(j,k) = hzero(j,k)+eta(j,k)
    wet(j,k) = 1
    if (h(j,k)<hmin) then
        wet(j,k) = 0
    end if
    u(j,k) = un(j,k)
    v(j,k) = vn(j,k)
    }
end subroutine vernieuw

--------------------------------------------------------------------------------

Parsing ./main.f95

--------------------------------------------------------------------------------
dyn
--------------------------------------------------------------------------------
	dt -> dt
	dx -> dx
	dy -> dy
	eta -> eta
	etan -> etan
	g -> g
	h -> h
	j -> j
	k -> k
	u -> u
	un -> un
	v -> v
	vn -> vn
	wet -> wet


--------------------------------------------------------------------------------
shapiro
--------------------------------------------------------------------------------
	eps -> eps
	eta -> eta
	etan -> etan
	j -> j
	k -> k
	wet -> wet


--------------------------------------------------------------------------------
vernieuw
--------------------------------------------------------------------------------
	dt -> dt
	dx -> dx
	dy -> dy
	eps -> eps
	eta -> eta
	etan -> etan
	g -> g
	h -> h
	hmin -> hmin
	hzero -> hzero
	j -> j
	k -> k
	u -> u
	un -> un
	v -> v
	vn -> vn
	wet -> wet

ParallelFortran: Analysing ./dyn.f95

ParallelFortran: Adjacent maps at 38:0 and 44:0 fused	
ParallelFortran: Adjacent maps at 44:0 and 64:0 fused	
ParallelFortran: Nested map at 39:0 fused into surrounding map	
ParallelFortran: Nested map at 45:0 fused into surrounding map	
ParallelFortran: Nested map at 65:0 fused into surrounding map	

ParallelFortran: Map at 38:0	
ParallelFortran: Map at 39:0	
ParallelFortran: Map at 44:0	
ParallelFortran: Map at 45:0	
ParallelFortran: Map at 64:0	
ParallelFortran: Map at 65:0	

ParallelFortran: Analysing ./shapiro.f95

ParallelFortran: Nested map at 16:0 fused into surrounding map	

ParallelFortran: Map at 15:0	
ParallelFortran: Map at 16:0	

ParallelFortran: Analysing ./vernieuw.f95

ParallelFortran: Nested map at 24:0 fused into surrounding map	

ParallelFortran: Map at 23:0	
ParallelFortran: Map at 24:0	

ParallelFortran: Synthesising OpenCL files
Output dir: ../AutoparV1/
